<!DOCTYPE HTML>
<!-- saved from url=(0026)https://phet.colorado.edu/ -->
<html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1"/>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="phet-sim-level" content="production">

  <!-- metadata for Open Graph protocol -->
  <meta property="og:title" content="&#8234;&#1052;&#1072;&#1090;&#1077;&#1084;&#1072;&#1090;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1084;&#1072;&#1103;&#1090;&#1085;&#1080;&#1082;&#8236;"/>
  <meta property="og:type" content="phet:simulation"/>
  <meta property="og:url" content="https://phet.colorado.edu/sims/html/pendulum-lab/latest/pendulum-lab_ru.html"/>
  <meta property="og:image" content="https://phet.colorado.edu/sims/html/pendulum-lab/latest/pendulum-lab-600.png"/>

  <title>&#8234;&#1052;&#1072;&#1090;&#1077;&#1084;&#1072;&#1090;&#1080;&#1095;&#1077;&#1089;&#1082;&#1080;&#1081; &#1084;&#1072;&#1103;&#1090;&#1085;&#1080;&#1082;&#8236;</title>
</head>
<!--  
‪Pendulum Lab‬ 1.0.27
Copyright 2002-2023, Regents of the University of Colorado
PhET Interactive Simulations, University of Colorado Boulder

This file is licensed under Creative Commons Attribution 4.0
For alternate source code licensing, see https://github.com/phetsims
For licenses for third-party software used by this simulation, see below
For more information, see https://phet.colorado.edu/en/licensing/html

The PhET name and PhET logo are registered trademarks of The Regents of the
University of Colorado. Permission is granted to use the PhET name and PhET logo
only for attribution purposes. Use of the PhET name and/or PhET logo for promotional,
marketing, or advertising purposes requires a separate license agreement from the
University of Colorado. Contact phethelp@colorado.edu regarding licensing.
-->
<!-- body is only made black for the loading phase so that the splash screen is black -->
<body style="background-color:black;">

<!-- a11y - aria-live attribute is used to send alerts and status updates to screen readers, otherwise invisible -->
<div id='aria-live-elements' style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; clip: rect(0px 0px 0px 0px); pointer-events: none;">
  <p id="assertive" aria-live="assertive"></p>
  <p id="polite" aria-live="polite"></p>
  <p id="assertive-alert" aria-live="assertive" role="alert"></p>
  <p id="polite-status" aria-live="polite" role="status"></p>
</div>

<script type="text/javascript">
  window.phet = {};
  window.phet.chipper = {};
  window.phet.chipper.project = 'pendulum-lab';
  window.phet.chipper.version = '1.0.27';
  window.phet.chipper.buildTimestamp = '2023-12-12 02:03:08 UTC';
  window.phet.chipper.brand = 'phet';
  window.phet.chipper.locale = 'ru';

  // This simulation uses following third-party resources.  The following code block describes each resource
  // and provides its licensing information.  The START and END tags make it easy to automatically parse
  // and the entries are in JSON.  See getLicenseEntry.js for information about the attributes in each entry.
  // ### START THIRD PARTY LICENSE ENTRIES ###
  window.phet.chipper.thirdPartyLicenseEntries = {
  "lib": {
    "almond-0.2.9.js": {
      "text": [
        "Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved."
      ],
      "projectURL": "https://github.com/jrburke/almond",
      "license": "The MIT License",
      "notes": "Allows a RequireJS-based simulation to run in its compiled (smaller, faster) form",
      "licenseText": [
        "MIT License",
        "-----------",
        "",
        "Copyright (c) 2010-2011, The Dojo Foundation",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy",
        "of this software and associated documentation files (the \"Software\"), to deal",
        "in the Software without restriction, including without limitation the rights",
        "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
        "copies of the Software, and to permit persons to whom the Software is",
        "furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in",
        "all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
        "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
        "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
        "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
        "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
        "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
        "THE SOFTWARE."
      ]
    },
    "base64-js-1.2.0.js": {
      "text": [
        "Copyright (c) 2014"
      ],
      "license": "The MIT License",
      "projectURL": "https://github.com/beatgammit/base64-js",
      "notes": "For converting typed arrays to base64 (helps converting encoded SVG data URLs)",
      "licenseText": [
        "The MIT License (MIT)",
        "",
        "Copyright (c) 2014",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy",
        "of this software and associated documentation files (the \"Software\"), to deal",
        "in the Software without restriction, including without limitation the rights",
        "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
        "copies of the Software, and to permit persons to whom the Software is",
        "furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in",
        "all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
        "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
        "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
        "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
        "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
        "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
        "THE SOFTWARE.",
        ""
      ]
    },
    "FileSaver-b8054a2.js": {
      "text": [
        "Copyright (c) 2015 Eli Grey. (http://eligrey.com)"
      ],
      "license": "The MIT License",
      "projectURL": "https://github.com/eligrey/FileSaver.js",
      "notes": "Used for saving screenshot images",
      "licenseText": [
        "Copyright © 2014 Eli Grey.",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
        ""
      ]
    },
    "font-awesome-4.5.0": {
      "text": [
        "Created by Dave Gandy"
      ],
      "license": "Font Awesome licensed under SIL OFL 1.1 · Code licensed under MIT License · Documentation licensed under CC BY 3.0",
      "projectURL": "http://fontawesome.io/",
      "notes": "Provides shapes and icons for phet-io wrappers, SVG for icons in FontAwesomeNode",
      "licenseText": [
        "Copyright (c) 2013, Dave Gandy - http://fontawesome.io",
        "with Reserved Font Name Font Awesome.",
        "",
        "This Font Software is licensed under the SIL Open Font License, Version 1.1.",
        "This license is copied below, and is also available with a FAQ at:",
        "http://scripts.sil.org/OFL",
        "",
        "",
        "-----------------------------------------------------------",
        "SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007",
        "-----------------------------------------------------------",
        "",
        "PREAMBLE",
        "The goals of the Open Font License (OFL) are to stimulate worldwide",
        "development of collaborative font projects, to support the font creation",
        "efforts of academic and linguistic communities, and to provide a free and",
        "open framework in which fonts may be shared and improved in partnership",
        "with others.",
        "",
        "The OFL allows the licensed fonts to be used, studied, modified and",
        "redistributed freely as long as they are not sold by themselves. The",
        "fonts, including any derivative works, can be bundled, embedded,",
        "redistributed and/or sold with any software provided that any reserved",
        "names are not used by derivative works. The fonts and derivatives,",
        "however, cannot be released under any other type of license. The",
        "requirement for fonts to remain under this license does not apply",
        "to any document created using the fonts or their derivatives.",
        "",
        "DEFINITIONS",
        "\"Font Software\" refers to the set of files released by the Copyright",
        "Holder(s) under this license and clearly marked as such. This may",
        "include source files, build scripts and documentation.",
        "",
        "\"Reserved Font Name\" refers to any names specified as such after the",
        "copyright statement(s).",
        "",
        "\"Original Version\" refers to the collection of Font Software components as",
        "distributed by the Copyright Holder(s).",
        "",
        "\"Modified Version\" refers to any derivative made by adding to, deleting,",
        "or substituting -- in part or in whole -- any of the components of the",
        "Original Version, by changing formats or by porting the Font Software to a",
        "new environment.",
        "",
        "\"Author\" refers to any designer, engineer, programmer, technical",
        "writer or other person who contributed to the Font Software.",
        "",
        "PERMISSION & CONDITIONS",
        "Permission is hereby granted, free of charge, to any person obtaining",
        "a copy of the Font Software, to use, study, copy, merge, embed, modify,",
        "redistribute, and sell modified and unmodified copies of the Font",
        "Software, subject to the following conditions:",
        "",
        "1) Neither the Font Software nor any of its individual components,",
        "in Original or Modified Versions, may be sold by itself.",
        "",
        "2) Original or Modified Versions of the Font Software may be bundled,",
        "redistributed and/or sold with any software, provided that each copy",
        "contains the above copyright notice and this license. These can be",
        "included either as stand-alone text files, human-readable headers or",
        "in the appropriate machine-readable metadata fields within text or",
        "binary files as long as those fields can be easily viewed by the user.",
        "",
        "3) No Modified Version of the Font Software may use the Reserved Font",
        "Name(s) unless explicit written permission is granted by the corresponding",
        "Copyright Holder. This restriction only applies to the primary font name as",
        "presented to the users.",
        "",
        "4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font",
        "Software shall not be used to promote, endorse or advertise any",
        "Modified Version, except to acknowledge the contribution(s) of the",
        "Copyright Holder(s) and the Author(s) or with their explicit written",
        "permission.",
        "",
        "5) The Font Software, modified or unmodified, in part or in whole,",
        "must be distributed entirely under this license, and must not be",
        "distributed under any other license. The requirement for fonts to",
        "remain under this license does not apply to any document created",
        "using the Font Software.",
        "",
        "TERMINATION",
        "This license becomes null and void if any of the above conditions are",
        "not met.",
        "",
        "DISCLAIMER",
        "THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
        "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF",
        "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT",
        "OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE",
        "COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,",
        "INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL",
        "DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING",
        "FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM",
        "OTHER DEALINGS IN THE FONT SOFTWARE.",
        ""
      ]
    },
    "game-up-camera-1.0.0.js": {
      "text": [
        "Copyright (c) BrainPOP"
      ],
      "license": "MIT",
      "projectURL": "https://github.com/phetsims/sherpa/blob/master/lib/game-up-camera-1.0.0.js",
      "notes": "Allows a simulation to return a snapshot to BrainPOP/GameUp/SnapThought",
      "licenseText": [
        "The MIT License (MIT) Copyright (c) 2016 BrainPOP",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
      ]
    },
    "himalaya-0.2.7.js": {
      "text": [
        "Copyright (c) 2015, Chris Andrejewski <christopher.andrejewski@gmail.com>"
      ],
      "license": "ISC License",
      "projectURL": "https://github.com/andrejewski/himalaya",
      "notes": "Used for HTML parsing in simulations, to sanitize/handle rich HTML text",
      "licenseText": [
        "Copyright (c) 2015, Chris Andrejewski <christopher.andrejewski@gmail.com>",
        "",
        "Permission to use, copy, modify, and/or distribute this software for any",
        "purpose with or without fee is hereby granted, provided that the above",
        "copyright notice and this permission notice appear in all copies.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES",
        "WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF",
        "MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR",
        "ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES",
        "WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN",
        "ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF",
        "OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
        ""
      ]
    },
    "jama-1.0.2": {
      "text": [
        "a basic linear algebra package for Java."
      ],
      "license": "Public Domain",
      "projectURL": "http://math.nist.gov/javanumerics/jama/",
      "notes": "A derived work (certain ported and modified files) is used in Dot, mainly for matrix decompositions. Used in assorted simulations.",
      "licenseText": [
        "Public Domain",
        "",
        "Copyright Notice This software is a cooperative product of The MathWorks and the National Institute of Standards and Technology (NIST) which has been released to the public domain. ",
        "Neither The MathWorks nor NIST assumes any responsibility whatsoever for its use by other parties, and makes no guarantees, expressed or implied, about its quality, reliability, or any other characteristic."
      ]
    },
    "jquery-2.1.0.js": {
      "text": [
        "Copyright (c) 2005, 2014 jQuery Foundation, Inc. and other contributors",
        "(includes Sizzle.js, http://sizzlejs.com)"
      ],
      "license": "The MIT License",
      "projectURL": "http://jquery.com",
      "notes": "Facilitates interaction with browser DOM elements, mainly used in Scenery",
      "licenseText": [
        "Copyright 2013 jQuery Foundation and other contributors",
        "http://jquery.com/",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining",
        "a copy of this software and associated documentation files (the",
        "\"Software\"), to deal in the Software without restriction, including",
        "without limitation the rights to use, copy, modify, merge, publish,",
        "distribute, sublicense, and/or sell copies of the Software, and to",
        "permit persons to whom the Software is furnished to do so, subject to",
        "the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be",
        "included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
        "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",
        "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND",
        "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE",
        "LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
        "OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION",
        "WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
      ]
    },
    "lodash-4.17.4.js": {
      "text": [
        "Lodash <https://lodash.com/>",
        "Copyright JS Foundation and other contributors <https://js.foundation/>",
        "Released under MIT license <https://lodash.com/license>",
        "Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>",
        "Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors"
      ],
      "license": "The MIT License",
      "projectURL": "http://lodash.com",
      "notes": "Adds common data structure operations such as sorting, grouping, etc.",
      "licenseText": [
        "Copyright JS Foundation and other contributors <https://js.foundation/>",
        "",
        "Based on Underscore.js, copyright Jeremy Ashkenas,",
        "DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>",
        "",
        "This software consists of voluntary contributions made by many",
        "individuals. For exact contribution history, see the revision history",
        "available at https://github.com/lodash/lodash",
        "",
        "The following license applies to all parts of this software except as",
        "documented below:",
        "",
        "====",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining",
        "a copy of this software and associated documentation files (the",
        "\"Software\"), to deal in the Software without restriction, including",
        "without limitation the rights to use, copy, modify, merge, publish,",
        "distribute, sublicense, and/or sell copies of the Software, and to",
        "permit persons to whom the Software is furnished to do so, subject to",
        "the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be",
        "included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
        "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",
        "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND",
        "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE",
        "LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
        "OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION",
        "WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
        "",
        "====",
        "",
        "Copyright and related rights for sample code are waived via CC0. Sample",
        "code is defined as all source code displayed within the prose of the",
        "documentation.",
        "",
        "CC0: http://creativecommons.org/publicdomain/zero/1.0/",
        "",
        "====",
        "",
        "Files located in the node_modules and vendor directories are externally",
        "maintained libraries used by this software which have their own",
        "licenses; we recommend you read them, as their terms may differ from the",
        "terms above."
      ]
    },
    "pegjs-0.7.0.js": {
      "text": [
        "Copyright (c) 2010-2012 David Majda"
      ],
      "license": "The MIT License",
      "projectURL": "http://pegjs.majda.cz",
      "notes": "Parser Generator for JavaScript. SVG path parsing in Kite",
      "licenseText": [
        "Copyright (c) 2010-2012 David Majda",
        "",
        "Permission is hereby granted, free of charge, to any person",
        "obtaining a copy of this software and associated documentation",
        "files (the \"Software\"), to deal in the Software without",
        "restriction, including without limitation the rights to use,",
        "copy, modify, merge, publish, distribute, sublicense, and/or sell",
        "copies of the Software, and to permit persons to whom the",
        "Software is furnished to do so, subject to the following",
        "conditions:",
        "",
        "The above copyright notice and this permission notice shall be",
        "included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
        "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES",
        "OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND",
        "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT",
        "HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,",
        "WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING",
        "FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR",
        "OTHER DEALINGS IN THE SOFTWARE."
      ]
    },
    "seedrandom-2.4.2.js": {
      "text": [
        "Copyright 2015 David Bau."
      ],
      "license": "MIT",
      "projectURL": "https://github.com/davidbau/seedrandom",
      "notes": "seeded random number generator for Javascript",
      "licenseText": [
        "Copyright 2015 David Bau.",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated",
        "documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the",
        "rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit",
        "persons to whom the Software is furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the",
        "Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE",
        "WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR",
        "COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR",
        "OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
      ]
    },
    "text-2.0.12.js": {
      "text": [
        "Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved."
      ],
      "license": "The MIT License",
      "projectURL": "http://github.com/requirejs/text",
      "notes": "Loads strings to be displayed in the sim, including internationalized strings.",
      "licenseText": [
        "MIT License",
        "-----------",
        "",
        "Copyright (c) 2010-2011, The Dojo Foundation",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy",
        "of this software and associated documentation files (the \"Software\"), to deal",
        "in the Software without restriction, including without limitation the rights",
        "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
        "copies of the Software, and to permit persons to whom the Software is",
        "furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in",
        "all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
        "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
        "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
        "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
        "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
        "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
        "THE SOFTWARE."
      ]
    },
    "TextEncoderLite-3c9f6f0.js": {
      "text": [
        "AJ ONeal <awesome@coolaj86.com>"
      ],
      "license": "Apache 2.0",
      "projectURL": "https://github.com/coolaj86/TextEncoderLite",
      "notes": "Used for encoding unicode strings to typed arrays, for Scenery foreign object rasterization",
      "licenseText": [
        "",
        "                                 Apache License",
        "                           Version 2.0, January 2011",
        "                        http://www.apache.org/licenses/",
        "",
        "   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION",
        "",
        "   1. Definitions.",
        "",
        "      \"License\" shall mean the terms and conditions for use, reproduction,",
        "      and distribution as defined by Sections 1 through 9 of this document.",
        "",
        "      \"Licensor\" shall mean the copyright owner or entity authorized by",
        "      the copyright owner that is granting the License.",
        "",
        "      \"Legal Entity\" shall mean the union of the acting entity and all",
        "      other entities that control, are controlled by, or are under common",
        "      control with that entity. For the purposes of this definition,",
        "      \"control\" means (i) the power, direct or indirect, to cause the",
        "      direction or management of such entity, whether by contract or",
        "      otherwise, or (ii) ownership of fifty percent (50%) or more of the",
        "      outstanding shares, or (iii) beneficial ownership of such entity.",
        "",
        "      \"You\" (or \"Your\") shall mean an individual or Legal Entity",
        "      exercising permissions granted by this License.",
        "",
        "      \"Source\" form shall mean the preferred form for making modifications,",
        "      including but not limited to software source code, documentation",
        "      source, and configuration files.",
        "",
        "      \"Object\" form shall mean any form resulting from mechanical",
        "      transformation or translation of a Source form, including but",
        "      not limited to compiled object code, generated documentation,",
        "      and conversions to other media types.",
        "",
        "      \"Work\" shall mean the work of authorship, whether in Source or",
        "      Object form, made available under the License, as indicated by a",
        "      copyright notice that is included in or attached to the work",
        "      (an example is provided in the Appendix below).",
        "",
        "      \"Derivative Works\" shall mean any work, whether in Source or Object",
        "      form, that is based on (or derived from) the Work and for which the",
        "      editorial revisions, annotations, elaborations, or other modifications",
        "      represent, as a whole, an original work of authorship. For the purposes",
        "      of this License, Derivative Works shall not include works that remain",
        "      separable from, or merely link (or bind by name) to the interfaces of,",
        "      the Work and Derivative Works thereof.",
        "",
        "      \"Contribution\" shall mean any work of authorship, including",
        "      the original version of the Work and any modifications or additions",
        "      to that Work or Derivative Works thereof, that is intentionally",
        "      submitted to Licensor for inclusion in the Work by the copyright owner",
        "      or by an individual or Legal Entity authorized to submit on behalf of",
        "      the copyright owner. For the purposes of this definition, \"submitted\"",
        "      means any form of electronic, verbal, or written communication sent",
        "      to the Licensor or its representatives, including but not limited to",
        "      communication on electronic mailing lists, source code control systems,",
        "      and issue tracking systems that are managed by, or on behalf of, the",
        "      Licensor for the purpose of discussing and improving the Work, but",
        "      excluding communication that is conspicuously marked or otherwise",
        "      designated in writing by the copyright owner as \"Not a Contribution.\"",
        "",
        "      \"Contributor\" shall mean Licensor and any individual or Legal Entity",
        "      on behalf of whom a Contribution has been received by Licensor and",
        "      subsequently incorporated within the Work.",
        "",
        "   2. Grant of Copyright License. Subject to the terms and conditions of",
        "      this License, each Contributor hereby grants to You a perpetual,",
        "      worldwide, non-exclusive, no-charge, royalty-free, irrevocable",
        "      copyright license to reproduce, prepare Derivative Works of,",
        "      publicly display, publicly perform, sublicense, and distribute the",
        "      Work and such Derivative Works in Source or Object form.",
        "",
        "   3. Grant of Patent License. Subject to the terms and conditions of",
        "      this License, each Contributor hereby grants to You a perpetual,",
        "      worldwide, non-exclusive, no-charge, royalty-free, irrevocable",
        "      (except as stated in this section) patent license to make, have made,",
        "      use, offer to sell, sell, import, and otherwise transfer the Work,",
        "      where such license applies only to those patent claims licensable",
        "      by such Contributor that are necessarily infringed by their",
        "      Contribution(s) alone or by combination of their Contribution(s)",
        "      with the Work to which such Contribution(s) was submitted. If You",
        "      institute patent litigation against any entity (including a",
        "      cross-claim or counterclaim in a lawsuit) alleging that the Work",
        "      or a Contribution incorporated within the Work constitutes direct",
        "      or contributory patent infringement, then any patent licenses",
        "      granted to You under this License for that Work shall terminate",
        "      as of the date such litigation is filed.",
        "",
        "   4. Redistribution. You may reproduce and distribute copies of the",
        "      Work or Derivative Works thereof in any medium, with or without",
        "      modifications, and in Source or Object form, provided that You",
        "      meet the following conditions:",
        "",
        "      (a) You must give any other recipients of the Work or",
        "          Derivative Works a copy of this License; and",
        "",
        "      (b) You must cause any modified files to carry prominent notices",
        "          stating that You changed the files; and",
        "",
        "      (c) You must retain, in the Source form of any Derivative Works",
        "          that You distribute, all copyright, patent, trademark, and",
        "          attribution notices from the Source form of the Work,",
        "          excluding those notices that do not pertain to any part of",
        "          the Derivative Works; and",
        "",
        "      (d) If the Work includes a \"NOTICE\" text file as part of its",
        "          distribution, then any Derivative Works that You distribute must",
        "          include a readable copy of the attribution notices contained",
        "          within such NOTICE file, excluding those notices that do not",
        "          pertain to any part of the Derivative Works, in at least one",
        "          of the following places: within a NOTICE text file distributed",
        "          as part of the Derivative Works; within the Source form or",
        "          documentation, if provided along with the Derivative Works; or,",
        "          within a display generated by the Derivative Works, if and",
        "          wherever such third-party notices normally appear. The contents",
        "          of the NOTICE file are for informational purposes only and",
        "          do not modify the License. You may add Your own attribution",
        "          notices within Derivative Works that You distribute, alongside",
        "          or as an addendum to the NOTICE text from the Work, provided",
        "          that such additional attribution notices cannot be construed",
        "          as modifying the License.",
        "",
        "      You may add Your own copyright statement to Your modifications and",
        "      may provide additional or different license terms and conditions",
        "      for use, reproduction, or distribution of Your modifications, or",
        "      for any such Derivative Works as a whole, provided Your use,",
        "      reproduction, and distribution of the Work otherwise complies with",
        "      the conditions stated in this License.",
        "",
        "   5. Submission of Contributions. Unless You explicitly state otherwise,",
        "      any Contribution intentionally submitted for inclusion in the Work",
        "      by You to the Licensor shall be under the terms and conditions of",
        "      this License, without any additional terms or conditions.",
        "      Notwithstanding the above, nothing herein shall supersede or modify",
        "      the terms of any separate license agreement you may have executed",
        "      with Licensor regarding such Contributions.",
        "",
        "   6. Trademarks. This License does not grant permission to use the trade",
        "      names, trademarks, service marks, or product names of the Licensor,",
        "      except as required for reasonable and customary use in describing the",
        "      origin of the Work and reproducing the content of the NOTICE file.",
        "",
        "   7. Disclaimer of Warranty. Unless required by applicable law or",
        "      agreed to in writing, Licensor provides the Work (and each",
        "      Contributor provides its Contributions) on an \"AS IS\" BASIS,",
        "      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or",
        "      implied, including, without limitation, any warranties or conditions",
        "      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A",
        "      PARTICULAR PURPOSE. You are solely responsible for determining the",
        "      appropriateness of using or redistributing the Work and assume any",
        "      risks associated with Your exercise of permissions under this License.",
        "",
        "   8. Limitation of Liability. In no event and under no legal theory,",
        "      whether in tort (including negligence), contract, or otherwise,",
        "      unless required by applicable law (such as deliberate and grossly",
        "      negligent acts) or agreed to in writing, shall any Contributor be",
        "      liable to You for damages, including any direct, indirect, special,",
        "      incidental, or consequential damages of any character arising as a",
        "      result of this License or out of the use or inability to use the",
        "      Work (including but not limited to damages for loss of goodwill,",
        "      work stoppage, computer failure or malfunction, or any and all",
        "      other commercial damages or losses), even if such Contributor",
        "      has been advised of the possibility of such damages.",
        "",
        "   9. Accepting Warranty or Additional Liability. While redistributing",
        "      the Work or Derivative Works thereof, You may choose to offer,",
        "      and charge a fee for, acceptance of support, warranty, indemnity,",
        "      or other liability obligations and/or rights consistent with this",
        "      License. However, in accepting such obligations, You may act only",
        "      on Your own behalf and on Your sole responsibility, not on behalf",
        "      of any other Contributor, and only if You agree to indemnify,",
        "      defend, and hold each Contributor harmless for any liability",
        "      incurred by, or claims asserted against, such Contributor by reason",
        "      of your accepting any such warranty or additional liability.",
        "",
        "   END OF TERMS AND CONDITIONS",
        "",
        "   APPENDIX: How to apply the Apache License to your work.",
        "",
        "      To apply the Apache License to your work, attach the following",
        "      boilerplate notice, with the fields enclosed by brackets \"[]\"",
        "      replaced with your own identifying information. (Don't include",
        "      the brackets!)  The text should be enclosed in the appropriate",
        "      comment syntax for the file format. We also recommend that a",
        "      file or class name and description of purpose be included on the",
        "      same \"printed page\" as the copyright notice for easier",
        "      identification within third-party archives.",
        "",
        "   Copyright [yyyy] [name of copyright owner]",
        "",
        "   Licensed under the Apache License, Version 2.0 (the \"License\");",
        "   you may not use this file except in compliance with the License.",
        "   You may obtain a copy of the License at",
        "",
        "       http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "   Unless required by applicable law or agreed to in writing, software",
        "   distributed under the License is distributed on an \"AS IS\" BASIS,",
        "   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "   See the License for the specific language governing permissions and",
        "   limitations under the License.",
        ""
      ]
    }
  },
  "images": {
    "PENDULUM_LAB/energy-screen-icon.png": {
      "text": [
        "Copyright 2002-2016 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar"
    },
    "PENDULUM_LAB/intro-navbar-icon.png": {
      "text": [
        "Copyright 2002-2016 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar"
    },
    "PENDULUM_LAB/intro-screen-icon.png": {
      "text": [
        "Copyright 2002-2016 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar"
    },
    "PENDULUM_LAB/period-timer-background.png": {
      "text": [
        "Copyright 2017 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar"
    },
    "PENDULUM_LAB/lab-navbar-icon.png": {
      "text": [
        "Copyright 2002-2016 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar"
    },
    "PENDULUM_LAB/lab-screen-icon.png": {
      "text": [
        "Copyright 2002-2016 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar"
    },
    "BRAND/logo.png": {
      "text": [
        "Copyright 2002-2015 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": ""
    },
    "BRAND/logo-on-white.png": {
      "text": [
        "Copyright 2002-2015 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": ""
    },
    "JOIST/keyboard-icon.png": {
      "text": [
        "Copyright 2016 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar based on original icon from Font Awesome"
    },
    "JOIST/keyboard-icon-on-white.png": {
      "text": [
        "Copyright 2016 University of Colorado Boulder"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar based on original icon from Font Awesome"
    }
  }
};
  // ### END THIRD PARTY LICENSE ENTRIES ###
  window.phet.chipper.dependencies = {
  "comment": "# pendulum-lab 1.0.27 Mon Dec 11 2023 19:03:07 GMT-0700 (Mountain Standard Time)",
  "assert": {
    "sha": "928741cfc8fe804334d5b35292140314511f8678",
    "branch": "HEAD"
  },
  "axon": {
    "sha": "24c942a45d087621bd125e3b5495a17c67dd3ee3",
    "branch": "HEAD"
  },
  "babel": {
    "sha": "1dcd4998211cd826bf377fbdd0c13ae4088632e3",
    "branch": "main"
  },
  "brand": {
    "sha": "6945d66be1d817c4e8eb296f0ffd72e57539e6c0",
    "branch": "HEAD"
  },
  "chipper": {
    "sha": "e25e259afdfded9af778a476403eb4320edc73a1",
    "branch": "HEAD"
  },
  "dot": {
    "sha": "db33a2c7fca14980bccd7d9517839c5b8ae7a9ee",
    "branch": "HEAD"
  },
  "joist": {
    "sha": "6ad7152e1f4d807e44a1c61302fdfbc2da871849",
    "branch": "HEAD"
  },
  "kite": {
    "sha": "dc5c4382bce034652a4e0bae6c739ba8284b2558",
    "branch": "HEAD"
  },
  "pendulum-lab": {
    "sha": "e6f5c346ee380cfdd0a0d3038bf605cce2b76a0f",
    "branch": "HEAD"
  },
  "phet-core": {
    "sha": "574e21cea6572c2c9f5c75d8cf51560024145c67",
    "branch": "HEAD"
  },
  "phetcommon": {
    "sha": "21d5fe5fa42b28417ea02dac1f8c8eb7e8321dc1",
    "branch": "HEAD"
  },
  "phetmarks": {
    "sha": "a9ad33f2be05b094e134a189391baa52a6c860ab",
    "branch": "HEAD"
  },
  "query-string-machine": {
    "sha": "c74e454ec68033a9546b8181d4d962eb8ceef81f",
    "branch": "HEAD"
  },
  "scenery": {
    "sha": "3041922cc2c57f09bbc9a5d6ecf16e739a7431aa",
    "branch": "HEAD"
  },
  "scenery-phet": {
    "sha": "961cb04e3623638a59e1cf0e6888d372876f29d0",
    "branch": "HEAD"
  },
  "sherpa": {
    "sha": "8a5d6d7f7fe731babf3d0c54b357c82740ba4b8e",
    "branch": "HEAD"
  },
  "sun": {
    "sha": "9820ea3048d1b97debc53fff442040e189d229fd",
    "branch": "HEAD"
  },
  "tandem": {
    "sha": "37243b99c58d4195f7f9302b72bda8456dff307a",
    "branch": "HEAD"
  }
};
  window.phet.chipper.strings = {"ru":{"PENDULUM_LAB/custom":"‪Заданная пользователем‬","PENDULUM_LAB/earth":"‪Земля‬","PENDULUM_LAB/jupiter":"‪Юпитер‬","PENDULUM_LAB/moon":"‪Луна‬","PENDULUM_LAB/planetX":"‪Планета Х‬","PENDULUM_LAB/legend.kineticEnergyAbbreviation":"‪E<sub>к</sub>‬","PENDULUM_LAB/legend.potentialEnergyAbbreviation":"‪E<sub>п</sub>‬","PENDULUM_LAB/legend.thermalEnergyAbbreviation":"‪ΔU‬","PENDULUM_LAB/legend.totalEnergyAbbreviation":"‪E<sub>полн</sub>‬","PENDULUM_LAB/energyLegend":"‪Энергия‬","PENDULUM_LAB/legend.kineticEnergy":"‪Кинетическая энергия‬","PENDULUM_LAB/legend.potentialEnergy":"‪Потенциальная энергия‬","PENDULUM_LAB/legend.thermalEnergy":"‪Внутренняя энергия‬","PENDULUM_LAB/legend.totalEnergy":"‪Полная энергия‬","PENDULUM_LAB/energyGraph":"‪Диаграмма превращения энергии‬","PENDULUM_LAB/pendulumMassPattern":"‪Масса {{pendulumNumber}}‬","PENDULUM_LAB/friction":"‪Затухание‬","PENDULUM_LAB/lots":"‪Большое ‬","PENDULUM_LAB/none":"‪Отсутствует‬","PENDULUM_LAB/gravitationalAccelerationPattern":"‪{{gravity}} м/с<sup>2</sup>‬","PENDULUM_LAB/whatIsTheValueOfGravity":"‪Какого значение силы тяжести?‬","PENDULUM_LAB/gravity":"‪Сила тяжести (гравитация g)‬","PENDULUM_LAB/length":"‪Длина {{pendulumNumber}}‬","PENDULUM_LAB/mass":"‪Масса {{pendulumNumber}}‬","PENDULUM_LAB/metersPattern":"‪{{meters}} м‬","PENDULUM_LAB/kilogramsPattern":"‪{{kilograms}} кг‬","PENDULUM_LAB/rulerUnits":"‪см‬","PENDULUM_LAB/normal":"‪Нормально‬","PENDULUM_LAB/slowMotion":"‪Медленно‬","PENDULUM_LAB/degreesPattern":"‪{{degrees}}°‬","SCENERY_PHET/ResetAllButton.name":"‪Reset All‬","PENDULUM_LAB/ruler":"‪Линейка‬","PENDULUM_LAB/stopwatch":"‪Секундомер‬","PENDULUM_LAB/periodTimer":"‪Таймер периода‬","PENDULUM_LAB/periodTrace":"‪Траектория за один период‬","PENDULUM_LAB/screen.energy":"‪Энергия‬","PENDULUM_LAB/screen.intro":"‪Введение‬","PENDULUM_LAB/acceleration":"‪Вектор ускорения‬","PENDULUM_LAB/velocity":"‪Вектор скорости‬","PENDULUM_LAB/secondsPattern":"‪{{seconds}} с‬","PENDULUM_LAB/period":"‪Период‬","PENDULUM_LAB/screen.lab":"‪Лаборатория‬","JOIST/credits.contributors":"‪В проекте участвовали: {0}‬","JOIST/credits.graphicArts":"‪Графика: {0}‬","JOIST/credits.leadDesign":"‪Дизайн: {0}‬","JOIST/credits.qualityAssurance":"‪Тестирование: {0}‬","JOIST/credits.softwareDevelopment":"‪Разработка ПО: {0}‬","JOIST/credits.team":"‪Команда: {0}‬","JOIST/credits.thanks":"‪Благодарности‬","JOIST/credits.title":"‪Над программой работали‬","JOIST/credits.translation":"‪Перевод‬","JOIST/termsPrivacyAndLicensing":"‪Условия лицензирования конфиденциальности‬","JOIST/translation.credits.link":"‪Над переводом работали‬","JOIST/thirdParty.credits.link":"‪Сторонние разработчики‬","JOIST/updates.upToDate":"‪Обновление не требуется‬","JOIST/updates.outOfDate":"‪Доступна новая версия‬","JOIST/updates.checking":"‪Проверка обновлений...‬","JOIST/updates.offline":"‪Невозможно проверить наличие обновлений.‬","JOIST/updates.newVersionAvailable":"‪Доступна новая версия: {0}‬","JOIST/updates.yourCurrentVersion":"‪Текущая версия: {0}‬","JOIST/updates.getUpdate":"‪Обновить...‬","JOIST/updates.noThanks":"‪Нет, спасибо‬","JOIST/versionPattern":"‪версия {0}‬","JOIST/options.title":"‪Настройки‬","JOIST/menuItem.options":"‪Настройки...‬","JOIST/menuItem.about":"‪Справка‬","JOIST/menuItem.mailInputEventsLog":"‪Выслать на почту лог событий ввода‬","JOIST/menuItem.outputInputEventsLog":"‪Вывести лог событий ввода‬","JOIST/menuItem.phetWebsite":"‪Сайт PhET...‬","JOIST/menuItem.reportAProblem":"‪Сообщить об ошибке...‬","JOIST/menuItem.screenshot":"‪Фотография экрана‬","JOIST/menuItem.fullscreen":"‪Во весь экран‬","JOIST/menuItem.getUpdate":"‪Проверить на наличие обновлений...‬","JOIST/menuItem.submitInputEventsLog":"‪Отправить лог событий ввода‬","JOIST/keyboardShortcuts.title":"‪Горячие клавиши‬","JOIST/simTitleWithScreenNamePattern":"‪{{simName}} — {{screenName}}‬","PENDULUM_LAB/pendulum-lab.title":"‪Математический маятник‬"}};
</script>

<!--
Populate the splash image data for use in the splash screen.
-->
<script>window.PHET_SPLASH_DATA_URI="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuNCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSIyNzZweCIgaGVpZ2h0PSIxMzJweCIgdmlld0JveD0iMCAwIDI3NiAxMzIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI3NiAxMzIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8Zz4KCTxnPgoJCTxyZWN0IHg9IjAuNDk5IiB5PSIxMTYuNzgxIiBmaWxsPSIjRkZGRkZGIiB3aWR0aD0iMy42IiBoZWlnaHQ9IjEzLjk4NCIvPgoJCTxwb2x5Z29uIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iMTYuOTQyLDEyNS4xNzIgMTEuMjYxLDExNi43ODEgNy42NTEsMTE2Ljc4MSA3LjY1MSwxMzAuNzY2IDExLjI2MSwxMzAuNzY2IDExLjI2MSwxMjIuNDQxIAoJCQkxNi45ODcsMTMwLjc2NiAyMC41NTMsMTMwLjc2NiAyMC41NTMsMTE2Ljc4MSAxNi45NDIsMTE2Ljc4MSAJCSIvPgoJCTxwb2x5Z29uIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iMjMuMDUxLDEyMC4wNSAyNy4wNzcsMTIwLjA1IDI3LjA3NywxMzAuNzY2IDMwLjY4MywxMzAuNzY2IDMwLjY4MywxMjAuMDUgMzQuNzU3LDEyMC4wNSAKCQkJMzQuNzU3LDExNi43ODEgMjMuMDUxLDExNi43ODEgCQkiLz4KCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjM3LjAyNCwxMzAuNzY2IDQ2Ljc3NiwxMzAuNzY2IDQ2Ljc3NiwxMjcuODEyIDQwLjYyOSwxMjcuODEyIDQwLjYyOSwxMjUuMjQ4IDQ1Ljk1OSwxMjUuMjQ4IAoJCQk0NS45NTksMTIyLjI5MSA0MC42MjksMTIyLjI5MSA0MC42MjksMTE5LjcxNSA0Ni43NzYsMTE5LjcxNSA0Ni43NzYsMTE2Ljc4MSAzNy4wMjQsMTE2Ljc4MSAJCSIvPgoJCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik02MC44MjksMTIxLjMyOWMwLTIuOTU0LTIuMzAzLTQuNTUyLTUuNjM3LTQuNTUyaC01LjUxOXYxMy45ODhoMy42MXYtNC42NzZoMS40OWwyLjU5OSw0LjY3Nmg0LjAyNgoJCQlsLTMuMzc5LTUuMjE5QzU5LjY0MSwxMjUuMDE4LDYwLjgyOSwxMjMuNjM3LDYwLjgyOSwxMjEuMzI5eiBNNTUuNDIyLDEyMy4zODVoLTIuMTM4di0zLjY3aDIuMTM4CgkJCWMwLjkzNywwLDEuODAyLDAuNzEzLDEuODAyLDEuODQ2QzU3LjIyNCwxMjIuNjY5LDU2LjM1OCwxMjMuMzg1LDU1LjQyMiwxMjMuMzg1eiIvPgoJCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik02OC43ODgsMTE2Ljc4MWwtNS41NjIsMTMuOTg0aDMuODg0bDEuMDg4LTMuMzUzaDQuNTcxbDEuMDk1LDMuMzUzaDMuODc5bC01LjU1OS0xMy45ODRINjguNzg4egoJCQkgTTY5LjA2LDEyNC43NDhsMS40My00LjM0MmwxLjQwMSw0LjM0Mkg2OS4wNnoiLz4KCQk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNNzkuMDI4LDEyMy43NjJjMCw1LjkxMSwzLjU2Miw3LjE1NCw2LjU2NCw3LjE1NGMxLjQ4OSwwLDMuMDIxLTAuMzk4LDQuNDg2LTAuOTg4di0zLjEyNwoJCQljLTEuNTMxLDAuNzM3LTIuODMyLDEuMDEyLTQuMjc0LDEuMDEyYy0xLjY2MSwwLTMuMTcxLTAuNzM2LTMuMTcxLTQuMDUxYzAtMy4zMTUsMS41MS00LjA0OSwzLjE3MS00LjA0OQoJCQljMS40NDIsMCwyLjc0NCwwLjI3MSw0LjI3NCwxLjAwNHYtMy4xMjNjLTEuNDYzLTAuNTg2LTIuOTk3LTAuOTg0LTQuNDg2LTAuOTg0QzgyLjU5MSwxMTYuNjA5LDc5LjAyOCwxMTcuODQ2LDc5LjAyOCwxMjMuNzYyeiIvPgoJCTxwb2x5Z29uIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iOTEuOTk1LDEyMC4wNSA5Ni4wMjEsMTIwLjA1IDk2LjAyMSwxMzAuNzY2IDk5LjYyOSwxMzAuNzY2IDk5LjYyOSwxMjAuMDUgMTAzLjY5NiwxMjAuMDUgCgkJCTEwMy42OTYsMTE2Ljc4MSA5MS45OTUsMTE2Ljc4MSAJCSIvPgoJCTxyZWN0IHg9IjEwNS45ODUiIHk9IjExNi43ODEiIGZpbGw9IiNGRkZGRkYiIHdpZHRoPSIzLjYwNyIgaGVpZ2h0PSIxMy45ODQiLz4KCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjExOC44MDIsMTI2LjY3NiAxMTUuNjgxLDExNi43ODEgMTExLjgyMywxMTYuNzgxIDExNy4xOSwxMzAuNzY2IDEyMC40NjIsMTMwLjc2NiAxMjUuNzksMTE2Ljc4MSAKCQkJMTIxLjkzMiwxMTYuNzgxIAkJIi8+CgkJPHBvbHlnb24gZmlsbD0iI0ZGRkZGRiIgcG9pbnRzPSIxMjcuOTU0LDEzMC43NjYgMTM3LjcwNCwxMzAuNzY2IDEzNy43MDQsMTI3LjgxMiAxMzEuNTYsMTI3LjgxMiAxMzEuNTYsMTI1LjI0OCAxMzYuODg5LDEyNS4yNDggCgkJCTEzNi44ODksMTIyLjI5MSAxMzEuNTYsMTIyLjI5MSAxMzEuNTYsMTE5LjcxNSAxMzcuNzA0LDExOS43MTUgMTM3LjcwNCwxMTYuNzgxIDEyNy45NTQsMTE2Ljc4MSAJCSIvPgoJCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik0xNDcuNjg2LDEyMC40OWMwLTEuNTUxLDEuMjM4LTIuMzkzLDMuNDY0LTIuMzkzYzEuNDI2LDAsMi41NzcsMC40NDEsMy4zNTQsMC44ODV2LTEuNTU4CgkJCWMtMC44OTktMC40NDItMi4wODEtMC44MzUtMy41MDQtMC44MzVjLTMuNTY0LDAtNC44MjQsMi4wMTQtNC44MjQsMy44OTljMCw0LjY4Myw3LjcxNywyLjYyLDcuNzE3LDYuNzEKCQkJYzAsMS44NDctMS45NDYsMi4yMjUtMy41NjksMi4yMjVjLTEuOSwwLTMuMjAxLTAuNTY0LTQuMDIxLTEuMTExdjEuNjM4YzAuOTg1LDAuNTI4LDIuMzQ5LDAuOTg3LDQuMTMxLDAuOTg3CgkJCWMzLjEyNiwwLDQuOTc0LTEuNDEsNC45NzQtMy43MzdDMTU1LjQwNSwxMjEuODUyLDE0Ny42ODYsMTIzLjU1MSwxNDcuNjg2LDEyMC40OXoiLz4KCQk8cmVjdCB4PSIxNTguNTE1IiB5PSIxMTYuNzc3IiBmaWxsPSIjRkZGRkZGIiB3aWR0aD0iMS41MSIgaGVpZ2h0PSIxMy45ODgiLz4KCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjE3MC4wODksMTIzLjg5MSAxNjUuMjg4LDExNi43ODEgMTYzLjY1MywxMTYuNzgxIDE2My42NTMsMTMwLjc2NiAxNjUuMTYzLDEzMC43NjYgCgkJCTE2NS4xNjMsMTE5LjI1MiAxNzAuMDg5LDEyNi4zODQgMTc1LjA0MSwxMTkuMjUyIDE3NS4wNDEsMTMwLjc2NiAxNzYuNTUxLDEzMC43NjYgMTc2LjU1MSwxMTYuNzgxIDE3NC45MTksMTE2Ljc4MSAJCSIvPgoJCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik0xOTAuMTEsMTI1LjEwNGMwLDMtMS4zNjUsNC40NDktNC4xNzcsNC40NDlzLTQuMTc4LTEuNDQ5LTQuMTc4LTQuNDQ5di04LjMyMmgtMS41MDd2OC4yMzQKCQkJYzAsMy44MjQsMi4wMTcsNS45MjIsNS42ODUsNS45MjJjMy42NzMsMCw1LjY4NS0yLjA5OCw1LjY4NS01LjkyMnYtOC4yMzRoLTEuNTA4VjEyNS4xMDRMMTkwLjExLDEyNS4xMDR6Ii8+CgkJPHBvbHlnb24gZmlsbD0iI0ZGRkZGRiIgcG9pbnRzPSIxOTYuNjU3LDExNi43ODEgMTk1LjE0NSwxMTYuNzgxIDE5NS4xNDUsMTMwLjc2NiAyMDMuODA5LDEzMC43NjYgMjAzLjgwOSwxMjkuMjk5IAoJCQkxOTYuNjU3LDEyOS4yOTkgCQkiLz4KCQk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNMjExLjEzNCwxMTYuNzgxbC01LjU4LDEzLjk4NGgxLjYzM2wxLjY4LTQuMzU1aDYuMDQzbDEuNjc5LDQuMzU1aDEuNjFsLTUuNTU4LTEzLjk4NEgyMTEuMTM0egoJCQkgTTIwOS40MjksMTI0Ljk1OWwyLjQ2LTYuMzk4bDIuNDUyLDYuMzk4SDIwOS40Mjl6Ii8+CgkJPHBvbHlnb24gZmlsbD0iI0ZGRkZGRiIgcG9pbnRzPSIyMTcuNDg5LDExOC4yNDQgMjIyLjQzOCwxMTguMjQ0IDIyMi40MzgsMTMwLjc2NiAyMjMuOTUyLDEzMC43NjYgMjIzLjk1MiwxMTguMjQ0IAoJCQkyMjguODc5LDExOC4yNDQgMjI4Ljg3OSwxMTYuNzgxIDIxNy40ODksMTE2Ljc4MSAJCSIvPgoJCTxyZWN0IHg9IjIzMS4xNjciIHk9IjExNi43NzciIGZpbGw9IiNGRkZGRkYiIHdpZHRoPSIxLjUwOSIgaGVpZ2h0PSIxMy45ODgiLz4KCQk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNMjQyLjE4MiwxMTYuNTljLTQuMjk3LDAtNi40NzksMi40MDktNi40NzksNy4xNzJjMCw0Ljc2LDIuMTgzLDcuMTc2LDYuNDc5LDcuMTc2CgkJCWM0LjMyMSwwLDYuNTA3LTIuNDE2LDYuNTA3LTcuMTc0QzI0OC42ODgsMTE4Ljk5OSwyNDYuNTAzLDExNi41OSwyNDIuMTgyLDExNi41OXogTTI0Mi4xODIsMTI5LjUxCgkJCWMtMy40MzgsMC00Ljk3Mi0xLjc2Mi00Ljk3Mi01Ljc0NmMwLTMuOTY1LDEuNTMzLTUuNzQ4LDQuOTcyLTUuNzQ4YzMuNDY2LDAsNC45OTUsMS43ODMsNC45OTUsNS43NDgKCQkJQzI0Ny4xNzYsMTI3Ljc0OCwyNDUuNjQ2LDEyOS41MSwyNDIuMTgyLDEyOS41MXoiLz4KCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjI2MS43MTUsMTI4LjU2NCAyNTMuMzY5LDExNi43ODEgMjUxLjY0OCwxMTYuNzgxIDI1MS42NDgsMTMwLjc2NiAyNTMuMTU4LDEzMC43NjYgCgkJCTI1My4xNTgsMTE4Ljk4MiAyNjEuNTI0LDEzMC43NjYgMjYzLjIyNSwxMzAuNzY2IDI2My4yMjUsMTE2Ljc4MSAyNjEuNzE1LDExNi43ODEgCQkiLz4KCQk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNMjY3Ljc3OCwxMjAuNDljMC0xLjU1MSwxLjIzNi0yLjM5MywzLjQ2NS0yLjM5M2MxLjQyNSwwLDIuNTc2LDAuNDQxLDMuMzU1LDAuODg1di0xLjU1OAoJCQljLTAuOTAyLTAuNDQyLTIuMDc3LTAuODM1LTMuNTA1LTAuODM1Yy0zLjU2MywwLTQuODIxLDIuMDE0LTQuODIxLDMuODk5YzAsNC42ODMsNy43MjIsMi42Miw3LjcyMiw2LjcxCgkJCWMwLDEuODQ3LTEuOTU1LDIuMjI1LTMuNTcsMi4yMjVjLTEuOTA3LDAtMy4yMDctMC41NjQtNC4wMjctMS4xMTF2MS42MzhjMC45ODYsMC41MjgsMi4zNTQsMC45ODcsNC4xMzMsMC45ODcKCQkJYzMuMTI1LDAsNC45NzItMS40MSw0Ljk3Mi0zLjczN0MyNzUuNDk5LDEyMS44NTIsMjY3Ljc3OCwxMjMuNTUxLDI2Ny43NzgsMTIwLjQ5eiIvPgoJPC9nPgoJPGc+CgkJPHBhdGggZmlsbD0iIzZBQ0VGNSIgZD0iTTM0LjcyMywyNS4zNTlIMi41MTFjLTEuMTExLDAtMi4wMTIsMC45MDQtMi4wMTIsMi4wMDl2ODAuNTQyYzAsMS4xMTEsMC45LDIuMDEyLDIuMDEyLDIuMDEyaDE3Ljc3NwoJCQljMS4xMTUsMCwyLjAxNi0wLjksMi4wMTYtMi4wMTJWODYuODRjMC0xLjExOSwwLjg5OC0yLjAxNiwyLjAxNi0yLjAxNmgxMC40MDFjMjAuNTQ0LDAsMzIuMzM0LTEwLjkwNSwzMi4zMzQtMjkuNzk5CgkJCUM2Ny4wNTgsMzYuMjY0LDU1LjI2NywyNS4zNTksMzQuNzIzLDI1LjM1OSBNMzIuNjk2LDY2LjgyMmgtOC4zNzVjLTEuMTE5LDAtMi4wMTctMC45MDUtMi4wMTctMi4wMlY0NS4xMjQKCQkJYzAtMS4xMTUsMC44OTctMi4wMTIsMi4wMTctMi4wMTJoOC4zNzVjOS42MzEsMCwxMi42ODMsNi41OTEsMTIuNjgzLDExLjkxNUM0NS4zNzgsNjAuNjExLDQyLjMyNyw2Ni44MjIsMzIuNjk2LDY2LjgyMiIvPgoJCTxwYXRoIGZpbGw9IiM2QUNFRjUiIGQ9Ik0yNzMuNDg3LDI1LjM1OUgxNDkuODM5Yy0xLjExMiwwLTIuMDE4LDAuOTA0LTIuMDE4LDIuMDA5djgwLjU0MmMwLDEuMTExLDAuOTA0LDIuMDEyLDIuMDE4LDIuMDEyaDU0LjkyOAoJCQljMS4xMTMsMCwyLjAxNC0wLjksMi4wMTQtMi4wMTJWOTQuMDY0YzAtMS4xMTMtMC44OTktMi4wMi0yLjAxNC0yLjAyaC0zNC4xMzNjLTAuNTU1LDAtMS4wMDUtMC40NDktMS4wMDUtMS4wMDhWNzcuNTg0CgkJCWMwLTAuNTU1LDAuNDUtMS4wMSwxLjAwNS0xLjAxaDI5LjE4OGMxLjExMSwwLDIuMDEzLTAuODk2LDIuMDEzLTIuMDFWNjAuNzE5YzAtMS4xMTMtMC45LTIuMDItMi4wMTMtMi4wMmgtMjkuMTg4CgkJCWMtMC41NTUsMC0xLjAwNS0wLjQ1LTEuMDA1LTEuMDA4VjQ0LjExNWMwLTAuNTU1LDAuNDUtMS4wMDYsMS4wMDUtMS4wMDZsNTcuNDUsMC4wNmMwLjU1OCwwLDEuMDE0LDAuNDUzLDEuMDE0LDEuMDA3djYzLjczMwoJCQljMCwxLjExLDAuOTAyLDIuMDEyLDIuMDA5LDIuMDEyaDE3Ljc4M2MxLjEwOSwwLDIuMDE0LTAuODk5LDIuMDE0LTIuMDEyVjQ0LjE3OGMwLTAuNTUzLDAuNDUtMS4wMDcsMS4wMDgtMS4wMDdoMjEuNTc2CgkJCWMxLjEwNCwwLDIuMDEzLTAuOTA1LDIuMDEzLTIuMDA5VjI3LjM2OEMyNzUuNDk5LDI2LjI2NCwyNzQuNTkyLDI1LjM1OSwyNzMuNDg3LDI1LjM1OSIvPgoJCTxwYXRoIGZpbGw9IiNGRUUxMDUiIGQ9Ik0xMjEuMzc0LDQ4LjE4NmMtMC44MDksMi41MDQtMS41NzIsNS4wMzktMi4yNjIsNy42MjVjLTAuMTQ0LDAuNTQzLTAuMjc3LDEuMDk4LTAuNDI2LDEuNjQ2CgkJCWMtNi40OCwyOC4wMDgtMi45NjcsNDYuMzEyLTEuNzQ2LDUyLjI3M2MwLjI5MywwLjEyNSwwLjU4NiwwLjE5MSwwLjg5MSwwLjE5MWgxNi40MzdjMS4xMTEsMCwyLjAyNC0wLjksMi4wMjQtMi4wMTJWNzIuNjQ4CgkJCUMxMzYuMjkxLDYwLjk2MywxMzAuOTkzLDUyLjE5MywxMjEuMzc0LDQ4LjE4NiIvPgoJCTxwYXRoIGZpbGw9IiNGRUUxMDUiIGQ9Ik05Ny40OTEsNDYuNTMzVjI0LjU4NWMwLTEuMTEyLTAuOTA3LTIuMDIxLTIuMDEyLTIuMDIxSDc3LjY5NGMtMS4xMTEsMC0yLjAxNiwwLjkwOC0yLjAxNiwyLjAyMXY4My4zMjYKCQkJYzAsMS4xMSwwLjkwNCwyLjAxMiwyLjAxNiwyLjAxMmgxMS4xODRjMC41MTUsMCwxLjAwMi0wLjE5MiwxLjQwNi0wLjQ5M2MzLjE1Ni0yNS4yNDgsMTIuNTg4LTQ3LjIwNywyMS44OTYtNjMuNDY3CgkJCWMtMS4yNjQtMC4xMjUtMi41NTgtMC4xODYtMy45MTYtMC4xODZDMTA0Ljg1LDQ1Ljc3NywxMDAuNTM0LDQ2LjAyMSw5Ny40OTEsNDYuNTMzIi8+CgkJPHBvbHlnb24gZmlsbD0iI0ZFRTEwNSIgcG9pbnRzPSIxMDcuNzExLDE3LjQyOCAxMjAuMTg1LDIxLjkzOCAxMzYuMjMzLDguNTcyIDEyMy44OCwyMy4xOTkgMTM3LjIyOCwyNy45MDQgMTQyLjA0LDEuMDYyIAkJIi8+CgkJPHBvbHlsaW5lIGZpbGw9IiNGMkU5MTYiIHBvaW50cz0iMTI1LjEwOCwzMC41ODggMTI0LjU4NywyNC42IDEyOS4xOTIsMjYuMjYgCQkiLz4KCTwvZz4KCTxnPgoJCTxwYXRoIGZpbGw9IiM2QUNFRjUiIGQ9Ik0yNTcuMzMzLDEwOS45MjJ2LTQuODUxaC0xLjgxMnYtMC42NDhoNC4zNnYwLjY0OGgtMS44MnY0Ljg1MUgyNTcuMzMzeiIvPgoJCTxwYXRoIGZpbGw9IiM2QUNFRjUiIGQ9Ik0yNjAuNjA0LDEwOS45MjJ2LTUuNDk5aDEuMDk4bDEuMzAyLDMuODk0YzAuMTIsMC4zNjMsMC4yMDgsMC42MzYsMC4yNjMsMC44MTUKCQkJYzAuMDYyLTAuMjAyLDAuMTYtMC40OTMsMC4yOTItMC44ODFsMS4zMTctMy44MjhoMC45Nzl2NS40OTloLTAuNzAxdi00LjYwMmwtMS41OTksNC42MDJoLTAuNjU2bC0xLjU5MS00LjY4MnY0LjY4MkgyNjAuNjA0eiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="</script>
<script type="text/javascript">window.phet.chipper.mipmaps = {"BRAND/logo-on-white.png":[{width:273,height:108,url:"data:image/png;base64,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"},{width:137,height:54,url:"data:image/png;base64,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"},{width:69,height:27,url:"data:image/png;base64,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"},{width:35,height:14,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAOCAYAAACl66WxAAAAAklEQVR4AewaftIAAALnSURBVK3BT0jedQDH8ffn+/3p47SpUyTcVpMdokV/RFZBl6BiVzt0rYgdQpFgQREE3jp48FCkshFBtegwrDFqXYIOHVrNkgUDC2lSGYyVo/no4/T5fT89zmf6IK6J6/USd8AzscORQUvluL98jDuUsQP5TDhI0JsJjmAKyCf5H2RHf5pXXL6LDcvspp7hwzJV6UrsJfEgAi3xWQp6lMQBoi+S8wzi/MvfL8ihkZ0pcuLwbmeFPI47lJ7kJsEipcX+ycUpKRsa6a7/ykt+UbmeBewCc7GzPAZ8kP8ZXyFwLpTD57FOE3api51QvAA8ldluBtpYZRsDUpthnykf6psoPi2aQRYIMDfFvfk73JDT96P3AG0Yg7k1gRC2WacWKjI2WDGOCBVTSr3Y92PvDXVxgFq5jqTZ+JCcD7gcDoauNE0tMR9C9jaIzYxxyl8DGgjhUlD8mFXyLBUZVQKc0pejPU1n+ydLM8ZjgJx8D5C4waKsXkc+hfgCkaE0GwfCvvwUYNastC4XBt96TGz20rTVML/4KmZVcaS7MEiNjFpGR8/MU/EEa4woAo1UWSzIHrLUr0QH5pgnONUPYk3rXF3pSt/kIhgUdCkPDY8ff1jmNgJVpkKcrN8frtrpeUDACtIX1BLnwr3pPKYLLIsDHEJsCNjt2O3gdie3zUW2JbBBQAvQwpp5BY2NPrLrE9bJiNOs2UOFINBIrWKIcVhZNqwsGw5ZPMF1zDZkbLBCeA+4JvF3Xk7jY92Nv1DD8NfySjgOOYIGtrbc2lB4ve4+zKolmJv8lu3IqBLglE6P9TSd5RYkpncdXClTYUhiS61XS6U/uMC69uaej4A3uI2MNTYV5r/Y0q9UCa4BBswqA8JAcHIntUwrFXmeU2Uq+n4oPod4ADQ31tP0bhayOI50kYr8+vLPbMF1OkPO72T+mioHPiToO8Q/v03hUB/fB3WwmSEEvqGicyV6IctGDQXbs06ewr4MvpuKfwGZEj3EDvHM3gAAAABJRU5ErkJggg=="},{width:18,height:7,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAHCAYAAAAF1R1/AAAAAklEQVR4AewaftIAAAE2SURBVIXBsUvUcRzG8ffz+QXX+QukKAcRT2xSiNLjcslVnaLFfyAsEhr6B1wEcWwQuhtrEWlsbRDcUzBF3CxyiEyKIkrv+326uvWi10v8QzrSFaQlpKFiOM3zH1rc/tGyuSqRJDbXrl06V+KhL2iZzAym8vjkW9WmpBfxpTXZtxB2nhN5Grvu7KcfzlZuAg3ZDaW8XAynR9h3Rb4tck3kmsg14XsiT8geoiP4S/uEVhGV4/PxQbDcZtahV/l9PEEY6SuKI4ri+c/+smGRiHjdrJdzdAR/iDtkN4HjGxfXD0Em2MCMWExhBFwGXyd7gB6Crh0V8cBmooyXvwynZ+1YAyoC0fWZ0KGCKj2EQgeIt89uVV+06uWJpY+IrepoOyO2De8QewhjjwGjKSUkdoFPi2++36fjNxqpew9Z59GLAAAAAElFTkSuQmCC"}],"BRAND/logo.png":[{width:273,height:108,url:"data:image/png;base64,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"},{width:137,height:54,url:"data:image/png;base64,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"},{width:69,height:27,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEUAAAAbCAYAAAAqCUKuAAAAAklEQVR4AewaftIAAAaMSURBVM3BW4ycZQHG8f/zfu/sqdsTtS0WaAsoCKgIha4UouVwYYhCYtJEL4wQIIDGkFRD8EaHGy6QaKJAQgATQzxEAgFD1EQOxmihsIXS0qYIateytGVry8Ludmfm+97HabvLHjqzdMvS9vcTx5lfQF6cneoW3RFqukvLa70cZ5HjxJuB2fEcR+7AfEXGULuNE0DkGPMWSB3holQKt8u+ylarEoUj/9YyCk4AkWOo2J6tdom1KnQ5BR1keleim8RlmF5OEJEZ5FcJRMa0AWeQJMh7SosV/X0Sq4AOIj2GZ1RwnUGKvMk2TgiRuhs3vR9CtZPmBphLJ/sj/sT5uCwxmQ3+X7yXxAIwB0loB7+B/Mm4rLbb5hp6Sp9MmW9SjRfUwiNAUGZ7WC+Fc/D31lmVlgFBJ8fWAMWizvTwUhFv6R44O3N8gljJaEYl71dlyKivb7NfvGXD+/cvH+zceceXZEb9i1a3+RvKNRfEQcJuYSfwJHUShtrbwJ3F9niRApsd2UTSpUHh2bW9prJn//0ll66ECseUIlnf4M+Be2OQ5jmls22LD2OsoCtDFm/cMbf2wNffcPnxT8uMEAg58AEZTCNB3uEK94fZxeP0gC7AZcM772i5XXwKEMeSlIROoy4gjpyQ7eCUFjnlP1xSqfy0/JzFUdCyYreWFo/pJKwLMMefGBFoxhjb2MaYiWS7lHLftHvO4NUcJYlGxGTG2Anb2MY2trGNbWxjG9vYxja2sRPGTGYb29jGNrYBm0MijVlZ6JbCbg7yHNvnu0hzEGKEi9SRtZRuXrvOfwTRjNcjVmLqJD6MmUx6N2TxH0yfXBRXGLczxiHG10A9jCOhPFVfoi7SQAiBlIqHFvW3PUjdvtl9VEPHlSHLHklFWowQBwi5SJ/tn4tpyFDoWi+J19DrFjK9audf5S0yp2y1dhXPqAszkZhEUt9shq9t2zvHTMOuzkrIWrTThdsZJ4T499b3su92VplodYupizQhRPlymRE3/NdPt+2rPoXSDYxjMb+1NtROK4nDicLLOSAoxzzBo9gr4xpK/NKnxcfs/FsSZoxpoO3zc1JZYjquf9PuGBxmMgvuuVSmicgRenip+E73QC9ZAJsPJFpEaAOGaMayg18OoXiIywD7anK1In/Tb8fc3fn1ugjTnPNuVLZNAwPAPRIzJXKEbt5oKdQ+47zGeArs93AxxFQCSQUP6hRsg3t1jqgzAbPGC+KvIH+OQ8Qkdlq6r1R5jU0cYiYIUX+5faPX3v0FJWZApAmbbM3vLeqWzN9FjcoPXKSrATHGmL5ZHe9WgRYaswNbQlY8zAE7CTKngsUBBW208m1389c7wTTWnlJxLo0lUtz+nxJHzkwp0kBKCQX9aNFZw7cZVGNep1M6GSzGMxC04Y3+96CdxiQQf+BkTF1RzT4XAgsYI5sztYJRZjrMjAs0Jtsnp5TOdkpnOaUl4ACIMQ4x7HGtuPuJy841TVj0hWr6mcRBAV2CyPiApYx2BhCHiMMZMGDAgAED5hAxHWJKkaNjBQ0g7mq5sGMTTckEXoK0l1EZZ2ImMtBJUxLvKYuv0ETItJ4KZoZEmjMNSCoUwibsnwwPtP3uPommhKnxpE7noBfLQIl5roCYjrB7wWDfFUOvP20m6Zx7MT0nncujXxYzJdKYQwhbkPZS5+QkMaQsbC9q+VN9tdY/n7cClyWmJN6ppvAIIy6+CYw7hZhATElA+OIpvueS6zgWIg2EEEh5ce/iFbMeoG7+1q1s6u9neOgS/fqqVlP3KB9GttjWdnp1mFFLgF3KmMxMyeDqq4SybRrph9e3Ps9vV60yMyDShIJclpjETIPkjTzPmLfBgSSmZCaxfcr7peo6ttDUwvkrtpVf9vXlC2U+osDHJWBy/qRVjOkFyYM2E4nxxGHcmVfzrryad+XVvCuv5l15Ne/Kq3lXXs278mq+MuW+gFbEUSiXzXiRj4vYq1r8GxSM0kpIO7RXATBjzEcljsKtGwZ+DAzvKQ3Pu/VrA6/EttLCX5zXel/AZoQBAzbYRkxHZJQB2/QxUKkwWcFWhAEDBowYz5gDDBgwYMCAAQMGDBgwYBqoVWuMMGDAHGAzYjfwz6JWLATOyIdrs6iLJvRlMVsHREZJKc/zN5iOTnLneh5xEgIiG9nFYSQ/m4LWkykwQhmbe7bhHfugfY5ewXE+02EIga2VWZhxTk0lD2asVwgLGWHARbGVOqE9lvsx64BlwFvU/R9mVkvKB3VahwAAAABJRU5ErkJggg=="},{width:35,height:14,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAOCAYAAACl66WxAAAAAklEQVR4AewaftIAAALnSURBVK3BT0jedQDH8ffn+/3p47SpUyTcVpMdokV/RFZBl6BiVzt0rYgdQpFgQREE3jp48FCkshFBtegwrDFqXYIOHVrNkgUDC2lSGYyVo/no4/T5fT89zmf6IK6J6/USd8AzscORQUvluL98jDuUsQP5TDhI0JsJjmAKyCf5H2RHf5pXXL6LDcvspp7hwzJV6UrsJfEgAi3xWQp6lMQBoi+S8wzi/MvfL8ihkZ0pcuLwbmeFPI47lJ7kJsEipcX+ycUpKRsa6a7/ykt+UbmeBewCc7GzPAZ8kP8ZXyFwLpTD57FOE3api51QvAA8ldluBtpYZRsDUpthnykf6psoPi2aQRYIMDfFvfk73JDT96P3AG0Yg7k1gRC2WacWKjI2WDGOCBVTSr3Y92PvDXVxgFq5jqTZ+JCcD7gcDoauNE0tMR9C9jaIzYxxyl8DGgjhUlD8mFXyLBUZVQKc0pejPU1n+ydLM8ZjgJx8D5C4waKsXkc+hfgCkaE0GwfCvvwUYNastC4XBt96TGz20rTVML/4KmZVcaS7MEiNjFpGR8/MU/EEa4woAo1UWSzIHrLUr0QH5pgnONUPYk3rXF3pSt/kIhgUdCkPDY8ff1jmNgJVpkKcrN8frtrpeUDACtIX1BLnwr3pPKYLLIsDHEJsCNjt2O3gdie3zUW2JbBBQAvQwpp5BY2NPrLrE9bJiNOs2UOFINBIrWKIcVhZNqwsGw5ZPMF1zDZkbLBCeA+4JvF3Xk7jY92Nv1DD8NfySjgOOYIGtrbc2lB4ve4+zKolmJv8lu3IqBLglE6P9TSd5RYkpncdXClTYUhiS61XS6U/uMC69uaej4A3uI2MNTYV5r/Y0q9UCa4BBswqA8JAcHIntUwrFXmeU2Uq+n4oPod4ADQ31tP0bhayOI50kYr8+vLPbMF1OkPO72T+mioHPiToO8Q/v03hUB/fB3WwmSEEvqGicyV6IctGDQXbs06ewr4MvpuKfwGZEj3EDvHM3gAAAABJRU5ErkJggg=="},{width:18,height:7,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAHCAYAAAAF1R1/AAAAAklEQVR4AewaftIAAAE2SURBVIXBsUvUcRzG8ffz+QXX+QukKAcRT2xSiNLjcslVnaLFfyAsEhr6B1wEcWwQuhtrEWlsbRDcUzBF3CxyiEyKIkrv+326uvWi10v8QzrSFaQlpKFiOM3zH1rc/tGyuSqRJDbXrl06V+KhL2iZzAym8vjkW9WmpBfxpTXZtxB2nhN5Grvu7KcfzlZuAg3ZDaW8XAynR9h3Rb4tck3kmsg14XsiT8geoiP4S/uEVhGV4/PxQbDcZtahV/l9PEEY6SuKI4ri+c/+smGRiHjdrJdzdAR/iDtkN4HjGxfXD0Em2MCMWExhBFwGXyd7gB6Crh0V8cBmooyXvwynZ+1YAyoC0fWZ0KGCKj2EQgeIt89uVV+06uWJpY+IrepoOyO2De8QewhjjwGjKSUkdoFPi2++36fjNxqpew9Z59GLAAAAAElFTkSuQmCC"}],"JOIST/keyboard-icon-on-white.png":[{width:77,height:67,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAABDCAYAAADZA4jAAAAAAklEQVR4AewaftIAAAOrSURBVO3B4XXb5hUA0Ptw8J/YoNpA6ATiBmYmKDOBmAnCDcJswEwQeoLSG6AbWBtAE7yenDAHhJFS/iy5oi3cG5npLYiIFo0/9ZnZ+UK1t2OPW3/6gKUvVHk7br2QyqxY5Q2IiBsvqPI2tMZ6z1B5G5bGOs9Q+c5FRIO1sYNnqHz/tlgYPGRm5xkq37GI2OLe2N4z1b5DEbHCBnfGHrDzTLVvXES0uEGLFkssTD1ilZm9Z6p9QyLiBisscYNbn+cR68zsvIDaNyAiltjiTrkPWGfmRy+kdsUiosEO/1LmAUfsM/PohdWu2wF3LvuAj+jQocvM3ldUu1IRscOdqQ/Y45iZH72C2hWKiBvcG3vAOjOPXlntOm2NPaLNzN4VqFynlbFVZvauROXKRESLhcFDZh5dkcr1WRk7uDKRmf4SEQ022GBh9og9tpnZO6mMHfEzFmZ/WOAex4honFROImKLW7O/c4utk8pgbXbJ2kll8A+zSxZOahdkZnijIiL9D5VZscqsWGVWrFYoIjZoDA6Z2TkTEQ02xnaZ2TsTES1WBn1m7nwiIlZoDQ6Z2flERGzQGOwys3cmIhpsDPrM3ClQKxARS/xibImlsQ1+NrU1dsTCmYjoMvPoJCJa/G5sg8aZiNjgF2MtVsb2eOdMRMjMnc9UeV0LT2tMLUw1phpTjalGgcqsWGVWrFamw3s0BntTByyNHUz9iLVBj85Yh/doDDpTByyN7X0FtQKZ2WPlCZnZYekJmbnH3gWZ2WPlCZnZYen/oDIrVpkVq8yK1QpERIM9GpdtMrNzJiLWWBv0WGdm70xE7NAadJm5cSYiGuzRGOwzc+9MRLTYGWs9U61Mi3eetsPS2Bp3xlocjd0bu8PGWIt3pvbGVrjzwiqzYpVZscrX0fu29ArUCmTmMSJ+QuOynakNVgZ9Zh5N/YDWoPOJzDxGxE9oDA6mdp7WZ+ZOgVqhzNz5ApnZofOEzDzg4AmZufOEzOyx9cIqs2KVWbHKrFitQETcoMPC4NfM3DgTESv87vX9mpkbZyJih3uDRywzs/OZKmVusDDWmmpdh9ZUa2yBlQKVWbHKrFilTG+qN9W7Dp2p3lSnQK1AZnYR8U80Bp1PZOYuIjqvLDOPptZoDfrM7BSoFcrMzmfIzKMrlJk9jp6hMitWmRWrXRARS7OJ2mX/NpuoDP5jdsmDk8pgZ3bJ3knlJDP3+M3s7/yWmVsnlTOZucYPeI8Hb9sD3uPHzFw7E5lpVua/SRtMh53sI98AAAAASUVORK5CYII="},{width:39,height:34,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAiCAYAAADcbsCGAAAAAklEQVR4AewaftIAAAJ8SURBVM3BT2ibZRwA4Kdf34XCZFoYgx46WdWpRbfBQBEvIp2IOwiFYY8eVDyIHtpLh2ywKp4mogeLIsIC1lIHIj04DP4DEdQIBqHaaRQKK0xED4KhK+rgd/gM+WLqkjV7nkH9cRaTeMd/SPpjEms6yGy/O4VNHWS232PCBR1kttcEpoRPdZBcfYdwHx7EPdiFb3FKB0nvjWEOd+Am7NTsSzyKhg4G9NYTeB675X7EBfyKJbxli5LeGcYcduN7vIoz+M0VSnrnOexBHYfQ0KVM7xwUzqKhBwaEpzGDUf21iQ8wicagsIAb9V+GW7AL7ydhn/AzzuufI8LtLkuanccD+udv/5K09whKqGAdQzgmLKGBEUxgA4vCOA7jIs4J92IM66gIExhBHZ8pkBQ7gLeF05jBMZyRK+N1HBVWUMMruB+b2CG8iLvwE8aE17APX+BuBTLdKWk1ICS5TEhySci0kRRbxQsoYUGo4LRQEWZRwwZWhTfxNX6XewOfYM3/kBRr4Lhm65jRrIqqZmWUNZt3BZJiQziBktwPmBeewSi+QVl4FjfgYyxjCCdQwgKqGMG0sFMHSbH9mNVsDfPCNEbxEcrCnHAAy9iPWbkqJjBtizJbt+nq+EsbSbEaplCSW5d7HHtQl3sY16Mq1DCFEirCklZ1bSTtLWrvnFbvabWoWQNlW5QUG0YZJbyMZYzjJd2p40lhHmP4HCcVSIqN4qhQwzIO44jurMk9hFEM46QCmWKX5DaEDd37U25TuKSNpNgKxrEDq8IiVnTnD7kJXIdftJG0t6JVTe/UdZA0uxUfukYk4Tvchr3Yq/++ctmgcBE3YxhJ/6zjXTzlWvcPH1WKJsdV9HIAAAAASUVORK5CYII="},{width:20,height:17,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAklEQVR4AewaftIAAAFdSURBVJ3BsUtUcQAA4O/OH5QY6CAR1KBZRENNpZCI1ST5NyguEthqDg6BEESgf0GEUgQOtYRRLgqJgiAoBAUmiJglBmlxepxFevCC9zp8ovd9Fco3jNt4JyGrfJdwQong+FrRhcsYUCI4mkYM4Sry+IYHGFciOJrHOIk7mHaIDG7gPqqka8IH7DjYX4xiJKAXbViX7gfOSleDOowEnMI66nELc7ggsoRrmMR1bGEX5zCNZnzBE1xUFMTqMYG76BB5j36cx0t8wmd0oAZv8FxCEFtFN95iTWQBy1hFH75jG7MiGWQkBLFa9OAeXiOLHrRjDk9xE9UYxDwqlcj6Xw45FFDAjsg2fiOPPPaQwywWJWTFfmIK3dhAFZbwCDNoQAEbaEcLxvFRQhA7jX4soxMt0m3iIXrxTEIQW0Ed1jCGSun+iFzBFl75J+AXzmBF+arxVVHAAHZRq3x5vFC0DxfFVSqBrHvfAAAAAElFTkSuQmCC"},{width:10,height:9,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAACFSURBVIXBsQoBYQAA4M/1l8lJSnQyMolXsZq8gnfwKgZl9yIGTGcjg1GKjrqrS5Lv88dSIfjWxQJN7BUqmGGgNMINB6V1wBxbZHJXZOghQ4JOwAMXnFBFAzU80MIZUSQXYYxE7ogUfdy9BbmALSZKd2xQRzUgIEaMnU9tJEgrmGLotydWL90BGkUTJltKAAAAAElFTkSuQmCC"},{width:5,height:5,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAAklEQVR4AewaftIAAAA8SURBVE3BMQqAIAAAwFOksSERfFj0rH7Q74KGwF1aass7gw27T8CBjoIbT0RBx4mMJWFCRUZDClgx+10v5PsJAW+Zqq4AAAAASUVORK5CYII="}],"JOIST/keyboard-icon.png":[{width:77,height:67,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAABDCAYAAADZA4jAAAAAAklEQVR4AewaftIAAAMNSURBVO3B0XHURgAA0MeO/k8d4A6sVGB1wKWCXCqwqCDXAaIDUQGigsgdbDrAHcgVOJnBGWVHcMdyJpZ9eu/V/f29M1Gh9MWI6AcVzkeHS1/coPaDgvNx6ZEEq2zBebjwiILzUEmNThCch1oqOkHw8pXYSfVOELx8e2xMbhGdIHjZ9riW6pyo8DJt0eBK6hatExWevwoXqFChxsbcHbYYnajwvFxgixoXuPR97rBD9AgKz0ONPa7ku8EOnz2SwrKVaPGbPLcY0GHwyArL1uPKYTf4jIiIiNFPVFiuFlfmbtBhwGdPoLBMF7iWusUOgydWWKa91B0qjBYgWKat1BajhQiWp8LG5BaDBQmWZyvVW5hCqkSDBhvLcI1rT+MOHfYYPSikBlxa/WuDa9SoMfpHMNnj0uprLrH3IJjsrA7ZeRBMXlsdsvGgcNgr5+veNwSrbMEqW7DKVsjXoDTpEaVKNFItRqkKW5MRrbktKpMe0VyD0qTFKFWiMRnRylDIU+OdVI1aqsEf5vZSAzZSEYNJhY9SDUqpBu+kKmylOrwx1/pOwdPaOK40tzFXmivNleZKGYJVtmCVrZAn4hNKk85cj1qqN/c7diYjolTEJ5Qm0VyPWqrzExTyjNg6LqJ2XIfOYSO2jouo/Q+CVbZglS1YZSvkKdGhdFiDKLXDzmTEDqNUi8okopEq0aE06dBJVWilKicq5KnwxnEtaqkdrqQqDFLXUldopCq8MddJbXHlkQWrbMEqW/BzjJ6XUYZCngFvUTqsNddgazJiMPcrKpNobsBblCa9udZxI1oZCvlaPyYiOq5H77jWcSP2HlmwyhassgWrbIU8F4jYmLxHI7XFR0/vPRqpFtcmd6gRfacgzwU2UpW5yjJU5iqpDbYyBKtswSpbkGc0N5obLUM0N5qLMhTyRPyC0iSaaxE9vcHcDpXJiChDIV/0fQbLNGJwgmCVLVhlKxxWW80UDvvTaiaY/GV1yK0HwaS1OqTzIJh0+GD1NR+w96CQ2qHHDhVeO1+3iOjR+Y/CXI/e6pv+Brsmp1sL3s1UAAAAAElFTkSuQmCC"},{width:39,height:34,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAiCAYAAADcbsCGAAAAAklEQVR4AewaftIAAALgSURBVM3BTYiUdRwA4Oc3vQ2CUQkieFghAyspEzxFlw6r9HEIBMljh4pOFawXJfzIIjokUYcWI4JZSMW87SVc+oLoUFu0BJbWEiy4UEQdgoZ16dcL/8O7mzONuavj89xkCDLzzOHDh3cfOXLkA/+hMhy7MWeAlussM+9TLBqg5fp7SnHRAC3XUWaOYq/iMwNUrrHM3I6H8DAewK34Di8ZoLLKMnMzjuJe3Im1lvsST0ZE1wBhFWXmM3gF6zV+wkX8htMR8b4rVFklmbkOR7EeP+BtdCLid1epsnpexgbMYntEdK1Qy+q5X3EmIrpWQahl5nPYhxHDtYiz2B0R3ZbiBYwYvgqP4DW1SnGH4mdcMDw7FfeoVZa7EBG7DEnWLFHpIzOfQBtTETGfmWuwR3E6IrqZuRGjWIiIU2qZuRU78EtEfKiWmQ9iM+YjYkotM0exEbMR8bkeWnrIzG04iQ7GFHvQQQd7FO+gg5OZuU3xFjqY1DiGDo5rHEcHx/TRsjJtlwtFpdFSVBqVoqWPSm/n8SraOKGYwuuKKcV+zGAB5xXv4Wv8ofEuPsWc/6HSQ0R0ccASETGPfZaIiGlMWyIiJjBhiYgYdxUqPWTmGhxEW+PHiBhXy8znMYJvI2JCLTNfxO34JCImM3MNDqKNExExnZkbMaZYa4BKb1uw33JzGFeMYQQfY0JxVLENk9iC/RrTGMWYK9Ry5RZdG3/ro9JDRMxk5l60NeY1nsYGzGo8jtswrRYRM5m5F21MKU673Kw+Qi1rirMRscuQZE1xNiJ2VXrIzHWYQBtvRsRkZm7FG1ZmNiKeVcvMcWzGFxFxSA+V3kbwmGIGk9iBnVZmTuNRjGAdDumhpbdLGguKBSv3l8ai4pI+Kj1ExLnM3IqbcV4tIk5l5jkr86fGKG7Br/qo9BER5/xLRMxYJRExa4DKcndl5kduEJXie9yNTdhk+L5SaykO4ht0Ddc8JiLigBvdPzHj7bg5l7ABAAAAAElFTkSuQmCC"},{width:20,height:17,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAklEQVR4AewaftIAAAGGSURBVJ3Bz2vOARwA4Ofz+tasKUtLymUvBznYcaSW5SBxW3HapNVSLi7jsIP2lpKDf0DKIuXAbWIXByLLgVJTqLXWWFN+tR8N+Vi9q72WV9ueZ5MNyswbg4ODhyuVykM1SjZuDxqsUlinzDyE09iLilUKa5CZ7biKNizgIy5GxIhVCmtzBZtxLCKe+o/IzIM4jyb17cdrzPu337gTEUMF+nEU0+r7jJ3qa0YrhkrYgumIKKMXbehCF9rQGxFlnMQRdKI7IsroRideoMGSwrLMLOMRzqBH1WMMZOYu3MUbvEMPmnEft9QorJhEHx5gStUrjGMSF/AJcxhVFQg1Sla04CyG0Y4DuBYR1/Ec23AC5zCWmS/RaJWSv81iFotYxLyqOfzEAhaQmMUo3qpRsuIbnqAPM2jC+8y8jGfYjUXM4HhEdGAEY2oUVmzHAMZxCh3q+4JL6MdNNQrLImIiM1sxhWE0qu+Xqn34inuWFfiOHZk5YR0yU42t+GBJgQp+oMXGLeC2JX8AO/x2pDbtElkAAAAASUVORK5CYII="},{width:10,height:9,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAACQSURBVH3BMWrCYBgA0NfwQyYjIpRKiqNO0l7FG/QKvUOXHqSD0L0XcVCnuCkOjhIIfAoJBAvte/4TEV86yS8R8YwPjLHVeYiIN8z1XnDBTu874R1rhNYZgSkCJSYJDU44IMcIAzR4xBFZppXhFaXWHhVmqN0krYQ1lno1fjBEnpBQoMDGvSeUqBI+sfC3Cqsry2kjUQBG7/AAAAAASUVORK5CYII="},{width:5,height:5,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAAklEQVR4AewaftIAAAA/SURBVEXBMQpAYAAG0Ed/RgMpJ3MsJ+B2yqDsMnws8p5PkinJ7FUlWXFhwIG7xoALG3p0BQ1G9DhRCha0fvsDCxoSQzqXcdgAAAAASUVORK5CYII="}],"PENDULUM_LAB/energy-screen-icon.png":[{width:694,height:472,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArYAAAHYCAYAAAC4FatbAAAAAklEQVR4AewaftIAAA52SURBVO3BX+juB10H8Pfzfp7fOTt6dEtaRwQJM1urmxB01KAIm15YeGF0Ed5005Vg7qBDcVIiom5eLFdhILQgTnhxUBDJwpaJQxQnYqGbf/L/0ln+OR7POTvn93ybF4HINv/tOZzf5/d6vVbLwwIAAAdcAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAwAAAzQAADBAAxw6Dz74YL797W8HACZpgEPl4sWLefGLX5y3vvWtAYBJNgEOldtuuy0f+MAHcu+99+amm27KDTfcEACYoAEOjQ9/+MN505velO87e/Zsbr755nzve98LAEzQAIfCmTNn8tKXvjTf+c538v/uueeevPGNbwwATNAAh8Kb3/zmfOQjH8kPu/322/P+978/AHDQNcB4d999d2677bY8knPnzuXkyZP51re+FQA4yBpgtG9+85t52ctelgsXLuTRfPSjH82tt94aADjIGmC017/+9fnEJz6RH+XOO+/Mu971rgDAQdUAY73nPe/JnXfemR/XK17xinzta18LABxEDTDSV7/61bz85S/PQw89lB/Xpz/96dxyyy0BgIOoAUZ67Wtfm/vvvz8/qbvuuiunTp0KABw0DTDOO97xjrz97W/PT+uWW27J5z//+QDAQdIAo3zhC1/IyZMn87P40pe+lJMnTwYADpIGGOVVr3pVvvzlL+dndfr06bztbW8LABwUDTDGXXfdlVOnTuXxcuutt+bjH/94AOAgaIAR7rvvvrzyla/M4+nBBx/MyZMn89BDDwUArnQNMMKrX/3qfP3rX8/j7X3ve19uv/32AMCVrgEOvLe85S05ffp0duUNb3hDPvjBDwYArmSbAAfaAw88kNOnT+f666/P3t5eHknbnDlzJp/73OeyLEseydOe9rScOHEi+/v7+WFnzpzJqVOncuONNwYArlSbAAfatddem/e+971Zr9d5NMeOHcvdd9+dm266Kfv7+3kkN998c06ePJlz587lkezv72e73aZtAOBKtAlwoG02mxw/fjw/ytGjR7NarfJojhw5ku87duxYAOAgaoBDYVmWLMuSR7MsSwDgIGsAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABtgEAK4A953/bP7mG3+fi8vFNM0und9eyO9f83t50dUvCDDHJgBwBfjchS/mrx74y1zank9W6+zU/tlc3aN50dUvCDDHJgBwBdhbbbJaX52sjiardXar6epYgFkaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAE2AYArwLLaJuvzyep8slpnt84nvRhglk0A4AqwOnd1rvnSC/LQ9lLWq2aXzlw6lyPHnpU8LcAgmwDAFeDJZ341z/zY63Lh4pJ1s1NnL2xz4vjPJb8WYJBNAOAKsHQ/2/X5bLdLVs1O7a+3WXoxwCwNAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwAANAAAM0AAAwACbABwC//yfZ3LPZ8/mqr1Vdmm7JOsmf/zcp+TpT9kLAJfPJgCHwD2f/W7++t8ezNXH1tml/e2SvXXzu9c9KU9/yl4AuHw2ATgErtprrj62zpOvWmeX9rfJ3jrZNABcZg0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAA0AAAzQAADAAJsAPIZPnf9MPnHuU9lbbbJLS5Y0zQ1PfHaeundtAOAntQnAY/jH/31n/uLLf56sn5Td2qbZ5J2//Hf5g6tvCgD8pBqAx7AEAA6GTQAewyqrJE3S7F6zyioA8NNoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggAYAAAZoAABggE0A4AqwrDb5Xo/nfJesm506220u9miAWTYB4OD45L8nX7kvWW+yc9v95Df/MHnCNbkcjn/3K3nxg+9ItvtZrVbZpYcuXMh13/rtJM8LMMcmABwc//K3yT/9Q3JVdu9ikutuTJ5wTS6Ha/7nk3nlf70mT+h+sspunU++/sCf5WKel70AU2wCwMGxWiWbJOvs3jaX1c8/aS97R5pc2k9W2blrnrDJJsAkmwBwcKxWySrJKrvXXFZXHWnSVS6LJTmytwowSwMAV4IlD1ty2SwBhmkAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABmgAAGCABgAABtgE4DEsWZJlP1n2s1vbJKssWbILy5Jsl2S7ZKe2S7JdkiU7sizJNsk2u7efy2tZkm2SbXZvm2QJMMwmAI9hvVonPZJNj2SXttlmk02aZhfWTY6sV9lbr7JLXSV762S1WmUn1ptkL8neJju3upSscvmsmuxtkuVS0nV26silZL0OMMsmAA9rm0fyp099SX7nxG9lk3V2acmSddb59f5KduElN57I83/jRNar7NSSpKvkl56S3fij1yTP/5Nktc7OLdvk2l/MZXPdDcnr/jXZv5SsVtmp7aXkxLMCzLIJwMM+85nP5N57783Zs2fzg/ZWmzxpdSRLluzWKsk2/7F8PPvLNo+nJcmR9SqbJhdzeXzs/iXbJY+/zZGkT8xl898fS5ZtLouuk83RJHvZvVXyjS9me+H+/MKJE7n++usDHHybADzsjjvuyB133BE4bF74whfm3e9+d4CDrwGAQ+zo0aMBZmgA4BC7ePFigBkaADjElmUJMMMmwKGwv7+f7XabR/PMZz4z1113XS5duhQ4LM6fP5/nPOc5AWbYBDgUnv3sZ+dDH/pQttttVqtVftCyLHnGM56REydOBAAOqk2AQ+H48eN57nOfGwCYqgEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAYoAEAgAEaAAAY4P8ADpDhUtXEkLMAAAAASUVORK5CYII="},{width:347,height:236,url:"data:image/png;base64,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"},{width:174,height:118,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAAB2CAYAAABRYaisAAAAAklEQVR4AewaftIAAANlSURBVO3Bz4tVBRyH4fd85sxVxyz8Ma6MslBxKVEbWwX1D0jgxvUoBIJtREEIwYUYKC0iqJbWUkhLaKHgMl2EtTEKJTRiyMkhrZjuPaUQxMx1kaDMl/M+T9P9A6mWL4NUUJAKClJBQSooSAWFHhsOh6im0FNd13HixAlu3bqF6gk9denSJQ4ePMjx48dZWFhAtYQemp2d5cCBA9x36tQpzp07h2oJPTMcDjl58iRXrlzhXzMzM1y/fh3VEXrm2rVrTE1NceTIEe7btm0b+/fv58KFC3Rdh2po6Znt27dz+PBh5ufnOXr0KFu2bOHQoUOoliAVFKSCglRQi5a9r+aucG94j8W6Dl5e9xKrJ6bomxYtex/89CEf/X6GJboRN5/+mtUTU/RNkAoKUkFBKihIBQWpoCAVFKSCglRQkAoKUkFBKihIBQWpoCAVFKSCglRQkAoKUkFBKihIBQWpoCAVFKSCglRQkAoKUkFBKihIBQWpoBYte+3cDjbNb2SxrutohgP6qEXL3qrvXmfDj3+y2GjUkZ1P0UdBKihIBQWpoCAVFKSCglRQkAoKUkFBKihIBQWpoCAVFKSCglRQkAoKUkFBKqhFj+TXu3/x6cWfoWGJ6Wcm2bVzI3p8WvRI/lgY8f7leZKGxV57dgW7dqLHKEgFBamgIBUUpIKCVFCQCgpSQUEqKEgFBamgFj3ww93r3F64zTgvTG1m3WAtWj5a9MAXs+d565d3GOfyi5+zbrAWLR9BKihIBQWpoCAVFKSCglRQkAoKUkFBKihIBbXoyblxDe7MMdbmrbBmLeO88tv3bJ2/w2LdCAbDTcCAvmnRk3PxLJx9m7GOfQNr1jLO7rlPaG58zBJD6EY3gTX0TYueoAYa/reGhodp6KcgFRSkgoJUUJAKClJBQSooSAUFqaAgFRSkgoJUUJAKClJBQSooSAUFqaAWPTC9ciN717zJYh2wql3FYpMTDW9sXk3TsMTzGwaMNb0RduxlrBUreKjntkK7lyW6DtpJ+qil565evcq+fftIF9omjPNed4pRN+K/mgbaNIzzLTBzpmOJiRZoGevYu9CNGGtiEmgZ59XPzrNnzx76pqWnBoMBp0+fJgnr16+nqunpafqopadWrlzJ7t27UU1BKihIBQWpoCAVFKSC/gbGOabRujmdfAAAAABJRU5ErkJggg=="},{width:87,height:59,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFcAAAA7CAYAAAAO/hZNAAAAAklEQVR4AewaftIAAAIeSURBVO3BwUuTcRjA8e/77DdtTVBbhKBDIoLZPxAdRqgQkYHQJTp1ioIOXQoigg47dfeyq3gIa6eigkAIvXjo0KnyUrBEsBQ3kNqb+ct35foLHn7by/P5RP4ARsMXwagRjBohoI2NDVqtFmklBBLHMZVKhVqtRloJgaysrLC2tsbCwgL1ep00cgQyNTVFs9lkaGiIYrFIGglGjSNlPjQ+8vL7KxLew+2Tt8hlcoTgSJntX9vc3XlMm4eb/gahCEaNYNQIRo1g1AhGjWDUCEaNYNQIRo1g1AhGjWDUCEaNI232+jm+e4E278FHhOJImcz2KcbePiDhvSc6ewSyBCEYNYJRIxg1glEjGDWCUSMYNYJR4+hib95t8fp9g8RwPsPDq+P0EkcX29ndY2k9JlEazNBrBKNGMGoEo0YwahxdYHG9xrd4k0QpX2L6xCRp4OgCy41l5n48ITHHI6aZJA0Eo0YwagSjRjBqHL3o62dYek7HleswMEjidKvOfP0pbR769+8DRwnB0YuaDXhxh47L1zhU2G9S2KnQts+Be4QiGDWCUSMYNYJRIxg1glEjGDWOLjDcd4yZ3+dI5F2eQ7m+DGeGsyRGBjJ0OAejM3REQkc2C6MztHkgigjFEVChUGB1dZWxTyMUo0skYv+TKlUSUQTn+/grhmqVfyKYmKVj8Rn/RTAxy6GLm1uMjw8QgiOgcrlMuVwmrQSjRjBq/gDfp3ndAd+IDAAAAABJRU5ErkJggg=="},{width:44,height:30,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAeCAYAAABXNvynAAAAAklEQVR4AewaftIAAAFMSURBVNXBQSuDcRzA8e9+++8hBydnppxEHkpRUg5OSl7EqJVXsIsX4ogrtavzUw4OU4+EFEtsM3lmmj3Psz1jF5z99zz1/3xSvW+Y40DQEAQBURSRJEFDsVjEcRySpNBg2zaWZZEkISGH5SN23DxBFKBDSEg9rLPfPqGHHsEwgmEEwwiGEQwjJKUzzGg4Cz20KBKSud5gsrRKalGhQzCMYBjBMMIAeR8hZ5dvVF7bxEUYoNqbT/64yu1ji7gIhlFoevHreF6DiZFxIE3cBE0lr8Tc3ToPrTJJEAwjxMVvw9UFVJ/om/af2W3ekOpF6BDi0mzAng3nDn1rHw65+y0ydNEhGEYwjGAYhQalFFElomDlqEYVlB+yOebh1d5xP7swX4DPDrgupEdgocBU2GE4M8R/KTRks1m2szn+Wlvh19IyP2ZmGAQFnGIO9wtDym3j887e2gAAAABJRU5ErkJggg=="}],"PENDULUM_LAB/intro-navbar-icon.png":[{width:148,height:101,url:"data:image/png;base64,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"},{width:74,height:51,url:"data:image/png;base64,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"},{width:37,height:26,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACUAAAAaCAYAAAAwspV7AAAAAklEQVR4AewaftIAAAI9SURBVM3Bb0sTcQDA8e/9dps3o03qRAOdIZZGK92kCETBRPCJUE8DX4IPrKDA1+DzegX2XLCn4nygiyy1f+ADISfezam3zdud2y5jDwY+msv9Aj8f5ezs7BvQwRWiAteBMFeIQJJk0sO2kUIgwanrklybR9OQQiDB5/V1eu48wedDCoEEX9e/MDzcgyyCBm1vbxMfjOO6SCNo0EpihVgsRrmMNCoNsCyLcEuYJk0jjDyCBiSWlxkZGaHCNJFGcEmlUol0Oo2u61ToOtIILmljY4OhoSGqXBdpBHWyLIvz1lZX6e3ro8rzkEalDp7n8fqVxdhYngcPoSngEo1GURSFqlAIaQR1+PHdwPvTxY2bnSwudvLypcZuqoPDzDFVpok0gjosLHjEYgquC/v7kD/pZHa2h7u9AebmdrBtG11HGsEFDCND8lMr3d2QSoFpQjYLhQLk89f49TNAc3Mzto00ggssLbkMDATx+WBvDw4PIZeD01PwPJia8lAUBZkENTiOw4d5jWgUDAMMA46PoVCAYhEG4xkePW6lIhRCGkENyeQBkS6dUAhSKchkIJcDx4FyGWZmXILBIBWmiTSCGjY3bfr7y1gWGAYcHcHJCRSL0BRwGH2qUdXWhjSCGqan7zE+foDf/5t0Ok82C44DpRK8eXtAe7tOVS6HNCoXiERuEYnA6GiWRGKX9+9UFj+28/yZ4DwhkEalTi0tYSYnw0xMlNja2uF+9Dbn6TrSqPwjv99PPN7N/6QCLwCNK+QvXEDK4nNGQ2MAAAAASUVORK5CYII="},{width:19,height:13,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAANCAYAAABLjFUnAAAAAklEQVR4AewaftIAAAD8SURBVKXBz0rCcADA8e9+23JrIyPanzdonjx4qTfwlCfv9RT1MPUogRAUeNvBi9FOYsncDHKCaVt0iTHI/aLPRymKYgYc8H93GtAADH6R5znjcUoQHFNjT1AjiiIcx0KGoEaWZRiGiQzBDnEc4/s+ioIUwQ4v0yme5yEEUgQVRVEwHCbM528YpslfaFREz++E4RG3Nx+02y62ndFsWsgQVDw8gq4rjJ8aXF0fkqZbZGmULBYr0sTkdQaTCfTOl7RaNus1UgQlmw2cBCtGoy1JAheXn6iqihBI0Shx3X26Xeh0MgaDJWenBt9UFSkacA9YlDiORb/PD11HRvgF9nRL1guER9wAAAAASUVORK5CYII="},{width:10,height:7,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAHCAYAAAAxrNxjAAAAAklEQVR4AewaftIAAAB4SURBVH3BMQrCMBiG4dfkI4ilYE7QW+SC3Vw8U3Hr2oNEkCIY2r8dOogEn+dkZi/gzGGePzRN4MfNAQIECFDOWYAAAQIEOMeXZ87EGKlxHKbpzTiumHlqHLtSFoZB9P2VUlZqxM4MUlroukLbXqgRcA/BKyXPH48NZvsj0/x8I5gAAAAASUVORK5CYII="}],"PENDULUM_LAB/intro-screen-icon.png":[{width:694,height:472,url:"data:image/png;base64,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3ZHv+c+01r5gTp065Wsf+SiXXX6Fe93rPsbRDzp65Gobv+TmW/6MugDHpEk5cPL4P/cl9/gXvv8HXu/oGFprrbXz3VZr7YvGM575LM945rN86IMf9O6fvMH7fvFKv/fx1/nt33muP7vlSSIeKPJe/l+nTl7pkqc9w4XHj2uttdYaW621Lzpf+4hH+NpHPMJNN32nt7/1TX7uZ/+53/qtG3zsYw/zx595riNHppPHf8UVL32t1lprrf0XW621L1onT570rS99uW996cv9ws//K9e/7Vof+chrfPzjN3rQVz7Cg7/ma7TWWmvtv9hqrd0pPO7xT/S4xz/Rxz72Ude97W0e8pCHaa211tr/Z6u1dqfygAc80Hf+rf9Va6211s610VprrbXW2g7YaK211lprbQdstdZaO1Q33siNN9p33/tqrbV2SLZaa60dqne9ize9yb6f+AmttdYOyVZrrbVD9eEP8453aK21dsg2WmutHao5tdZa+zzYaK211lprbQdstNZaa621tgM2WmuttdZa2wEbrbXWWmut7YCN1lprrbXWdsBGa6211lprO2CjtdZaa621HbDRWmuttdbaDthorbXWWmttB2y01lprrbW2AzZaa6211lrbARuttdYO1dmzWmutfR5stdZaO1T3vjcPeYjWWmuHbKu11tqh+it/hYc9TGuttUO21Vpr7VDd5z7c5z5aa60dso3WWmuttdZ2wEZrrbXWWms7YKO11lprrbUdsNFaa6211toO2GittdZaa20HbLTWWmuttbYDNlprrbXWWtsBG6211lprre2AjdZaa6211nbARmuttdZaaztgo7XWWmuttR2w0VprrbXW2g7YaK211lprbQdstdZaO1Qf+AAf+IB9r3iF1lprh2Srtdbaofqpn+K1r7XvFa/QWmvtkGy11lo7VGfO8Kd/qrXW2iHbaK21dqg2G6211j4PNlprrbXWWtsBG6211lprre2AjdZaa6211nbARmuttUN1881aa619Hmy11lo7VE95itZaa58HW6211g7VE5/IYx6jtdbaIdtqrbV2qI4e5ehRrbXWDtlGa6211lprO2CjtdZaa621HbDRWmuttdbaDthorbXWWmttB2y01lprrbW2AzZaa6211lrbARuttdZaa63tgI3WWmuttdZ2wEZrrbXWWms7YKO11lprrbUdsNFaa6211toO2GittdZaa20HbLTWWmuttbYDNlprrbXWWtsBG6211lprre2AjdZaa6211nbARmuttdZaaztgo7XWWmuttR2w0VprrbXW2g7YaK211lprbQdstNZaa621tgM2WmuttdZa2wEbrbXWWmut7YCN1lprrbXWdsBGa6211lprO2CjtdZaa621HbDRWmuttdbaDthorbXWWmttB2y01lprrbW2AzZaa6211lrbARuttdZaa63tgI3WWmuttdZ2wEZrrbXWWms7YKO11lprrbUdsNFaa6211toO2GittdZaa20HbLTWWmuttbYDNlprrbXWWtsBG6211lprre2AjdZaa6211nbA/wN2M1HK3keSRAAAAABJRU5ErkJggg=="},{width:347,height:236,url:"data:image/png;base64,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"},{width:174,height:118,url:"data:image/png;base64,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"},{width:87,height:59,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFcAAAA7CAYAAAAO/hZNAAAAAklEQVR4AewaftIAAAQBSURBVO3B209TBxzA8e/5UU6BU5NOJNagxAsieGGA4MwMnj25vexlbokvxgTn/gAf/D+29+11e9D3GV883dMQuokXRJCpWQMtLcXa0gttz8aDiTFeypJDz2/p52O4/6LJC0+FJs8ITZ4RmjwjNHkmgBJPn0IiAbt3w/79qCAokUzWMM0SqRRqCEpUKrP8EZuhuxs1BCVm7ka5ePFj9uxBDUGBRCJB9969PHtuoomggOM4jI+Ps76OKgF8rlAokMvlCIfDtLaiiuBzdyYnsW2bTZaFKoKP1Wo1/rx7l4MHD7Jpbg5VBB97PDfHJ6dOYRgGm0olVBF8zIlGGR4Z4ZXeXlQRfCqZTBKJRDBNk1c6OlBF8Kmo43B2fJzXzc6iiuBDxUKRF9ksH+3cyes2NlBF8KGpqTvYts2b+vpQRfAZ13WJxWIcOnSIN7W1oYrgM/OPHzM2NoZhGLzp/n1UEXzGcRxGTp7kbWo1VBF8JJ1K0blrF8FgkLcZGEAVwUei0d+wbZt3aW1FFcEnSqUSqdQKnZ2dvMu9e6gi+MT09DS2/Rnv47qoIviA67pM3Zmi93Av73P0KKoIPvDkyRNGTo4gIrxPIIAqgg84t28zOjrKh8zMoIrQYKurq4TDYdra2vi/ERosGo1y1rapx+AgqggNVC6XSSYSdHV1UY9KBVWEBorFYpy1ber18CGqCA3iui6Tv0/S19dHvQwDVYQGWVxcZGh4CBGhXidOoIqwTarVCq9zHIexsTG2olxGFWEbFItFvruygOP8xUoyRSaTIWSFaG9vZysePUKVANtgejqFGeynXIYff8rz/NksX39zmGq1SktLC/VqaUGVAB5zXZfr1w2GhiCfh5UVi/mFUa5cqXH6dJxLl2qcObMLy7L4kGPHUEXw2Pz8MktLEXp6IB6HlRVYW4N8XrhxYx9ffhkhk8lTj0IBVQSP3bxZZWiohU1LS5BKQTYLxSJUKnDtWpLu7i7qMT+PKoKH0uk1bv4apr8flpdheRkyGcjnoVyGWs3l/FcGhmFQD9NEFcFD0WiOY8dDWBbE45BOQzYLhQJUKnD+fILjJyLUq78fVQSPlEolfvk5yOAgpNOwvAyrq5DLQakElQp8e7lCIBCgXuvrqCJ4pFarMTFRxOpIEI+7pFLw4gUUCrCxAQMDa3x6JsxWLCygSgCPtLe38/kX+yiXyzx48DcvX7pMTUUoFk2qVbh6NceOHXvZimAQVQJ4zDRNhof3MTwMExMJbt0q8sP3bZw7Z7JVR46gSoBt1NOzm8uX4cKFHJYVYqtyOQiFUENoAMsK8V8sLqKKoEhHB6oIivT2ooqgSDaLKoIi6TSqCIocOIAqQpNnhCbPCE2eEZo88w/UXFywEeDOFQAAAABJRU5ErkJggg=="},{width:44,height:30,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAeCAYAAABXNvynAAAAAklEQVR4AewaftIAAAGnSURBVNXBy24SYRiA4ff//hmkEWQqJnUDLSTSG+hKl41cSve66QV5Ga67Y1d6iCyA0MQ0LadEkMyBX1k0MZO6GJnPhOcx7jd2xxdhxwgKHh5gtUKFoODq6juLBSqEnIVhSKk0pVpFhZCzXq9Hs9lCi5Aj5xxRFFEsemgRcjQcDmk2GsQxaoQczaZTXlUqeB5qhJzMZjNeV6tsJAlqhJwMBgNqtRobIqgRchBFEQXfxxjDhnOoEXLQ+9bjXavFE2NQI2zJOUcYhvi+zxPnUCNsaTQacdQ44k/GoEbY0mQyIQgC/hdhC/P5nP0gIM051Ahb6Pf71A8PSTMGNUJG6/Way8sxy+US3/cxxpC2XqNGyOj29gedTpXz84hu94DxeEGatagRMrq4AGvh5qbC2dkbOp2YtCRBjUcG9/cLVquX9Ptwdwf1esiH9y9IsxY1QgajUUhQSbi+hsdH+PxpRalcJC2OUeORwcnJPsfHPzl4O6dQMHxsG57jeajxyKhc3qPd3uP0NMFay3PiGDXCP7LW8je+jxpBQZKgRlBQKqFG2DEe8JXd0f0FmyyHAUU/0L0AAAAASUVORK5CYII="}],"PENDULUM_LAB/lab-navbar-icon.png":[{width:148,height:101,url:"data:image/png;base64,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"},{width:74,height:51,url:"data:image/png;base64,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"},{width:37,height:26,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACUAAAAaCAYAAAAwspV7AAAAAklEQVR4AewaftIAAAPlSURBVM3BW0xbBQCA4b+Hc1oOkyIMWqBQLgPk5gaEgNlcQSZDYgYOSAZxos7Li+xh+ibxkqgP7mHqwxQ1Jhr1YZqYSTLGboyhyGJIDDI37kUK5dKxpp3QYluO4cFkIUtpoST7PpWiKH1AIg8QEUgEjDxABELA7Yb2dhsuF0Gx2+0MjQ2xnkAIhIV5mZu7yPW+qwTK4XTwdG8NZ2Z+YD2BEBgaukVDfTV5+XlcvnSJjSwsLtDSf5yDEU/yUuYx1hMIgdnZWWJ2xqDT6SgoKOBCZyeKonA/lnkLzw28QLFQTOv+N0lKTGI9gS2y2+3E6/X8LzYujpLSUjo6OvD5fKxxOhysGZ4cpvGvZzkqN3Hc1IIkSdyPyBb9OTDA3n37uFd0dDQmk4kLnZ3kx8cjNzZx8eO3OaZ+h9NRH1FbUoM/AluwurqK1+dDkiTWi4yMJC02HrH1JAP7l2nSvMEnthZqS2rYiMgWjI6MkJ+fz71stgXc7jnc7pv4pGt4Tw8wfONfOttkHj3Xynh0Nruqq/FHZBOWlpaQZZnBwQFKH9vF1NQvCMJN4Czh4X+gUlUQEVHFXfsjzHZmYHIbMLraUeJ+x3fnDhsRCdL4eBcq1VvI8iLlT4zjch1CEExACYrSgCDEk5QUwxqDAUYdV1AmV1msbGDl5SPkHK5lIyJB8Hg8SJKW5eVX6O9XqKqqIzY2Cn8yKw8wcq0Ht7ST3L1FBEIkCJIkYTQWA8XMzFwhKiqKQGSVmQiGwCZMTEyQmZnJdhEIgNVq48sv/mZsbBqPx4N5wozRaGS7iASgu3sFlZBCXx+cOjVHWmoM2dkLGJJ0OJ0Opqa+QpJWSUh4Fa1Wy1YJbGB52cX58+EkJIDFApOT8XzWVsgzh+/S0/MubnceGs11wsJ2o9VqCQWRDfT33yYrKxmPB6xW0OluceLETxQUfMD8/Ot4PF1kZGSiUqkIFQE/FEXh57MCOTkwPQ39GScxvPg448LnHHjtDD5fMwZDFiqVilAS8WNkZJZll54dO2BmBpTBOtqsu3Gk3kBz9EMKbGPUXzZRHllGvjaPlIdSMOgNqNVqtkLEj+6rSxQViSwugtUKK9MZ0JcBjqfo6j1CaroGi32K0X9GOWfr4FvLj0hDYTSq69B5dBxMr2RP+h6CJeJH8/NJmM0WfuuF+flYnE4ZtxvKyxYoLNSjVqvRx+koppgmmnh/5T2sC1bMTjPfmb/HN+EjKyELWZYJhogfsiyTm5tMbi4cqrlN76+LfP2NQHOzF7VazXoajYa05DTSSKMir4LNEgmQXh9LXT3U1Hrxer1sJxH4FHiYAImiiCiKbKf/AK2VWv4PqVi9AAAAAElFTkSuQmCC"},{width:19,height:13,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAANCAYAAABLjFUnAAAAAklEQVR4AewaftIAAAGcSURBVKXBPWsTYQDA8f89z3MkuctLDZirMW0SM5RCQVEEwZdFKOJah266GPoR/Bg6+wVcuzkpdKlLW5pkiKdCbaBtaEFDzfXaa+6xGQLH0TSCv5+hte4AGf7fZwVkgBxjnJ9rvqy3efR4nrj2fhtTmNScGhdswQTd7h5375VxXRetNSOtvRZbB1uUpkqMKCYIggDLsqhWq7iui9P3aCZ/0dMnLN9ZxjAMRgRX8DwP27YZ8v0/pNQBXzdf462+5enNhxiGQZRijKOjDfr9BkJoOh2DdNrBnipiyzfMHn+DwYA4xSXCMETKPL7/gLm5eaKspVto4xmpTJo4Rczp6Rnd7gmmmaRcvkFcKptlHEVMo+HTauVYWxuwsrJDsfiJROIJhcICkygitNZsb8O+1+X28/f4Z9MUCq9IJCz+hSJid7dHGOZorpt8tJZ4V2/yo/EBKRXl/CwzyRlq0zXGUUSUShkWF48ZurZxnZf3XyCEIAxDDn8fstP7SWVQQUrJZRTQAGwuSCmpVLLU6xAEAUIIhoQQOHkHJ+9whe9/AQOthdJiuqIBAAAAAElFTkSuQmCC"},{width:10,height:7,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAHCAYAAAAxrNxjAAAAAklEQVR4AewaftIAAAC3SURBVG3BsWrCQBzA4V/uLj0PhzoUF0E6dBBKsS+UF+izuLm5dy04O7n5AE7iIKKLOCSDpxe8/k0ghQz9vkREcsDSyPMLvV6Xmg+eJElwT25iAAt0aIiUnM9X1G9gF058DsZUjKKlKLbEuAPZs/+e8vEyQilFzdDwviQER7//Ru35653UWv4oKiLCzzywWG4oii211FraFJXb7Y7cNbEz5OAD6+MaEaHNADPnUpNlKTG+orXmH6sHF59C07rkqZsAAAAASUVORK5CYII="}],"PENDULUM_LAB/lab-screen-icon.png":[{width:694,height:472,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArYAAAHYCAYAAAC4FatbAAB8lklEQVR4AezBD5QcB2Hn+W+VRpYso6JBxhDUFybnRKSLLCovebFuLywzWavfBiRspuvyurf3Qbc2G21e7mLIds+8ZJN4DOzbSDN5mLy9S5TsqRvuOjOPqx4gNiTpcXZGkLuM8y6PGgLVRBvumlwLbLCgKdljW7K6zqNZWXbRxtLo33TP7/MxohcgIiIiItLnTEREREREBoCJiIiIiMgAMBERERERGQAmIiIiIiIDwEREREREZACYiIiIiIgMABMRERERkQFgIiIiIiIyAExERERERAaAiYiIiIjIADARERERERkAJiIiIiIiA8BERERERGQAmIiIiIiIDAATEREREZEBYCIiIiIiMgBMREREREQGgImIiIiIyAAwEREREREZACYiIiIiIgPARERERERkAJiIiIiIiAwAExERERGRAWAiIiIiIjIATEREREREBoCJiIiIiMgAMBERERERGQAmIiIiIiIDwEREREREZACYiIiIiIgMABMRERERkQFgIiIiIiIyAExERERERAaAiYiIiIjIADARERERERkAJiIiIiIiA2AIEZE+1+nA4iIsL/Myb3kLjIzA8DAiIrIJDCEi0qd8Hz7+cahW+aFGRuCBB2BkBBERGWBDiIj0oQ99CB56iMuyuAiLizAyAp/+NCQSiIjIABpCRKSPdDowOgq+z4tGRuD++2FkBBIJXvSZz8BnPwvVKhcsLsJdd8GnPw2Og4iIDJgtky9ARKRP/PzPw9ISFwwPw6c/DZOT8JM/Cdu38zI/+ZNw331QKMDyMrRa0OnAn/85FAqwfTsiIjJATERE+sSDD8LiIhc4DnzpSzAywqsaHoaFBSgUuKDVgmIREREZMCYiIn2g04GHHuKCRAIWFiCR4IpUKjAywgWf+QwsLiIiIgPERESkD1Sr0Olwwcc+BokE61Kp8KKPfxwRERkgJiIifeATn+CC4WEoFFi34WG47z4u+MxnEBGRAWIiItIHfJ8L7ruPV+T78L73wegofOYzvKJ77+VFi4uIiMiAGEJEZINrtXhRIsEret/7oNWCbbcEnGx+hH/8j4/xoz9qETc8jIiIDCATEZENrtXiRXv38opaLdh2S8Cb35jj1u1L3HfgnTSDABER2RxMREQ2uJERXrS8zCva+4+O8+Y3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MGBSY66Jc8455/a+Is7dBevtNuM0hxwGERABERABERABERABERABERABESgWISVICcZjSAn+nb9Q58/9W3X++I8G/F//dI31tTarKys8cOoUM/UZHq5WybKMn2e9vcakE1NTnJiawjnnnHN7XxHn7rD1dpvRaESyJkcEREAEREAEREAEREAEREAEREAERKBQgO1tSAlSgpQgJVCFz2Rl/r1/f54//xfm+e3vdvjd393k6SefIsue43S1SmOuyYmpKT5oNBqx1m4zqTnXxDnnnHP7QxHn7rDWSovtVKdYzBABERABERABERABERABERABERABEVCFlCAlSAlSgpQgJUgJUgJV+Nznq/wr/1qVk+EZfue322xurrHW/mXK5TKNuSbT9TpZlvFyp8PP8nC1inPOOef2hyLO3UFXt7a4urVF0me4714QAREQAREQAREQAREQAREoFkEERODQIRiPISVICVKClCAlSAlSgpQgJVAFVThUzPg3fmmO8r8+x49+uEX/91r89//tMl//2nOcrla5urXFpJl6nSzLcM4559z+UMS5O2h1pYVamXsKpxABERABERABERABERABERCBw4dBBIpFdozHkBKkBKqQEqQEKUFKoAqqkBKkBCmBKqjCnzk2xZdPnOMLv3SOH/xBm29/e4233hwwabo+g3POOef2jyLO3SGj0YjNTof3xs9w+F4QAREQAREQAREQAREQAREQAREQARFICVKC8RhSgpQgJUgJUgJVSAlSAlVQBVVICVRBFVQhJbj/X67zmazOO+8MeP2Ha4zeaDPeHnDNa4MBo9GILMvYD77whS/Q7/eZVKlUuFmlUokQAj/P7OwseZ7jnHPO7UVFnLtD1ttt3ngDjCoiIAIiIAIiIAIiIAIiIAIiIAIiIAKFAmxvQ0qQEqQEKYEqqIIqpASqkBKkBKqgCqqgCqqgCqqgCqpQLJYp3T/PsWyet97s8M7bmzz95FNk2XOcrlZpzDU5MTXFXrawsECz2aTVgjxnx3AIvV6XmxUjdLsbfNBwCDFCCIGFhQWcc865vaqIc3fI6kqLsVYpFjNEQAREQAREQAREQAREQAREQAREQARUISVICVKClCAlSAlSgpRAFVICVVCFlEAVVEEVVEEVVEEVVEEVzMAMDt9b5VCxyn1Hn+HdH3d48cUWa+1fplwu05hrMl2vk2UZe02j0WBxcZHLl/s0GryvVuOWNJvQ75d48cUXcc455/ayQ8/+CZzbZa9eucLqSot3t7/BffdlHDkCR47AkSNw5AgcOQJHjsCRI3DkCBw5AkeOwH33wZEjcOQI3HsvpATb27C9DdvbsL0N29uwvQ3b2zAew/Y2jMcwHsN4DOMxjMeQEqQEKcF4DKqQEqQEKUFKkBKoQkpgdi/cM0Wh+Dj3FKq88cZ7fKvb4ht/b5mrW1e59957+eIXv8heUiqVWFx8iUYDSiVu2eoqLC7CxYsXOXXqFM4559xeVsS5O2B1pcU4neJQsYwIiIAIiIAIiIAIiIAIiIAIiIAIFIvsSAlSgpRAFVKClCAlSAlSAlVICVKClEAVVEEVVEEVVEEVVMEMVEEVVEEVzEAVzMAMuGcKClMYz2CpzW/+5iabna9SLpd5uFqlOdfkeLnM3dLv91lcXGRjY4NSCWKEPOeWxAjNJpw9e5ZarYZzzjm31xVxbpe9Nhiw2ekw1nMcvhdEQAREQAREQAREQAREoFgEERABERCBlGA8hvEYUoKUICVICVICVUgJUgJVUAVVSAlUQRVUQRXMQBVUQRXMwAzMwAxUwQzMQBVUwQzMIFmdlOqYDfi9/horv95mdWWFB06dYqY+w8PVKlmWcSd0u12++c1vsrq6Sp7D0hLUalAqcUuGQzhzBiqVCktLSzjnnHP7QRHndtlaew3VMmp1REAEREAEREAEREAEREAEREAEREAE7rkHUoKUICVICVICVVAFVUgJVEEVUgJVUAVVUAVVUAVVUAVVMANVUAVVUAUzMAMzUAUzMAMzMAMzMAPVMmOd58fvzlO45wrf+tYar155iix7jtPVKtP1GR44dYrdsLGxwfLyMt1ul0oFWi1oNLhtmk0YDku8+OKLOOecc/tFEed22erKCttpDhEQAREoFkEEREAEREAEikUQAREQgcOHQQTMICVICVKClCAlSAlSgpRAFVKClEAVUgJVUAVVUAVVUAVVUAVVMAMzUAUzUAUzUAUzMAMzMAMzMGOHGZiBGWynU7z73inefOcZRm91uHSpxVq7TblcpjHX5HS1yvFymVu1urrK4uIi/X6fWg1eeQUqFW6r8+dhYwNeeeVFSqUSzjnn3H5RxLldtN5uMxqNSDrDvQIiIAKHD4MIiIAIFIsgAocPgwiIgAiIwKFDMB5DSpASqEJKkBKkBCmBKqQEqqAKqqAKKYEqqIIqqIIqqIIqqIIqqIIZqIIZqIIZmIEZmIEZqIIZmIEZmIEZmLFDNeOdn9R5+8d1ioe2eOudNb62uMzXv/Ycp6tVpusznK5W+TiGwyHLy8ucP3+e4XBIowELC5Dn3HbdLjzxBDz77LNUKhWcc865/aSIc7torb3G9rjKoWIZERABERABERABETh8GERABERABESgWGRHSpASpAQpQUqQEqQEKUFKoAopQUqQEqiCKqiCKqiCKqiCKpiBKqiCKqiCGaiCGZiBGZiBGZiBGZiBGTvMwIwdZmDG+97bnuLd96Z4/Y1nOHqkzUv/cJPNzlfJsozpep3mXJPj5TI/T7/fZ3FxkdXVVUolOHsW5uehVGJXDIdw5gzUajUWFhZwzjnn9psizu2S1wYDXr1yhe10kfuOgAiIgAiIgAiIgAiIgAgUiyACIiACIpASjMcwHkNKkBKkBCmBKqhCSpASqIIqqEJKoAqqoAqqoAqqoAqqYAZmYAZmoApmYAaqoAqqYAZmYAZmYAZmvM8MzNhhBmZ8yNvv1Hnr7TqHDg04Nlrjf/r7bVZXVjgxNUVzrsnD1SpZlnFNt9tleXmZjY0N8hxaLajVoFRiV505A6VSTqvVwjnnnNuPiji3S/7u+WVUy3DPKURABERABIpFEAEREIFiEURABERABESgUIDtbUgJUoKUICVQBVVICVICVVCFlEAVVEEVVEEVVEEVVEEVzEAVVEEVVMEMzMAMVMEMzMAMzMAMzMAMzMAMzMAMzNhhxg4zMAMzMAMzdozHZV5/Y57X35jnvnuv8Obba1zdeoose44H/uJf5Lv/z3fpdrtUKtBqQaPBHbG4CN0ufOc7L1IqlXDOOef2oyLO7YLRaMRmp8N743lEQAREoFgEERABESgWQQREQAREQAREQARUISVICVKClCAlSAlSgpRAFVKClEAVUgJVUAVVUAVVUAVVUAVVMAMzMAMzUAUzUAUzMAMzMAMzMGOHGZiBGZiBGTvM2GHGz2TGh/z4J6f48U/+TX74o89xT+G/5jv/7P+mVoNXXoFKhTum24Vnn4WlpSVCCDjnnHP7VRHndsHLnQ5vvAFJ69wnIAIiIAIiIAIiIAIiIAIiIAIiIAKHDsF4DClBSqAKKUFKkBKkBKqQEqiCKqiCKqQEqqAKqqAKqqAKZqAKqqAKqqAKZqAKZmAGZmAGZmAGZmAGZmAGZmDGDjMwAzPeZwZmfIgZO8yGwDJm50k2pPErsLAAec4d1e/DmTPQaDQ4e/Yszjnn3H5WxLld8HfPL7OdqhQlQwREQAREQAQOHwYREAEROHwYREAERECEHSlBSpASpAQpQUqQEqhCSqAKKUFKkBKogiqogiqogiqogiqogiqogiqoghmoghmYgRmYgRmYgRmYgRk7zHifGZjxPjMw431mYMa/0MdsEbNVSiU4exbm56FUYtcMh7C8DJ/9LJw9y4ecOQN5HlhaWsI555zb74o4d5u9euUKg8GA7XGTI0dBBERABERABERABERABIpFEAEREAERSAnGYxiPISVICVKClEAVUoKUICVQBVVQhZRAFVRBFVRBFVRBFVTBDMzADMxAFczADFRBFVTBDMxAFczADMzYYQZmYMYOMzDjZzLrYraM2QZ5DgsL0Giwq/p9WFyE1VV2lErQaECpxI4nnoB+v8Qrr7QolUo455xz+10R526z9fYa43SKewpTiIAIiIAIiIAIiIAIiIAIiIAIiIAIFAqwvQ0pQUqQEqQEqqAKKUFKoAqqoAqqoAqqoAqqoAqqoAqqYAaqoAqqoApmYAZmoApmYAZmYAZmYAZmYAZmYAZmYMYOM3aYgRmYgRmorqL6Tcy6VCowPw+1Gruq24XlZdjYgDzPabUWqNVqfOELX2B5ecjCAmxswPnz0GotEULAOeecOwiKOHcbvTYYsNZusz0+hxwGERCBYhFEQAREoFgEERABERABERABEVCFlCAlSAlSgpQgJUgJUgJVSAlSgpQgJVAFVVAFVVAFVVAFVVAFMzADMzADVTADVTADMzADMzADM3aYgRmYgRmYscOMHWb8C0NUN0hpEbM+jQbMzkKlwq5aXYXlZYgRKpUKL744T61W46fOnj3L+fPP8sgj0GxCo9Gg0WjgnHPOHRRFnLuN1tprmGUkq3NEQAREQAREQAREQAREQAREQAREQAQOHYLxGFKClEAVUoKUICVICVQhJVAFVVAFVUgJVEEVVEEVVEEVzEAVVEEVVEEVzEAVzMAMzMAMzMAMzMAMzMAMzMCMHWZgBmZgNmQ8XmY8Pk+pNKRWg4UFyHN2zXAIq6uwvAz9PjQaDZaWZqlUKkyan5/n/PnzPPTQkDwPtFotnHPOuYOkiHO30Xq7zbvbc4iACBSLIAIiIAIiIAIiIAIiIAIiIAIi7EgJUoKUICVICVKClEAVUgJVSAlSgpRAFVRBFVRBFVRBFVRBFVRBFVRBFcxAFczADMzADMzADMzADMzYYcb7zMAMzPq8994i4/EqpRKcPQvz81AqsWv6ffjmN+H8ef5EiVqtxsLCAnme8/OUSiVqtRobGxu8+OKLOOeccwdNEeduk81Oh8FgwDjNcOReEAEREAEREAEREAEREAEREAEREAERSAlSgpQgJUgJVCElUIWUICVICVRBFVQhJVAFVVAFVVAFVVAFVTADMzADM1AFMzADVVAFVTADMzADMzADM3aYgRmMx13ee2+Z8XiDPIeFBWg02FX9PiwuwuoqlEolzp49y/z8PKVSiZuxsLDA7OwseZ7jnHPOHTRFnLtNVldavDeuUjhURgREQAREQAREQAREQAREQAREQAREoFCA7W0Yj2E8hpQgJUgJVCElSAlUQRVUQRVUQRVUQRVUQRVUQRXMQBVUQRVUwQzMwAxUwQzMwAzMwAzMwAzMwAzM4N13V3nvvW8yHnepVGB+Hmo1dlW3C4uL0O1Cnue0Wgs0Gg0+rjzPyfMc55xz7iAq4txt8NpgwKtXrrA9/gaH7wUREAEREAEREAEREAEREAEREAEREAFVSAlSgpQgJUgJUoKUICVQhZQgJUgJUgJVUAVVUAVVUAVVUAVVMAMzMAMzUAUzUAUzMAMzMAMzMAMzMAPVIT/5yQbvvLOIap9GA2ZnoVJhV62uwvIyxAiVSoUXX5ynVqvhnHPOuT+tiHO3QWulhWoZo4oIHD4MIiACIiACIiACIiACIiACIiAChw7BeAwpQUqgCilBSpASpASqkBKogiqogiqkBKqgCqqgCqqgCmagCqqgCqqgCmagCmZgBmZgBmZgBmaQ0pC33lrmnXfO89nPDvmVX4GFBchzds1wCKursLwM/T40Gg2WlmapVCo455xz7ucr4twtGo1GrLfb/GR7HhEQgWIRREAEREAEREAEREAEREAERECEHSlBSpASpAQpQUqQEqhCSqAKKUFKkBKogiqogiqogiqogiqogiqogiqYgRmoghmYgRmYgRmYwfZ2nzfeWOSdd1YplWBhAebnoVRi1/T78M1vwvnz/IkSjUaD+fl58jzHOeeccx+tiHO36OVOh9FoxDjVufc+EAEREAEREAEREAEREAEREAEREAERSAlSgpQgJUgJVCElUIWUICVICVRBFVQhJVAFVVAFVVAFVVAFVTADMzADVVAFMzADVVAFVfjxj7u8/voiP/lJlzyHhQVoNNhV/T4sLsLqKuR5ztmzDebn5ymVSjjnnHPu5hVx7ha1Vlq8u12nWMwQAREQAREQAREQAREQAREQAREQAREoFGB7G8ZjSAlSgpQgJVCFlCAlUAVVUAVVUAVVUAVVUAVVUAVVMIP/nz34jdHDvg/D/rm753vHk3Tnc2Qnln1tz2t3trlhfNIrJgJDc4+wiPALryake5HMGErxRd2+iYS16QokqujmVecWk9ZhtYOFpNPWboajajQLGlBG9RCGEbke20dFI9UcnDAt/SfxP5r0H5LP8/t+Z17jixW7tuRINiX9Pp9MMskkkyqqqCKTKr7yldMuX37M9esToxEPPsjRo15S4zHveQ/jMRsbG06desSxY8d0Xdd1XfeDGei6P4GPP/WUZ595xo3pex1YJoIIIogggggiiCCCCCKIIIIIMmmN1miN1miN1miN1sikNVqjNVojk0wyySSTTDLJJJMqqqiiikyqmM0u++IXT/viFx8znV507Bh/+S8zGnlJnT7NY48xmbB84IAnn/wXRqORruu6ruv+ZAa67k/g8d0zZu0gcwdFEEEEEUQQQQQRRBBBBBFEEMHCArMZrdEardEardEarZFJa2SSSSaZtEYmmWSSSSaZVJFJJplkksn16xd9/vMf8PnPP2pl5bJ3vYtHHmFjw0vm8mVOn+axx7h40Tcd8+N3XvLTP/06o9FI13Vd13V/cgNd9wO6cuWKM7u7rt94r8VFIogggggiiCCCCCKIIIIIIoiwpzVaozVaozVaozUyaY1MWqM1WiOTTDLJJJNMMskkkyoyyeTatYv+w394jy984bS1NR5+mAcfZG3NS+biRT7wAR59lMuX13AMDxoMBlbu+IuOHf95Xdd1Xde9OAa67gf0+O6uqlWz3HFgQAQRRBBBBBFEEEEEEUQQQQQRtEZrtEZrtEYmrZFJa7RGa2SSSSatkUkmmWSSSSZVZJLJl788dvHie3zlK2MbG7z3vRw75iV18SLveQ+nT/umDRzDg1hz09rKL1lfX3fvkSO6ruu6rntxDHTdD+j0yVOu39gRQQQRRBBBBBFEEEEEEUQQQQQRzM8znTKb0Rqt0RqtkUlrtEYmmWSSSSaZZJLJlSsXLS1tyCSTTD796dMuXnzMV786MRrxyCOMRl5S4zHveQ/jsW/aMDf3CI6p8hwrd+y6b+e4ruu6rutePANd9wN44uxZly5dcn32gNtuI4IIIogggggiiCCCCCKIIIIIMmmN1miN1miN1miN1sikNVqjNVojk0wy+cIXJv75P/9Jt9++YXV1aGVl6D/+x9O+8Y2Ljh3jwQcZDr2kTp/msceYTJibG5mbewQj383KHbvm5684dvwBXdd1Xde9eAa67gfw+O4Z09lh8/PrIogggggiiCCCCCKIIIIIIohgYYHZjNZojdZojdZojdbIpDUyySSTTFojk0y++MUJK/O+9le+7Gvnf9NnL/w632humkz4wAeYTBiN2Njworl8mdOneewxLl5kbu6Y+fkHMVRlX5XneM3KKffv7FhdXdV1Xdd13YtnoOteoE9fuuSJs2ddu/F+sUgEEUQQQQQRRBBBBBFEEEEEEfa0Rmu0Rmu0Rmu0RiatkUlrtEZrZJJJJpl87nPn2FrkZ2/nZ2+352py/obJhanJR2/w6HU3ra0xGjEcsr3NcMjamhfk4kUee4zTp7l8ec38/DELCw9iQ5XvaWnxGUuLz7hv52Fd13Vd1724BrruBTp18pSW67KOiCCCCCKIIIIIIogggggiiCCCCFqjNVqjNVojk0wyaY3WaI1MMsmkNTLJJJPf//0x/314jpV5RgcYHbDvwtTl8zd8+MLUhz845cTUTcMhwyHb2wyHDIe+q8mExx7j9Gnm5jbMzx8zGDyINVX2VdlX5Tles3LK2w4edPfhw7qu67que3ENdN0L9Pjurus3josggggiiCCCCCKIIIIIIoggggjm55lOmc1ojdZojdZojdZojUwyySSTTDLJJJMrVy766lcvsvU639dmsBn2XU0uzEzOXzc5f8PpM1OuprU1hkNGIw4dsuexxxiPmZvbEPGIubljqqiyr8r3ND9/xcodux44/l5d13Vd1734BrruBXh8d9eVK1fcmD3g9tuJIIIIIogggggiiCCCCCKIIIJMWqM1WqM1WqM1WqM1MmmN1miN1sgkk0wy+dKXJvZsLXrBVubZWmRr0b4LU5cvTI0/OTX+4A1OTH3L/PzQwsJfNjc39O2qPC8rd+xaXV3100eO6Lqu67ruxTfQdS/AqZOnXLuxY2FhVQQRRBBBBBFEEEEEEUQQQQQRLCwwm9EardEardEardEambRGJplkkklrZJJJJp/73Dm2lrxoNoPN4B3+yPkbnL8uL/x7ef6vczXdNDc3Mjc3xDaG2FBlX5XnWFs55d4jR6yuruq6ruu67sU30HXP07PPPOPZZ55xY/qwxSUiiCCCCCKIIIIIIogggggiiLCnNVqjNVojk9bIJJPWyCST1miNTDLJJJNM/uAPxmwvekltLbK1aN9nG5+cqvOfUBd+i/OP+k82MDQ3t40hRr5l+cBTBoNLfu6hB3Vd13Vd99IY6Lrn6fTJU2btoHJYBBFEEEEEEUQQQQQRRBBBBBFE0Bqt0Rqt0RqtkUlrtEZrtEZrZJJJJplkksm1a5d9+csTNn/MD9VdC9y1wOiAfedvcOHLnP9NdeHX+Uzznwwxsrj4r239hb/gTevruq7ruq57aQx03fNw5coVT5w96xvXHxZBBBFEEEEEEUQQQQQRRBBBBBHMzzOdMpvRGq3RGq3RGq3RGplkkkkmmbRGJplk8qUvTezZWvQjt7XI1iI/e7s9V5PzN7jwKc4/6yvnr/u/z3D2ta81Go0Mh0Pb29uGw6G1tTVd13Vd1/3JDXTd8/D47q6vfIWWRxwIIogggggiiCCCCCKIIIIIIhgMyKQ1WqM1WqM1WqM1WiOT1miN1miNTDLJJJNMfv/3z7EZrMy75azMMzrA6IB9F6Yun7/hwxfO+vAHf4MTJ9w0HA4Nh0Pb29uGw6HhcKjruq7ruhduoOueh9MnT7k+PWJhYVUEEUQQQQQRRBBBBBFEEEEEEQwGzGa0Rmu0Riat0RqtkUlrZJJJJpm0RiaZZJLJH/zBmP9qgavJyrxb3mawGfZdTS7MTM5/yuT8s06f+VWuprW1NcPh0Gg0cujQIaPRyNramq7ruq7rvreBrvs+Pv7UUy5duuQb1x+0vEwEEUQQQQQRRBBBBBFEEEEEEfa0Rmu0Rmu0RmtkkklrZJJJa7RGJplkkkkmmdy4cZnxNcafYzN4S7C1yGawGW55K/NsLbK1aN+FqcsXpsaf/ITxBz/GiambNjY2jEYjhw4dMhwOjUYjXdd1Xdc910DXfR+nT55yY3rY/Py6CCKIIIIIIogggggiiCCCCCKIoDVaozVaozVaI5PWaI1MWqM1Mskkk0wyySSTTO6559/4xjcu+9KXJr7whXO+/NGxr/6Lidns86zMsxlsLbIZbC2yMu+WtxlsBu/wR87fcPH8F52+8E8586tcTTeNRiPD4dD29rbhcGhjY0PXdV3XvZoNdN338OlLlzxx9qzr0/eKIIIIIogggggiiCCCCCKIIIII5ueZTpnNaI3WaI3WaI3WaI3WyCSTTDJpjUwyySSTTDJZWFjz2teO3HHHyPr6I2Yzrl6duHp14mu/97Sv/vbYtWsTe964wNYSm8HWIpvhZWFrka1F+z7b+OTU+PwnjD/6Wx599FE3bWxsGA6HhsOh7e1to9FI13Vd172aDHTd93Bm94yW66azHQeWiSCCCCKIIIIIIogggggiiGAwIJPWaI3WaI3WaI3WaI1MWqM1WqM1Mskkk0wyySSTTDLJpIoqqjhwYChiaHWV1miNr3517OtfP+faRyau/8ZY5uft2Vpic8DWEm8J7lpwy7trgbsWGB2w7/wNFy982cULZ334l3+dEyfcNBwOjUYjhw4dMhqNbGxs6Lqu67pXqoGu+x5Onzzp2vXjIogggggiiCCCCCKIIIIIIogggsGA2YzWaI3WyKQ1WiOTTFojk0wyyaQ1Mskkk0wyyaSKTDLJJJNMqsikiiqqOHBgJGJkZYXWmE4vun594sYz58z+7cT0Q2N73rjAZrC1xGawtehlYWuRrUX7ribnb5hc+JTJR5/l0etuWltbMxwOjUYj29vbhsOhtbU1Xdd1XfdKMNB1/xmP7+66cuWKG7P7LS8TQQQRRBBBBBFEEEEEEUQQQYQ9rdEardEarZFJJq3RGplkkkkmmWSSSSaZZJJJJplUkUkmVVSRSRVVVFFFFVVUUcX8/IalpQ2DwVFVZHLjxlj74sTso+fkuYmqi/ZsBluLvCXYWuKuBbe8lXlGBxgdsO/C1OULU+Pz/8r4gx/jxAk3DYdDw+HQ9va24XBoOBzquq7rupejga77zzize8Y3ru+Yn18XQQQRRBBBBBEMBkQQQQQRRDAYEEEmrdEardEardEardEambRGa7RGa2SSSSaZZJJJJlVkkkkVVWRSRRVVZJJJJlVUUUUVVVTZU0UVCwsj8/MjCwsPqSLzssyx/NTT8v8bqxrbszLP1iKbwdYSmwNW5t3yNoPN4B232XM1uTAzOf8pk/PPOn3mV7mabhqNRkajkUOHDhmNRtbW1nRd13XdrW6g676LZ595xsefesr1Gx+yuEQEEUQQQQQRRLC4SAQRRDAYEMHiIvPzXL9Oa7RGa7RGa7RGa7RGa2SSSSaZtEYmmWSSSSaZZFJFJplkUkUmVWRSRRVVVFFFFVVUUUUVVVTZU+XbrJmbO2p+/qi5uUfclDlRXx1z7mk1nmBiz2bwlmBrkc1gM9zyVubZWmRr0b7PNs5fN/7kJ4w/+DFOTN20sbFhNBo5dOiQ4XBoNBrpuq7rulvNQNd9F6dPntJyXdZhEUQQQQQRRBBBBBFEEEEEi4tEMBiQSWvMZrRGa7RGa7RGa2SSSWu0RmtkkkkmmWSSSSaZZJJJFVVUkUkVmVRRRRVVVFFFFVVUUUUVVfZU2VNFle9QxdzcEEN/5LKqCRfOcWHMr0/weVbm2Qy2FtkMthZZmXfLu2uBd9zGO/yR8zdcPP9Fpy/8U87+Iz7T3DQajQyHQ9vb24bDoY2NDV3XdV33ozTQdX/MlStXPHH2rK9fe1AEEUQQQQQRRBBBBBFEEEEEEUQwGDCb0Rqt0RqZtEZrZJJJa7RGJplk0hqZZJJJJplkUkUmmWSSSSZVZFJFFVVUUUUVVVTZU0UVVfZU2VNlXxVVnqPKnip/aA0jjPCIweCSN7z+bu/4S3/JgeUDxuOxyS9P7HnjAltLbAZbi2yGl4WtRbYW7fts45NT4/OfMP7ob3n00UfdtLGxYTgcGg6Htre3jUYjXdd1XffDNNB1f8xHzp51+SvcmO64/XYiiCCCCCKIIIIIBgMiiCCCwYAIe1qjNVqjNVojk0xaozUyySSTTDLJJJNMMskkk0wyqSKTTKqoIpMqqqiiiiqqqKKKKqo8RxVVVNlTRZV9VVR5XlbvOOP1r3udf/i+f+jbjcdj586dM5lMjH9l7PLf/7w9W0tsDtha4i3BXQtueXctcNcCowP2nb/h4oUvu3jhrA//8q9z4oSbhsOh0Wjk0KFDRqORjY0NXdd1XfdSGei6P+Z/f/Qx128cMRisiiCCCCKIIIIIBgMiiCCCwYAIIoggk9ZojdZojdZojdZojUxaozVaozUyySSTTDLJJJMqMsmkiioyqaKKKjLJJJMqqqiiiiqqqKKKKqrsqaLKC1LlOVZu33Xs+HF/3Gg0MhqNfMvFixdNJhPnzp0zmUyM/8bYnjcusBlsLbEZbC16WdhaZGvRvqvJ+RsmFz5l8tFnefS6m9bW1gyHQ6PRyPb2tuFwaG1tzYvlPe95jwcffNDa2pqu67ru1Weg677Nx596yqVLl1y7/oClA0QQQQQRRBBBBBFEEEEEEUQQwfw816/TGq3RGq3RGq3RGq3RGplkkkkmrZFJJplkkkkmmVSRSSaZVJFJFZlUUUUVVVRRRRVVVFFFFVX2VNlXRRVVVNlXZU+V72rljl2DwSX379zv+9nY2LCxseHo0aO+ZTwem0wmzp07Z3Jm4uLFi/ZsBluLvCXYWuKuBbe8lXlGBxgdsO/C1OULU+Pz/8r4gx/jxAk3DYdDw+HQ9va24XBoOBz6QZ04ccKHP/xhTz75pLW1NV3Xdd2ry0DXfZvHd8+4MT2sHBRBBBFEEEEEEUQQQQSLi0QQQQQRZNIasxmt0Rqt0RqtkUkmmbRGa7RGJplkkkkmmWSSSSaZVFFFFZlUkUkVVVRRRRVVVFFFFVVUUWVPlT1VVPkOVZ6XldvPuPfIEW9aX/eDGI1GRqORhx56yE2XL182Ho89/fTTxuOx8YfG9qzMs7XIZrC1xOaAlXm3vM1gM3jHbfZcTS7MTM5/yuT8s06f+VWupptGo5HRaOTQoUNGo5G1tTXfz3g8dtPkU//WPffc48knn7S2tqbruq579Rjouj/06UuXnNndde36e0UQQQQRRBBBBBFEEEEEEUQQQQSDAbMZrdEarZFJa7RGJq3RGq2RSSaZtEYmmWSSSSaZVJFJJplkkkkVmVRRRRVVVFFFFVX2VFFFlT1V9lTZV0WV56iyp8q+KvsGg0uWDzzl2PEPebGsra05evSoo0ePeuSRR9w0mUyMx2NPP/20yb+amPzyxJ7N4C3B1iKbwWa45a3Ms7XI1qJ9n22cv278yU8Yf/BjnJi6aWNjw2g0cujQIcPh0Gg08sedO3eONy7w/teZ/PXfds8993jyySetra3puq7rXh0Guu4Pndk9I2vVjdmOOw4QQQQRRBBBBBFEEEEEEUQQQYQ9rdEardEarZFJJq3RGplkkkkmmWSSSSaZZJJJJplUUUUmVVSRSRVVVFFFFVVUUUUVVZ6jiiqq7Kmiyr4qqjwvayunrK+vu/vwYS+l4XBoOBz6lsuXL5tMJs6dO2c8Hps8OnH58udZmWcz2FpkM9haZGXeLe+uBd5xG+/wR87fcPH8F52+8E85+4/4THPTaDQyHA5tb28bDocmkwlbS9y1wPvvNHn3b7vnnnv8s3/2z2xsbOi6rute+Qa67g89vrvr6984LoIIIogggggiiGAwIIIIIhgMiCCCwYBMWqM1WqM1WqM1WqM1MmmN1miN1sgkk0wyySSTTKrIJJNMqsikiiqqyCSTTKqooooqqqiiiiqqqLKniiovSJV98/NXrNyx69jxB/2wra2tGY1GRqORRx55xE2TycRkMvH0008bj8cmvzyx540LbC2xGWwtshleFrYW2Vq077ONT06Nz3/C+KO/5dFHH7XvxJo9K/O8/06Td/+2n/zJn/Tkk08aDoe6ruu6V7aBrvumx3d3Xbp0yfUb91u+jQgiiCCCCCKIIIIIIogggggiWFjg+nVaozVaozVaozVaI5PWyCSTTDJpjUwyySSTTDLJpIpMMsmkikyqyKSKKqqooooqqqiiiiqqqLKnyr4qqqiiyr4qe6p8V7ffdtb8/BX37ey4FQyHQ8Ph0Lcbj8fOnTtnMpkY/8rY5b//eXu2ltgcsLXEW4K7Ftzy7lrgrgVGB+w7f4MLU7aW7FuZ5/13uvzuL7rnnns8+eSThsOhruu67pVroOu+6czuGdeuHzE3vy6CCAYDIogggsGACCKIIIIIIogggkxaYzajNVqjNVqjNTJpjUxaozUyySSTTDLJJJNMMskkkyqqqCKTKjKpoooqqqiiiiqqqKKKKqrsqbKniirfocrz8pqVU+7f2bG6uupWNRqNjEYj33Lx4kWTycS5c+dMJhPjvzG2540LbAZbS2wGW4teFrYW2Vr0HVbmef+dLr/7i+655x5PPvmk4XCo67que2Ua6F71Pn3pko8/9ZQYrLttblcMjohYFUEEgwERRBBBBBFEEEEEEQwGzGa0Rmu0Riat0RqZtEZrtEYmmbRGa2SSSSaZZJJJFZlkkkkmmVSRSRVVVFFFFVVUUWVPFVVU2VNlT5XnqPIcVfZU2Vdl3/KBpywtPuPY8fd6OdnY2LCxseHo0aO+ZTwem0wmzp07Z3Jm4uLFi/ZsBluLvCXYWuKuBS8rK/O8/06X3/1F99xzjyeffNJwONR1Xde98iyc+Cbdq9rq6qq7Dx82P3/V73/2lOvXT+F3LC2tWllZt7zM8jLLyywvs7zM8jLLyywvs7zM8jILC0ynTKdMp0ynTKfMZsxmTKdMp8xmzGbMZsxmzGbMZrRGa7RGa7RGa7RGJpm0RiaZZJJJJplkkkkmVWRSRRVVVFFFFVVU2VNFFVX2VFHlefmx1zxmOOTnHnrIy93GxobDhw/7mZ/5GQ899JCHHnrI4cOHve3HN/l3UxdP/3s+9DU+9DX+3Q0uzjDHyhxLc25pS3McWXbtya/4tf/zg97+9rd7wxveoOu6rntlWTjxTbpXvfX1dfceOeJn3/Uuf/bPrvu9i0/4vd99n69cPmNhgZXV11tZWbW8zPIyy8ssL7O8zPIyBw5QxXTKdMp0ynTKdMp0ynTKdMpsxnTKbMZsxmxGa8xmtEZrtEZrtEYmrdEarZFJa2TSGpm0RiZVZJJJFZlUUUUVVVRRZU8VVV6QKvvm56/4idf/nL/5v/xNbzt40CvNgQMHvPWtbzUajRw7dsyJEyccPXrUW9/8Fnddfz3nb/jc//U7fOCrjK/x76Z8Ne25c8EtZ2mOI8uufebrfu3v/GNvf/vbveENb9B1Xde9ciyc+CZd94eWlpa87eBB/+O73uX+nR2tXfWv/99TLvz797nylWfNzV23/qcOWl5meZnlZZaXWVxkOmU6ZTplOmU6ZTplOmU6ZTZjOmU2YzZjNmM2YzajNVqjNVqjNVqjNTJpjdZojUxaI5PWyCSTTKrIpIpMqqiiiiqq7Kmyr4oqqqiyr8qeKt/Va1/zPj/x48949B/8A68Wb3jDGxw+fNjRo0f91b/6Vz300EPe/va3e/Pqn+bC1OUPf861f/IlPvQ1fus6n21cLe6cZ2nOj9zSHKMDrv3u1/za3/nH3vrWt3rrW9+q67que2VYOPFNuu67WF1d9VPb29791/6atx086Auff9a//Mj7/Jvzp3z9619w552v9xM/8XrLy8zNMZ1y4wbTKdMp0ynTKdMpsxnTKbMZ0ymzGa0xmzGb0Rqt0Rqt0Rqt0RqtkUkmmbRGJq2RSSaZZFJFJlVkUkUVVVTZU2VPFVW+Q5Xn5cfv/Hnv+p/+Bz+1ve3V6sCBAzY2NoxGI8eOHfO3/tbfcvToUYd/8m5vXvpTrn3sis/96u/yga/y/3ydCzM+21ia484FPzKjA6797tf82t/5xzY2NgyHQ13Xdd3L30DXPQ/3Hjni3iNHfPrSJU+cPev0yVPe+7GT/vSfOegvHX3An986YmFhVWu0Riat0RqZtEZrtEYmmbRGJplkkkkmmWRSRSaZZJJJJlVkUkUVVVRRRRVVVNlTRRVV9lTZU+U5qjxHlT1V9lXZd/ttZw0Glzxw/AHdcw2HQ8Ph0Lcbj8fOnTtnMpkY/8rY5b//eXu2ltgcsLXEW4K7FvzQPLLmpgceeMBNx44d03Vd1728DXTdC/Cm9XXHjh937PhxH3/qKY/vnvGrp37J//HYz/vv/uKO//bu+/3pP3NYa2SSSWu0RiaZZJJJJq2RSSaZZJJJJplUUUUVVVRRRRVVVFFFFVVUUUUVVZ6jiiqq7Kmiiip7qqjyvKzcfsa9R4540/q67vsbjUZGo5FvuXjxoslk4ty5cyaTifHfGNvzxgU2g60lNoOtRS+pR9bc9MADD7jp2LFjuq7rupevga77Ad19+LC7Dx/2C1ce9pGzZ506ecr/9vd2vfbH1v3kn9/xX/8391teXtcambRGa7RGa2SSSSaZZJJJJlVkkkkmmWRSRSZVVJFJFVVUUUUVVVRRRRVVVNlTRZUXpMq+weCS2287676d9+t+MBsbGzY2Nhw9etS3jMdjk8nEuXPnTM5MXLx40Z7NYGuRtwRbS9y14EX1yBqfnHrggQfcdOzYMV3Xdd3L00DX/Qmtrq66b2fHfTs7Pn3pklMnT3l896R/+ZFH/bnNI9785nv9F39uRyaZZJJJJplkkkkmmWSSSRWZZJJJFZlUkUkmVWRSRRVVVFFFFVVUUWVPlX1VVFFFlX1V9lT5rtZWTllfX3fvkSO6F89oNDIajTz00ENuunz5svF47OmnnzYej40/NLZnZZ6tRTaDrSU2B6zMe0E+2xhf4/x1zt/gahoOh55++mld13Xdy9dcfZOuewk8cfasx3fPeOLsWYuLq/7sf7njz2zc7/Y7Drpxgxs3mE6ZTplOmU6ZTplOmc2YzZjNmM2YzZjNaI3ZjNZojdZojUxaI5PWyCSTTDKpIpMqMqmiiiqqqKLKnip7quyrsu/Nf+qQh/7n437uoQd1P1yTycR4PPb000+bTCYmkwk/ezt//TW+r/E1zl/n3DU+06ytrRmNRt75zncajUY2NjZ0Xdd1L28DXfcSuffIEfceOeLTly554uxZp0+e8pu/cdJr1g7aePMDfux1R1StyiSTTDKpIpNMMskkkyoyqaKKKqqooooqquypoooqe6rsqfIcVZ6jyp4q+6rsW7lj1/z8FceOP6D74RsOh4bDoW+Zm5tja8l39dnG+BrnrzO+5qbhcOjoXznqne98p+FwqOu6rntlGei6l9ib1tcdO37csePHffyppzy+e8YTZ3/J0//m5/3EXTte9/r7Ld92WCaZZFJFFVVUUUUVVVRRRRVVVFFFFVVUeY4qqqiyp4oqquyposrz8pqVU+7f2bG6uqr70RqPx/a8JewbX+P8dc5d4zPN2tqao0d/xvapbUePHrW2tqbruq575Rrouh+iuw8fdvfhw37hysM+cvasUydP+e1/u2txad1rf2zHyur9zK3LJJNMMqkikyqqyKSKKqqooooqqqiiiiqq7KmiygtSZd/S4jOWFp9x387Duh+9c+fOsTLP+BrnrzO+5qbhcOjoXznqne98p+FwqOu6rnv1GOi6H4HV1VX37ey4b2fHpy9dcurkKY/vnvT7n33U7XccceC2ey0d2JFJFZlUkUkmVWRSRRVVVFFFFVVUUWVPlX1VVFFFlX1V9lT5rl6zcsrbDh509+HDuh+9yWTC1bT2K3OOHv0Z26e2HT161Nramq7ruu7VaaDrfsTetL7uF//2w37xbz/sibNnPb57xhNnf978/C9ZWt4Ri/czd1AmVVRRRRVVVFFFFVVUUUWVPVX2VFHlO1T5vubnr1i5Y9cDx9+ruzVsb2975JFHDIdDXdd1XXfTQNfdQu49csS9R4749KVLnjh71umTp1y6dNL8wkGDeEDNHVG1qooqqqiiyp4qqqiyp8qeKt9TlT1V9lXZt3LHrtXVVT995Iju1vDQQw/puq7rum830HW3oDetrzt2/Lhjx4/7+FNPeXz3jCfO/pIrV37e3PyOcr+qw6qooooqz1FFFVX2VFFFFVVUUeV5WVs55b6dHaurq7qu67quuzUNdN0t7u7Dh919+LBfuPKwj5w968zuGR9/6mctWMeO5n5V66qooooqquyposoLUmXf7bedNRhc8sDxB3Rd13Vdd+sa6LqXidXVVfft7LhvZ8enL11y6uQpHzm769KlR83mj5jO7nWt7aiiyp4q+6qooooq+6rsqfJdrdx+xt2HD3vT+rqu67qu625dCye+Sde9zKyurvqp7W3Hjh/3toMHzabP+g+/9z4HFk+Zm/uCzNdr7fVuqqLKd6jyfQ0Gl7z+zl/04EMPetvBg7qu67quu3UNdN3L3L1Hjrj3yBFXrlzx+O6u0ydPuXTppNnsoK9fu9/XvrGjatV3U2VPlX1V9q3eccb6+rr7dnZ0Xdd1XXdrG+i6V4jV1VXHjh937Phxzz7zjNMnT3ni7GOuXPklX//Gjq9fu9fXv3FEFVWel9esnHTfznFd13Vd1936BrruFehtBw/6u3/vvX7hysM+cvasM7tnfPypd5utrvva13dc/dr9ZrN138vKHbvm56+4f+d+Xdd1Xdfd+ga67hVsdXXVfTs77tvZ8elLl5w6ecpHzu66dOlR164fdvVr97v61R3fUmXfyu1n3L+z403r67qu67quu/UtnPgmXfcqsLq66qe2tx07ftzbDh6U7Xd87jPv85qVUyJ+x2y2rrXXu2lp8Rl3vvZ/9Yt/+2Hr6+u6ruu6rrv1DXTdq9C9R46498gRV65c8fjurtMnT7l0adf1Gwdd/dr9lpc+bn193d2HD+u6ruu67uVhoOtexVZXVx07ftyx48c9+8wzTp885Ymzj7ly5Yqfe+i9uq7ruq57+Rjoum7P2w4e9Hf/3nv9wpWHfeTsWT995Iiu67qu614+Brque47V1VX37ezouq7ruu7lZV7XdV3XdV3XvQLM67qu67qu67pXgHld13Vd13Vd9wowr+u6ruu6ruteAeZ1Xdd1Xdd13SvAvO7/n5ceyQAAAJpJREFUbw8OSAAAABAARf9H9yNUAAAONAAAcKABAIADDQAAHGgAAOBAAwAABxoAADjQAADAgQYAAA40AABwoAEAgAMNAAAcaAAA4EADAAAHGgAAONAAAMCBBgAADjQAAHCgAQCAAw0AABxoAADgQAMAAAcaAAA40AAAwIEGAAAONAAAcKABAIADDQAAHGgAAOBAAwAABxoAADgweQP5u7Qya7MAAAAASUVORK5CYII="},{width:347,height:236,url:"data:image/png;base64,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"},{width:174,height:118,url:"data:image/png;base64,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"},{width:87,height:59,url:"data:image/png;base64,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"},{width:44,height:30,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAeCAYAAABXNvynAAAAAklEQVR4AewaftIAAAM+SURBVNXBT2hbdQDA8e/7vV+a9/rnJattY9oszZpS32RgL6XgwUvBzXmwHqbDk5eBXuYOO+nJoScvnrwOcehJLIxBYTAVh38mFap1VtImJWt5S0lNu7ylLy9/nvZQkLEt/1v6+Sjefzg6vhAcMYI2yechlfKoVOgoQZtUq1Vu3bpONpulkwRtks2mOH9+hlwuy+bmJp0iaJN8Pk9PTw+mabK9vY1lWXSCoA1s28YwDPZNTExQKBTY2Nig3QRtkEwmicVi/F88HqdUKpFOp2knQYs8z8PzPIQQPCoWi7FnbW2NdhG0aH19ndHRUZ4kGo0ipWR1dZUncVyH93/8AOsfi1oELdra2iIYDPI0kUiE7u5uEokEjyo4BT5a/JjXI7MMBYaoRdCCYrGIruvUIxwOYxgGy8vL7HFsm/xung9/v8IbI+eYik6hqiq1SFqwkkjwnGlSr1AohCoEf177ksD1z/nk0knePfEO5rMm9ZK0oFypIKWkHo6zi+vep+Qu8Yx5k28Cf3HhmkPksp9GSJqUyWQIh8M8TqGQp1y2gDSwQqGwhM9n4POdotcYI3P3VV5OvUbA+x61r49GSJpkWRaTk5Psse0UpdKvCLHBw4d/o+sRVPUkEENRZhkcvICqquzrmamy7l9Af/sKutFHIyRNKJfL+Hw+9lUqRTwvihAzhMP9KIrC0wghiL40RTMkTVhZWWF8fJx9gYDJQRE0wXEc/H4/h0HQoFwux8DAAIdFUAfP87CsHTzPI51OMzIywmGR1CGdtrlxow9Ny6NpvcTjRXTdx87OLyhKP8eOmRwUSR1u3/YIhQTz8wYLC35c9zvOnPkan28KXT/HQZLUYNsOyaTG8DC4z8/x2cWr3F99i2DwUzStm4MmqeHOHZd43GBxscoPcoivfprllci3/PbHXSYDLzDeO87xvuMEe4PsURSFTpLUUCqVUZQiyaSf0s8vMliZ4urSm/g1j3v5eyTtJPOZeVYfpDjRE+O9UxfRNZ1OkdRw+nQ/u7suY2MPmJuDoaEq/f1B9pjdJmbI5CxnqVQqZHIZNL9GJ0nqoOtdTE93MT0NruvyOKqqMjwwTKcJGtTV1cVhksBNjo6lfwGg9h6IwB7DXgAAAABJRU5ErkJggg=="}],"PENDULUM_LAB/period-timer-background.png":[{width:231,height:158,url:"data:image/png;base64,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"},{width:116,height:79,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABPCAYAAAA6J+FJAAAAAklEQVR4AewaftIAAAViSURBVO3BbWhddx3A8e//d859ym3z1DRJ22W9qdR2TNxmB9ap9NxOoYOhDCcTivpKRaZS3Dsn2wsnxU2QMS3iC0Haigi+2GDqpvOeS7sHdC+s8aGZtLvtuprWLGmS3iW5T38PrGA8PYlxs83Zn9/nY1ilICjfbC13G8NuoIi6Hs4BvwF+HYaVaVbBsIIgKOeBb4O9E8wtqDVi69aal43hUBhWfs4KDMsIgvIB4OvACJFMJkuxWCRfyNPb24fneYCl1WpjiBiwFnzfR8Sg/q3TsTSbTcAyMzPLxQsTWGt5m44DXwrDyl9JYEiwZ0/5iDHsJ+L7PtlcnnXFIr39fRTyBay1tNstWq0WYLBYFubnWVxcpNPpYK1F/adOp0Oz0cDzfeZmZ2m327wDk9baR6rV8HFiDDFBUH4euIOIiIAxFItFurq68DyPbDZLvV7HE4+JiX+g1kwLOBiGlYdYwrDEnj3lI8awnyuMMfiZDL7v02q2yOVyXL48x/tG8+zb3csNQ3kG+7L0rs9QyAnq7ZuebTFTb3FxapG/nKrz5PFpZuodVmbr1vLlajU8zBWGK4KgfAD4Hiso37aO+z4+yI6tRdS11Wh2eP7EJX705AUmplqs4CxwaxhWpol4RIKgnAf7UzA9JOjKC9/6wgj79w0z0JtFXXueZxjdXOCuD/WDbTN2ep5l9IDdWqvVfkHEI1IqjX4HzD4S3DiY4fsPvIcdpSLq+stmhF07u7lhwOeFsTms5SrWcuPo6OhParXaZeEtd5JguN/nsa9tY2hDDrW2PvbBDTz4+S0kMcZ0A98kIkFQvhm4hRhP4NH7Swz2ZVHpUL69ny9+YiNJrLW7iIi13E2Cr947xMhwAZUun9o7yPYtORLcRESMYTcxw/0+d90xgEqfbEb4yqc3EWeM6Q6CYLsARWI+u2+AbEZQ6fT+7espDWW5mikICT6wsweVbvfu7SeJEDMymGV4QxaVbtu2dJFEiNm1owuVfqXNBZIIMds251DpV8gJfes94oSYdQVBvTt05YQ4QTlFUE4RlFME5RRBOUVQThGUUwTlFEE5RVBOEZRTBOUUQTlFUE4RlFME5RRBOUVQThGUUwTlFEE5RVBOEZRTBOUUQTlFUE4RlFME5RRBOUVQThGUUwTlFEE5RVBOEZRTBOUUQTlFUE4RlFME5RRBOUVQThFiWm2LendodyxxQswrry2i0q/R7DAx1SJOiBk/u4BKv/OTDZIIMWOn55mea6LS7fS5OkmEBH96ZQ6Vbk8dmyaJAA1ijj4zSbttUek0fqbOiVPzXM02xVr7EjF/f32RF8cuodLpyK8ukKAehuHfBHiGBAcPn2fyUhOVLs++9AbHx+rEWcs4EalWwz8A48S8udDhkR/XmF/soNLhZK3Oo0fPk8QYxogIbzlOghOnFvju4TPM1luotXWyVueBJ2q0OyRZAJ4g4hEplUb/DOwHuoh5daLBH8fnuPW9RbqLPur6++3vp/jGD8/SaFqS2efCMHyMiEekVqtNb91a2miM+TAJJmfaPHVsioxnGRnKk88J6tobP1Pn8Z+d4+izb2Aty5kGc1+tVvsnEcMSQVB+DtjLCrIZwz0f7eX2m7opbSkw0JNB/X+025bXLi5Se73O0y9c4uXxN/kvWmAfCsPwIFcYlgiC8iZr+Z0x7GSVshnDxh4f9c60O5aJqRb/o0NhWLmfJQwxQVDeBDwN3IZKqxbwgzCsHCDGsIwgKB8C+zkwRVSK2Fet5eFqNTxMAsMKgqC8C3gY+AjQh1pD9iSYXwIPhmFlgWUYViEIynngM8AngR5rbQHwUdeMMcyDaQCnrOVItVo5xir8C48FsNWAAmPwAAAAAElFTkSuQmCC"},{width:58,height:40,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAAoCAYAAACvpem4AAAAAklEQVR4AewaftIAAAKeSURBVOXB3YtUdRjA8e/znDOvNi07mxLt4swkmCJqJkGWLGe66iJihUC6VfoD/AekJfBKEBT0QtQLrzZICO8WjDMTgbhgguJLkW6mQRE7q7vTjuc083hkz8CyF17vzO/zEdYIgroPdtxMAhHGzVAGisXAPHC10QjPsIaQmpysH1blhOf575bLZcpjY3ie0u12iaKIjcIM4jhisbVIu73Ma8z1enas2Qx/JiEkJifrh1U5D5Ry+TzFQpFCtsfBXRkm3lLeKCob2cLzLg+frjA7t8T/PdawJ70eXzSb4S9+ENR9sBMgJRJx1OHI1AiffjhGMe8xSL4+FHPlx7+5PNtilUyI2Ckg8KrV2jcgUySyGeH0sRqf7B0l4yuDJp/z2LfjTbZu8WneWiI1Ua3WbnuVSm1ahAqJ6aPjfLBzhEFXGy+SkS43f1tBRNTMIgXGSby/LceBPaMMi6n6FgpZ4RVV3lFASXx2oIyqMCw2FXw+/3iEVSJKauvbeYbNe5UCfUpqU14ZNtmM0qc4QnGE4gjFEYojFEcojlAcoThCcYTiCMURiiMURyiOUByhOEJxhOIIxRFKyhhuSurfxZhhs/A8pk9J3X24zLC5fnuJPgVrk5i51uLZcsyw+P1Jm+v3VlhlkQK/kmi/MC7+8BfdnjHo/ut0OTPzlD4zueXVatUuyCHAe/DnC6IoYve2Er4nDKJnyzEnL//BjfsdVtmCiBzx5ufn71Yq1f0isoPEnUcdbtxZZLTkUSr6FHIeG52Z8U8r4qebLaYvPObe44iUAefCMPxeSARBvWRmsyLyEesUskLGFzayTmxEsbGOgc2EYfgVCWGNIAjOgnwJbGag2SMzLjUa4bekhHWCoO6DHTVjuxk5BogqK2bMNRrhd6zzEgOw3qoN+iXfAAAAAElFTkSuQmCC"},{width:29,height:20,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAUCAYAAABxnDbHAAAAAklEQVR4AewaftIAAAE4SURBVMXBPUtCURzA4d/5a3TTXg3UQRoiWl3a7x3cCloDSaIl2lrahOgbVBANLY0NQVNjUX6LilIky4LIJbP0nNO1r5B6nkcR8v2gGIvF85NTU2mtOxhj+C+jDY1GA601YC1QA45vbq4PlO8HRaXYyc6NRVdy06QSUSJCz3S05emtxcnFG+V6+9sYtqKg8gvzXnR3Y4aYF6EfZjNxsvPjbO8/DN/VftYFSBcWU8S8CP00MTrE2lKSUFIIZZIeg5BJjdAlhEQpBkEp/ggOCA4IDggOCA4IDggOCA4IDgihtjYMgtaWLgFr7qtNBuG28olSWAEqh2cv1N9b9FPlucnR+SvWUla+H6wCh6OejK3kEmSSwyhFz1gLj7UvTi8/aGv7DhQUoSAIloFNa0kDit6zQNVa9kql66tfjllnL1kd0EEAAAAASUVORK5CYII="},{width:15,height:10,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAKCAYAAABrGwT5AAAAAklEQVR4AewaftIAAACmSURBVGO0t3eY424uFqqpwMHGyPCfAR/4/+8vw8cvP/6vPfj+4cev/xNYPM15Q0tixfmYmRgZiAUG6rwaef0PU5j0VbjZmJkYGUgBClJcDEDAwcTIyMhAKmBkgAAmBgoAEwMFgImBAsD07/9/BlLBfwYIYDpx5dOPX7//MZACrt37zMDIyPCF5eDFb3M/TLwdrqfCxcZABPj87S/DpmOf7jMyMkwAAHZ1MX0I7aqhAAAAAElFTkSuQmCC"}]};</script>
<script type="text/javascript">
!function(){"use strict";function t(t,r){0===o&&0===d&&(o=r.width,d=r.height);var i=o,n=d,a=window.innerHeight,l=window.innerWidth,w=l/i,c=a/n,h=Math.min(w,c)*e,p=Math.round((l-i*h)/2),u=Math.round((a-n*h)*s),m="translate("+p+"px, "+u+"px) scale3d("+h+", "+h+", 1)";t.style["-webkit-transform"]=m,t.style["-ms-transform"]=m,t.style.transform=m}var e=.2605,r="http://www.w3.org/2000/svg",i="splash-container",n=25,s=.435,o=0,d=0,a=document.createElement("div");a.id=i,a.style.position="fixed",a.style.left="0px",a.style.top="0px",a.style["-webkit-transform-origin"]="0 0",a.style["-ms-transform-origin"]="0 0",a.style["transform-origin"]="0 0";var l=document.createElement("img");l.style.display="block";var w=function(){t(a,l)};l.onload=function(){w(),window.addEventListener("resize",w),window.addEventListener("load",w);var t=document.getElementById(i);t&&t.parentNode.removeChild(t),document.body.appendChild(a)};var c=document.createElement("div");c.setAttribute("style","width:273px;height:10px"),c.style.display="block";var h=document.createElementNS(r,"svg");h.style["margin-left"]="-1px";var p=document.createElementNS(r,"rect");p.setAttribute("id","progressBarBackground"),p.setAttribute("x","1"),p.setAttribute("y",n+""),p.setAttribute("width","273"),p.setAttribute("height","10"),p.setAttribute("rx","3"),p.setAttribute("ry","3"),p.setAttribute("style","stroke: white;stroke-width:1");var u=document.createElementNS(r,"rect");u.setAttribute("id","progressBarForeground"),u.setAttribute("x","1"),u.setAttribute("y",n+""),u.setAttribute("width","0"),u.setAttribute("height","10"),u.setAttribute("rx","3"),u.setAttribute("ry","3"),u.setAttribute("style","fill:#6acef5;"),h.appendChild(p),h.appendChild(u);var m=setInterval(function(){p.style["stroke-width"]=(.55*Math.sin(Date.now()/1e3*4)+1).toFixed(2)},16);if(window.phetSplashScreenDownloadComplete=function(){clearInterval(m),p.style["stroke-width"]=1},a.appendChild(l),a.appendChild(h),window.PHET_SPLASH_DATA_URI)l.src=window.PHET_SPLASH_DATA_URI;else{var A=location.search.match(/brand=([^&]+)/),v=A?decodeURIComponent(A[1]):"adapted-from-phet";l.src="../brand/"+v+"/images/splash.svg"}window.phetSplashScreen={dispose:function(){window.PHET_SPLASH_DATA_URI&&delete window.PHET_SPLASH_DATA_URI,window.removeEventListener("resize",w),window.removeEventListener("load",w),document.body.removeChild(a),delete window.phetSplashScreen}}}();
</script>

<script type="text/javascript">
!function(e,t){"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){function n(e){var t=e.length,n=ee.type(e);return"function"!==n&&!ee.isWindow(e)&&(!(1!==e.nodeType||!t)||("array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e))}function r(e,t,n){if(ee.isFunction(t))return ee.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return ee.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(ae.test(t))return ee.filter(t,e,n);t=ee.filter(t,e)}return ee.grep(e,function(e){return U.call(t,e)>=0!==n})}function i(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}function o(e){var t=he[e]={};return ee.each(e.match(de)||[],function(e,n){t[n]=!0}),t}function s(){K.removeEventListener("DOMContentLoaded",s,!1),e.removeEventListener("load",s,!1),ee.ready()}function a(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=ee.expando+Math.random()}function u(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(be,"-$1").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n="true"===n||"false"!==n&&("null"===n?null:+n+""===n?+n:xe.test(n)?ee.parseJSON(n):n)}catch(e){}ye.set(e,t,n)}else n=void 0;return n}function l(){return!0}function c(){return!1}function f(){try{return K.activeElement}catch(e){}}function p(e,t){return ee.nodeName(e,"table")&&ee.nodeName(11!==t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function d(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function h(e){var t=Pe.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function g(e,t){for(var n=0,r=e.length;n<r;n++)ve.set(e[n],"globalEval",!t||ve.get(t[n],"globalEval"))}function m(e,t){var n,r,i,o,s,a,u,l;if(1===t.nodeType){if(ve.hasData(e)&&(o=ve.access(e),s=ve.set(t,o),l=o.events)){delete s.handle,s.events={};for(i in l)for(n=0,r=l[i].length;n<r;n++)ee.event.add(t,i,l[i][n])}ye.hasData(e)&&(a=ye.access(e),u=ee.extend({},a),ye.set(t,u))}}function v(e,t){var n=e.getElementsByTagName?e.getElementsByTagName(t||"*"):e.querySelectorAll?e.querySelectorAll(t||"*"):[];return void 0===t||t&&ee.nodeName(e,t)?ee.merge([e],n):n}function y(e,t){var n=t.nodeName.toLowerCase();"input"===n&&Ne.test(e.type)?t.checked=e.checked:"input"!==n&&"textarea"!==n||(t.defaultValue=e.defaultValue)}function x(t,n){var r=ee(n.createElement(t)).appendTo(n.body),i=e.getDefaultComputedStyle?e.getDefaultComputedStyle(r[0]).display:ee.css(r[0],"display");return r.detach(),i}function b(e){var t=K,n=$e[e];return n||(n=x(e,t),"none"!==n&&n||(We=(We||ee("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement),t=We[0].contentDocument,t.write(),t.close(),n=x(e,t),We.detach()),$e[e]=n),n}function w(e,t,n){var r,i,o,s,a=e.style;return n=n||_e(e),n&&(s=n.getPropertyValue(t)||n[t]),n&&(""!==s||ee.contains(e.ownerDocument,e)||(s=ee.style(e,t)),Ie.test(s)&&Be.test(t)&&(r=a.width,i=a.minWidth,o=a.maxWidth,a.minWidth=a.maxWidth=a.width=s,s=n.width,a.width=r,a.minWidth=i,a.maxWidth=o)),void 0!==s?s+"":s}function T(e,t){return{get:function(){return e()?void delete this.get:(this.get=t).apply(this,arguments)}}}function C(e,t){if(t in e)return t;for(var n=t[0].toUpperCase()+t.slice(1),r=t,i=Ge.length;i--;)if(t=Ge[i]+n,t in e)return t;return r}function N(e,t,n){var r=ze.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function k(e,t,n,r,i){for(var o=n===(r?"border":"content")?4:"width"===t?1:0,s=0;o<4;o+=2)"margin"===n&&(s+=ee.css(e,n+Te[o],!0,i)),r?("content"===n&&(s-=ee.css(e,"padding"+Te[o],!0,i)),"margin"!==n&&(s-=ee.css(e,"border"+Te[o]+"Width",!0,i))):(s+=ee.css(e,"padding"+Te[o],!0,i),"padding"!==n&&(s+=ee.css(e,"border"+Te[o]+"Width",!0,i)));return s}function E(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=_e(e),s="border-box"===ee.css(e,"boxSizing",!1,o);if(i<=0||null==i){if(i=w(e,t,o),(i<0||null==i)&&(i=e.style[t]),Ie.test(i))return i;r=s&&(J.boxSizingReliable()||i===e.style[t]),i=parseFloat(i)||0}return i+k(e,t,n||(s?"border":"content"),r,o)+"px"}function D(e,t){for(var n,r,i,o=[],s=0,a=e.length;s<a;s++)r=e[s],r.style&&(o[s]=ve.get(r,"olddisplay"),n=r.style.display,t?(o[s]||"none"!==n||(r.style.display=""),""===r.style.display&&Ce(r)&&(o[s]=ve.access(r,"olddisplay",b(r.nodeName)))):o[s]||(i=Ce(r),(n&&"none"!==n||!i)&&ve.set(r,"olddisplay",i?n:ee.css(r,"display"))));for(s=0;s<a;s++)r=e[s],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[s]||"":"none"));return e}function j(e,t,n,r,i){return new j.prototype.init(e,t,n,r,i)}function S(){return setTimeout(function(){Qe=void 0}),Qe=ee.now()}function A(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)n=Te[r],i["margin"+n]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function L(e,t,n){for(var r,i=(nt[t]||[]).concat(nt["*"]),o=0,s=i.length;o<s;o++)if(r=i[o].call(n,t,e))return r}function q(e,t,n){var r,i,o,s,a,u,l,c=this,f={},p=e.style,d=e.nodeType&&Ce(e),h=ve.get(e,"fxshow");n.queue||(a=ee._queueHooks(e,"fx"),null==a.unqueued&&(a.unqueued=0,u=a.empty.fire,a.empty.fire=function(){a.unqueued||u()}),a.unqueued++,c.always(function(){c.always(function(){a.unqueued--,ee.queue(e,"fx").length||a.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],l=ee.css(e,"display"),"none"===l&&(l=b(e.nodeName)),"inline"===l&&"none"===ee.css(e,"float")&&(p.display="inline-block")),n.overflow&&(p.overflow="hidden",c.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Ke.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(d?"hide":"show")){if("show"!==i||!h||void 0===h[r])continue;d=!0}f[r]=h&&h[r]||ee.style(e,r)}if(!ee.isEmptyObject(f)){h?"hidden"in h&&(d=h.hidden):h=ve.access(e,"fxshow",{}),o&&(h.hidden=!d),d?ee(e).show():c.done(function(){ee(e).hide()}),c.done(function(){var t;ve.remove(e,"fxshow");for(t in f)ee.style(e,t,f[t])});for(r in f)s=L(d?h[r]:0,r,c),r in h||(h[r]=s.start,d&&(s.end=s.start,s.start="width"===r||"height"===r?1:0))}}function H(e,t){var n,r,i,o,s;for(n in e)if(r=ee.camelCase(n),i=t[r],o=e[n],ee.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),s=ee.cssHooks[r],s&&"expand"in s){o=s.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function O(e,t,n){var r,i,o=0,s=tt.length,a=ee.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=Qe||S(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,s=0,u=l.tweens.length;s<u;s++)l.tweens[s].run(o);return a.notifyWith(e,[l,o,n]),o<1&&u?n:(a.resolveWith(e,[l]),!1)},l=a.promise({elem:e,props:ee.extend({},t),opts:ee.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Qe||S(),duration:n.duration,tweens:[],createTween:function(t,n){var r=ee.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;n<r;n++)l.tweens[n].run(1);return t?a.resolveWith(e,[l,t]):a.rejectWith(e,[l,t]),this}}),c=l.props;for(H(c,l.opts.specialEasing);o<s;o++)if(r=tt[o].call(l,e,c,l.opts))return r;return ee.map(c,L,l),ee.isFunction(l.opts.start)&&l.opts.start.call(e,l),ee.fx.timer(ee.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function F(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(de)||[];if(ee.isFunction(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function P(e,t,n,r){function i(a){var u;return o[a]=!0,ee.each(e[a]||[],function(e,a){var l=a(t,n,r);return"string"!=typeof l||s||o[l]?s?!(u=l):void 0:(t.dataTypes.unshift(l),i(l),!1)}),u}var o={},s=e===wt;return i(t.dataTypes[0])||!o["*"]&&i("*")}function M(e,t){var n,r,i=ee.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&ee.extend(!0,e,r),e}function R(e,t,n){for(var r,i,o,s,a=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in a)if(a[i]&&a[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}s||(s=i)}o=o||s}if(o)return o!==u[0]&&u.unshift(o),n[o]}function W(e,t,n,r){var i,o,s,a,u,l={},c=e.dataTypes.slice();if(c[1])for(s in e.converters)l[s.toLowerCase()]=e.converters[s];for(o=c.shift();o;)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(s=l[u+" "+o]||l["* "+o],!s)for(i in l)if(a=i.split(" "),a[1]===o&&(s=l[u+" "+a[0]]||l["* "+a[0]])){s===!0?s=l[i]:l[i]!==!0&&(o=a[0],c.unshift(a[1]));break}if(s!==!0)if(s&&e.throws)t=s(t);else try{t=s(t)}catch(e){return{state:"parsererror",error:s?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}function $(e,t,n,r){var i;if(ee.isArray(t))ee.each(t,function(t,i){n||Nt.test(e)?r(e,i):$(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==ee.type(t))r(e,t);else for(i in t)$(e+"["+i+"]",t[i],n,r)}function B(e){return ee.isWindow(e)?e:9===e.nodeType&&e.defaultView}var I=[],_=I.slice,X=I.concat,z=I.push,U=I.indexOf,V={},Y=V.toString,G=V.hasOwnProperty,Q="".trim,J={},K=e.document,Z="2.1.0",ee=function(e,t){return new ee.fn.init(e,t)},te=/^-ms-/,ne=/-([\da-z])/gi,re=function(e,t){return t.toUpperCase()};ee.fn=ee.prototype={jquery:Z,constructor:ee,selector:"",length:0,toArray:function(){return _.call(this)},get:function(e){return null!=e?e<0?this[e+this.length]:this[e]:_.call(this)},pushStack:function(e){var t=ee.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return ee.each(this,e,t)},map:function(e){return this.pushStack(ee.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(_.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:z,sort:I.sort,splice:I.splice},ee.extend=ee.fn.extend=function(){var e,t,n,r,i,o,s=arguments[0]||{},a=1,u=arguments.length,l=!1;for("boolean"==typeof s&&(l=s,s=arguments[a]||{},a++),"object"==typeof s||ee.isFunction(s)||(s={}),a===u&&(s=this,a--);a<u;a++)if(null!=(e=arguments[a]))for(t in e)n=s[t],r=e[t],s!==r&&(l&&r&&(ee.isPlainObject(r)||(i=ee.isArray(r)))?(i?(i=!1,o=n&&ee.isArray(n)?n:[]):o=n&&ee.isPlainObject(n)?n:{},s[t]=ee.extend(l,o,r)):void 0!==r&&(s[t]=r));return s},ee.extend({expando:"jQuery"+(Z+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===ee.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return e-parseFloat(e)>=0},isPlainObject:function(e){if("object"!==ee.type(e)||e.nodeType||ee.isWindow(e))return!1;try{if(e.constructor&&!G.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(e){return!1}return!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?V[Y.call(e)]||"object":typeof e},globalEval:function(e){var t,n=eval;e=ee.trim(e),e&&(1===e.indexOf("use strict")?(t=K.createElement("script"),t.text=e,K.head.appendChild(t).parentNode.removeChild(t)):n(e))},camelCase:function(e){return e.replace(te,"ms-").replace(ne,re)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,r){var i,o=0,s=e.length,a=n(e);if(r){if(a)for(;o<s&&(i=t.apply(e[o],r),i!==!1);o++);else for(o in e)if(i=t.apply(e[o],r),i===!1)break}else if(a)for(;o<s&&(i=t.call(e[o],o,e[o]),i!==!1);o++);else for(o in e)if(i=t.call(e[o],o,e[o]),i===!1)break;return e},trim:function(e){return null==e?"":Q.call(e)},makeArray:function(e,t){var r=t||[];return null!=e&&(n(Object(e))?ee.merge(r,"string"==typeof e?[e]:e):z.call(r,e)),r},inArray:function(e,t,n){return null==t?-1:U.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r,i=[],o=0,s=e.length,a=!n;o<s;o++)r=!t(e[o],o),r!==a&&i.push(e[o]);return i},map:function(e,t,r){var i,o=0,s=e.length,a=n(e),u=[];if(a)for(;o<s;o++)i=t(e[o],o,r),null!=i&&u.push(i);else for(o in e)i=t(e[o],o,r),null!=i&&u.push(i);return X.apply([],u)},guid:1,proxy:function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),ee.isFunction(e))return r=_.call(arguments,2),i=function(){return e.apply(t||this,r.concat(_.call(arguments)))},i.guid=e.guid=e.guid||ee.guid++,i},now:Date.now,support:J}),ee.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){V["[object "+t+"]"]=t.toLowerCase()});var ie=function(e){function t(e,t,n,r){var i,o,s,a,u,l,f,h,g,m;if((t?t.ownerDocument||t:$)!==q&&L(t),t=t||q,n=n||[],!e||"string"!=typeof e)return n;if(1!==(a=t.nodeType)&&9!==a)return[];if(O&&!r){if(i=ye.exec(e))if(s=i[1]){if(9===a){if(o=t.getElementById(s),!o||!o.parentNode)return n;if(o.id===s)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(s))&&R(t,o)&&o.id===s)return n.push(o),n}else{if(i[2])return Z.apply(n,t.getElementsByTagName(e)),n;if((s=i[3])&&C.getElementsByClassName&&t.getElementsByClassName)return Z.apply(n,t.getElementsByClassName(s)),n}if(C.qsa&&(!F||!F.test(e))){if(h=f=W,g=t,m=9===a&&e,1===a&&"object"!==t.nodeName.toLowerCase()){for(l=p(e),(f=t.getAttribute("id"))?h=f.replace(be,"\\$&"):t.setAttribute("id",h),h="[id='"+h+"'] ",u=l.length;u--;)l[u]=h+d(l[u]);g=xe.test(e)&&c(t.parentNode)||t,m=l.join(",")}if(m)try{return Z.apply(n,g.querySelectorAll(m)),n}catch(e){}finally{f||t.removeAttribute("id")}}}return w(e.replace(ue,"$1"),t,n,r)}function n(){function e(n,r){return t.push(n+" ")>N.cacheLength&&delete e[t.shift()],e[n+" "]=r}var t=[];return e}function r(e){return e[W]=!0,e}function i(e){var t=q.createElement("div");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function o(e,t){for(var n=e.split("|"),r=e.length;r--;)N.attrHandle[n[r]]=t}function s(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||Y)-(~e.sourceIndex||Y);if(r)return r;if(n)for(;n=n.nextSibling;)if(n===t)return-1;return e?1:-1}function a(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function u(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function l(e){return r(function(t){return t=+t,r(function(n,r){for(var i,o=e([],n.length,t),s=o.length;s--;)n[i=o[s]]&&(n[i]=!(r[i]=n[i]))})})}function c(e){return e&&typeof e.getElementsByTagName!==V&&e}function f(){}function p(e,n){var r,i,o,s,a,u,l,c=X[e+" "];if(c)return n?0:c.slice(0);for(a=e,u=[],l=N.preFilter;a;){r&&!(i=le.exec(a))||(i&&(a=a.slice(i[0].length)||a),u.push(o=[])),r=!1,(i=ce.exec(a))&&(r=i.shift(),o.push({value:r,type:i[0].replace(ue," ")}),a=a.slice(r.length));for(s in N.filter)!(i=he[s].exec(a))||l[s]&&!(i=l[s](i))||(r=i.shift(),o.push({value:r,type:s,matches:i}),a=a.slice(r.length));if(!r)break}return n?a.length:a?t.error(e):X(e,u).slice(0)}function d(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function h(e,t,n){var r=t.dir,i=n&&"parentNode"===r,o=I++;return t.first?function(t,n,o){for(;t=t[r];)if(1===t.nodeType||i)return e(t,n,o)}:function(t,n,s){var a,u,l=[B,o];if(s){for(;t=t[r];)if((1===t.nodeType||i)&&e(t,n,s))return!0}else for(;t=t[r];)if(1===t.nodeType||i){if(u=t[W]||(t[W]={}),(a=u[r])&&a[0]===B&&a[1]===o)return l[2]=a[2];if(u[r]=l,l[2]=e(t,n,s))return!0}}}function g(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function m(e,t,n,r,i){for(var o,s=[],a=0,u=e.length,l=null!=t;a<u;a++)(o=e[a])&&(n&&!n(o,r,i)||(s.push(o),l&&t.push(a)));return s}function v(e,t,n,i,o,s){return i&&!i[W]&&(i=v(i)),o&&!o[W]&&(o=v(o,s)),r(function(r,s,a,u){var l,c,f,p=[],d=[],h=s.length,g=r||b(t||"*",a.nodeType?[a]:a,[]),v=!e||!r&&t?g:m(g,p,e,a,u),y=n?o||(r?e:h||i)?[]:s:v;if(n&&n(v,y,a,u),i)for(l=m(y,d),i(l,[],a,u),c=l.length;c--;)(f=l[c])&&(y[d[c]]=!(v[d[c]]=f));if(r){if(o||e){if(o){for(l=[],c=y.length;c--;)(f=y[c])&&l.push(v[c]=f);o(null,y=[],l,u)}for(c=y.length;c--;)(f=y[c])&&(l=o?te.call(r,f):p[c])>-1&&(r[l]=!(s[l]=f))}}else y=m(y===s?y.splice(h,y.length):y),o?o(null,s,y,u):Z.apply(s,y)})}function y(e){for(var t,n,r,i=e.length,o=N.relative[e[0].type],s=o||N.relative[" "],a=o?1:0,u=h(function(e){return e===t},s,!0),l=h(function(e){return te.call(t,e)>-1},s,!0),c=[function(e,n,r){return!o&&(r||n!==j)||((t=n).nodeType?u(e,n,r):l(e,n,r))}];a<i;a++)if(n=N.relative[e[a].type])c=[h(g(c),n)];else{if(n=N.filter[e[a].type].apply(null,e[a].matches),n[W]){for(r=++a;r<i&&!N.relative[e[r].type];r++);return v(a>1&&g(c),a>1&&d(e.slice(0,a-1).concat({value:" "===e[a-2].type?"*":""})).replace(ue,"$1"),n,a<r&&y(e.slice(a,r)),r<i&&y(e=e.slice(r)),r<i&&d(e))}c.push(n)}return g(c)}function x(e,n){var i=n.length>0,o=e.length>0,s=function(r,s,a,u,l){var c,f,p,d=0,h="0",g=r&&[],v=[],y=j,x=r||o&&N.find.TAG("*",l),b=B+=null==y?1:Math.random()||.1,w=x.length;for(l&&(j=s!==q&&s);h!==w&&null!=(c=x[h]);h++){if(o&&c){for(f=0;p=e[f++];)if(p(c,s,a)){u.push(c);break}l&&(B=b)}i&&((c=!p&&c)&&d--,r&&g.push(c))}if(d+=h,i&&h!==d){for(f=0;p=n[f++];)p(g,v,s,a);if(r){if(d>0)for(;h--;)g[h]||v[h]||(v[h]=J.call(u));v=m(v)}Z.apply(u,v),l&&!r&&v.length>0&&d+n.length>1&&t.uniqueSort(u)}return l&&(B=b,j=y),g};return i?r(s):s}function b(e,n,r){for(var i=0,o=n.length;i<o;i++)t(e,n[i],r);return r}function w(e,t,n,r){var i,o,s,a,u,l=p(e);if(!r&&1===l.length){if(o=l[0]=l[0].slice(0),o.length>2&&"ID"===(s=o[0]).type&&C.getById&&9===t.nodeType&&O&&N.relative[o[1].type]){if(t=(N.find.ID(s.matches[0].replace(we,Te),t)||[])[0],!t)return n;e=e.slice(o.shift().value.length)}for(i=he.needsContext.test(e)?0:o.length;i--&&(s=o[i],!N.relative[a=s.type]);)if((u=N.find[a])&&(r=u(s.matches[0].replace(we,Te),xe.test(o[0].type)&&c(t.parentNode)||t))){if(o.splice(i,1),e=r.length&&d(o),!e)return Z.apply(n,r),n;break}}return D(e,l)(r,t,!O,n,xe.test(e)&&c(t.parentNode)||t),n}var T,C,N,k,E,D,j,S,A,L,q,H,O,F,P,M,R,W="sizzle"+-new Date,$=e.document,B=0,I=0,_=n(),X=n(),z=n(),U=function(e,t){return e===t&&(A=!0),0},V="undefined",Y=1<<31,G={}.hasOwnProperty,Q=[],J=Q.pop,K=Q.push,Z=Q.push,ee=Q.slice,te=Q.indexOf||function(e){for(var t=0,n=this.length;t<n;t++)if(this[t]===e)return t;return-1},ne="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",re="[\\x20\\t\\r\\n\\f]",ie="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",oe=ie.replace("w","w#"),se="\\["+re+"*("+ie+")"+re+"*(?:([*^$|!~]?=)"+re+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+oe+")|)|)"+re+"*\\]",ae=":("+ie+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+se.replace(3,8)+")*)|.*)\\)|)",ue=new RegExp("^"+re+"+|((?:^|[^\\\\])(?:\\\\.)*)"+re+"+$","g"),le=new RegExp("^"+re+"*,"+re+"*"),ce=new RegExp("^"+re+"*([>+~]|"+re+")"+re+"*"),fe=new RegExp("="+re+"*([^\\]'\"]*?)"+re+"*\\]","g"),pe=new RegExp(ae),de=new RegExp("^"+oe+"$"),he={ID:new RegExp("^#("+ie+")"),CLASS:new RegExp("^\\.("+ie+")"),TAG:new RegExp("^("+ie.replace("w","w*")+")"),ATTR:new RegExp("^"+se),PSEUDO:new RegExp("^"+ae),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+re+"*(even|odd|(([+-]|)(\\d*)n|)"+re+"*(?:([+-]|)"+re+"*(\\d+)|))"+re+"*\\)|)","i"),bool:new RegExp("^(?:"+ne+")$","i"),needsContext:new RegExp("^"+re+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+re+"*((?:-\\d)?\\d*)"+re+"*\\)|)(?=[^-]|$)","i")},ge=/^(?:input|select|textarea|button)$/i,me=/^h\d$/i,ve=/^[^{]+\{\s*\[native \w/,ye=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,xe=/[+~]/,be=/'|\\/g,we=new RegExp("\\\\([\\da-f]{1,6}"+re+"?|("+re+")|.)","ig"),Te=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)};try{Z.apply(Q=ee.call($.childNodes),$.childNodes),Q[$.childNodes.length].nodeType}catch(e){Z={apply:Q.length?function(e,t){K.apply(e,ee.call(t))}:function(e,t){for(var n=e.length,r=0;e[n++]=t[r++];);e.length=n-1}}}C=t.support={},E=t.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&"HTML"!==t.nodeName},L=t.setDocument=function(e){var t,n=e?e.ownerDocument||e:$,r=n.defaultView;return n!==q&&9===n.nodeType&&n.documentElement?(q=n,H=n.documentElement,O=!E(n),r&&r!==r.top&&(r.addEventListener?r.addEventListener("unload",function(){L()},!1):r.attachEvent&&r.attachEvent("onunload",function(){L()})),C.attributes=i(function(e){return e.className="i",!e.getAttribute("className")}),C.getElementsByTagName=i(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),C.getElementsByClassName=ve.test(n.getElementsByClassName)&&i(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),C.getById=i(function(e){return H.appendChild(e).id=W,!n.getElementsByName||!n.getElementsByName(W).length}),C.getById?(N.find.ID=function(e,t){if(typeof t.getElementById!==V&&O){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},N.filter.ID=function(e){var t=e.replace(we,Te);return function(e){return e.getAttribute("id")===t}}):(delete N.find.ID,N.filter.ID=function(e){var t=e.replace(we,Te);return function(e){var n=typeof e.getAttributeNode!==V&&e.getAttributeNode("id");return n&&n.value===t}}),N.find.TAG=C.getElementsByTagName?function(e,t){if(typeof t.getElementsByTagName!==V)return t.getElementsByTagName(e)}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i++];)1===n.nodeType&&r.push(n);return r}return o},N.find.CLASS=C.getElementsByClassName&&function(e,t){if(typeof t.getElementsByClassName!==V&&O)return t.getElementsByClassName(e)},P=[],F=[],(C.qsa=ve.test(n.querySelectorAll))&&(i(function(e){e.innerHTML="<select t=''><option selected=''></option></select>",e.querySelectorAll("[t^='']").length&&F.push("[*^$]="+re+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||F.push("\\["+re+"*(?:value|"+ne+")"),e.querySelectorAll(":checked").length||F.push(":checked")}),i(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&F.push("name"+re+"*[*^$|!~]?="),e.querySelectorAll(":enabled").length||F.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),F.push(",.*:")})),(C.matchesSelector=ve.test(M=H.webkitMatchesSelector||H.mozMatchesSelector||H.oMatchesSelector||H.msMatchesSelector))&&i(function(e){C.disconnectedMatch=M.call(e,"div"),M.call(e,"[s!='']:x"),P.push("!=",ae)}),F=F.length&&new RegExp(F.join("|")),P=P.length&&new RegExp(P.join("|")),t=ve.test(H.compareDocumentPosition),R=t||ve.test(H.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},U=t?function(e,t){if(e===t)return A=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r?r:(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1,1&r||!C.sortDetached&&t.compareDocumentPosition(e)===r?e===n||e.ownerDocument===$&&R($,e)?-1:t===n||t.ownerDocument===$&&R($,t)?1:S?te.call(S,e)-te.call(S,t):0:4&r?-1:1)}:function(e,t){if(e===t)return A=!0,0;var r,i=0,o=e.parentNode,a=t.parentNode,u=[e],l=[t];if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:S?te.call(S,e)-te.call(S,t):0;if(o===a)return s(e,t);for(r=e;r=r.parentNode;)u.unshift(r);for(r=t;r=r.parentNode;)l.unshift(r);for(;u[i]===l[i];)i++;return i?s(u[i],l[i]):u[i]===$?-1:l[i]===$?1:0},n):q},t.matches=function(e,n){return t(e,null,null,n)},t.matchesSelector=function(e,n){if((e.ownerDocument||e)!==q&&L(e),n=n.replace(fe,"='$1']"),C.matchesSelector&&O&&(!P||!P.test(n))&&(!F||!F.test(n)))try{var r=M.call(e,n);if(r||C.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){}return t(n,q,null,[e]).length>0},t.contains=function(e,t){return(e.ownerDocument||e)!==q&&L(e),R(e,t)},t.attr=function(e,t){(e.ownerDocument||e)!==q&&L(e);var n=N.attrHandle[t.toLowerCase()],r=n&&G.call(N.attrHandle,t.toLowerCase())?n(e,t,!O):void 0;return void 0!==r?r:C.attributes||!O?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},t.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},t.uniqueSort=function(e){var t,n=[],r=0,i=0;if(A=!C.detectDuplicates,S=!C.sortStable&&e.slice(0),e.sort(U),A){for(;t=e[i++];)t===e[i]&&(r=n.push(i));for(;r--;)e.splice(n[r],1)}return S=null,e},k=t.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=k(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r++];)n+=k(t);return n},N=t.selectors={cacheLength:50,createPseudo:r,match:he,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(we,Te),e[3]=(e[4]||e[5]||"").replace(we,Te),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||t.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&t.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return he.CHILD.test(e[0])?null:(e[3]&&void 0!==e[4]?e[2]=e[4]:n&&pe.test(n)&&(t=p(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(we,Te).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=_[e+" "];return t||(t=new RegExp("(^|"+re+")"+e+"("+re+"|$)"))&&_(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==V&&e.getAttribute("class")||"")})},ATTR:function(e,n,r){return function(i){var o=t.attr(i,e);return null==o?"!="===n:!n||(o+="","="===n?o===r:"!="===n?o!==r:"^="===n?r&&0===o.indexOf(r):"*="===n?r&&o.indexOf(r)>-1:"$="===n?r&&o.slice(-r.length)===r:"~="===n?(" "+o+" ").indexOf(r)>-1:"|="===n&&(o===r||o.slice(0,r.length+1)===r+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),s="last"!==e.slice(-4),a="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==s?"nextSibling":"previousSibling",m=t.parentNode,v=a&&t.nodeName.toLowerCase(),y=!u&&!a;if(m){if(o){for(;g;){for(f=t;f=f[g];)if(a?f.nodeName.toLowerCase()===v:1===f.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[s?m.firstChild:m.lastChild],s&&y){for(c=m[W]||(m[W]={}),l=c[e]||[],d=l[0]===B&&l[1],p=l[0]===B&&l[2],f=d&&m.childNodes[d];f=++d&&f&&f[g]||(p=d=0)||h.pop();)if(1===f.nodeType&&++p&&f===t){c[e]=[B,d,p];break}}else if(y&&(l=(t[W]||(t[W]={}))[e])&&l[0]===B)p=l[1];else for(;(f=++d&&f&&f[g]||(p=d=0)||h.pop())&&((a?f.nodeName.toLowerCase()!==v:1!==f.nodeType)||!++p||(y&&((f[W]||(f[W]={}))[e]=[B,p]),f!==t)););return p-=i,p===r||p%r===0&&p/r>=0}}},PSEUDO:function(e,n){var i,o=N.pseudos[e]||N.setFilters[e.toLowerCase()]||t.error("unsupported pseudo: "+e);return o[W]?o(n):o.length>1?(i=[e,e,"",n],N.setFilters.hasOwnProperty(e.toLowerCase())?r(function(e,t){for(var r,i=o(e,n),s=i.length;s--;)r=te.call(e,i[s]),e[r]=!(t[r]=i[s])}):function(e){return o(e,0,i)}):o}},pseudos:{not:r(function(e){var t=[],n=[],i=D(e.replace(ue,"$1"));return i[W]?r(function(e,t,n,r){for(var o,s=i(e,null,r,[]),a=e.length;a--;)(o=s[a])&&(e[a]=!(t[a]=o))}):function(e,r,o){return t[0]=e,i(t,null,o,n),!n.pop()}}),has:r(function(e){return function(n){return t(e,n).length>0}}),contains:r(function(e){return function(t){return(t.textContent||t.innerText||k(t)).indexOf(e)>-1}}),lang:r(function(e){return de.test(e||"")||t.error("unsupported lang: "+e),e=e.replace(we,Te).toLowerCase(),function(t){var n;do if(n=O?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===H},focus:function(e){return e===q.activeElement&&(!q.hasFocus||q.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!N.pseudos.empty(e)},header:function(e){return me.test(e.nodeName)},input:function(e){return ge.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:l(function(){return[0]}),last:l(function(e,t){return[t-1]}),eq:l(function(e,t,n){return[n<0?n+t:n]}),even:l(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:l(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:l(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:l(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}},N.pseudos.nth=N.pseudos.eq;for(T in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})N.pseudos[T]=a(T);for(T in{submit:!0,reset:!0})N.pseudos[T]=u(T);return f.prototype=N.filters=N.pseudos,N.setFilters=new f,D=t.compile=function(e,t){var n,r=[],i=[],o=z[e+" "];if(!o){for(t||(t=p(e)),n=t.length;n--;)o=y(t[n]),o[W]?r.push(o):i.push(o);o=z(e,x(i,r))}return o},C.sortStable=W.split("").sort(U).join("")===W,C.detectDuplicates=!!A,L(),C.sortDetached=i(function(e){return 1&e.compareDocumentPosition(q.createElement("div"))}),i(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||o("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),C.attributes&&i(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||o("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),i(function(e){return null==e.getAttribute("disabled")})||o(ne,function(e,t,n){var r;if(!n)return e[t]===!0?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),t}(e);ee.find=ie,ee.expr=ie.selectors,ee.expr[":"]=ee.expr.pseudos,ee.unique=ie.uniqueSort,ee.text=ie.getText,ee.isXMLDoc=ie.isXML,ee.contains=ie.contains;var oe=ee.expr.match.needsContext,se=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,ae=/^.[^:#\[\.,]*$/;ee.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?ee.find.matchesSelector(r,e)?[r]:[]:ee.find.matches(e,ee.grep(t,function(e){return 1===e.nodeType}))},ee.fn.extend({find:function(e){var t,n=this.length,r=[],i=this;if("string"!=typeof e)return this.pushStack(ee(e).filter(function(){for(t=0;t<n;t++)if(ee.contains(i[t],this))return!0}));for(t=0;t<n;t++)ee.find(e,i[t],r);return r=this.pushStack(n>1?ee.unique(r):r),r.selector=this.selector?this.selector+" "+e:e,r},filter:function(e){return this.pushStack(r(this,e||[],!1));
},not:function(e){return this.pushStack(r(this,e||[],!0))},is:function(e){return!!r(this,"string"==typeof e&&oe.test(e)?ee(e):e||[],!1).length}});var ue,le=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,ce=ee.fn.init=function(e,t){var n,r;if(!e)return this;if("string"==typeof e){if(n="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:le.exec(e),!n||!n[1]&&t)return!t||t.jquery?(t||ue).find(e):this.constructor(t).find(e);if(n[1]){if(t=t instanceof ee?t[0]:t,ee.merge(this,ee.parseHTML(n[1],t&&t.nodeType?t.ownerDocument||t:K,!0)),se.test(n[1])&&ee.isPlainObject(t))for(n in t)ee.isFunction(this[n])?this[n](t[n]):this.attr(n,t[n]);return this}return r=K.getElementById(n[2]),r&&r.parentNode&&(this.length=1,this[0]=r),this.context=K,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):ee.isFunction(e)?"undefined"!=typeof ue.ready?ue.ready(e):e(ee):(void 0!==e.selector&&(this.selector=e.selector,this.context=e.context),ee.makeArray(e,this))};ce.prototype=ee.fn,ue=ee(K);var fe=/^(?:parents|prev(?:Until|All))/,pe={children:!0,contents:!0,next:!0,prev:!0};ee.extend({dir:function(e,t,n){for(var r=[],i=void 0!==n;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&ee(e).is(n))break;r.push(e)}return r},sibling:function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}}),ee.fn.extend({has:function(e){var t=ee(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(ee.contains(this,t[e]))return!0})},closest:function(e,t){for(var n,r=0,i=this.length,o=[],s=oe.test(e)||"string"!=typeof e?ee(e,t||this.context):0;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(s?s.index(n)>-1:1===n.nodeType&&ee.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?ee.unique(o):o)},index:function(e){return e?"string"==typeof e?U.call(ee(e),this[0]):U.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(ee.unique(ee.merge(this.get(),ee(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),ee.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return ee.dir(e,"parentNode")},parentsUntil:function(e,t,n){return ee.dir(e,"parentNode",n)},next:function(e){return i(e,"nextSibling")},prev:function(e){return i(e,"previousSibling")},nextAll:function(e){return ee.dir(e,"nextSibling")},prevAll:function(e){return ee.dir(e,"previousSibling")},nextUntil:function(e,t,n){return ee.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return ee.dir(e,"previousSibling",n)},siblings:function(e){return ee.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return ee.sibling(e.firstChild)},contents:function(e){return e.contentDocument||ee.merge([],e.childNodes)}},function(e,t){ee.fn[e]=function(n,r){var i=ee.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=ee.filter(r,i)),this.length>1&&(pe[e]||ee.unique(i),fe.test(e)&&i.reverse()),this.pushStack(i)}});var de=/\S+/g,he={};ee.Callbacks=function(e){e="string"==typeof e?he[e]||o(e):ee.extend({},e);var t,n,r,i,s,a,u=[],l=!e.once&&[],c=function(o){for(t=e.memory&&o,n=!0,a=i||0,i=0,s=u.length,r=!0;u&&a<s;a++)if(u[a].apply(o[0],o[1])===!1&&e.stopOnFalse){t=!1;break}r=!1,u&&(l?l.length&&c(l.shift()):t?u=[]:f.disable())},f={add:function(){if(u){var n=u.length;!function t(n){ee.each(n,function(n,r){var i=ee.type(r);"function"===i?e.unique&&f.has(r)||u.push(r):r&&r.length&&"string"!==i&&t(r)})}(arguments),r?s=u.length:t&&(i=n,c(t))}return this},remove:function(){return u&&ee.each(arguments,function(e,t){for(var n;(n=ee.inArray(t,u,n))>-1;)u.splice(n,1),r&&(n<=s&&s--,n<=a&&a--)}),this},has:function(e){return e?ee.inArray(e,u)>-1:!(!u||!u.length)},empty:function(){return u=[],s=0,this},disable:function(){return u=l=t=void 0,this},disabled:function(){return!u},lock:function(){return l=void 0,t||f.disable(),this},locked:function(){return!l},fireWith:function(e,t){return!u||n&&!l||(t=t||[],t=[e,t.slice?t.slice():t],r?l.push(t):c(t)),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!n}};return f},ee.extend({Deferred:function(e){var t=[["resolve","done",ee.Callbacks("once memory"),"resolved"],["reject","fail",ee.Callbacks("once memory"),"rejected"],["notify","progress",ee.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return ee.Deferred(function(n){ee.each(t,function(t,o){var s=ee.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&ee.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[o[0]+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?ee.extend(e,r):r}},i={};return r.pipe=r.then,ee.each(t,function(e,o){var s=o[2],a=o[3];r[o[1]]=s.add,a&&s.add(function(){n=a},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=s.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t,n,r,i=0,o=_.call(arguments),s=o.length,a=1!==s||e&&ee.isFunction(e.promise)?s:0,u=1===a?e:ee.Deferred(),l=function(e,n,r){return function(i){n[e]=this,r[e]=arguments.length>1?_.call(arguments):i,r===t?u.notifyWith(n,r):--a||u.resolveWith(n,r)}};if(s>1)for(t=new Array(s),n=new Array(s),r=new Array(s);i<s;i++)o[i]&&ee.isFunction(o[i].promise)?o[i].promise().done(l(i,r,o)).fail(u.reject).progress(l(i,n,t)):--a;return a||u.resolveWith(r,o),u.promise()}});var ge;ee.fn.ready=function(e){return ee.ready.promise().done(e),this},ee.extend({isReady:!1,readyWait:1,holdReady:function(e){e?ee.readyWait++:ee.ready(!0)},ready:function(e){(e===!0?--ee.readyWait:ee.isReady)||(ee.isReady=!0,e!==!0&&--ee.readyWait>0||(ge.resolveWith(K,[ee]),ee.fn.trigger&&ee(K).trigger("ready").off("ready")))}}),ee.ready.promise=function(t){return ge||(ge=ee.Deferred(),"complete"===K.readyState?setTimeout(ee.ready):(K.addEventListener("DOMContentLoaded",s,!1),e.addEventListener("load",s,!1))),ge.promise(t)},ee.ready.promise();var me=ee.access=function(e,t,n,r,i,o,s){var a=0,u=e.length,l=null==n;if("object"===ee.type(n)){i=!0;for(a in n)ee.access(e,t,a,n[a],!0,o,s)}else if(void 0!==r&&(i=!0,ee.isFunction(r)||(s=!0),l&&(s?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(ee(e),n)})),t))for(;a<u;a++)t(e[a],n,s?r:r.call(e[a],a,t(e[a],n)));return i?e:l?t.call(e):u?t(e[0],n):o};ee.acceptData=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType},a.uid=1,a.accepts=ee.acceptData,a.prototype={key:function(e){if(!a.accepts(e))return 0;var t={},n=e[this.expando];if(!n){n=a.uid++;try{t[this.expando]={value:n},Object.defineProperties(e,t)}catch(r){t[this.expando]=n,ee.extend(e,t)}}return this.cache[n]||(this.cache[n]={}),n},set:function(e,t,n){var r,i=this.key(e),o=this.cache[i];if("string"==typeof t)o[t]=n;else if(ee.isEmptyObject(o))ee.extend(this.cache[i],t);else for(r in t)o[r]=t[r];return o},get:function(e,t){var n=this.cache[this.key(e)];return void 0===t?n:n[t]},access:function(e,t,n){var r;return void 0===t||t&&"string"==typeof t&&void 0===n?(r=this.get(e,t),void 0!==r?r:this.get(e,ee.camelCase(t))):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r,i,o=this.key(e),s=this.cache[o];if(void 0===t)this.cache[o]={};else{ee.isArray(t)?r=t.concat(t.map(ee.camelCase)):(i=ee.camelCase(t),t in s?r=[t,i]:(r=i,r=r in s?[r]:r.match(de)||[])),n=r.length;for(;n--;)delete s[r[n]]}},hasData:function(e){return!ee.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){e[this.expando]&&delete this.cache[e[this.expando]]}};var ve=new a,ye=new a,xe=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,be=/([A-Z])/g;ee.extend({hasData:function(e){return ye.hasData(e)||ve.hasData(e)},data:function(e,t,n){return ye.access(e,t,n)},removeData:function(e,t){ye.remove(e,t)},_data:function(e,t,n){return ve.access(e,t,n)},_removeData:function(e,t){ve.remove(e,t)}}),ee.fn.extend({data:function(e,t){var n,r,i,o=this[0],s=o&&o.attributes;if(void 0===e){if(this.length&&(i=ye.get(o),1===o.nodeType&&!ve.get(o,"hasDataAttrs"))){for(n=s.length;n--;)r=s[n].name,0===r.indexOf("data-")&&(r=ee.camelCase(r.slice(5)),u(o,r,i[r]));ve.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){ye.set(this,e)}):me(this,function(t){var n,r=ee.camelCase(e);if(o&&void 0===t){if(n=ye.get(o,e),void 0!==n)return n;if(n=ye.get(o,r),void 0!==n)return n;if(n=u(o,r,void 0),void 0!==n)return n}else this.each(function(){var n=ye.get(this,r);ye.set(this,r,t),e.indexOf("-")!==-1&&void 0!==n&&ye.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){ye.remove(this,e)})}}),ee.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=ve.get(e,t),n&&(!r||ee.isArray(n)?r=ve.access(e,t,ee.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=ee.queue(e,t),r=n.length,i=n.shift(),o=ee._queueHooks(e,t),s=function(){ee.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,s,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return ve.get(e,n)||ve.access(e,n,{empty:ee.Callbacks("once memory").add(function(){ve.remove(e,[t+"queue",n])})})}}),ee.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?ee.queue(this[0],e):void 0===t?this:this.each(function(){var n=ee.queue(this,e,t);ee._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&ee.dequeue(this,e)})},dequeue:function(e){return this.each(function(){ee.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=ee.Deferred(),o=this,s=this.length,a=function(){--r||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";s--;)n=ve.get(o[s],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(a));return a(),i.promise(t)}});var we=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,Te=["Top","Right","Bottom","Left"],Ce=function(e,t){return e=t||e,"none"===ee.css(e,"display")||!ee.contains(e.ownerDocument,e)},Ne=/^(?:checkbox|radio)$/i;!function(){var e=K.createDocumentFragment(),t=e.appendChild(K.createElement("div"));t.innerHTML="<input type='radio' checked='checked' name='t'/>",J.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,t.innerHTML="<textarea>x</textarea>",J.noCloneChecked=!!t.cloneNode(!0).lastChild.defaultValue}();var ke="undefined";J.focusinBubbles="onfocusin"in e;var Ee=/^key/,De=/^(?:mouse|contextmenu)|click/,je=/^(?:focusinfocus|focusoutblur)$/,Se=/^([^.]*)(?:\.(.+)|)$/;ee.event={global:{},add:function(e,t,n,r,i){var o,s,a,u,l,c,f,p,d,h,g,m=ve.get(e);if(m)for(n.handler&&(o=n,n=o.handler,i=o.selector),n.guid||(n.guid=ee.guid++),(u=m.events)||(u=m.events={}),(s=m.handle)||(s=m.handle=function(t){return typeof ee!==ke&&ee.event.triggered!==t.type?ee.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(de)||[""],l=t.length;l--;)a=Se.exec(t[l])||[],d=g=a[1],h=(a[2]||"").split(".").sort(),d&&(f=ee.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=ee.event.special[d]||{},c=ee.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&ee.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||(p=u[d]=[],p.delegateCount=0,f.setup&&f.setup.call(e,r,h,s)!==!1||e.addEventListener&&e.addEventListener(d,s,!1)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),ee.event.global[d]=!0)},remove:function(e,t,n,r,i){var o,s,a,u,l,c,f,p,d,h,g,m=ve.hasData(e)&&ve.get(e);if(m&&(u=m.events)){for(t=(t||"").match(de)||[""],l=t.length;l--;)if(a=Se.exec(t[l])||[],d=g=a[1],h=(a[2]||"").split(".").sort(),d){for(f=ee.event.special[d]||{},d=(r?f.delegateType:f.bindType)||d,p=u[d]||[],a=a[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=o=p.length;o--;)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||a&&!a.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));s&&!p.length&&(f.teardown&&f.teardown.call(e,h,m.handle)!==!1||ee.removeEvent(e,d,m.handle),delete u[d])}else for(d in u)ee.event.remove(e,d+t[l],n,r,!0);ee.isEmptyObject(u)&&(delete m.handle,ve.remove(e,"events"))}},trigger:function(t,n,r,i){var o,s,a,u,l,c,f,p=[r||K],d=G.call(t,"type")?t.type:t,h=G.call(t,"namespace")?t.namespace.split("."):[];if(s=a=r=r||K,3!==r.nodeType&&8!==r.nodeType&&!je.test(d+ee.event.triggered)&&(d.indexOf(".")>=0&&(h=d.split("."),d=h.shift(),h.sort()),l=d.indexOf(":")<0&&"on"+d,t=t[ee.expando]?t:new ee.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=h.join("."),t.namespace_re=t.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=r),n=null==n?[t]:ee.makeArray(n,[t]),f=ee.event.special[d]||{},i||!f.trigger||f.trigger.apply(r,n)!==!1)){if(!i&&!f.noBubble&&!ee.isWindow(r)){for(u=f.delegateType||d,je.test(u+d)||(s=s.parentNode);s;s=s.parentNode)p.push(s),a=s;a===(r.ownerDocument||K)&&p.push(a.defaultView||a.parentWindow||e)}for(o=0;(s=p[o++])&&!t.isPropagationStopped();)t.type=o>1?u:f.bindType||d,c=(ve.get(s,"events")||{})[t.type]&&ve.get(s,"handle"),c&&c.apply(s,n),c=l&&s[l],c&&c.apply&&ee.acceptData(s)&&(t.result=c.apply(s,n),t.result===!1&&t.preventDefault());return t.type=d,i||t.isDefaultPrevented()||f._default&&f._default.apply(p.pop(),n)!==!1||!ee.acceptData(r)||l&&ee.isFunction(r[d])&&!ee.isWindow(r)&&(a=r[l],a&&(r[l]=null),ee.event.triggered=d,r[d](),ee.event.triggered=void 0,a&&(r[l]=a)),t.result}},dispatch:function(e){e=ee.event.fix(e);var t,n,r,i,o,s=[],a=_.call(arguments),u=(ve.get(this,"events")||{})[e.type]||[],l=ee.event.special[e.type]||{};if(a[0]=e,e.delegateTarget=this,!l.preDispatch||l.preDispatch.call(this,e)!==!1){for(s=ee.event.handlers.call(this,e,u),t=0;(i=s[t++])&&!e.isPropagationStopped();)for(e.currentTarget=i.elem,n=0;(o=i.handlers[n++])&&!e.isImmediatePropagationStopped();)e.namespace_re&&!e.namespace_re.test(o.namespace)||(e.handleObj=o,e.data=o.data,r=((ee.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,a),void 0!==r&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()));return l.postDispatch&&l.postDispatch.call(this,e),e.result}},handlers:function(e,t){var n,r,i,o,s=[],a=t.delegateCount,u=e.target;if(a&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!==this;u=u.parentNode||this)if(u.disabled!==!0||"click"!==e.type){for(r=[],n=0;n<a;n++)o=t[n],i=o.selector+" ",void 0===r[i]&&(r[i]=o.needsContext?ee(i,this).index(u)>=0:ee.find(i,this,null,[u]).length),r[i]&&r.push(o);r.length&&s.push({elem:u,handlers:r})}return a<t.length&&s.push({elem:this,handlers:t.slice(a)}),s},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,t){var n,r,i,o=t.button;return null==e.pageX&&null!=t.clientX&&(n=e.target.ownerDocument||K,r=n.documentElement,i=n.body,e.pageX=t.clientX+(r&&r.scrollLeft||i&&i.scrollLeft||0)-(r&&r.clientLeft||i&&i.clientLeft||0),e.pageY=t.clientY+(r&&r.scrollTop||i&&i.scrollTop||0)-(r&&r.clientTop||i&&i.clientTop||0)),e.which||void 0===o||(e.which=1&o?1:2&o?3:4&o?2:0),e}},fix:function(e){if(e[ee.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];for(s||(this.fixHooks[i]=s=De.test(i)?this.mouseHooks:Ee.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new ee.Event(o),t=r.length;t--;)n=r[t],e[n]=o[n];return e.target||(e.target=K),3===e.target.nodeType&&(e.target=e.target.parentNode),s.filter?s.filter(e,o):e},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==f()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===f()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&ee.nodeName(this,"input"))return this.click(),!1},_default:function(e){return ee.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=ee.extend(new ee.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?ee.event.trigger(i,null,t):ee.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},ee.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)},ee.Event=function(e,t){return this instanceof ee.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&e.getPreventDefault&&e.getPreventDefault()?l:c):this.type=e,t&&ee.extend(this,t),this.timeStamp=e&&e.timeStamp||ee.now(),void(this[ee.expando]=!0)):new ee.Event(e,t)},ee.Event.prototype={isDefaultPrevented:c,isPropagationStopped:c,isImmediatePropagationStopped:c,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=l,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=l,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=l,this.stopPropagation()}},ee.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){ee.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return i&&(i===r||ee.contains(r,i))||(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),J.focusinBubbles||ee.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){ee.event.simulate(t,e.target,ee.event.fix(e),!0)};ee.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=ve.access(r,t);i||r.addEventListener(e,n,!0),ve.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=ve.access(r,t)-1;i?ve.access(r,t,i):(r.removeEventListener(e,n,!0),ve.remove(r,t))}}}),ee.fn.extend({on:function(e,t,n,r,i){var o,s;if("object"==typeof e){"string"!=typeof t&&(n=n||t,t=void 0);for(s in e)this.on(s,t,n,e[s],i);return this}if(null==n&&null==r?(r=t,n=t=void 0):null==r&&("string"==typeof t?(r=n,n=void 0):(r=n,n=t,t=void 0)),r===!1)r=c;else if(!r)return this;return 1===i&&(o=r,r=function(e){return ee().off(e),o.apply(this,arguments)},r.guid=o.guid||(o.guid=ee.guid++)),this.each(function(){ee.event.add(this,e,r,n,t)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,ee(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return t!==!1&&"function"!=typeof t||(n=t,t=void 0),n===!1&&(n=c),this.each(function(){ee.event.remove(this,e,n,t)})},trigger:function(e,t){return this.each(function(){ee.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return ee.event.trigger(e,t,n,!0)}});var Ae=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,Le=/<([\w:]+)/,qe=/<|&#?\w+;/,He=/<(?:script|style|link)/i,Oe=/checked\s*(?:[^=]|=\s*.checked.)/i,Fe=/^$|\/(?:java|ecma)script/i,Pe=/^true\/(.*)/,Me=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,Re={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};Re.optgroup=Re.option,Re.tbody=Re.tfoot=Re.colgroup=Re.caption=Re.thead,Re.th=Re.td,ee.extend({clone:function(e,t,n){var r,i,o,s,a=e.cloneNode(!0),u=ee.contains(e.ownerDocument,e);if(!(J.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||ee.isXMLDoc(e)))for(s=v(a),o=v(e),r=0,i=o.length;r<i;r++)y(o[r],s[r]);if(t)if(n)for(o=o||v(e),s=s||v(a),r=0,i=o.length;r<i;r++)m(o[r],s[r]);else m(e,a);return s=v(a,"script"),s.length>0&&g(s,!u&&v(e,"script")),a},buildFragment:function(e,t,n,r){for(var i,o,s,a,u,l,c=t.createDocumentFragment(),f=[],p=0,d=e.length;p<d;p++)if(i=e[p],i||0===i)if("object"===ee.type(i))ee.merge(f,i.nodeType?[i]:i);else if(qe.test(i)){for(o=o||c.appendChild(t.createElement("div")),s=(Le.exec(i)||["",""])[1].toLowerCase(),a=Re[s]||Re._default,o.innerHTML=a[1]+i.replace(Ae,"<$1></$2>")+a[2],l=a[0];l--;)o=o.lastChild;ee.merge(f,o.childNodes),o=c.firstChild,o.textContent=""}else f.push(t.createTextNode(i));for(c.textContent="",p=0;i=f[p++];)if((!r||ee.inArray(i,r)===-1)&&(u=ee.contains(i.ownerDocument,i),o=v(c.appendChild(i),"script"),u&&g(o),n))for(l=0;i=o[l++];)Fe.test(i.type||"")&&n.push(i);return c},cleanData:function(e){for(var t,n,r,i,o,s,a=ee.event.special,u=0;void 0!==(n=e[u]);u++){if(ee.acceptData(n)&&(o=n[ve.expando],o&&(t=ve.cache[o]))){if(r=Object.keys(t.events||{}),r.length)for(s=0;void 0!==(i=r[s]);s++)a[i]?ee.event.remove(n,i):ee.removeEvent(n,i,t.handle);ve.cache[o]&&delete ve.cache[o]}delete ye.cache[n[ye.expando]]}}}),ee.fn.extend({text:function(e){return me(this,function(e){return void 0===e?ee.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=p(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=p(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){for(var n,r=e?ee.filter(e,this):this,i=0;null!=(n=r[i]);i++)t||1!==n.nodeType||ee.cleanData(v(n)),n.parentNode&&(t&&ee.contains(n.ownerDocument,n)&&g(v(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(ee.cleanData(v(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return ee.clone(this,e,t)})},html:function(e){return me(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!He.test(e)&&!Re[(Le.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(Ae,"<$1></$2>");try{for(;n<r;n++)t=this[n]||{},1===t.nodeType&&(ee.cleanData(v(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=arguments[0];return this.domManip(arguments,function(t){e=this.parentNode,ee.cleanData(v(this)),e&&e.replaceChild(t,this)}),e&&(e.length||e.nodeType)?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t){e=X.apply([],e);var n,r,i,o,s,a,u=0,l=this.length,c=this,f=l-1,p=e[0],g=ee.isFunction(p);if(g||l>1&&"string"==typeof p&&!J.checkClone&&Oe.test(p))return this.each(function(n){var r=c.eq(n);g&&(e[0]=p.call(this,n,r.html())),r.domManip(e,t)});if(l&&(n=ee.buildFragment(e,this[0].ownerDocument,!1,this),r=n.firstChild,1===n.childNodes.length&&(n=r),r)){for(i=ee.map(v(n,"script"),d),o=i.length;u<l;u++)s=n,u!==f&&(s=ee.clone(s,!0,!0),o&&ee.merge(i,v(s,"script"))),t.call(this[u],s,u);if(o)for(a=i[i.length-1].ownerDocument,ee.map(i,h),u=0;u<o;u++)s=i[u],Fe.test(s.type||"")&&!ve.access(s,"globalEval")&&ee.contains(a,s)&&(s.src?ee._evalUrl&&ee._evalUrl(s.src):ee.globalEval(s.textContent.replace(Me,"")))}return this}}),ee.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){ee.fn[e]=function(e){for(var n,r=[],i=ee(e),o=i.length-1,s=0;s<=o;s++)n=s===o?this:this.clone(!0),ee(i[s])[t](n),z.apply(r,n.get());return this.pushStack(r)}});var We,$e={},Be=/^margin/,Ie=new RegExp("^("+we+")(?!px)[a-z%]+$","i"),_e=function(e){return e.ownerDocument.defaultView.getComputedStyle(e,null)};!function(){function t(){a.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",o.appendChild(s);var t=e.getComputedStyle(a,null);n="1%"!==t.top,r="4px"===t.width,o.removeChild(s)}var n,r,i="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",o=K.documentElement,s=K.createElement("div"),a=K.createElement("div");a.style.backgroundClip="content-box",a.cloneNode(!0).style.backgroundClip="",J.clearCloneStyle="content-box"===a.style.backgroundClip,s.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",s.appendChild(a),e.getComputedStyle&&ee.extend(J,{pixelPosition:function(){return t(),n},boxSizingReliable:function(){return null==r&&t(),r},reliableMarginRight:function(){var t,n=a.appendChild(K.createElement("div"));return n.style.cssText=a.style.cssText=i,n.style.marginRight=n.style.width="0",a.style.width="1px",o.appendChild(s),t=!parseFloat(e.getComputedStyle(n,null).marginRight),o.removeChild(s),a.innerHTML="",t}})}(),ee.swap=function(e,t,n,r){var i,o,s={};for(o in t)s[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=s[o];return i};var Xe=/^(none|table(?!-c[ea]).+)/,ze=new RegExp("^("+we+")(.*)$","i"),Ue=new RegExp("^([+-])=("+we+")","i"),Ve={position:"absolute",visibility:"hidden",display:"block"},Ye={letterSpacing:0,fontWeight:400},Ge=["Webkit","O","Moz","ms"];ee.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=w(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{float:"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,s,a=ee.camelCase(t),u=e.style;return t=ee.cssProps[a]||(ee.cssProps[a]=C(u,a)),s=ee.cssHooks[t]||ee.cssHooks[a],void 0===n?s&&"get"in s&&void 0!==(i=s.get(e,!1,r))?i:u[t]:(o=typeof n,"string"===o&&(i=Ue.exec(n))&&(n=(i[1]+1)*i[2]+parseFloat(ee.css(e,t)),o="number"),null!=n&&n===n&&("number"!==o||ee.cssNumber[a]||(n+="px"),J.clearCloneStyle||""!==n||0!==t.indexOf("background")||(u[t]="inherit"),s&&"set"in s&&void 0===(n=s.set(e,n,r))||(u[t]="",u[t]=n)),void 0)}},css:function(e,t,n,r){var i,o,s,a=ee.camelCase(t);return t=ee.cssProps[a]||(ee.cssProps[a]=C(e.style,a)),s=ee.cssHooks[t]||ee.cssHooks[a],s&&"get"in s&&(i=s.get(e,!0,n)),void 0===i&&(i=w(e,t,r)),"normal"===i&&t in Ye&&(i=Ye[t]),""===n||n?(o=parseFloat(i),n===!0||ee.isNumeric(o)?o||0:i):i}}),ee.each(["height","width"],function(e,t){ee.cssHooks[t]={get:function(e,n,r){if(n)return 0===e.offsetWidth&&Xe.test(ee.css(e,"display"))?ee.swap(e,Ve,function(){return E(e,t,r)}):E(e,t,r)},set:function(e,n,r){var i=r&&_e(e);return N(e,n,r?k(e,t,r,"border-box"===ee.css(e,"boxSizing",!1,i),i):0)}}}),ee.cssHooks.marginRight=T(J.reliableMarginRight,function(e,t){if(t)return ee.swap(e,{display:"inline-block"},w,[e,"marginRight"])}),ee.each({margin:"",padding:"",border:"Width"},function(e,t){ee.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];r<4;r++)i[e+Te[r]+t]=o[r]||o[r-2]||o[0];return i}},Be.test(e)||(ee.cssHooks[e+t].set=N)}),ee.fn.extend({css:function(e,t){return me(this,function(e,t,n){var r,i,o={},s=0;if(ee.isArray(t)){for(r=_e(e),i=t.length;s<i;s++)o[t[s]]=ee.css(e,t[s],!1,r);return o}return void 0!==n?ee.style(e,t,n):ee.css(e,t)},e,t,arguments.length>1)},show:function(){return D(this,!0)},hide:function(){return D(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){Ce(this)?ee(this).show():ee(this).hide()})}}),ee.Tween=j,j.prototype={constructor:j,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(ee.cssNumber[n]?"":"px")},cur:function(){var e=j.propHooks[this.prop];return e&&e.get?e.get(this):j.propHooks._default.get(this)},run:function(e){var t,n=j.propHooks[this.prop];return this.options.duration?this.pos=t=ee.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):j.propHooks._default.set(this),this}},j.prototype.init.prototype=j.prototype,j.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=ee.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){ee.fx.step[e.prop]?ee.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[ee.cssProps[e.prop]]||ee.cssHooks[e.prop])?ee.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},j.propHooks.scrollTop=j.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},ee.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},ee.fx=j.prototype.init,ee.fx.step={};var Qe,Je,Ke=/^(?:toggle|show|hide)$/,Ze=new RegExp("^(?:([+-])=|)("+we+")([a-z%]*)$","i"),et=/queueHooks$/,tt=[q],nt={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Ze.exec(t),o=i&&i[3]||(ee.cssNumber[e]?"":"px"),s=(ee.cssNumber[e]||"px"!==o&&+r)&&Ze.exec(ee.css(n.elem,e)),a=1,u=20;if(s&&s[3]!==o){o=o||s[3],i=i||[],s=+r||1;do a=a||".5",s/=a,ee.style(n.elem,e,s+o);while(a!==(a=n.cur()/r)&&1!==a&&--u)}return i&&(s=n.start=+s||+r||0,n.unit=o,n.end=i[1]?s+(i[1]+1)*i[2]:+i[2]),n}]};ee.Animation=ee.extend(O,{tweener:function(e,t){ee.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");for(var n,r=0,i=e.length;r<i;r++)n=e[r],nt[n]=nt[n]||[],nt[n].unshift(t)},prefilter:function(e,t){t?tt.unshift(e):tt.push(e)}}),ee.speed=function(e,t,n){var r=e&&"object"==typeof e?ee.extend({},e):{complete:n||!n&&t||ee.isFunction(e)&&e,duration:e,easing:n&&t||t&&!ee.isFunction(t)&&t};return r.duration=ee.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in ee.fx.speeds?ee.fx.speeds[r.duration]:ee.fx.speeds._default,null!=r.queue&&r.queue!==!0||(r.queue="fx"),r.old=r.complete,r.complete=function(){ee.isFunction(r.old)&&r.old.call(this),r.queue&&ee.dequeue(this,r.queue)},r},ee.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Ce).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=ee.isEmptyObject(e),o=ee.speed(t,n,r),s=function(){var t=O(this,ee.extend({},e),o);(i||ve.get(this,"finish"))&&t.stop(!0)};return s.finish=s,i||o.queue===!1?this.each(s):this.queue(o.queue,s)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=ee.timers,s=ve.get(this);if(i)s[i]&&s[i].stop&&r(s[i]);else for(i in s)s[i]&&s[i].stop&&et.test(i)&&r(s[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));!t&&n||ee.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=ve.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=ee.timers,s=r?r.length:0;for(n.finish=!0,ee.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;t<s;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),ee.each(["toggle","show","hide"],function(e,t){var n=ee.fn[t];ee.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(A(t,!0),e,r,i)}}),ee.each({
slideDown:A("show"),slideUp:A("hide"),slideToggle:A("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){ee.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),ee.timers=[],ee.fx.tick=function(){var e,t=0,n=ee.timers;for(Qe=ee.now();t<n.length;t++)e=n[t],e()||n[t]!==e||n.splice(t--,1);n.length||ee.fx.stop(),Qe=void 0},ee.fx.timer=function(e){ee.timers.push(e),e()?ee.fx.start():ee.timers.pop()},ee.fx.interval=13,ee.fx.start=function(){Je||(Je=setInterval(ee.fx.tick,ee.fx.interval))},ee.fx.stop=function(){clearInterval(Je),Je=null},ee.fx.speeds={slow:600,fast:200,_default:400},ee.fn.delay=function(e,t){return e=ee.fx?ee.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},function(){var e=K.createElement("input"),t=K.createElement("select"),n=t.appendChild(K.createElement("option"));e.type="checkbox",J.checkOn=""!==e.value,J.optSelected=n.selected,t.disabled=!0,J.optDisabled=!n.disabled,e=K.createElement("input"),e.value="t",e.type="radio",J.radioValue="t"===e.value}();var rt,it,ot=ee.expr.attrHandle;ee.fn.extend({attr:function(e,t){return me(this,ee.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){ee.removeAttr(this,e)})}}),ee.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(e&&3!==o&&8!==o&&2!==o)return typeof e.getAttribute===ke?ee.prop(e,t,n):(1===o&&ee.isXMLDoc(e)||(t=t.toLowerCase(),r=ee.attrHooks[t]||(ee.expr.match.bool.test(t)?it:rt)),void 0===n?r&&"get"in r&&null!==(i=r.get(e,t))?i:(i=ee.find.attr(e,t),null==i?void 0:i):null!==n?r&&"set"in r&&void 0!==(i=r.set(e,n,t))?i:(e.setAttribute(t,n+""),n):void ee.removeAttr(e,t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(de);if(o&&1===e.nodeType)for(;n=o[i++];)r=ee.propFix[n]||n,ee.expr.match.bool.test(n)&&(e[r]=!1),e.removeAttribute(n)},attrHooks:{type:{set:function(e,t){if(!J.radioValue&&"radio"===t&&ee.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}}}),it={set:function(e,t,n){return t===!1?ee.removeAttr(e,n):e.setAttribute(n,n),n}},ee.each(ee.expr.match.bool.source.match(/\w+/g),function(e,t){var n=ot[t]||ee.find.attr;ot[t]=function(e,t,r){var i,o;return r||(o=ot[t],ot[t]=i,i=null!=n(e,t,r)?t.toLowerCase():null,ot[t]=o),i}});var st=/^(?:input|select|textarea|button)$/i;ee.fn.extend({prop:function(e,t){return me(this,ee.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[ee.propFix[e]||e]})}}),ee.extend({propFix:{for:"htmlFor",class:"className"},prop:function(e,t,n){var r,i,o,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return o=1!==s||!ee.isXMLDoc(e),o&&(t=ee.propFix[t]||t,i=ee.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||st.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),J.optSelected||(ee.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null}}),ee.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){ee.propFix[this.toLowerCase()]=this});var at=/[\t\r\n\f]/g;ee.fn.extend({addClass:function(e){var t,n,r,i,o,s,a="string"==typeof e&&e,u=0,l=this.length;if(ee.isFunction(e))return this.each(function(t){ee(this).addClass(e.call(this,t,this.className))});if(a)for(t=(e||"").match(de)||[];u<l;u++)if(n=this[u],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(at," "):" ")){for(o=0;i=t[o++];)r.indexOf(" "+i+" ")<0&&(r+=i+" ");s=ee.trim(r),n.className!==s&&(n.className=s)}return this},removeClass:function(e){var t,n,r,i,o,s,a=0===arguments.length||"string"==typeof e&&e,u=0,l=this.length;if(ee.isFunction(e))return this.each(function(t){ee(this).removeClass(e.call(this,t,this.className))});if(a)for(t=(e||"").match(de)||[];u<l;u++)if(n=this[u],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(at," "):"")){for(o=0;i=t[o++];)for(;r.indexOf(" "+i+" ")>=0;)r=r.replace(" "+i+" "," ");s=e?ee.trim(r):"",n.className!==s&&(n.className=s)}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):ee.isFunction(e)?this.each(function(n){ee(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n)for(var t,r=0,i=ee(this),o=e.match(de)||[];t=o[r++];)i.hasClass(t)?i.removeClass(t):i.addClass(t);else n!==ke&&"boolean"!==n||(this.className&&ve.set(this,"__className__",this.className),this.className=this.className||e===!1?"":ve.get(this,"__className__")||"")})},hasClass:function(e){for(var t=" "+e+" ",n=0,r=this.length;n<r;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(at," ").indexOf(t)>=0)return!0;return!1}});var ut=/\r/g;ee.fn.extend({val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=ee.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,ee(this).val()):e,null==i?i="":"number"==typeof i?i+="":ee.isArray(i)&&(i=ee.map(i,function(e){return null==e?"":e+""})),t=ee.valHooks[this.type]||ee.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))});if(i)return t=ee.valHooks[i.type]||ee.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:(n=i.value,"string"==typeof n?n.replace(ut,""):null==n?"":n)}}}),ee.extend({valHooks:{select:{get:function(e){for(var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||i<0,s=o?null:[],a=o?i+1:r.length,u=i<0?a:o?i:0;u<a;u++)if(n=r[u],(n.selected||u===i)&&(J.optDisabled?!n.disabled:null===n.getAttribute("disabled"))&&(!n.parentNode.disabled||!ee.nodeName(n.parentNode,"optgroup"))){if(t=ee(n).val(),o)return t;s.push(t)}return s},set:function(e,t){for(var n,r,i=e.options,o=ee.makeArray(t),s=i.length;s--;)r=i[s],(r.selected=ee.inArray(ee(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),ee.each(["radio","checkbox"],function(){ee.valHooks[this]={set:function(e,t){if(ee.isArray(t))return e.checked=ee.inArray(ee(e).val(),t)>=0}},J.checkOn||(ee.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),ee.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){ee.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),ee.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var lt=ee.now(),ct=/\?/;ee.parseJSON=function(e){return JSON.parse(e+"")},ee.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{n=new DOMParser,t=n.parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||ee.error("Invalid XML: "+e),t};var ft,pt,dt=/#.*$/,ht=/([?&])_=[^&]*/,gt=/^(.*?):[ \t]*([^\r\n]*)$/gm,mt=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,vt=/^(?:GET|HEAD)$/,yt=/^\/\//,xt=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,bt={},wt={},Tt="*/".concat("*");try{pt=location.href}catch(e){pt=K.createElement("a"),pt.href="",pt=pt.href}ft=xt.exec(pt.toLowerCase())||[],ee.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:pt,type:"GET",isLocal:mt.test(ft[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Tt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":ee.parseJSON,"text xml":ee.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?M(M(e,ee.ajaxSettings),t):M(ee.ajaxSettings,e)},ajaxPrefilter:F(bt),ajaxTransport:F(wt),ajax:function(e,t){function n(e,t,n,s){var u,c,v,y,b,T=t;2!==x&&(x=2,a&&clearTimeout(a),r=void 0,o=s||"",w.readyState=e>0?4:0,u=e>=200&&e<300||304===e,n&&(y=R(f,w,n)),y=W(f,y,w,u),u?(f.ifModified&&(b=w.getResponseHeader("Last-Modified"),b&&(ee.lastModified[i]=b),b=w.getResponseHeader("etag"),b&&(ee.etag[i]=b)),204===e||"HEAD"===f.type?T="nocontent":304===e?T="notmodified":(T=y.state,c=y.data,v=y.error,u=!v)):(v=T,!e&&T||(T="error",e<0&&(e=0))),w.status=e,w.statusText=(t||T)+"",u?h.resolveWith(p,[c,T,w]):h.rejectWith(p,[w,T,v]),w.statusCode(m),m=void 0,l&&d.trigger(u?"ajaxSuccess":"ajaxError",[w,f,u?c:v]),g.fireWith(p,[w,T]),l&&(d.trigger("ajaxComplete",[w,f]),--ee.active||ee.event.trigger("ajaxStop")))}"object"==typeof e&&(t=e,e=void 0),t=t||{};var r,i,o,s,a,u,l,c,f=ee.ajaxSetup({},t),p=f.context||f,d=f.context&&(p.nodeType||p.jquery)?ee(p):ee.event,h=ee.Deferred(),g=ee.Callbacks("once memory"),m=f.statusCode||{},v={},y={},x=0,b="canceled",w={readyState:0,getResponseHeader:function(e){var t;if(2===x){if(!s)for(s={};t=gt.exec(o);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===x?o:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return x||(e=y[n]=y[n]||e,v[e]=t),this},overrideMimeType:function(e){return x||(f.mimeType=e),this},statusCode:function(e){var t;if(e)if(x<2)for(t in e)m[t]=[m[t],e[t]];else w.always(e[w.status]);return this},abort:function(e){var t=e||b;return r&&r.abort(t),n(0,t),this}};if(h.promise(w).complete=g.add,w.success=w.done,w.error=w.fail,f.url=((e||f.url||pt)+"").replace(dt,"").replace(yt,ft[1]+"//"),f.type=t.method||t.type||f.method||f.type,f.dataTypes=ee.trim(f.dataType||"*").toLowerCase().match(de)||[""],null==f.crossDomain&&(u=xt.exec(f.url.toLowerCase()),f.crossDomain=!(!u||u[1]===ft[1]&&u[2]===ft[2]&&(u[3]||("http:"===u[1]?"80":"443"))===(ft[3]||("http:"===ft[1]?"80":"443")))),f.data&&f.processData&&"string"!=typeof f.data&&(f.data=ee.param(f.data,f.traditional)),P(bt,f,t,w),2===x)return w;l=f.global,l&&0===ee.active++&&ee.event.trigger("ajaxStart"),f.type=f.type.toUpperCase(),f.hasContent=!vt.test(f.type),i=f.url,f.hasContent||(f.data&&(i=f.url+=(ct.test(i)?"&":"?")+f.data,delete f.data),f.cache===!1&&(f.url=ht.test(i)?i.replace(ht,"$1_="+lt++):i+(ct.test(i)?"&":"?")+"_="+lt++)),f.ifModified&&(ee.lastModified[i]&&w.setRequestHeader("If-Modified-Since",ee.lastModified[i]),ee.etag[i]&&w.setRequestHeader("If-None-Match",ee.etag[i])),(f.data&&f.hasContent&&f.contentType!==!1||t.contentType)&&w.setRequestHeader("Content-Type",f.contentType),w.setRequestHeader("Accept",f.dataTypes[0]&&f.accepts[f.dataTypes[0]]?f.accepts[f.dataTypes[0]]+("*"!==f.dataTypes[0]?", "+Tt+"; q=0.01":""):f.accepts["*"]);for(c in f.headers)w.setRequestHeader(c,f.headers[c]);if(f.beforeSend&&(f.beforeSend.call(p,w,f)===!1||2===x))return w.abort();b="abort";for(c in{success:1,error:1,complete:1})w[c](f[c]);if(r=P(wt,f,t,w)){w.readyState=1,l&&d.trigger("ajaxSend",[w,f]),f.async&&f.timeout>0&&(a=setTimeout(function(){w.abort("timeout")},f.timeout));try{x=1,r.send(v,n)}catch(e){if(!(x<2))throw e;n(-1,e)}}else n(-1,"No Transport");return w},getJSON:function(e,t,n){return ee.get(e,t,n,"json")},getScript:function(e,t){return ee.get(e,void 0,t,"script")}}),ee.each(["get","post"],function(e,t){ee[t]=function(e,n,r,i){return ee.isFunction(n)&&(i=i||r,r=n,n=void 0),ee.ajax({url:e,type:t,dataType:i,data:n,success:r})}}),ee.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){ee.fn[t]=function(e){return this.on(t,e)}}),ee._evalUrl=function(e){return ee.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,throws:!0})},ee.fn.extend({wrapAll:function(e){var t;return ee.isFunction(e)?this.each(function(t){ee(this).wrapAll(e.call(this,t))}):(this[0]&&(t=ee(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return ee.isFunction(e)?this.each(function(t){ee(this).wrapInner(e.call(this,t))}):this.each(function(){var t=ee(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=ee.isFunction(e);return this.each(function(n){ee(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){ee.nodeName(this,"body")||ee(this).replaceWith(this.childNodes)}).end()}}),ee.expr.filters.hidden=function(e){return e.offsetWidth<=0&&e.offsetHeight<=0},ee.expr.filters.visible=function(e){return!ee.expr.filters.hidden(e)};var Ct=/%20/g,Nt=/\[\]$/,kt=/\r?\n/g,Et=/^(?:submit|button|image|reset|file)$/i,Dt=/^(?:input|select|textarea|keygen)/i;ee.param=function(e,t){var n,r=[],i=function(e,t){t=ee.isFunction(t)?t():null==t?"":t,r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(void 0===t&&(t=ee.ajaxSettings&&ee.ajaxSettings.traditional),ee.isArray(e)||e.jquery&&!ee.isPlainObject(e))ee.each(e,function(){i(this.name,this.value)});else for(n in e)$(n,e[n],t,i);return r.join("&").replace(Ct,"+")},ee.fn.extend({serialize:function(){return ee.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=ee.prop(this,"elements");return e?ee.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!ee(this).is(":disabled")&&Dt.test(this.nodeName)&&!Et.test(e)&&(this.checked||!Ne.test(e))}).map(function(e,t){var n=ee(this).val();return null==n?null:ee.isArray(n)?ee.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}}),ee.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var jt=0,St={},At={0:200,1223:204},Lt=ee.ajaxSettings.xhr();e.ActiveXObject&&ee(e).on("unload",function(){for(var e in St)St[e]()}),J.cors=!!Lt&&"withCredentials"in Lt,J.ajax=Lt=!!Lt,ee.ajaxTransport(function(e){var t;if(J.cors||Lt&&!e.crossDomain)return{send:function(n,r){var i,o=e.xhr(),s=++jt;if(o.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(i in e.xhrFields)o[i]=e.xhrFields[i];e.mimeType&&o.overrideMimeType&&o.overrideMimeType(e.mimeType),e.crossDomain||n["X-Requested-With"]||(n["X-Requested-With"]="XMLHttpRequest");for(i in n)o.setRequestHeader(i,n[i]);t=function(e){return function(){t&&(delete St[s],t=o.onload=o.onerror=null,"abort"===e?o.abort():"error"===e?r(o.status,o.statusText):r(At[o.status]||o.status,o.statusText,"string"==typeof o.responseText?{text:o.responseText}:void 0,o.getAllResponseHeaders()))}},o.onload=t(),o.onerror=t("error"),t=St[s]=t("abort"),o.send(e.hasContent&&e.data||null)},abort:function(){t&&t()}}}),ee.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return ee.globalEval(e),e}}}),ee.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),ee.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=ee("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),K.head.appendChild(t[0])},abort:function(){n&&n()}}}});var qt=[],Ht=/(=)\?(?=&|$)|\?\?/;ee.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=qt.pop()||ee.expando+"_"+lt++;return this[e]=!0,e}}),ee.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,s,a=t.jsonp!==!1&&(Ht.test(t.url)?"url":"string"==typeof t.data&&!(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ht.test(t.data)&&"data");if(a||"jsonp"===t.dataTypes[0])return i=t.jsonpCallback=ee.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,a?t[a]=t[a].replace(Ht,"$1"+i):t.jsonp!==!1&&(t.url+=(ct.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return s||ee.error(i+" was not called"),s[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){s=arguments},r.always(function(){e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,qt.push(i)),s&&ee.isFunction(o)&&o(s[0]),s=o=void 0}),"script"}),ee.parseHTML=function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||K;var r=se.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=ee.buildFragment([e],t,i),i&&i.length&&ee(i).remove(),ee.merge([],r.childNodes))};var Ot=ee.fn.load;ee.fn.load=function(e,t,n){if("string"!=typeof e&&Ot)return Ot.apply(this,arguments);var r,i,o,s=this,a=e.indexOf(" ");return a>=0&&(r=e.slice(a),e=e.slice(0,a)),ee.isFunction(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),s.length>0&&ee.ajax({url:e,type:i,dataType:"html",data:t}).done(function(e){o=arguments,s.html(r?ee("<div>").append(ee.parseHTML(e)).find(r):e)}).complete(n&&function(e,t){s.each(n,o||[e.responseText,t,e])}),this},ee.expr.filters.animated=function(e){return ee.grep(ee.timers,function(t){return e===t.elem}).length};var Ft=e.document.documentElement;ee.offset={setOffset:function(e,t,n){var r,i,o,s,a,u,l,c=ee.css(e,"position"),f=ee(e),p={};"static"===c&&(e.style.position="relative"),a=f.offset(),o=ee.css(e,"top"),u=ee.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=f.position(),s=r.top,i=r.left):(s=parseFloat(o)||0,i=parseFloat(u)||0),ee.isFunction(t)&&(t=t.call(e,n,a)),null!=t.top&&(p.top=t.top-a.top+s),null!=t.left&&(p.left=t.left-a.left+i),"using"in t?t.using.call(e,p):f.css(p)}},ee.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){ee.offset.setOffset(this,e,t)});var t,n,r=this[0],i={top:0,left:0},o=r&&r.ownerDocument;if(o)return t=o.documentElement,ee.contains(t,r)?(typeof r.getBoundingClientRect!==ke&&(i=r.getBoundingClientRect()),n=B(o),{top:i.top+n.pageYOffset-t.clientTop,left:i.left+n.pageXOffset-t.clientLeft}):i},position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===ee.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),ee.nodeName(e[0],"html")||(r=e.offset()),r.top+=ee.css(e[0],"borderTopWidth",!0),r.left+=ee.css(e[0],"borderLeftWidth",!0)),{top:t.top-r.top-ee.css(n,"marginTop",!0),left:t.left-r.left-ee.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent||Ft;e&&!ee.nodeName(e,"html")&&"static"===ee.css(e,"position");)e=e.offsetParent;return e||Ft})}}),ee.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,n){var r="pageYOffset"===n;ee.fn[t]=function(i){return me(this,function(t,i,o){var s=B(t);return void 0===o?s?s[n]:t[i]:void(s?s.scrollTo(r?e.pageXOffset:o,r?o:e.pageYOffset):t[i]=o)},t,i,arguments.length,null)}}),ee.each(["top","left"],function(e,t){ee.cssHooks[t]=T(J.pixelPosition,function(e,n){if(n)return n=w(e,t),Ie.test(n)?ee(e).position()[t]+"px":n})}),ee.each({Height:"height",Width:"width"},function(e,t){ee.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){ee.fn[r]=function(r,i){var o=arguments.length&&(n||"boolean"!=typeof r),s=n||(r===!0||i===!0?"margin":"border");return me(this,function(t,n,r){var i;return ee.isWindow(t)?t.document.documentElement["client"+e]:9===t.nodeType?(i=t.documentElement,Math.max(t.body["scroll"+e],i["scroll"+e],t.body["offset"+e],i["offset"+e],i["client"+e])):void 0===r?ee.css(t,n,s):ee.style(t,n,r,s)},t,o?r:void 0,o,null)}})}),ee.fn.size=function(){return this.length},ee.fn.andSelf=ee.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return ee});var Pt=e.jQuery,Mt=e.$;return ee.noConflict=function(t){return e.$===ee&&(e.$=Mt),t&&e.jQuery===ee&&(e.jQuery=Pt),ee},typeof t===ke&&(e.jQuery=e.$=ee),ee});
</script>

<script type="text/javascript">
(function(){function n(n,t){return n.set(t[0],t[1]),n}function t(n,t){return n.add(t),n}function r(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function e(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&t(n[r],r,n)!==!1;);return n}function i(n,t){for(var r=null==n?0:n.length;r--&&t(n[r],r,n)!==!1;);return n}function o(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return!1;return!0}function f(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function a(n,t){var r=null==n?0:n.length;return!!r&&b(n,t,0)>-1}function c(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return!0;return!1}function l(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function s(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function h(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function p(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function v(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return!0;return!1}function _(n){return n.split("")}function g(n){return n.match(Dt)||[]}function y(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,!1}),e}function d(n,t,r,e){for(var u=n.length,i=r+(e?1:-1);e?i--:++i<u;)if(t(n[i],i,n))return i;return-1}function b(n,t,r){return t===t?K(n,t,r):d(n,m,r)}function w(n,t,r,e){for(var u=r-1,i=n.length;++u<i;)if(e(n[u],t))return u;return-1}function m(n){return n!==n}function x(n,t){var r=null==n?0:n.length;return r?I(n,t)/r:Ln}function j(n){return function(t){return null==t?X:t[n]}}function A(n){return function(t){return null==n?X:n[t]}}function k(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=!1,n):t(r,n,u,i)}),r}function O(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].value;return n}function I(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==X&&(r=r===X?i:r+i)}return r}function R(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function z(n,t){return l(t,function(t){return[t,n[t]]})}function E(n){return function(t){return n(t)}}function S(n,t){return l(t,function(t){return n[t]})}function W(n,t){return n.has(t)}function L(n,t){for(var r=-1,e=n.length;++r<e&&b(t,n[r],0)>-1;);return r}function C(n,t){for(var r=n.length;r--&&b(t,n[r],0)>-1;);return r}function U(n,t){for(var r=n.length,e=0;r--;)n[r]===t&&++e;return e}function B(n){return"\\"+Yr[n]}function T(n,t){return null==n?X:n[t]}function $(n){return Nr.test(n)}function D(n){return Pr.test(n)}function M(n){for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}function F(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function N(n,t){return function(r){return n(t(r))}}function P(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&o!==fn||(n[r]=fn,i[u++]=r)}return i}function q(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function Z(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function K(n,t,r){for(var e=r-1,u=n.length;++e<u;)if(n[e]===t)return e;return-1}function V(n,t,r){for(var e=r+1;e--;)if(n[e]===t)return e;return e}function G(n){return $(n)?J(n):ve(n)}function H(n){return $(n)?Y(n):_(n)}function J(n){for(var t=Mr.lastIndex=0;Mr.test(n);)++t;return t}function Y(n){return n.match(Mr)||[]}function Q(n){return n.match(Fr)||[]}var X,nn="4.17.4",tn=200,rn="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",en="Expected a function",un="__lodash_hash_undefined__",on=500,fn="__lodash_placeholder__",an=1,cn=2,ln=4,sn=1,hn=2,pn=1,vn=2,_n=4,gn=8,yn=16,dn=32,bn=64,wn=128,mn=256,xn=512,jn=30,An="...",kn=800,On=16,In=1,Rn=2,zn=3,En=1/0,Sn=9007199254740991,Wn=1.7976931348623157e308,Ln=NaN,Cn=4294967295,Un=Cn-1,Bn=Cn>>>1,Tn=[["ary",wn],["bind",pn],["bindKey",vn],["curry",gn],["curryRight",yn],["flip",xn],["partial",dn],["partialRight",bn],["rearg",mn]],$n="[object Arguments]",Dn="[object Array]",Mn="[object AsyncFunction]",Fn="[object Boolean]",Nn="[object Date]",Pn="[object DOMException]",qn="[object Error]",Zn="[object Function]",Kn="[object GeneratorFunction]",Vn="[object Map]",Gn="[object Number]",Hn="[object Null]",Jn="[object Object]",Yn="[object Promise]",Qn="[object Proxy]",Xn="[object RegExp]",nt="[object Set]",tt="[object String]",rt="[object Symbol]",et="[object Undefined]",ut="[object WeakMap]",it="[object WeakSet]",ot="[object ArrayBuffer]",ft="[object DataView]",at="[object Float32Array]",ct="[object Float64Array]",lt="[object Int8Array]",st="[object Int16Array]",ht="[object Int32Array]",pt="[object Uint8Array]",vt="[object Uint8ClampedArray]",_t="[object Uint16Array]",gt="[object Uint32Array]",yt=/\b__p \+= '';/g,dt=/\b(__p \+=) '' \+/g,bt=/(__e\(.*?\)|\b__t\)) \+\n'';/g,wt=/&(?:amp|lt|gt|quot|#39);/g,mt=/[&<>"']/g,xt=RegExp(wt.source),jt=RegExp(mt.source),At=/<%-([\s\S]+?)%>/g,kt=/<%([\s\S]+?)%>/g,Ot=/<%=([\s\S]+?)%>/g,It=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Rt=/^\w*$/,zt=/^\./,Et=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,St=/[\\^$.*+?()[\]{}|]/g,Wt=RegExp(St.source),Lt=/^\s+|\s+$/g,Ct=/^\s+/,Ut=/\s+$/,Bt=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Tt=/\{\n\/\* \[wrapped with (.+)\] \*/,$t=/,? & /,Dt=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,Mt=/\\(\\)?/g,Ft=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Nt=/\w*$/,Pt=/^[-+]0x[0-9a-f]+$/i,qt=/^0b[01]+$/i,Zt=/^\[object .+?Constructor\]$/,Kt=/^0o[0-7]+$/i,Vt=/^(?:0|[1-9]\d*)$/,Gt=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Ht=/($^)/,Jt=/['\n\r\u2028\u2029\\]/g,Yt="\\ud800-\\udfff",Qt="\\u0300-\\u036f",Xt="\\ufe20-\\ufe2f",nr="\\u20d0-\\u20ff",tr=Qt+Xt+nr,rr="\\u2700-\\u27bf",er="a-z\\xdf-\\xf6\\xf8-\\xff",ur="\\xac\\xb1\\xd7\\xf7",ir="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",or="\\u2000-\\u206f",fr=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",ar="A-Z\\xc0-\\xd6\\xd8-\\xde",cr="\\ufe0e\\ufe0f",lr=ur+ir+or+fr,sr="['’]",hr="["+Yt+"]",pr="["+lr+"]",vr="["+tr+"]",_r="\\d+",gr="["+rr+"]",yr="["+er+"]",dr="[^"+Yt+lr+_r+rr+er+ar+"]",br="\\ud83c[\\udffb-\\udfff]",wr="(?:"+vr+"|"+br+")",mr="[^"+Yt+"]",xr="(?:\\ud83c[\\udde6-\\uddff]){2}",jr="[\\ud800-\\udbff][\\udc00-\\udfff]",Ar="["+ar+"]",kr="\\u200d",Or="(?:"+yr+"|"+dr+")",Ir="(?:"+Ar+"|"+dr+")",Rr="(?:"+sr+"(?:d|ll|m|re|s|t|ve))?",zr="(?:"+sr+"(?:D|LL|M|RE|S|T|VE))?",Er=wr+"?",Sr="["+cr+"]?",Wr="(?:"+kr+"(?:"+[mr,xr,jr].join("|")+")"+Sr+Er+")*",Lr="\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)",Cr="\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)",Ur=Sr+Er+Wr,Br="(?:"+[gr,xr,jr].join("|")+")"+Ur,Tr="(?:"+[mr+vr+"?",vr,xr,jr,hr].join("|")+")",$r=RegExp(sr,"g"),Dr=RegExp(vr,"g"),Mr=RegExp(br+"(?="+br+")|"+Tr+Ur,"g"),Fr=RegExp([Ar+"?"+yr+"+"+Rr+"(?="+[pr,Ar,"$"].join("|")+")",Ir+"+"+zr+"(?="+[pr,Ar+Or,"$"].join("|")+")",Ar+"?"+Or+"+"+Rr,Ar+"+"+zr,Cr,Lr,_r,Br].join("|"),"g"),Nr=RegExp("["+kr+Yt+tr+cr+"]"),Pr=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,qr=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],Zr=-1,Kr={};Kr[at]=Kr[ct]=Kr[lt]=Kr[st]=Kr[ht]=Kr[pt]=Kr[vt]=Kr[_t]=Kr[gt]=!0,Kr[$n]=Kr[Dn]=Kr[ot]=Kr[Fn]=Kr[ft]=Kr[Nn]=Kr[qn]=Kr[Zn]=Kr[Vn]=Kr[Gn]=Kr[Jn]=Kr[Xn]=Kr[nt]=Kr[tt]=Kr[ut]=!1;var Vr={};Vr[$n]=Vr[Dn]=Vr[ot]=Vr[ft]=Vr[Fn]=Vr[Nn]=Vr[at]=Vr[ct]=Vr[lt]=Vr[st]=Vr[ht]=Vr[Vn]=Vr[Gn]=Vr[Jn]=Vr[Xn]=Vr[nt]=Vr[tt]=Vr[rt]=Vr[pt]=Vr[vt]=Vr[_t]=Vr[gt]=!0,Vr[qn]=Vr[Zn]=Vr[ut]=!1;var Gr={"À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","Ç":"C","ç":"c","Ð":"D","ð":"d","È":"E","É":"E","Ê":"E","Ë":"E","è":"e","é":"e","ê":"e","ë":"e","Ì":"I","Í":"I","Î":"I","Ï":"I","ì":"i","í":"i","î":"i","ï":"i","Ñ":"N","ñ":"n","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","Ù":"U","Ú":"U","Û":"U","Ü":"U","ù":"u","ú":"u","û":"u","ü":"u","Ý":"Y","ý":"y","ÿ":"y","Æ":"Ae","æ":"ae","Þ":"Th","þ":"th","ß":"ss","Ā":"A","Ă":"A","Ą":"A","ā":"a","ă":"a","ą":"a","Ć":"C","Ĉ":"C","Ċ":"C","Č":"C","ć":"c","ĉ":"c","ċ":"c","č":"c","Ď":"D","Đ":"D","ď":"d","đ":"d","Ē":"E","Ĕ":"E","Ė":"E","Ę":"E","Ě":"E","ē":"e","ĕ":"e","ė":"e","ę":"e","ě":"e","Ĝ":"G","Ğ":"G","Ġ":"G","Ģ":"G","ĝ":"g","ğ":"g","ġ":"g","ģ":"g","Ĥ":"H","Ħ":"H","ĥ":"h","ħ":"h","Ĩ":"I","Ī":"I","Ĭ":"I","Į":"I","İ":"I","ĩ":"i","ī":"i","ĭ":"i","į":"i","ı":"i","Ĵ":"J","ĵ":"j","Ķ":"K","ķ":"k","ĸ":"k","Ĺ":"L","Ļ":"L","Ľ":"L","Ŀ":"L","Ł":"L","ĺ":"l","ļ":"l","ľ":"l","ŀ":"l","ł":"l","Ń":"N","Ņ":"N","Ň":"N","Ŋ":"N","ń":"n","ņ":"n","ň":"n","ŋ":"n","Ō":"O","Ŏ":"O","Ő":"O","ō":"o","ŏ":"o","ő":"o","Ŕ":"R","Ŗ":"R","Ř":"R","ŕ":"r","ŗ":"r","ř":"r","Ś":"S","Ŝ":"S","Ş":"S","Š":"S","ś":"s","ŝ":"s","ş":"s","š":"s","Ţ":"T","Ť":"T","Ŧ":"T","ţ":"t","ť":"t","ŧ":"t","Ũ":"U","Ū":"U","Ŭ":"U","Ů":"U","Ű":"U","Ų":"U","ũ":"u","ū":"u","ŭ":"u","ů":"u","ű":"u","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","Ż":"Z","Ž":"Z","ź":"z","ż":"z","ž":"z","Ĳ":"IJ","ĳ":"ij","Œ":"Oe","œ":"oe","ŉ":"'n","ſ":"s"},Hr={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Jr={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},Yr={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Qr=parseFloat,Xr=parseInt,ne="object"==typeof global&&global&&global.Object===Object&&global,te="object"==typeof self&&self&&self.Object===Object&&self,re=ne||te||Function("return this")(),ee="object"==typeof exports&&exports&&!exports.nodeType&&exports,ue=ee&&"object"==typeof module&&module&&!module.nodeType&&module,ie=ue&&ue.exports===ee,oe=ie&&ne.process,fe=function(){try{return oe&&oe.binding&&oe.binding("util")}catch(n){}}(),ae=fe&&fe.isArrayBuffer,ce=fe&&fe.isDate,le=fe&&fe.isMap,se=fe&&fe.isRegExp,he=fe&&fe.isSet,pe=fe&&fe.isTypedArray,ve=j("length"),_e=A(Gr),ge=A(Hr),ye=A(Jr),de=function _(A){function K(n){if(la(n)&&!mh(n)&&!(n instanceof Dt)){if(n instanceof Y)return n;if(ml.call(n,"__wrapped__"))return io(n)}return new Y(n)}function J(){}function Y(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=X}function Dt(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=Cn,this.__views__=[]}function Yt(){var n=new Dt(this.__wrapped__);return n.__actions__=Mu(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Mu(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Mu(this.__views__),n}function Qt(){if(this.__filtered__){var n=new Dt(this);n.__dir__=-1,n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Xt(){var n=this.__wrapped__.value(),t=this.__dir__,r=mh(n),e=t<0,u=r?n.length:0,i=zi(0,u,this.__views__),o=i.start,f=i.end,a=f-o,c=e?f:o-1,l=this.__iteratees__,s=l.length,h=0,p=Yl(a,this.__takeCount__);if(!r||!e&&u==a&&p==a)return mu(n,this.__actions__);var v=[];n:for(;a--&&h<p;){c+=t;for(var _=-1,g=n[c];++_<s;){var y=l[_],d=y.iteratee,b=y.type,w=d(g);if(b==Rn)g=w;else if(!w){if(b==In)continue n;break n}}v[h++]=g}return v}function nr(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function tr(){this.__data__=fs?fs(null):{},this.size=0}function rr(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}function er(n){var t=this.__data__;if(fs){var r=t[n];return r===un?X:r}return ml.call(t,n)?t[n]:X}function ur(n){var t=this.__data__;return fs?t[n]!==X:ml.call(t,n)}function ir(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=fs&&t===X?un:t,this}function or(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function fr(){this.__data__=[],this.size=0}function ar(n){var t=this.__data__,r=Lr(t,n);if(r<0)return!1;var e=t.length-1;return r==e?t.pop():Ul.call(t,r,1),--this.size,!0}function cr(n){var t=this.__data__,r=Lr(t,n);return r<0?X:t[r][1]}function lr(n){return Lr(this.__data__,n)>-1}function sr(n,t){var r=this.__data__,e=Lr(r,n);return e<0?(++this.size,r.push([n,t])):r[e][1]=t,this}function hr(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function pr(){this.size=0,this.__data__={hash:new nr,map:new(es||or),string:new nr}}function vr(n){var t=ki(this,n).delete(n);return this.size-=t?1:0,t}function _r(n){return ki(this,n).get(n)}function gr(n){return ki(this,n).has(n)}function yr(n,t){var r=ki(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this}function dr(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new hr;++t<r;)this.add(n[t])}function br(n){return this.__data__.set(n,un),this}function wr(n){return this.__data__.has(n)}function mr(n){var t=this.__data__=new or(n);this.size=t.size}function xr(){this.__data__=new or,this.size=0}function jr(n){var t=this.__data__,r=t.delete(n);return this.size=t.size,r}function Ar(n){return this.__data__.get(n)}function kr(n){return this.__data__.has(n)}function Or(n,t){var r=this.__data__;if(r instanceof or){var e=r.__data__;if(!es||e.length<tn-1)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new hr(e)}return r.set(n,t),this.size=r.size,this}function Ir(n,t){var r=mh(n),e=!r&&wh(n),u=!r&&!e&&jh(n),i=!r&&!e&&!u&&Rh(n),o=r||e||u||i,f=o?R(n.length,vl):[],a=f.length;for(var c in n)!t&&!ml.call(n,c)||o&&("length"==c||u&&("offset"==c||"parent"==c)||i&&("buffer"==c||"byteLength"==c||"byteOffset"==c)||Ti(c,a))||f.push(c);return f}function Rr(n){var t=n.length;return t?n[ru(0,t-1)]:X}function zr(n,t){return to(Mu(n),Fr(t,0,n.length))}function Er(n){return to(Mu(n))}function Sr(n,t,r){(r===X||Jf(n[t],r))&&(r!==X||t in n)||Tr(n,t,r)}function Wr(n,t,r){var e=n[t];ml.call(n,t)&&Jf(e,r)&&(r!==X||t in n)||Tr(n,t,r)}function Lr(n,t){for(var r=n.length;r--;)if(Jf(n[r][0],t))return r;return-1}function Cr(n,t,r,e){return bs(n,function(n,u,i){t(e,n,r(n),i)}),e}function Ur(n,t){return n&&Fu(t,Za(t),n)}function Br(n,t){return n&&Fu(t,Ka(t),n)}function Tr(n,t,r){"__proto__"==t&&Dl?Dl(n,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):n[t]=r}function Mr(n,t){for(var r=-1,e=t.length,u=fl(e),i=null==n;++r<e;)u[r]=i?X:Na(n,t[r]);return u}function Fr(n,t,r){return n===n&&(r!==X&&(n=n<=r?n:r),t!==X&&(n=n>=t?n:t)),n}function Nr(n,t,r,e,i,o){var f,a=t&an,c=t&cn,l=t&ln;if(r&&(f=i?r(n,e,i,o):r(n)),f!==X)return f;if(!ca(n))return n;var s=mh(n);if(s){if(f=Wi(n),!a)return Mu(n,f)}else{var h=Ss(n),p=h==Zn||h==Kn;if(jh(n))return Ru(n,a);if(h==Jn||h==$n||p&&!i){if(f=c||p?{}:Li(n),!a)return c?Pu(n,Br(f,n)):Nu(n,Ur(f,n))}else{if(!Vr[h])return i?n:{};f=Ci(n,h,Nr,a)}}o||(o=new mr);var v=o.get(n);if(v)return v;o.set(n,f);var _=l?c?mi:wi:c?Ka:Za,g=s?X:_(n);return u(g||n,function(e,u){g&&(u=e,e=n[u]),Wr(f,u,Nr(e,t,r,u,n,o))}),f}function Pr(n){var t=Za(n);return function(r){return Gr(r,n,t)}}function Gr(n,t,r){var e=r.length;if(null==n)return!e;for(n=hl(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===X&&!(u in n)||!i(o))return!1}return!0}function Hr(n,t,r){if("function"!=typeof n)throw new _l(en);return Cs(function(){n.apply(X,r)},t)}function Jr(n,t,r,e){var u=-1,i=a,o=!0,f=n.length,s=[],h=t.length;if(!f)return s;r&&(t=l(t,E(r))),e?(i=c,o=!1):t.length>=tn&&(i=W,o=!1,t=new dr(t));n:for(;++u<f;){var p=n[u],v=null==r?p:r(p);if(p=e||0!==p?p:0,o&&v===v){for(var _=h;_--;)if(t[_]===v)continue n;s.push(p)}else i(t,v,e)||s.push(p)}return s}function Yr(n,t){var r=!0;return bs(n,function(n,e,u){return r=!!t(n,e,u)}),r}function ne(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===X?o===o&&!ma(o):r(o,f)))var f=o,a=i}return a}function te(n,t,r,e){var u=n.length;for(r=Ia(r),r<0&&(r=-r>u?0:u+r),e=e===X||e>u?u:Ia(e),e<0&&(e+=u),e=r>e?0:Ra(e);r<e;)n[r++]=t;return n}function ee(n,t){var r=[];return bs(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function ue(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Bi),u||(u=[]);++i<o;){var f=n[i];t>0&&r(f)?t>1?ue(f,t-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function oe(n,t){return n&&ms(n,t,Za)}function fe(n,t){return n&&xs(n,t,Za)}function ve(n,t){return f(t,function(t){return oa(n[t])})}function de(n,t){t=Ou(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[ro(t[r++])];return r&&r==e?n:X}function we(n,t,r){var e=t(n);return mh(n)?e:s(e,r(n))}function me(n){return null==n?n===X?et:Hn:$l&&$l in hl(n)?Ri(n):Hi(n)}function xe(n,t){return n>t}function je(n,t){return null!=n&&ml.call(n,t)}function Ae(n,t){return null!=n&&t in hl(n)}function ke(n,t,r){return n>=Yl(t,r)&&n<Jl(t,r)}function Oe(n,t,r){for(var e=r?c:a,u=n[0].length,i=n.length,o=i,f=fl(i),s=1/0,h=[];o--;){var p=n[o];o&&t&&(p=l(p,E(t))),s=Yl(p.length,s),f[o]=!r&&(t||u>=120&&p.length>=120)?new dr(o&&p):X}p=n[0];var v=-1,_=f[0];n:for(;++v<u&&h.length<s;){var g=p[v],y=t?t(g):g;if(g=r||0!==g?g:0,!(_?W(_,y):e(h,y,r))){for(o=i;--o;){var d=f[o];if(!(d?W(d,y):e(n[o],y,r)))continue n}_&&_.push(y),h.push(g)}}return h}function Ie(n,t,r,e){return oe(n,function(n,u,i){t(e,r(n),u,i)}),e}function Re(n,t,e){t=Ou(t,n),n=Yi(n,t);var u=null==n?n:n[ro(ko(t))];return null==u?X:r(u,n,e)}function ze(n){return la(n)&&me(n)==$n}function Ee(n){return la(n)&&me(n)==ot}function Se(n){return la(n)&&me(n)==Nn}function We(n,t,r,e,u){return n===t||(null==n||null==t||!la(n)&&!la(t)?n!==n&&t!==t:Le(n,t,r,e,We,u))}function Le(n,t,r,e,u,i){var o=mh(n),f=mh(t),a=o?Dn:Ss(n),c=f?Dn:Ss(t);a=a==$n?Jn:a,c=c==$n?Jn:c;var l=a==Jn,s=c==Jn,h=a==c;if(h&&jh(n)){if(!jh(t))return!1;o=!0,l=!1}if(h&&!l)return i||(i=new mr),o||Rh(n)?gi(n,t,r,e,u,i):yi(n,t,a,r,e,u,i);if(!(r&sn)){var p=l&&ml.call(n,"__wrapped__"),v=s&&ml.call(t,"__wrapped__");if(p||v){var _=p?n.value():n,g=v?t.value():t;return i||(i=new mr),u(_,g,r,e,i)}}return!!h&&(i||(i=new mr),di(n,t,r,e,u,i))}function Ce(n){return la(n)&&Ss(n)==Vn}function Ue(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=hl(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return!1}for(;++u<i;){f=r[u];var a=f[0],c=n[a],l=f[1];if(o&&f[2]){if(c===X&&!(a in n))return!1}else{var s=new mr;if(e)var h=e(c,l,a,n,t,s);if(!(h===X?We(l,c,sn|hn,e,s):h))return!1}}return!0}function Be(n){if(!ca(n)||Ni(n))return!1;var t=oa(n)?Il:Zt;return t.test(eo(n))}function Te(n){return la(n)&&me(n)==Xn}function $e(n){return la(n)&&Ss(n)==nt}function De(n){return la(n)&&aa(n.length)&&!!Kr[me(n)]}function Me(n){return"function"==typeof n?n:null==n?Uc:"object"==typeof n?mh(n)?Ke(n[0],n[1]):Ze(n):Pc(n)}function Fe(n){if(!Pi(n))return Hl(n);var t=[];for(var r in hl(n))ml.call(n,r)&&"constructor"!=r&&t.push(r);return t}function Ne(n){if(!ca(n))return Gi(n);var t=Pi(n),r=[];for(var e in n)("constructor"!=e||!t&&ml.call(n,e))&&r.push(e);return r}function Pe(n,t){return n<t}function qe(n,t){var r=-1,e=Yf(n)?fl(n.length):[];return bs(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Ze(n){var t=Oi(n);return 1==t.length&&t[0][2]?Zi(t[0][0],t[0][1]):function(r){return r===n||Ue(r,n,t)}}function Ke(n,t){return Di(n)&&qi(t)?Zi(ro(n),t):function(r){var e=Na(r,n);return e===X&&e===t?qa(r,n):We(t,e,sn|hn)}}function Ve(n,t,r,e,u){n!==t&&ms(t,function(i,o){if(ca(i))u||(u=new mr),Ge(n,t,o,r,Ve,e,u);else{var f=e?e(n[o],i,o+"",n,t,u):X;f===X&&(f=i),Sr(n,o,f)}},Ka)}function Ge(n,t,r,e,u,i,o){var f=n[r],a=t[r],c=o.get(a);if(c)return void Sr(n,r,c);var l=i?i(f,a,r+"",n,t,o):X,s=l===X;if(s){var h=mh(a),p=!h&&jh(a),v=!h&&!p&&Rh(a);l=a,h||p||v?mh(f)?l=f:Qf(f)?l=Mu(f):p?(s=!1,l=Ru(a,!0)):v?(s=!1,l=Uu(a,!0)):l=[]:da(a)||wh(a)?(l=f,wh(f)?l=Ea(f):(!ca(f)||e&&oa(f))&&(l=Li(a))):s=!1}s&&(o.set(a,l),u(l,a,e,i,o),o.delete(a)),Sr(n,r,l)}function He(n,t){var r=n.length;if(r)return t+=t<0?r:0,Ti(t,r)?n[t]:X}function Je(n,t,r){var e=-1;t=l(t.length?t:[Uc],E(Ai()));var u=qe(n,function(n,r,u){var i=l(t,function(t){return t(n)});return{criteria:i,index:++e,value:n}});return O(u,function(n,t){return Tu(n,t,r)})}function Ye(n,t){return Qe(n,t,function(t,r){return qa(n,r)})}function Qe(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=de(n,o);r(f,o)&&au(i,Ou(o,n),f)}return i}function Xe(n){return function(t){return de(t,n)}}function nu(n,t,r,e){var u=e?w:b,i=-1,o=t.length,f=n;for(n===t&&(t=Mu(t)),r&&(f=l(n,E(r)));++i<o;)for(var a=0,c=t[i],s=r?r(c):c;(a=u(f,s,a,e))>-1;)f!==n&&Ul.call(f,a,1),Ul.call(n,a,1);return n}function tu(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];if(r==e||u!==i){var i=u;Ti(u)?Ul.call(n,u,1):du(n,u)}}return n}function ru(n,t){return n+ql(ns()*(t-n+1))}function eu(n,t,r,e){for(var u=-1,i=Jl(Pl((t-n)/(r||1)),0),o=fl(i);i--;)o[e?i:++u]=n,n+=r;return o}function uu(n,t){var r="";if(!n||t<1||t>Sn)return r;do t%2&&(r+=n),t=ql(t/2),t&&(n+=n);while(t);return r}function iu(n,t){return Us(Ji(n,t,Uc),n+"")}function ou(n){return Rr(uc(n))}function fu(n,t){var r=uc(n);return to(r,Fr(t,0,r.length))}function au(n,t,r,e){if(!ca(n))return n;t=Ou(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var a=ro(t[u]),c=r;if(u!=o){var l=f[a];c=e?e(l,a,f):X,c===X&&(c=ca(l)?l:Ti(t[u+1])?[]:{})}Wr(f,a,c),f=f[a]}return n}function cu(n){return to(uc(n))}function lu(n,t,r){var e=-1,u=n.length;t<0&&(t=-t>u?0:u+t),r=r>u?u:r,r<0&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0;for(var i=fl(u);++e<u;)i[e]=n[e+t];return i}function su(n,t){var r;return bs(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function hu(n,t,r){var e=0,u=null==n?e:n.length;if("number"==typeof t&&t===t&&u<=Bn){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!ma(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return pu(n,t,Uc,r)}function pu(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,a=ma(t),c=t===X;u<i;){var l=ql((u+i)/2),s=r(n[l]),h=s!==X,p=null===s,v=s===s,_=ma(s);if(o)var g=e||v;else g=c?v&&(e||h):f?v&&h&&(e||!p):a?v&&h&&!p&&(e||!_):!p&&!_&&(e?s<=t:s<t);g?u=l+1:i=l}return Yl(i,Un)}function vu(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!Jf(f,a)){var a=f;i[u++]=0===o?0:o}}return i}function _u(n){return"number"==typeof n?n:ma(n)?Ln:+n}function gu(n){if("string"==typeof n)return n;if(mh(n))return l(n,gu)+"";if(ma(n))return ys?ys.call(n):"";var t=n+"";return"0"==t&&1/n==-En?"-0":t}function yu(n,t,r){var e=-1,u=a,i=n.length,o=!0,f=[],l=f;if(r)o=!1,u=c;else if(i>=tn){var s=t?null:Is(n);if(s)return q(s);o=!1,u=W,l=new dr}else l=t?[]:f;n:for(;++e<i;){var h=n[e],p=t?t(h):h;if(h=r||0!==h?h:0,o&&p===p){for(var v=l.length;v--;)if(l[v]===p)continue n;t&&l.push(p),f.push(h)}else u(l,p,r)||(l!==f&&l.push(p),f.push(h))}return f}function du(n,t){return t=Ou(t,n),n=Yi(n,t),null==n||delete n[ro(ko(t))]}function bu(n,t,r,e){return au(n,t,r(de(n,t)),e)}function wu(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?lu(n,e?0:i,e?i+1:u):lu(n,e?i+1:0,e?u:i)}function mu(n,t){var r=n;return r instanceof Dt&&(r=r.value()),h(t,function(n,t){return t.func.apply(t.thisArg,s([n],t.args))},r)}function xu(n,t,r){var e=n.length;if(e<2)return e?yu(n[0]):[];for(var u=-1,i=fl(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=Jr(i[u]||o,n[f],t,r));return yu(ue(i,1),t,r)}function ju(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;){var f=e<i?t[e]:X;r(o,n[e],f)}return o}function Au(n){return Qf(n)?n:[]}function ku(n){return"function"==typeof n?n:Uc}function Ou(n,t){return mh(n)?n:Di(n,t)?[n]:Bs(Wa(n))}function Iu(n,t,r){var e=n.length;return r=r===X?e:r,!t&&r>=e?n:lu(n,t,r)}function Ru(n,t){if(t)return n.slice();var r=n.length,e=Sl?Sl(r):new n.constructor(r);return n.copy(e),e}function zu(n){var t=new n.constructor(n.byteLength);return new El(t).set(new El(n)),t}function Eu(n,t){var r=t?zu(n.buffer):n.buffer;return new n.constructor(r,n.byteOffset,n.byteLength)}function Su(t,r,e){var u=r?e(F(t),an):F(t);return h(u,n,new t.constructor)}function Wu(n){var t=new n.constructor(n.source,Nt.exec(n));return t.lastIndex=n.lastIndex,t}function Lu(n,r,e){var u=r?e(q(n),an):q(n);return h(u,t,new n.constructor)}function Cu(n){return gs?hl(gs.call(n)):{}}function Uu(n,t){var r=t?zu(n.buffer):n.buffer;return new n.constructor(r,n.byteOffset,n.length)}function Bu(n,t){if(n!==t){var r=n!==X,e=null===n,u=n===n,i=ma(n),o=t!==X,f=null===t,a=t===t,c=ma(t);if(!f&&!c&&!i&&n>t||i&&o&&a&&!f&&!c||e&&o&&a||!r&&a||!u)return 1;if(!e&&!i&&!c&&n<t||c&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!a)return-1}return 0}function Tu(n,t,r){for(var e=-1,u=n.criteria,i=t.criteria,o=u.length,f=r.length;++e<o;){var a=Bu(u[e],i[e]);if(a){if(e>=f)return a;var c=r[e];return a*("desc"==c?-1:1)}}return n.index-t.index}function $u(n,t,r,e){for(var u=-1,i=n.length,o=r.length,f=-1,a=t.length,c=Jl(i-o,0),l=fl(a+c),s=!e;++f<a;)l[f]=t[f];for(;++u<o;)(s||u<i)&&(l[r[u]]=n[u]);for(;c--;)l[f++]=n[u++];return l}function Du(n,t,r,e){for(var u=-1,i=n.length,o=-1,f=r.length,a=-1,c=t.length,l=Jl(i-f,0),s=fl(l+c),h=!e;++u<l;)s[u]=n[u];for(var p=u;++a<c;)s[p+a]=t[a];for(;++o<f;)(h||u<i)&&(s[p+r[o]]=n[u++]);return s}function Mu(n,t){var r=-1,e=n.length;for(t||(t=fl(e));++r<e;)t[r]=n[r];return t}function Fu(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],a=e?e(r[f],n[f],f,r,n):X;a===X&&(a=n[f]),u?Tr(r,f,a):Wr(r,f,a)}return r}function Nu(n,t){return Fu(n,zs(n),t)}function Pu(n,t){return Fu(n,Es(n),t)}function qu(n,t){return function(r,u){var i=mh(r)?e:Cr,o=t?t():{};return i(r,n,Ai(u,2),o)}}function Zu(n){return iu(function(t,r){var e=-1,u=r.length,i=u>1?r[u-1]:X,o=u>2?r[2]:X;for(i=n.length>3&&"function"==typeof i?(u--,i):X,o&&$i(r[0],r[1],o)&&(i=u<3?X:i,u=1),t=hl(t);++e<u;){var f=r[e];f&&n(t,f,e,i)}return t})}function Ku(n,t){return function(r,e){if(null==r)return r;if(!Yf(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=hl(r);(t?i--:++i<u)&&e(o[i],i,o)!==!1;);return r}}function Vu(n){return function(t,r,e){for(var u=-1,i=hl(t),o=e(t),f=o.length;f--;){var a=o[n?f:++u];if(r(i[a],a,i)===!1)break}return t}}function Gu(n,t,r){function e(){var t=this&&this!==re&&this instanceof e?i:n;return t.apply(u?r:this,arguments)}var u=t&pn,i=Yu(n);return e}function Hu(n){return function(t){t=Wa(t);var r=$(t)?H(t):X,e=r?r[0]:t.charAt(0),u=r?Iu(r,1).join(""):t.slice(1);return e[n]()+u}}function Ju(n){return function(t){return h(Ec(lc(t).replace($r,"")),n,"")}}function Yu(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=ds(n.prototype),e=n.apply(r,t);return ca(e)?e:r}}function Qu(n,t,e){function u(){for(var o=arguments.length,f=fl(o),a=o,c=ji(u);a--;)f[a]=arguments[a];var l=o<3&&f[0]!==c&&f[o-1]!==c?[]:P(f,c);if(o-=l.length,o<e)return ci(n,t,ti,u.placeholder,X,f,l,X,X,e-o);var s=this&&this!==re&&this instanceof u?i:n;return r(s,this,f)}var i=Yu(n);return u}function Xu(n){return function(t,r,e){var u=hl(t);if(!Yf(t)){var i=Ai(r,3);t=Za(t),r=function(n){return i(u[n],n,u)}}var o=n(t,r,e);return o>-1?u[i?t[o]:o]:X}}function ni(n){return bi(function(t){var r=t.length,e=r,u=Y.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if("function"!=typeof i)throw new _l(en);if(u&&!o&&"wrapper"==xi(i))var o=new Y([],!0)}for(e=o?e:r;++e<r;){i=t[e];var f=xi(i),a="wrapper"==f?Rs(i):X;o=a&&Fi(a[0])&&a[1]==(wn|gn|dn|mn)&&!a[4].length&&1==a[9]?o[xi(a[0])].apply(o,a[3]):1==i.length&&Fi(i)?o[f]():o.thru(i)}return function(){var n=arguments,e=n[0];if(o&&1==n.length&&mh(e))return o.plant(e).value();for(var u=0,i=r?t[u].apply(this,n):e;++u<r;)i=t[u].call(this,i);return i}})}function ti(n,t,r,e,u,i,o,f,a,c){function l(){for(var y=arguments.length,d=fl(y),b=y;b--;)d[b]=arguments[b];if(v)var w=ji(l),m=U(d,w);if(e&&(d=$u(d,e,u,v)),i&&(d=Du(d,i,o,v)),y-=m,v&&y<c){var x=P(d,w);return ci(n,t,ti,l.placeholder,r,d,x,f,a,c-y)}var j=h?r:this,A=p?j[n]:n;return y=d.length,f?d=Qi(d,f):_&&y>1&&d.reverse(),s&&a<y&&(d.length=a),this&&this!==re&&this instanceof l&&(A=g||Yu(A)),A.apply(j,d)}var s=t&wn,h=t&pn,p=t&vn,v=t&(gn|yn),_=t&xn,g=p?X:Yu(n);return l}function ri(n,t){return function(r,e){return Ie(r,n,t(e),{})}}function ei(n,t){return function(r,e){var u;if(r===X&&e===X)return t;if(r!==X&&(u=r),e!==X){if(u===X)return e;"string"==typeof r||"string"==typeof e?(r=gu(r),e=gu(e)):(r=_u(r),e=_u(e)),u=n(r,e)}return u}}function ui(n){return bi(function(t){return t=l(t,E(Ai())),iu(function(e){var u=this;return n(t,function(n){return r(n,u,e)})})})}function ii(n,t){t=t===X?" ":gu(t);var r=t.length;if(r<2)return r?uu(t,n):t;var e=uu(t,Pl(n/G(t)));return $(t)?Iu(H(e),0,n).join(""):e.slice(0,n)}function oi(n,t,e,u){function i(){for(var t=-1,a=arguments.length,c=-1,l=u.length,s=fl(l+a),h=this&&this!==re&&this instanceof i?f:n;++c<l;)s[c]=u[c];for(;a--;)s[c++]=arguments[++t];return r(h,o?e:this,s)}var o=t&pn,f=Yu(n);return i}function fi(n){return function(t,r,e){return e&&"number"!=typeof e&&$i(t,r,e)&&(r=e=X),t=Oa(t),r===X?(r=t,t=0):r=Oa(r),e=e===X?t<r?1:-1:Oa(e),eu(t,r,e,n)}}function ai(n){return function(t,r){return"string"==typeof t&&"string"==typeof r||(t=za(t),r=za(r)),n(t,r)}}function ci(n,t,r,e,u,i,o,f,a,c){var l=t&gn,s=l?o:X,h=l?X:o,p=l?i:X,v=l?X:i;t|=l?dn:bn,t&=~(l?bn:dn),t&_n||(t&=~(pn|vn));var _=[n,t,u,p,s,v,h,f,a,c],g=r.apply(X,_);return Fi(n)&&Ls(g,_),g.placeholder=e,Xi(g,n,t)}function li(n){var t=sl[n];return function(n,r){if(n=za(n),r=null==r?0:Yl(Ia(r),292)){var e=(Wa(n)+"e").split("e"),u=t(e[0]+"e"+(+e[1]+r));return e=(Wa(u)+"e").split("e"),+(e[0]+"e"+(+e[1]-r))}return t(n)}}function si(n){return function(t){var r=Ss(t);return r==Vn?F(t):r==nt?Z(t):z(t,n(t))}}function hi(n,t,r,e,u,i,o,f){var a=t&vn;if(!a&&"function"!=typeof n)throw new _l(en);var c=e?e.length:0;if(c||(t&=~(dn|bn),e=u=X),o=o===X?o:Jl(Ia(o),0),f=f===X?f:Ia(f),c-=u?u.length:0,t&bn){var l=e,s=u;e=u=X}var h=a?X:Rs(n),p=[n,t,r,e,u,l,s,i,o,f];if(h&&Vi(p,h),n=p[0],t=p[1],r=p[2],e=p[3],u=p[4],f=p[9]=p[9]===X?a?0:n.length:Jl(p[9]-c,0),!f&&t&(gn|yn)&&(t&=~(gn|yn)),t&&t!=pn)v=t==gn||t==yn?Qu(n,t,f):t!=dn&&t!=(pn|dn)||u.length?ti.apply(X,p):oi(n,t,r,e);else var v=Gu(n,t,r);var _=h?js:Ls;return Xi(_(v,p),n,t)}function pi(n,t,r,e){return n===X||Jf(n,dl[r])&&!ml.call(e,r)?t:n}function vi(n,t,r,e,u,i){return ca(n)&&ca(t)&&(i.set(t,n),Ve(n,t,X,vi,i),i.delete(t)),n}function _i(n){return da(n)?X:n}function gi(n,t,r,e,u,i){var o=r&sn,f=n.length,a=t.length;if(f!=a&&!(o&&a>f))return!1;var c=i.get(n);if(c&&i.get(t))return c==t;var l=-1,s=!0,h=r&hn?new dr:X;for(i.set(n,t),i.set(t,n);++l<f;){var p=n[l],_=t[l];if(e)var g=o?e(_,p,l,t,n,i):e(p,_,l,n,t,i);if(g!==X){if(g)continue;s=!1;break}if(h){if(!v(t,function(n,t){if(!W(h,t)&&(p===n||u(p,n,r,e,i)))return h.push(t)})){s=!1;break}}else if(p!==_&&!u(p,_,r,e,i)){s=!1;break}}return i.delete(n),i.delete(t),s}function yi(n,t,r,e,u,i,o){switch(r){case ft:if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;n=n.buffer,t=t.buffer;case ot:return!(n.byteLength!=t.byteLength||!i(new El(n),new El(t)));case Fn:case Nn:case Gn:return Jf(+n,+t);case qn:return n.name==t.name&&n.message==t.message;case Xn:case tt:return n==t+"";case Vn:var f=F;case nt:var a=e&sn;if(f||(f=q),n.size!=t.size&&!a)return!1;var c=o.get(n);if(c)return c==t;e|=hn,o.set(n,t);var l=gi(f(n),f(t),e,u,i,o);return o.delete(n),l;case rt:if(gs)return gs.call(n)==gs.call(t)}return!1}function di(n,t,r,e,u,i){var o=r&sn,f=wi(n),a=f.length,c=wi(t),l=c.length;if(a!=l&&!o)return!1;for(var s=a;s--;){var h=f[s];if(!(o?h in t:ml.call(t,h)))return!1}var p=i.get(n);if(p&&i.get(t))return p==t;var v=!0;i.set(n,t),i.set(t,n);for(var _=o;++s<a;){h=f[s];var g=n[h],y=t[h];if(e)var d=o?e(y,g,h,t,n,i):e(g,y,h,n,t,i);if(!(d===X?g===y||u(g,y,r,e,i):d)){v=!1;break}_||(_="constructor"==h)}if(v&&!_){var b=n.constructor,w=t.constructor;b!=w&&"constructor"in n&&"constructor"in t&&!("function"==typeof b&&b instanceof b&&"function"==typeof w&&w instanceof w)&&(v=!1);
}return i.delete(n),i.delete(t),v}function bi(n){return Us(Ji(n,X,go),n+"")}function wi(n){return we(n,Za,zs)}function mi(n){return we(n,Ka,Es)}function xi(n){for(var t=n.name+"",r=cs[t],e=ml.call(cs,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function ji(n){var t=ml.call(K,"placeholder")?K:n;return t.placeholder}function Ai(){var n=K.iteratee||Bc;return n=n===Bc?Me:n,arguments.length?n(arguments[0],arguments[1]):n}function ki(n,t){var r=n.__data__;return Mi(t)?r["string"==typeof t?"string":"hash"]:r.map}function Oi(n){for(var t=Za(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,qi(u)]}return t}function Ii(n,t){var r=T(n,t);return Be(r)?r:X}function Ri(n){var t=ml.call(n,$l),r=n[$l];try{n[$l]=X;var e=!0}catch(n){}var u=Al.call(n);return e&&(t?n[$l]=r:delete n[$l]),u}function zi(n,t,r){for(var e=-1,u=r.length;++e<u;){var i=r[e],o=i.size;switch(i.type){case"drop":n+=o;break;case"dropRight":t-=o;break;case"take":t=Yl(t,n+o);break;case"takeRight":n=Jl(n,t-o)}}return{start:n,end:t}}function Ei(n){var t=n.match(Tt);return t?t[1].split($t):[]}function Si(n,t,r){t=Ou(t,n);for(var e=-1,u=t.length,i=!1;++e<u;){var o=ro(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&aa(u)&&Ti(o,u)&&(mh(n)||wh(n)))}function Wi(n){var t=n.length,r=n.constructor(t);return t&&"string"==typeof n[0]&&ml.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Li(n){return"function"!=typeof n.constructor||Pi(n)?{}:ds(Wl(n))}function Ci(n,t,r,e){var u=n.constructor;switch(t){case ot:return zu(n);case Fn:case Nn:return new u(+n);case ft:return Eu(n,e);case at:case ct:case lt:case st:case ht:case pt:case vt:case _t:case gt:return Uu(n,e);case Vn:return Su(n,e,r);case Gn:case tt:return new u(n);case Xn:return Wu(n);case nt:return Lu(n,e,r);case rt:return Cu(n)}}function Ui(n,t){var r=t.length;if(!r)return n;var e=r-1;return t[e]=(r>1?"& ":"")+t[e],t=t.join(r>2?", ":" "),n.replace(Bt,"{\n/* [wrapped with "+t+"] */\n")}function Bi(n){return mh(n)||wh(n)||!!(Bl&&n&&n[Bl])}function Ti(n,t){return t=null==t?Sn:t,!!t&&("number"==typeof n||Vt.test(n))&&n>-1&&n%1==0&&n<t}function $i(n,t,r){if(!ca(r))return!1;var e=typeof t;return!!("number"==e?Yf(r)&&Ti(t,r.length):"string"==e&&t in r)&&Jf(r[t],n)}function Di(n,t){if(mh(n))return!1;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!ma(n))||(Rt.test(n)||!It.test(n)||null!=t&&n in hl(t))}function Mi(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}function Fi(n){var t=xi(n),r=K[t];if("function"!=typeof r||!(t in Dt.prototype))return!1;if(n===r)return!0;var e=Rs(r);return!!e&&n===e[0]}function Ni(n){return!!jl&&jl in n}function Pi(n){var t=n&&n.constructor,r="function"==typeof t&&t.prototype||dl;return n===r}function qi(n){return n===n&&!ca(n)}function Zi(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==X||n in hl(r)))}}function Ki(n){var t=Bf(n,function(n){return r.size===on&&r.clear(),n}),r=t.cache;return t}function Vi(n,t){var r=n[1],e=t[1],u=r|e,i=u<(pn|vn|wn),o=e==wn&&r==gn||e==wn&&r==mn&&n[7].length<=t[8]||e==(wn|mn)&&t[7].length<=t[8]&&r==gn;if(!i&&!o)return n;e&pn&&(n[2]=t[2],u|=r&pn?0:_n);var f=t[3];if(f){var a=n[3];n[3]=a?$u(a,f,t[4]):f,n[4]=a?P(n[3],fn):t[4]}return f=t[5],f&&(a=n[5],n[5]=a?Du(a,f,t[6]):f,n[6]=a?P(n[5],fn):t[6]),f=t[7],f&&(n[7]=f),e&wn&&(n[8]=null==n[8]?t[8]:Yl(n[8],t[8])),null==n[9]&&(n[9]=t[9]),n[0]=t[0],n[1]=u,n}function Gi(n){var t=[];if(null!=n)for(var r in hl(n))t.push(r);return t}function Hi(n){return Al.call(n)}function Ji(n,t,e){return t=Jl(t===X?n.length-1:t,0),function(){for(var u=arguments,i=-1,o=Jl(u.length-t,0),f=fl(o);++i<o;)f[i]=u[t+i];i=-1;for(var a=fl(t+1);++i<t;)a[i]=u[i];return a[t]=e(f),r(n,this,a)}}function Yi(n,t){return t.length<2?n:de(n,lu(t,0,-1))}function Qi(n,t){for(var r=n.length,e=Yl(t.length,r),u=Mu(n);e--;){var i=t[e];n[e]=Ti(i,r)?u[i]:X}return n}function Xi(n,t,r){var e=t+"";return Us(n,Ui(e,uo(Ei(e),r)))}function no(n){var t=0,r=0;return function(){var e=Ql(),u=On-(e-r);if(r=e,u>0){if(++t>=kn)return arguments[0]}else t=0;return n.apply(X,arguments)}}function to(n,t){var r=-1,e=n.length,u=e-1;for(t=t===X?e:t;++r<t;){var i=ru(r,u),o=n[i];n[i]=n[r],n[r]=o}return n.length=t,n}function ro(n){if("string"==typeof n||ma(n))return n;var t=n+"";return"0"==t&&1/n==-En?"-0":t}function eo(n){if(null!=n){try{return wl.call(n)}catch(n){}try{return n+""}catch(n){}}return""}function uo(n,t){return u(Tn,function(r){var e="_."+r[0];t&r[1]&&!a(n,e)&&n.push(e)}),n.sort()}function io(n){if(n instanceof Dt)return n.clone();var t=new Y(n.__wrapped__,n.__chain__);return t.__actions__=Mu(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function oo(n,t,r){t=(r?$i(n,t,r):t===X)?1:Jl(Ia(t),0);var e=null==n?0:n.length;if(!e||t<1)return[];for(var u=0,i=0,o=fl(Pl(e/t));u<e;)o[i++]=lu(n,u,u+=t);return o}function fo(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u}function ao(){var n=arguments.length;if(!n)return[];for(var t=fl(n-1),r=arguments[0],e=n;e--;)t[e-1]=arguments[e];return s(mh(r)?Mu(r):[r],ue(t,1))}function co(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:Ia(t),lu(n,t<0?0:t,e)):[]}function lo(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:Ia(t),t=e-t,lu(n,0,t<0?0:t)):[]}function so(n,t){return n&&n.length?wu(n,Ai(t,3),!0,!0):[]}function ho(n,t){return n&&n.length?wu(n,Ai(t,3),!0):[]}function po(n,t,r,e){var u=null==n?0:n.length;return u?(r&&"number"!=typeof r&&$i(n,t,r)&&(r=0,e=u),te(n,t,r,e)):[]}function vo(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:Ia(r);return u<0&&(u=Jl(e+u,0)),d(n,Ai(t,3),u)}function _o(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==X&&(u=Ia(r),u=r<0?Jl(e+u,0):Yl(u,e-1)),d(n,Ai(t,3),u,!0)}function go(n){var t=null==n?0:n.length;return t?ue(n,1):[]}function yo(n){var t=null==n?0:n.length;return t?ue(n,En):[]}function bo(n,t){var r=null==n?0:n.length;return r?(t=t===X?1:Ia(t),ue(n,t)):[]}function wo(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){var u=n[t];e[u[0]]=u[1]}return e}function mo(n){return n&&n.length?n[0]:X}function xo(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:Ia(r);return u<0&&(u=Jl(e+u,0)),b(n,t,u)}function jo(n){var t=null==n?0:n.length;return t?lu(n,0,-1):[]}function Ao(n,t){return null==n?"":Gl.call(n,t)}function ko(n){var t=null==n?0:n.length;return t?n[t-1]:X}function Oo(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;return r!==X&&(u=Ia(r),u=u<0?Jl(e+u,0):Yl(u,e-1)),t===t?V(n,t,u):d(n,m,u,!0)}function Io(n,t){return n&&n.length?He(n,Ia(t)):X}function Ro(n,t){return n&&n.length&&t&&t.length?nu(n,t):n}function zo(n,t,r){return n&&n.length&&t&&t.length?nu(n,t,Ai(r,2)):n}function Eo(n,t,r){return n&&n.length&&t&&t.length?nu(n,t,X,r):n}function So(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=Ai(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return tu(n,u),r}function Wo(n){return null==n?n:ts.call(n)}function Lo(n,t,r){var e=null==n?0:n.length;return e?(r&&"number"!=typeof r&&$i(n,t,r)?(t=0,r=e):(t=null==t?0:Ia(t),r=r===X?e:Ia(r)),lu(n,t,r)):[]}function Co(n,t){return hu(n,t)}function Uo(n,t,r){return pu(n,t,Ai(r,2))}function Bo(n,t){var r=null==n?0:n.length;if(r){var e=hu(n,t);if(e<r&&Jf(n[e],t))return e}return-1}function To(n,t){return hu(n,t,!0)}function $o(n,t,r){return pu(n,t,Ai(r,2),!0)}function Do(n,t){var r=null==n?0:n.length;if(r){var e=hu(n,t,!0)-1;if(Jf(n[e],t))return e}return-1}function Mo(n){return n&&n.length?vu(n):[]}function Fo(n,t){return n&&n.length?vu(n,Ai(t,2)):[]}function No(n){var t=null==n?0:n.length;return t?lu(n,1,t):[]}function Po(n,t,r){return n&&n.length?(t=r||t===X?1:Ia(t),lu(n,0,t<0?0:t)):[]}function qo(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:Ia(t),t=e-t,lu(n,t<0?0:t,e)):[]}function Zo(n,t){return n&&n.length?wu(n,Ai(t,3),!1,!0):[]}function Ko(n,t){return n&&n.length?wu(n,Ai(t,3)):[]}function Vo(n){return n&&n.length?yu(n):[]}function Go(n,t){return n&&n.length?yu(n,Ai(t,2)):[]}function Ho(n,t){return t="function"==typeof t?t:X,n&&n.length?yu(n,X,t):[]}function Jo(n){if(!n||!n.length)return[];var t=0;return n=f(n,function(n){if(Qf(n))return t=Jl(n.length,t),!0}),R(t,function(t){return l(n,j(t))})}function Yo(n,t){if(!n||!n.length)return[];var e=Jo(n);return null==t?e:l(e,function(n){return r(t,X,n)})}function Qo(n,t){return ju(n||[],t||[],Wr)}function Xo(n,t){return ju(n||[],t||[],au)}function nf(n){var t=K(n);return t.__chain__=!0,t}function tf(n,t){return t(n),n}function rf(n,t){return t(n)}function ef(){return nf(this)}function uf(){return new Y(this.value(),this.__chain__)}function of(){this.__values__===X&&(this.__values__=ka(this.value()));var n=this.__index__>=this.__values__.length,t=n?X:this.__values__[this.__index__++];return{done:n,value:t}}function ff(){return this}function af(n){for(var t,r=this;r instanceof J;){var e=io(r);e.__index__=0,e.__values__=X,t?u.__wrapped__=e:t=e;var u=e;r=r.__wrapped__}return u.__wrapped__=n,t}function cf(){var n=this.__wrapped__;if(n instanceof Dt){var t=n;return this.__actions__.length&&(t=new Dt(this)),t=t.reverse(),t.__actions__.push({func:rf,args:[Wo],thisArg:X}),new Y(t,this.__chain__)}return this.thru(Wo)}function lf(){return mu(this.__wrapped__,this.__actions__)}function sf(n,t,r){var e=mh(n)?o:Yr;return r&&$i(n,t,r)&&(t=X),e(n,Ai(t,3))}function hf(n,t){var r=mh(n)?f:ee;return r(n,Ai(t,3))}function pf(n,t){return ue(bf(n,t),1)}function vf(n,t){return ue(bf(n,t),En)}function _f(n,t,r){return r=r===X?1:Ia(r),ue(bf(n,t),r)}function gf(n,t){var r=mh(n)?u:bs;return r(n,Ai(t,3))}function yf(n,t){var r=mh(n)?i:ws;return r(n,Ai(t,3))}function df(n,t,r,e){n=Yf(n)?n:uc(n),r=r&&!e?Ia(r):0;var u=n.length;return r<0&&(r=Jl(u+r,0)),wa(n)?r<=u&&n.indexOf(t,r)>-1:!!u&&b(n,t,r)>-1}function bf(n,t){var r=mh(n)?l:qe;return r(n,Ai(t,3))}function wf(n,t,r,e){return null==n?[]:(mh(t)||(t=null==t?[]:[t]),r=e?X:r,mh(r)||(r=null==r?[]:[r]),Je(n,t,r))}function mf(n,t,r){var e=mh(n)?h:k,u=arguments.length<3;return e(n,Ai(t,4),r,u,bs)}function xf(n,t,r){var e=mh(n)?p:k,u=arguments.length<3;return e(n,Ai(t,4),r,u,ws)}function jf(n,t){var r=mh(n)?f:ee;return r(n,Tf(Ai(t,3)))}function Af(n){var t=mh(n)?Rr:ou;return t(n)}function kf(n,t,r){t=(r?$i(n,t,r):t===X)?1:Ia(t);var e=mh(n)?zr:fu;return e(n,t)}function Of(n){var t=mh(n)?Er:cu;return t(n)}function If(n){if(null==n)return 0;if(Yf(n))return wa(n)?G(n):n.length;var t=Ss(n);return t==Vn||t==nt?n.size:Fe(n).length}function Rf(n,t,r){var e=mh(n)?v:su;return r&&$i(n,t,r)&&(t=X),e(n,Ai(t,3))}function zf(n,t){if("function"!=typeof t)throw new _l(en);return n=Ia(n),function(){if(--n<1)return t.apply(this,arguments)}}function Ef(n,t,r){return t=r?X:t,t=n&&null==t?n.length:t,hi(n,wn,X,X,X,X,t)}function Sf(n,t){var r;if("function"!=typeof t)throw new _l(en);return n=Ia(n),function(){return--n>0&&(r=t.apply(this,arguments)),n<=1&&(t=X),r}}function Wf(n,t,r){t=r?X:t;var e=hi(n,gn,X,X,X,X,X,t);return e.placeholder=Wf.placeholder,e}function Lf(n,t,r){t=r?X:t;var e=hi(n,yn,X,X,X,X,X,t);return e.placeholder=Lf.placeholder,e}function Cf(n,t,r){function e(t){var r=h,e=p;return h=p=X,d=t,_=n.apply(e,r)}function u(n){return d=n,g=Cs(f,t),b?e(n):_}function i(n){var r=n-y,e=n-d,u=t-r;return w?Yl(u,v-e):u}function o(n){var r=n-y,e=n-d;return y===X||r>=t||r<0||w&&e>=v}function f(){var n=ch();return o(n)?a(n):void(g=Cs(f,i(n)))}function a(n){return g=X,m&&h?e(n):(h=p=X,_)}function c(){g!==X&&Os(g),d=0,h=y=p=g=X}function l(){return g===X?_:a(ch())}function s(){var n=ch(),r=o(n);if(h=arguments,p=this,y=n,r){if(g===X)return u(y);if(w)return g=Cs(f,t),e(y)}return g===X&&(g=Cs(f,t)),_}var h,p,v,_,g,y,d=0,b=!1,w=!1,m=!0;if("function"!=typeof n)throw new _l(en);return t=za(t)||0,ca(r)&&(b=!!r.leading,w="maxWait"in r,v=w?Jl(za(r.maxWait)||0,t):v,m="trailing"in r?!!r.trailing:m),s.cancel=c,s.flush=l,s}function Uf(n){return hi(n,xn)}function Bf(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new _l(en);var r=function(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;if(i.has(u))return i.get(u);var o=n.apply(this,e);return r.cache=i.set(u,o)||i,o};return r.cache=new(Bf.Cache||hr),r}function Tf(n){if("function"!=typeof n)throw new _l(en);return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function $f(n){return Sf(2,n)}function Df(n,t){if("function"!=typeof n)throw new _l(en);return t=t===X?t:Ia(t),iu(n,t)}function Mf(n,t){if("function"!=typeof n)throw new _l(en);return t=null==t?0:Jl(Ia(t),0),iu(function(e){var u=e[t],i=Iu(e,0,t);return u&&s(i,u),r(n,this,i)})}function Ff(n,t,r){var e=!0,u=!0;if("function"!=typeof n)throw new _l(en);return ca(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),Cf(n,t,{leading:e,maxWait:t,trailing:u})}function Nf(n){return Ef(n,1)}function Pf(n,t){return _h(ku(t),n)}function qf(){if(!arguments.length)return[];var n=arguments[0];return mh(n)?n:[n]}function Zf(n){return Nr(n,ln)}function Kf(n,t){return t="function"==typeof t?t:X,Nr(n,ln,t)}function Vf(n){return Nr(n,an|ln)}function Gf(n,t){return t="function"==typeof t?t:X,Nr(n,an|ln,t)}function Hf(n,t){return null==t||Gr(n,t,Za(t))}function Jf(n,t){return n===t||n!==n&&t!==t}function Yf(n){return null!=n&&aa(n.length)&&!oa(n)}function Qf(n){return la(n)&&Yf(n)}function Xf(n){return n===!0||n===!1||la(n)&&me(n)==Fn}function na(n){return la(n)&&1===n.nodeType&&!da(n)}function ta(n){if(null==n)return!0;if(Yf(n)&&(mh(n)||"string"==typeof n||"function"==typeof n.splice||jh(n)||Rh(n)||wh(n)))return!n.length;var t=Ss(n);if(t==Vn||t==nt)return!n.size;if(Pi(n))return!Fe(n).length;for(var r in n)if(ml.call(n,r))return!1;return!0}function ra(n,t){return We(n,t)}function ea(n,t,r){r="function"==typeof r?r:X;var e=r?r(n,t):X;return e===X?We(n,t,X,r):!!e}function ua(n){if(!la(n))return!1;var t=me(n);return t==qn||t==Pn||"string"==typeof n.message&&"string"==typeof n.name&&!da(n)}function ia(n){return"number"==typeof n&&Vl(n)}function oa(n){if(!ca(n))return!1;var t=me(n);return t==Zn||t==Kn||t==Mn||t==Qn}function fa(n){return"number"==typeof n&&n==Ia(n)}function aa(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=Sn}function ca(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function la(n){return null!=n&&"object"==typeof n}function sa(n,t){return n===t||Ue(n,t,Oi(t))}function ha(n,t,r){return r="function"==typeof r?r:X,Ue(n,t,Oi(t),r)}function pa(n){return ya(n)&&n!=+n}function va(n){if(Ws(n))throw new cl(rn);return Be(n)}function _a(n){return null===n}function ga(n){return null==n}function ya(n){return"number"==typeof n||la(n)&&me(n)==Gn}function da(n){if(!la(n)||me(n)!=Jn)return!1;var t=Wl(n);if(null===t)return!0;var r=ml.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&wl.call(r)==kl}function ba(n){return fa(n)&&n>=-Sn&&n<=Sn}function wa(n){return"string"==typeof n||!mh(n)&&la(n)&&me(n)==tt}function ma(n){return"symbol"==typeof n||la(n)&&me(n)==rt}function xa(n){return n===X}function ja(n){return la(n)&&Ss(n)==ut}function Aa(n){return la(n)&&me(n)==it}function ka(n){if(!n)return[];if(Yf(n))return wa(n)?H(n):Mu(n);if(Tl&&n[Tl])return M(n[Tl]());var t=Ss(n),r=t==Vn?F:t==nt?q:uc;return r(n)}function Oa(n){if(!n)return 0===n?n:0;if(n=za(n),n===En||n===-En){var t=n<0?-1:1;return t*Wn}return n===n?n:0}function Ia(n){var t=Oa(n),r=t%1;return t===t?r?t-r:t:0}function Ra(n){return n?Fr(Ia(n),0,Cn):0}function za(n){if("number"==typeof n)return n;if(ma(n))return Ln;if(ca(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=ca(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(Lt,"");var r=qt.test(n);return r||Kt.test(n)?Xr(n.slice(2),r?2:8):Pt.test(n)?Ln:+n}function Ea(n){return Fu(n,Ka(n))}function Sa(n){return n?Fr(Ia(n),-Sn,Sn):0===n?n:0}function Wa(n){return null==n?"":gu(n)}function La(n,t){var r=ds(n);return null==t?r:Ur(r,t)}function Ca(n,t){return y(n,Ai(t,3),oe)}function Ua(n,t){return y(n,Ai(t,3),fe)}function Ba(n,t){return null==n?n:ms(n,Ai(t,3),Ka)}function Ta(n,t){return null==n?n:xs(n,Ai(t,3),Ka)}function $a(n,t){return n&&oe(n,Ai(t,3))}function Da(n,t){return n&&fe(n,Ai(t,3))}function Ma(n){return null==n?[]:ve(n,Za(n))}function Fa(n){return null==n?[]:ve(n,Ka(n))}function Na(n,t,r){var e=null==n?X:de(n,t);return e===X?r:e}function Pa(n,t){return null!=n&&Si(n,t,je)}function qa(n,t){return null!=n&&Si(n,t,Ae)}function Za(n){return Yf(n)?Ir(n):Fe(n)}function Ka(n){return Yf(n)?Ir(n,!0):Ne(n)}function Va(n,t){var r={};return t=Ai(t,3),oe(n,function(n,e,u){Tr(r,t(n,e,u),n)}),r}function Ga(n,t){var r={};return t=Ai(t,3),oe(n,function(n,e,u){Tr(r,e,t(n,e,u))}),r}function Ha(n,t){return Ja(n,Tf(Ai(t)))}function Ja(n,t){if(null==n)return{};var r=l(mi(n),function(n){return[n]});return t=Ai(t),Qe(n,r,function(n,r){return t(n,r[0])})}function Ya(n,t,r){t=Ou(t,n);var e=-1,u=t.length;for(u||(u=1,n=X);++e<u;){var i=null==n?X:n[ro(t[e])];i===X&&(e=u,i=r),n=oa(i)?i.call(n):i}return n}function Qa(n,t,r){return null==n?n:au(n,t,r)}function Xa(n,t,r,e){return e="function"==typeof e?e:X,null==n?n:au(n,t,r,e)}function nc(n,t,r){var e=mh(n),i=e||jh(n)||Rh(n);if(t=Ai(t,4),null==r){var o=n&&n.constructor;r=i?e?new o:[]:ca(n)&&oa(o)?ds(Wl(n)):{}}return(i?u:oe)(n,function(n,e,u){return t(r,n,e,u)}),r}function tc(n,t){return null==n||du(n,t)}function rc(n,t,r){return null==n?n:bu(n,t,ku(r))}function ec(n,t,r,e){return e="function"==typeof e?e:X,null==n?n:bu(n,t,ku(r),e)}function uc(n){return null==n?[]:S(n,Za(n))}function ic(n){return null==n?[]:S(n,Ka(n))}function oc(n,t,r){return r===X&&(r=t,t=X),r!==X&&(r=za(r),r=r===r?r:0),t!==X&&(t=za(t),t=t===t?t:0),Fr(za(n),t,r)}function fc(n,t,r){return t=Oa(t),r===X?(r=t,t=0):r=Oa(r),n=za(n),ke(n,t,r)}function ac(n,t,r){if(r&&"boolean"!=typeof r&&$i(n,t,r)&&(t=r=X),r===X&&("boolean"==typeof t?(r=t,t=X):"boolean"==typeof n&&(r=n,n=X)),n===X&&t===X?(n=0,t=1):(n=Oa(n),t===X?(t=n,n=0):t=Oa(t)),n>t){var e=n;n=t,t=e}if(r||n%1||t%1){var u=ns();return Yl(n+u*(t-n+Qr("1e-"+((u+"").length-1))),t)}return ru(n,t)}function cc(n){return np(Wa(n).toLowerCase())}function lc(n){return n=Wa(n),n&&n.replace(Gt,_e).replace(Dr,"")}function sc(n,t,r){n=Wa(n),t=gu(t);var e=n.length;r=r===X?e:Fr(Ia(r),0,e);var u=r;return r-=t.length,r>=0&&n.slice(r,u)==t}function hc(n){return n=Wa(n),n&&jt.test(n)?n.replace(mt,ge):n}function pc(n){return n=Wa(n),n&&Wt.test(n)?n.replace(St,"\\$&"):n}function vc(n,t,r){n=Wa(n),t=Ia(t);var e=t?G(n):0;if(!t||e>=t)return n;var u=(t-e)/2;return ii(ql(u),r)+n+ii(Pl(u),r)}function _c(n,t,r){n=Wa(n),t=Ia(t);var e=t?G(n):0;return t&&e<t?n+ii(t-e,r):n}function gc(n,t,r){n=Wa(n),t=Ia(t);var e=t?G(n):0;return t&&e<t?ii(t-e,r)+n:n}function yc(n,t,r){return r||null==t?t=0:t&&(t=+t),Xl(Wa(n).replace(Ct,""),t||0)}function dc(n,t,r){return t=(r?$i(n,t,r):t===X)?1:Ia(t),uu(Wa(n),t)}function bc(){var n=arguments,t=Wa(n[0]);return n.length<3?t:t.replace(n[1],n[2])}function wc(n,t,r){return r&&"number"!=typeof r&&$i(n,t,r)&&(t=r=X),(r=r===X?Cn:r>>>0)?(n=Wa(n),n&&("string"==typeof t||null!=t&&!Oh(t))&&(t=gu(t),!t&&$(n))?Iu(H(n),0,r):n.split(t,r)):[]}function mc(n,t,r){return n=Wa(n),r=null==r?0:Fr(Ia(r),0,n.length),t=gu(t),n.slice(r,r+t.length)==t}function xc(n,t,r){var e=K.templateSettings;r&&$i(n,t,r)&&(t=X),n=Wa(n),t=Lh({},t,e,pi);var u,i,o=Lh({},t.imports,e.imports,pi),f=Za(o),a=S(o,f),c=0,l=t.interpolate||Ht,s="__p += '",h=pl((t.escape||Ht).source+"|"+l.source+"|"+(l===Ot?Ft:Ht).source+"|"+(t.evaluate||Ht).source+"|$","g"),p="//# sourceURL="+("sourceURL"in t?t.sourceURL:"lodash.templateSources["+ ++Zr+"]")+"\n";n.replace(h,function(t,r,e,o,f,a){return e||(e=o),s+=n.slice(c,a).replace(Jt,B),r&&(u=!0,s+="' +\n__e("+r+") +\n'"),f&&(i=!0,s+="';\n"+f+";\n__p += '"),e&&(s+="' +\n((__t = ("+e+")) == null ? '' : __t) +\n'"),c=a+t.length,t}),s+="';\n";var v=t.variable;v||(s="with (obj) {\n"+s+"\n}\n"),s=(i?s.replace(yt,""):s).replace(dt,"$1").replace(bt,"$1;"),s="function("+(v||"obj")+") {\n"+(v?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(u?", __e = _.escape":"")+(i?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+s+"return __p\n}";var _=tp(function(){return ll(f,p+"return "+s).apply(X,a)});if(_.source=s,ua(_))throw _;return _}function jc(n){return Wa(n).toLowerCase()}function Ac(n){return Wa(n).toUpperCase()}function kc(n,t,r){if(n=Wa(n),n&&(r||t===X))return n.replace(Lt,"");if(!n||!(t=gu(t)))return n;var e=H(n),u=H(t),i=L(e,u),o=C(e,u)+1;return Iu(e,i,o).join("")}function Oc(n,t,r){if(n=Wa(n),n&&(r||t===X))return n.replace(Ut,"");if(!n||!(t=gu(t)))return n;var e=H(n),u=C(e,H(t))+1;return Iu(e,0,u).join("")}function Ic(n,t,r){if(n=Wa(n),n&&(r||t===X))return n.replace(Ct,"");if(!n||!(t=gu(t)))return n;var e=H(n),u=L(e,H(t));return Iu(e,u).join("")}function Rc(n,t){var r=jn,e=An;if(ca(t)){var u="separator"in t?t.separator:u;r="length"in t?Ia(t.length):r,e="omission"in t?gu(t.omission):e}n=Wa(n);var i=n.length;if($(n)){var o=H(n);i=o.length}if(r>=i)return n;var f=r-G(e);if(f<1)return e;var a=o?Iu(o,0,f).join(""):n.slice(0,f);if(u===X)return a+e;if(o&&(f+=a.length-f),Oh(u)){if(n.slice(f).search(u)){var c,l=a;for(u.global||(u=pl(u.source,Wa(Nt.exec(u))+"g")),u.lastIndex=0;c=u.exec(l);)var s=c.index;a=a.slice(0,s===X?f:s)}}else if(n.indexOf(gu(u),f)!=f){var h=a.lastIndexOf(u);h>-1&&(a=a.slice(0,h))}return a+e}function zc(n){return n=Wa(n),n&&xt.test(n)?n.replace(wt,ye):n}function Ec(n,t,r){return n=Wa(n),t=r?X:t,t===X?D(n)?Q(n):g(n):n.match(t)||[]}function Sc(n){var t=null==n?0:n.length,e=Ai();return n=t?l(n,function(n){if("function"!=typeof n[1])throw new _l(en);return[e(n[0]),n[1]]}):[],iu(function(e){for(var u=-1;++u<t;){var i=n[u];if(r(i[0],this,e))return r(i[1],this,e)}})}function Wc(n){return Pr(Nr(n,an))}function Lc(n){return function(){return n}}function Cc(n,t){return null==n||n!==n?t:n}function Uc(n){return n}function Bc(n){return Me("function"==typeof n?n:Nr(n,an))}function Tc(n){return Ze(Nr(n,an))}function $c(n,t){return Ke(n,Nr(t,an))}function Dc(n,t,r){var e=Za(t),i=ve(t,e);null!=r||ca(t)&&(i.length||!e.length)||(r=t,t=n,n=this,i=ve(t,Za(t)));var o=!(ca(r)&&"chain"in r&&!r.chain),f=oa(n);return u(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__),u=r.__actions__=Mu(this.__actions__);return u.push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,s([this.value()],arguments))})}),n}function Mc(){return re._===this&&(re._=Ol),this}function Fc(){}function Nc(n){return n=Ia(n),iu(function(t){return He(t,n)})}function Pc(n){return Di(n)?j(ro(n)):Xe(n)}function qc(n){return function(t){return null==n?X:de(n,t)}}function Zc(){return[]}function Kc(){return!1}function Vc(){return{}}function Gc(){return""}function Hc(){return!0}function Jc(n,t){if(n=Ia(n),n<1||n>Sn)return[];var r=Cn,e=Yl(n,Cn);t=Ai(t),n-=Cn;for(var u=R(e,t);++r<n;)t(r);return u}function Yc(n){return mh(n)?l(n,ro):ma(n)?[n]:Mu(Bs(Wa(n)))}function Qc(n){var t=++xl;return Wa(n)+t}function Xc(n){return n&&n.length?ne(n,Uc,xe):X}function nl(n,t){return n&&n.length?ne(n,Ai(t,2),xe):X}function tl(n){return x(n,Uc)}function rl(n,t){return x(n,Ai(t,2))}function el(n){return n&&n.length?ne(n,Uc,Pe):X}function ul(n,t){return n&&n.length?ne(n,Ai(t,2),Pe):X}function il(n){return n&&n.length?I(n,Uc):0}function ol(n,t){return n&&n.length?I(n,Ai(t,2)):0}A=null==A?re:be.defaults(re.Object(),A,be.pick(re,qr));var fl=A.Array,al=A.Date,cl=A.Error,ll=A.Function,sl=A.Math,hl=A.Object,pl=A.RegExp,vl=A.String,_l=A.TypeError,gl=fl.prototype,yl=ll.prototype,dl=hl.prototype,bl=A["__core-js_shared__"],wl=yl.toString,ml=dl.hasOwnProperty,xl=0,jl=function(){var n=/[^.]+$/.exec(bl&&bl.keys&&bl.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),Al=dl.toString,kl=wl.call(hl),Ol=re._,Il=pl("^"+wl.call(ml).replace(St,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Rl=ie?A.Buffer:X,zl=A.Symbol,El=A.Uint8Array,Sl=Rl?Rl.allocUnsafe:X,Wl=N(hl.getPrototypeOf,hl),Ll=hl.create,Cl=dl.propertyIsEnumerable,Ul=gl.splice,Bl=zl?zl.isConcatSpreadable:X,Tl=zl?zl.iterator:X,$l=zl?zl.toStringTag:X,Dl=function(){try{var n=Ii(hl,"defineProperty");return n({},"",{}),n}catch(n){}}(),Ml=A.clearTimeout!==re.clearTimeout&&A.clearTimeout,Fl=al&&al.now!==re.Date.now&&al.now,Nl=A.setTimeout!==re.setTimeout&&A.setTimeout,Pl=sl.ceil,ql=sl.floor,Zl=hl.getOwnPropertySymbols,Kl=Rl?Rl.isBuffer:X,Vl=A.isFinite,Gl=gl.join,Hl=N(hl.keys,hl),Jl=sl.max,Yl=sl.min,Ql=al.now,Xl=A.parseInt,ns=sl.random,ts=gl.reverse,rs=Ii(A,"DataView"),es=Ii(A,"Map"),us=Ii(A,"Promise"),is=Ii(A,"Set"),os=Ii(A,"WeakMap"),fs=Ii(hl,"create"),as=os&&new os,cs={},ls=eo(rs),ss=eo(es),hs=eo(us),ps=eo(is),vs=eo(os),_s=zl?zl.prototype:X,gs=_s?_s.valueOf:X,ys=_s?_s.toString:X,ds=function(){function n(){}return function(t){if(!ca(t))return{};if(Ll)return Ll(t);n.prototype=t;var r=new n;return n.prototype=X,r}}();K.templateSettings={escape:At,evaluate:kt,interpolate:Ot,variable:"",imports:{_:K}},K.prototype=J.prototype,K.prototype.constructor=K,Y.prototype=ds(J.prototype),Y.prototype.constructor=Y,Dt.prototype=ds(J.prototype),Dt.prototype.constructor=Dt,nr.prototype.clear=tr,nr.prototype.delete=rr,nr.prototype.get=er,nr.prototype.has=ur,nr.prototype.set=ir,or.prototype.clear=fr,or.prototype.delete=ar,or.prototype.get=cr,or.prototype.has=lr,or.prototype.set=sr,hr.prototype.clear=pr,hr.prototype.delete=vr,hr.prototype.get=_r,hr.prototype.has=gr,hr.prototype.set=yr,dr.prototype.add=dr.prototype.push=br,dr.prototype.has=wr,mr.prototype.clear=xr,mr.prototype.delete=jr,mr.prototype.get=Ar,mr.prototype.has=kr,mr.prototype.set=Or;var bs=Ku(oe),ws=Ku(fe,!0),ms=Vu(),xs=Vu(!0),js=as?function(n,t){return as.set(n,t),n}:Uc,As=Dl?function(n,t){return Dl(n,"toString",{configurable:!0,enumerable:!1,value:Lc(t),writable:!0})}:Uc,ks=iu,Os=Ml||function(n){return re.clearTimeout(n)},Is=is&&1/q(new is([,-0]))[1]==En?function(n){return new is(n)}:Fc,Rs=as?function(n){return as.get(n)}:Fc,zs=Zl?function(n){return null==n?[]:(n=hl(n),f(Zl(n),function(t){return Cl.call(n,t)}))}:Zc,Es=Zl?function(n){for(var t=[];n;)s(t,zs(n)),n=Wl(n);return t}:Zc,Ss=me;(rs&&Ss(new rs(new ArrayBuffer(1)))!=ft||es&&Ss(new es)!=Vn||us&&Ss(us.resolve())!=Yn||is&&Ss(new is)!=nt||os&&Ss(new os)!=ut)&&(Ss=function(n){var t=me(n),r=t==Jn?n.constructor:X,e=r?eo(r):"";if(e)switch(e){case ls:return ft;case ss:return Vn;case hs:return Yn;case ps:return nt;case vs:return ut}return t});var Ws=bl?oa:Kc,Ls=no(js),Cs=Nl||function(n,t){return re.setTimeout(n,t)},Us=no(As),Bs=Ki(function(n){var t=[];return zt.test(n)&&t.push(""),n.replace(Et,function(n,r,e,u){t.push(e?u.replace(Mt,"$1"):r||n)}),t}),Ts=iu(function(n,t){return Qf(n)?Jr(n,ue(t,1,Qf,!0)):[]}),$s=iu(function(n,t){var r=ko(t);return Qf(r)&&(r=X),Qf(n)?Jr(n,ue(t,1,Qf,!0),Ai(r,2)):[]}),Ds=iu(function(n,t){var r=ko(t);return Qf(r)&&(r=X),Qf(n)?Jr(n,ue(t,1,Qf,!0),X,r):[]}),Ms=iu(function(n){var t=l(n,Au);return t.length&&t[0]===n[0]?Oe(t):[]}),Fs=iu(function(n){var t=ko(n),r=l(n,Au);return t===ko(r)?t=X:r.pop(),r.length&&r[0]===n[0]?Oe(r,Ai(t,2)):[]}),Ns=iu(function(n){var t=ko(n),r=l(n,Au);return t="function"==typeof t?t:X,t&&r.pop(),r.length&&r[0]===n[0]?Oe(r,X,t):[]}),Ps=iu(Ro),qs=bi(function(n,t){var r=null==n?0:n.length,e=Mr(n,t);return tu(n,l(t,function(n){return Ti(n,r)?+n:n}).sort(Bu)),e}),Zs=iu(function(n){return yu(ue(n,1,Qf,!0))}),Ks=iu(function(n){var t=ko(n);return Qf(t)&&(t=X),yu(ue(n,1,Qf,!0),Ai(t,2))}),Vs=iu(function(n){var t=ko(n);return t="function"==typeof t?t:X,yu(ue(n,1,Qf,!0),X,t)}),Gs=iu(function(n,t){return Qf(n)?Jr(n,t):[]}),Hs=iu(function(n){return xu(f(n,Qf))}),Js=iu(function(n){var t=ko(n);return Qf(t)&&(t=X),xu(f(n,Qf),Ai(t,2))}),Ys=iu(function(n){var t=ko(n);return t="function"==typeof t?t:X,xu(f(n,Qf),X,t)}),Qs=iu(Jo),Xs=iu(function(n){var t=n.length,r=t>1?n[t-1]:X;return r="function"==typeof r?(n.pop(),r):X,Yo(n,r)}),nh=bi(function(n){var t=n.length,r=t?n[0]:0,e=this.__wrapped__,u=function(t){return Mr(t,n)};return!(t>1||this.__actions__.length)&&e instanceof Dt&&Ti(r)?(e=e.slice(r,+r+(t?1:0)),e.__actions__.push({func:rf,args:[u],thisArg:X}),new Y(e,this.__chain__).thru(function(n){return t&&!n.length&&n.push(X),n})):this.thru(u)}),th=qu(function(n,t,r){ml.call(n,r)?++n[r]:Tr(n,r,1)}),rh=Xu(vo),eh=Xu(_o),uh=qu(function(n,t,r){ml.call(n,r)?n[r].push(t):Tr(n,r,[t])}),ih=iu(function(n,t,e){var u=-1,i="function"==typeof t,o=Yf(n)?fl(n.length):[];return bs(n,function(n){o[++u]=i?r(t,n,e):Re(n,t,e)}),o}),oh=qu(function(n,t,r){Tr(n,r,t)}),fh=qu(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),ah=iu(function(n,t){if(null==n)return[];var r=t.length;return r>1&&$i(n,t[0],t[1])?t=[]:r>2&&$i(t[0],t[1],t[2])&&(t=[t[0]]),Je(n,ue(t,1),[])}),ch=Fl||function(){return re.Date.now()},lh=iu(function(n,t,r){var e=pn;if(r.length){var u=P(r,ji(lh));e|=dn}return hi(n,e,t,r,u)}),sh=iu(function(n,t,r){var e=pn|vn;if(r.length){var u=P(r,ji(sh));e|=dn}return hi(t,e,n,r,u)}),hh=iu(function(n,t){return Hr(n,1,t)}),ph=iu(function(n,t,r){return Hr(n,za(t)||0,r)});Bf.Cache=hr;var vh=ks(function(n,t){t=1==t.length&&mh(t[0])?l(t[0],E(Ai())):l(ue(t,1),E(Ai()));var e=t.length;return iu(function(u){for(var i=-1,o=Yl(u.length,e);++i<o;)u[i]=t[i].call(this,u[i]);return r(n,this,u)})}),_h=iu(function(n,t){var r=P(t,ji(_h));return hi(n,dn,X,t,r)}),gh=iu(function(n,t){var r=P(t,ji(gh));return hi(n,bn,X,t,r)}),yh=bi(function(n,t){return hi(n,mn,X,X,X,t)}),dh=ai(xe),bh=ai(function(n,t){return n>=t}),wh=ze(function(){return arguments}())?ze:function(n){return la(n)&&ml.call(n,"callee")&&!Cl.call(n,"callee")},mh=fl.isArray,xh=ae?E(ae):Ee,jh=Kl||Kc,Ah=ce?E(ce):Se,kh=le?E(le):Ce,Oh=se?E(se):Te,Ih=he?E(he):$e,Rh=pe?E(pe):De,zh=ai(Pe),Eh=ai(function(n,t){return n<=t}),Sh=Zu(function(n,t){if(Pi(t)||Yf(t))return void Fu(t,Za(t),n);for(var r in t)ml.call(t,r)&&Wr(n,r,t[r])}),Wh=Zu(function(n,t){Fu(t,Ka(t),n)}),Lh=Zu(function(n,t,r,e){Fu(t,Ka(t),n,e)}),Ch=Zu(function(n,t,r,e){Fu(t,Za(t),n,e)}),Uh=bi(Mr),Bh=iu(function(n){return n.push(X,pi),r(Lh,X,n)}),Th=iu(function(n){return n.push(X,vi),r(Nh,X,n)}),$h=ri(function(n,t,r){n[t]=r},Lc(Uc)),Dh=ri(function(n,t,r){ml.call(n,t)?n[t].push(r):n[t]=[r]},Ai),Mh=iu(Re),Fh=Zu(function(n,t,r){Ve(n,t,r)}),Nh=Zu(function(n,t,r,e){Ve(n,t,r,e)}),Ph=bi(function(n,t){var r={};if(null==n)return r;var e=!1;t=l(t,function(t){return t=Ou(t,n),e||(e=t.length>1),t}),Fu(n,mi(n),r),e&&(r=Nr(r,an|cn|ln,_i));for(var u=t.length;u--;)du(r,t[u]);return r}),qh=bi(function(n,t){return null==n?{}:Ye(n,t)}),Zh=si(Za),Kh=si(Ka),Vh=Ju(function(n,t,r){return t=t.toLowerCase(),n+(r?cc(t):t)}),Gh=Ju(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Hh=Ju(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Jh=Hu("toLowerCase"),Yh=Ju(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Qh=Ju(function(n,t,r){return n+(r?" ":"")+np(t)}),Xh=Ju(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),np=Hu("toUpperCase"),tp=iu(function(n,t){try{return r(n,X,t)}catch(n){return ua(n)?n:new cl(n)}}),rp=bi(function(n,t){return u(t,function(t){t=ro(t),Tr(n,t,lh(n[t],n))}),n}),ep=ni(),up=ni(!0),ip=iu(function(n,t){return function(r){return Re(r,n,t)}}),op=iu(function(n,t){return function(r){return Re(n,r,t)}}),fp=ui(l),ap=ui(o),cp=ui(v),lp=fi(),sp=fi(!0),hp=ei(function(n,t){return n+t},0),pp=li("ceil"),vp=ei(function(n,t){return n/t},1),_p=li("floor"),gp=ei(function(n,t){return n*t},1),yp=li("round"),dp=ei(function(n,t){return n-t},0);return K.after=zf,K.ary=Ef,K.assign=Sh,K.assignIn=Wh,K.assignInWith=Lh,K.assignWith=Ch,K.at=Uh,K.before=Sf,K.bind=lh,K.bindAll=rp,K.bindKey=sh,K.castArray=qf,K.chain=nf,K.chunk=oo,K.compact=fo,K.concat=ao,K.cond=Sc,K.conforms=Wc,K.constant=Lc,K.countBy=th,K.create=La,K.curry=Wf,K.curryRight=Lf,K.debounce=Cf,K.defaults=Bh,K.defaultsDeep=Th,K.defer=hh,K.delay=ph,K.difference=Ts,K.differenceBy=$s,K.differenceWith=Ds,K.drop=co,
K.dropRight=lo,K.dropRightWhile=so,K.dropWhile=ho,K.fill=po,K.filter=hf,K.flatMap=pf,K.flatMapDeep=vf,K.flatMapDepth=_f,K.flatten=go,K.flattenDeep=yo,K.flattenDepth=bo,K.flip=Uf,K.flow=ep,K.flowRight=up,K.fromPairs=wo,K.functions=Ma,K.functionsIn=Fa,K.groupBy=uh,K.initial=jo,K.intersection=Ms,K.intersectionBy=Fs,K.intersectionWith=Ns,K.invert=$h,K.invertBy=Dh,K.invokeMap=ih,K.iteratee=Bc,K.keyBy=oh,K.keys=Za,K.keysIn=Ka,K.map=bf,K.mapKeys=Va,K.mapValues=Ga,K.matches=Tc,K.matchesProperty=$c,K.memoize=Bf,K.merge=Fh,K.mergeWith=Nh,K.method=ip,K.methodOf=op,K.mixin=Dc,K.negate=Tf,K.nthArg=Nc,K.omit=Ph,K.omitBy=Ha,K.once=$f,K.orderBy=wf,K.over=fp,K.overArgs=vh,K.overEvery=ap,K.overSome=cp,K.partial=_h,K.partialRight=gh,K.partition=fh,K.pick=qh,K.pickBy=Ja,K.property=Pc,K.propertyOf=qc,K.pull=Ps,K.pullAll=Ro,K.pullAllBy=zo,K.pullAllWith=Eo,K.pullAt=qs,K.range=lp,K.rangeRight=sp,K.rearg=yh,K.reject=jf,K.remove=So,K.rest=Df,K.reverse=Wo,K.sampleSize=kf,K.set=Qa,K.setWith=Xa,K.shuffle=Of,K.slice=Lo,K.sortBy=ah,K.sortedUniq=Mo,K.sortedUniqBy=Fo,K.split=wc,K.spread=Mf,K.tail=No,K.take=Po,K.takeRight=qo,K.takeRightWhile=Zo,K.takeWhile=Ko,K.tap=tf,K.throttle=Ff,K.thru=rf,K.toArray=ka,K.toPairs=Zh,K.toPairsIn=Kh,K.toPath=Yc,K.toPlainObject=Ea,K.transform=nc,K.unary=Nf,K.union=Zs,K.unionBy=Ks,K.unionWith=Vs,K.uniq=Vo,K.uniqBy=Go,K.uniqWith=Ho,K.unset=tc,K.unzip=Jo,K.unzipWith=Yo,K.update=rc,K.updateWith=ec,K.values=uc,K.valuesIn=ic,K.without=Gs,K.words=Ec,K.wrap=Pf,K.xor=Hs,K.xorBy=Js,K.xorWith=Ys,K.zip=Qs,K.zipObject=Qo,K.zipObjectDeep=Xo,K.zipWith=Xs,K.entries=Zh,K.entriesIn=Kh,K.extend=Wh,K.extendWith=Lh,Dc(K,K),K.add=hp,K.attempt=tp,K.camelCase=Vh,K.capitalize=cc,K.ceil=pp,K.clamp=oc,K.clone=Zf,K.cloneDeep=Vf,K.cloneDeepWith=Gf,K.cloneWith=Kf,K.conformsTo=Hf,K.deburr=lc,K.defaultTo=Cc,K.divide=vp,K.endsWith=sc,K.eq=Jf,K.escape=hc,K.escapeRegExp=pc,K.every=sf,K.find=rh,K.findIndex=vo,K.findKey=Ca,K.findLast=eh,K.findLastIndex=_o,K.findLastKey=Ua,K.floor=_p,K.forEach=gf,K.forEachRight=yf,K.forIn=Ba,K.forInRight=Ta,K.forOwn=$a,K.forOwnRight=Da,K.get=Na,K.gt=dh,K.gte=bh,K.has=Pa,K.hasIn=qa,K.head=mo,K.identity=Uc,K.includes=df,K.indexOf=xo,K.inRange=fc,K.invoke=Mh,K.isArguments=wh,K.isArray=mh,K.isArrayBuffer=xh,K.isArrayLike=Yf,K.isArrayLikeObject=Qf,K.isBoolean=Xf,K.isBuffer=jh,K.isDate=Ah,K.isElement=na,K.isEmpty=ta,K.isEqual=ra,K.isEqualWith=ea,K.isError=ua,K.isFinite=ia,K.isFunction=oa,K.isInteger=fa,K.isLength=aa,K.isMap=kh,K.isMatch=sa,K.isMatchWith=ha,K.isNaN=pa,K.isNative=va,K.isNil=ga,K.isNull=_a,K.isNumber=ya,K.isObject=ca,K.isObjectLike=la,K.isPlainObject=da,K.isRegExp=Oh,K.isSafeInteger=ba,K.isSet=Ih,K.isString=wa,K.isSymbol=ma,K.isTypedArray=Rh,K.isUndefined=xa,K.isWeakMap=ja,K.isWeakSet=Aa,K.join=Ao,K.kebabCase=Gh,K.last=ko,K.lastIndexOf=Oo,K.lowerCase=Hh,K.lowerFirst=Jh,K.lt=zh,K.lte=Eh,K.max=Xc,K.maxBy=nl,K.mean=tl,K.meanBy=rl,K.min=el,K.minBy=ul,K.stubArray=Zc,K.stubFalse=Kc,K.stubObject=Vc,K.stubString=Gc,K.stubTrue=Hc,K.multiply=gp,K.nth=Io,K.noConflict=Mc,K.noop=Fc,K.now=ch,K.pad=vc,K.padEnd=_c,K.padStart=gc,K.parseInt=yc,K.random=ac,K.reduce=mf,K.reduceRight=xf,K.repeat=dc,K.replace=bc,K.result=Ya,K.round=yp,K.runInContext=_,K.sample=Af,K.size=If,K.snakeCase=Yh,K.some=Rf,K.sortedIndex=Co,K.sortedIndexBy=Uo,K.sortedIndexOf=Bo,K.sortedLastIndex=To,K.sortedLastIndexBy=$o,K.sortedLastIndexOf=Do,K.startCase=Qh,K.startsWith=mc,K.subtract=dp,K.sum=il,K.sumBy=ol,K.template=xc,K.times=Jc,K.toFinite=Oa,K.toInteger=Ia,K.toLength=Ra,K.toLower=jc,K.toNumber=za,K.toSafeInteger=Sa,K.toString=Wa,K.toUpper=Ac,K.trim=kc,K.trimEnd=Oc,K.trimStart=Ic,K.truncate=Rc,K.unescape=zc,K.uniqueId=Qc,K.upperCase=Xh,K.upperFirst=np,K.each=gf,K.eachRight=yf,K.first=mo,Dc(K,function(){var n={};return oe(K,function(t,r){ml.call(K.prototype,r)||(n[r]=t)}),n}(),{chain:!1}),K.VERSION=nn,u(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){K[n].placeholder=K}),u(["drop","take"],function(n,t){Dt.prototype[n]=function(r){r=r===X?1:Jl(Ia(r),0);var e=this.__filtered__&&!t?new Dt(this):this.clone();return e.__filtered__?e.__takeCount__=Yl(r,e.__takeCount__):e.__views__.push({size:Yl(r,Cn),type:n+(e.__dir__<0?"Right":"")}),e},Dt.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),u(["filter","map","takeWhile"],function(n,t){var r=t+1,e=r==In||r==zn;Dt.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:Ai(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),u(["head","last"],function(n,t){var r="take"+(t?"Right":"");Dt.prototype[n]=function(){return this[r](1).value()[0]}}),u(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Dt.prototype[n]=function(){return this.__filtered__?new Dt(this):this[r](1)}}),Dt.prototype.compact=function(){return this.filter(Uc)},Dt.prototype.find=function(n){return this.filter(n).head()},Dt.prototype.findLast=function(n){return this.reverse().find(n)},Dt.prototype.invokeMap=iu(function(n,t){return"function"==typeof n?new Dt(this):this.map(function(r){return Re(r,n,t)})}),Dt.prototype.reject=function(n){return this.filter(Tf(Ai(n)))},Dt.prototype.slice=function(n,t){n=Ia(n);var r=this;return r.__filtered__&&(n>0||t<0)?new Dt(r):(n<0?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==X&&(t=Ia(t),r=t<0?r.dropRight(-t):r.take(t-n)),r)},Dt.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Dt.prototype.toArray=function(){return this.take(Cn)},oe(Dt.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=K[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(K.prototype[t]=function(){var t=this.__wrapped__,o=e?[1]:arguments,f=t instanceof Dt,a=o[0],c=f||mh(t),l=function(n){var t=u.apply(K,s([n],o));return e&&h?t[0]:t};c&&r&&"function"==typeof a&&1!=a.length&&(f=c=!1);var h=this.__chain__,p=!!this.__actions__.length,v=i&&!h,_=f&&!p;if(!i&&c){t=_?t:new Dt(this);var g=n.apply(t,o);return g.__actions__.push({func:rf,args:[l],thisArg:X}),new Y(g,h)}return v&&_?n.apply(this,o):(g=this.thru(l),v?e?g.value()[0]:g.value():g)})}),u(["pop","push","shift","sort","splice","unshift"],function(n){var t=gl[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);K.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(mh(u)?u:[],n)}return this[r](function(r){return t.apply(mh(r)?r:[],n)})}}),oe(Dt.prototype,function(n,t){var r=K[t];if(r){var e=r.name+"",u=cs[e]||(cs[e]=[]);u.push({name:t,func:r})}}),cs[ti(X,vn).name]=[{name:"wrapper",func:X}],Dt.prototype.clone=Yt,Dt.prototype.reverse=Qt,Dt.prototype.value=Xt,K.prototype.at=nh,K.prototype.chain=ef,K.prototype.commit=uf,K.prototype.next=of,K.prototype.plant=af,K.prototype.reverse=cf,K.prototype.toJSON=K.prototype.valueOf=K.prototype.value=lf,K.prototype.first=K.prototype.head,Tl&&(K.prototype[Tl]=ff),K},be=de();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(re._=be,define(function(){return be})):ue?((ue.exports=be)._=be,ee._=be):re._=be}).call(this);
</script>

<script type="text/javascript">
var saveAs=saveAs||"undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob&&navigator.msSaveOrOpenBlob.bind(navigator)||function(e){"use strict";if("undefined"==typeof navigator||!/MSIE [1-9]\./.test(navigator.userAgent)){var t=e.document,n=function(){return e.URL||e.webkitURL||e},o=t.createElementNS("http://www.w3.org/1999/xhtml","a"),r=!e.externalHost&&"download"in o,i=function(n){var o=t.createEvent("MouseEvents");o.initMouseEvent("click",!0,!1,e,0,0,0,0,0,!1,!1,!1,!1,0,null),n.dispatchEvent(o)},a=e.webkitRequestFileSystem,u=e.requestFileSystem||a||e.mozRequestFileSystem,c=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},d="application/octet-stream",f=0,s=[],l=function(){for(var e=s.length;e--;){var t=s[e];"string"==typeof t?n().revokeObjectURL(t):t.remove()}s.length=0},v=function(e,t,n){t=[].concat(t);for(var o=t.length;o--;){var r=e["on"+t[o]];if("function"==typeof r)try{r.call(e,n||e)}catch(e){c(e)}}},w=function(t,c){var l,w,p,y=this,m=t.type,h=!1,E=function(){var e=n().createObjectURL(t);return s.push(e),e},g=function(){v(y,"writestart progress write writeend".split(" "))},O=function(){!h&&l||(l=E(t)),w?w.location.href=l:window.open(l,"_blank"),y.readyState=y.DONE,g()},S=function(e){return function(){if(y.readyState!==y.DONE)return e.apply(this,arguments)}},R={create:!0,exclusive:!1};return y.readyState=y.INIT,c||(c="download"),r?(l=E(t),o.href=l,o.download=c,i(o),y.readyState=y.DONE,void g()):(e.chrome&&m&&m!==d&&(p=t.slice||t.webkitSlice,t=p.call(t,0,t.size,d),h=!0),a&&"download"!==c&&(c+=".download"),(m===d||a)&&(w=e),u?(f+=t.size,void u(e.TEMPORARY,f,S(function(e){e.root.getDirectory("saved",R,S(function(e){var n=function(){e.getFile(c,R,S(function(e){e.createWriter(S(function(n){n.onwriteend=function(t){w.location.href=e.toURL(),s.push(e),y.readyState=y.DONE,v(y,"writeend",t)},n.onerror=function(){var e=n.error;e.code!==e.ABORT_ERR&&O()},"writestart progress write abort".split(" ").forEach(function(e){n["on"+e]=y["on"+e]}),n.write(t),y.abort=function(){n.abort(),y.readyState=y.DONE},y.readyState=y.WRITING}),O)}),O)};e.getFile(c,{create:!1},S(function(e){e.remove(),n()}),S(function(e){e.code===e.NOT_FOUND_ERR?n():O()}))}),O)}),O)):void O())},p=w.prototype,y=function(e,t){return new w(e,t)};return p.abort=function(){var e=this;e.readyState=e.DONE,v(e,"abort")},p.readyState=p.INIT=0,p.WRITING=1,p.DONE=2,p.error=p.onwritestart=p.onprogress=p.onwrite=p.onabort=p.onerror=p.onwriteend=null,e.addEventListener("unload",l,!1),y.unload=function(){l(),e.removeEventListener("unload",l,!1)},y}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this.content);"undefined"!=typeof module&&null!==module?module.exports=saveAs:"undefined"!=typeof define&&null!==define&&null!=define.amd&&define([],function(){return saveAs});
</script>

<script type="text/javascript">
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.himalaya=t()}}(function(){return function t(e,r,n){function a(s,i){if(!r[s]){if(!e[s]){var u="function"==typeof require&&require;if(!i&&u)return u(s,!0);if(o)return o(s,!0);var c=new Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var f=r[s]={exports:{}};e[s][0].call(f.exports,function(t){var r=e[s][1][t];return a(r?r:t)},f,f.exports,t,e,r,n)}return r[s].exports}for(var o="function"==typeof require&&require,s=0;s<n.length;s++)a(n[s]);return a}({1:[function(t,e,r){"use strict";function n(t,e,r){return t.substr(r||0,e.length)===e}function a(t,e,r){var n=(r||t.length)-e.length,a=t.lastIndexOf(e,n);return a!==-1&&a===n}function o(t,e,r){return t.indexOf(e,r||0)!==-1}function s(t){return"number"==typeof t&&isNaN(t)}function i(t,e,r){var n=t.length;if(0===n)return!1;for(var a=0|r,o=s(e),i=a>=0?a:n+a;i<n;){var u=t[i++];if(u===e)return!0;if(o&&s(u))return!0}return!1}Object.defineProperty(r,"__esModule",{value:!0}),r.startsWith=n,r.endsWith=a,r.stringIncludes=o,r.isRealNaN=s,r.arrayIncludes=i},{}],2:[function(t,e,r){"use strict";function n(t){return t.map(function(t){var e=a(t.type);if("Element"===e){var r=t.tagName.toLowerCase(),o=c(t.attributes),s=n(t.children);return{type:e,tagName:r,attributes:o,children:s}}return{type:e,content:t.content}})}function a(t){return t.charAt(0).toUpperCase()+t.slice(1)}function o(t){return t.split("-").reduce(function(t,e){return t+e.charAt(0).toUpperCase()+e.slice(1)})}function s(t){if("string"!=typeof t)return t;if(""===t)return t;var e=+t;return isNaN(e)?t:e}function i(t){var e=t.charAt(0),r=t.length-1;return'"'===e||"'"===e&&e===t.charAt(r)?t.slice(1,r):t}function u(t,e){var r=t.indexOf(e);return r===-1?[t]:[t.slice(0,r),t.slice(r+e.length)]}function c(t){return t.reduce(function(t,e){var r=u(e.trim(),"="),n=l(r,2),a=n[0],c=n[1];if(c=c?i(c):a,"class"===a)t.className=c.split(" ");else if("style"===a)t.style=f(c);else if((0,p.startsWith)(a,"data-")){t.dataset=t.dataset||{};var v=o(a.slice(5));t.dataset[v]=s(c)}else t[o(a)]=s(c);return t},{})}function f(t){return t.trim().split(";").map(function(t){return t.trim().split(":")}).reduce(function(t,e){var r=l(e,2),n=r[0],a=r[1];if(a){var i=o(n.trim()),u=s(a.trim());t[i]=u}return t},{})}Object.defineProperty(r,"__esModule",{value:!0});var l=function(){function t(t,e){var r=[],n=!0,a=!1,o=void 0;try{for(var s,i=t[Symbol.iterator]();!(n=(s=i.next()).done)&&(r.push(s.value),!e||r.length!==e);n=!0);}catch(t){a=!0,o=t}finally{try{!n&&i.return&&i.return()}finally{if(a)throw o}}return r}return function(e,r){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();r.default=n,r.capitialize=a,r.camelCase=o,r.castValue=s,r.unquote=i,r.splitHead=u,r.formatAttributes=c,r.formatStyles=f;var p=t("../compat")},{"../compat":1}],3:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d,r=(0,s.default)(t,e),n=(0,u.default)(r,e);return(0,f.default)(n,e)}Object.defineProperty(r,"__esModule",{value:!0}),r.parseDefaults=void 0,r.parse=a;var o=t("./lexer"),s=n(o),i=t("./parser"),u=n(i),c=t("./formats/v0"),f=n(c),l=["style","script","template"],p=["html","head","body","p","dt","dd","li","option","thead","th","tbody","tr","td","tfoot","colgroup"],v=["!doctype","area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"],d=r.parseDefaults={voidTags:v,closingTags:p,childlessTags:l,format:f.default};r.default={parse:a,parseDefaults:d}},{"./formats/v0":2,"./lexer":4,"./parser":5}],4:[function(t,e,r){"use strict";function n(t){if(Array.isArray(t)){for(var e=0,r=Array(t.length);e<t.length;e++)r[e]=t[e];return r}return Array.from(t)}function a(t,e){var r={str:t,options:e,cursor:0,tokens:[]};return o(r),r.tokens}function o(t){for(var e=t.str,r=e.length;t.cursor<r;){var n="<"!==e.charAt(t.cursor);if(n)s(t);else{var a=(0,p.startsWith)(e,"!--",t.cursor+1);if(a)i(t);else{var o=u(t);if(o){var c=o.toLowerCase(),f=t.options.childlessTags;(0,p.arrayIncludes)(f,c)&&l(o,t)}}}}}function s(t){var e=t.str,r=t.cursor,n=e.indexOf("<",r),a="text";if(n===-1){var o=e.slice(r);return t.cursor=e.length,void t.tokens.push({type:a,content:o})}if(n!==r){var s=e.slice(r,n);t.cursor=n,t.tokens.push({type:a,content:s})}}function i(t){t.cursor+=4;var e=t.str,r=t.cursor,n=e.indexOf("--\x3e",r),a="comment";if(n===-1){var o=e.slice(r);return t.cursor=e.length,void t.tokens.push({type:a,content:o})}var s=e.slice(r,n);t.cursor=n+3,t.tokens.push({type:a,content:s})}function u(t){var e=t.str,r=e.charAt(t.cursor+1),n="/"===r;t.tokens.push({type:"tag-start",close:n}),t.cursor+=n?2:1;var a=c(t);f(t);var o=e.charAt(t.cursor),s="/"===o;return t.tokens.push({type:"tag-end",close:s}),t.cursor+=s?2:1,a}function c(t){for(var e=t.str,r=t.cursor,n=e.length,a=r;a<n;){var o=e.charAt(a),s=!(" "===o||"/"===o||">"===o);if(s)break;a++}for(var i=a+1;i<n;){var u=e.charAt(i),c=!(" "===u||"/"===u||">"===u);if(!c)break;i++}t.cursor=i;var f=e.slice(a,i);return t.tokens.push({type:"tag",content:f}),f}function f(t){for(var e=t.str,r=t.tokens,n=t.cursor,a=null,o=n,s=[],i=e.length;n<i;){var u=e.charAt(n);if(a){var c=u===a;c&&(a=null),n++}else{var f="/"===u||">"===u;if(f){n!==o&&s.push(e.slice(o,n));break}var l=" "===u;if(l)n!==o&&s.push(e.slice(o,n)),o=n+1,n++;else{var v="'"===u||'"'===u;v?(a=u,n++):n++}}}t.cursor=n;for(var d=s.length,h="attribute",y=0;y<d;y++){var g=s[y];if(g&&g.length){var m=g.indexOf("=")===-1;if(m){var b=s[y+1];if(b&&(0,p.startsWith)(b,"=")){if(b.length>1){var k=g+b;r.push({type:h,content:k}),y+=1;continue}var x=s[y+2];if(y+=1,x){var A=g+"="+x;r.push({type:h,content:A}),y+=1;continue}}}if((0,p.endsWith)(g,"=")){var N=s[y+1];if(N&&!(0,p.stringIncludes)(N,"=")){var O=g+N;r.push({type:h,content:O}),y+=1;continue}var w=g.slice(0,-1);r.push({type:h,content:w})}else r.push({type:h,content:g})}}}function l(t,e){for(var r=e.str,a=e.cursor,o=e.tokens,i=r.length,u=a;u<i;){var l=r.indexOf("</",u);if(l===-1){s(e);break}var p={str:r,cursor:l+2,tokens:[]},v=c(p),d=t.toLowerCase();if(d===v.toLowerCase()){var h=r.slice(a,l);o.push({type:"text",content:h});var y={type:"tag-start",close:!0},g={type:"tag-end",close:!1};f(p),o.push.apply(o,[y].concat(n(p.tokens),[g])),e.cursor=p.cursor+1;break}u=p.cursor}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=a,r.lex=o,r.lexText=s,r.lexComment=i,r.lexTag=u,r.lexTagName=c,r.lexTagAttributes=f,r.lexSkipTag=l;var p=t("./compat")},{"./compat":1}],5:[function(t,e,r){"use strict";function n(t,e){var r={tagName:null,children:[]},n={tokens:t,options:e,cursor:0,stack:[r]};return a(n),r.children}function a(t){for(var e=t.tokens,r=t.options,n=t.stack,s=n[n.length-1].children,i=e.length,u=t.cursor;u<i;){var c=e[u];if("tag-start"===c.type){var f=e[++u];u++;var l=f.content.toLowerCase();if(c.close){for(var p=void 0;(p=n.pop())&&l!==p.tagName;);for(;u<i;){var v=e[u];if("tag-end"!==v.type)break;u++}break}if((0,o.arrayIncludes)(r.closingTags,l))for(var d=n.length-1;d>0;){if(l===n[d].tagName){n=n.slice(0,d);var h=d-1;s=n[h].children;break}d-=1}for(var y=[],g=void 0;u<i&&(g=e[u],"tag-end"!==g.type);)y.push(g.content),u++;u++;var m=[];s.push({type:"element",tagName:f.content,attributes:y,children:m});var b=!(g.close||(0,o.arrayIncludes)(r.voidTags,l));if(b){n.push({tagName:l,children:m});var k={tokens:e,options:r,cursor:u,stack:n};a(k),u=k.cursor}}else s.push(c),u++}t.cursor=u}Object.defineProperty(r,"__esModule",{value:!0}),r.default=n,r.parse=a;var o=t("./compat")},{"./compat":1}]},{},[3])(3)});
</script>

<script type="text/javascript">
!function(){"use strict";window.assertions=window.assertions||{},window.assertions.assertFunction=window.assertions.assertFunction||function(o,n){if(!o){if(window.navigator&&"Microsoft Internet Explorer"===window.navigator.appName)try{throw new Error}catch(o){n=n+", stack=\n"+o.stack}var s=n?"Assertion failed: "+n:"Assertion failed";throw console&&console.log&&console.log(s),new Error(s)}},window.assert=window.assert||null,window.assertSlow=window.assertSlow||null,window.assertions.enableAssert=function(){window.assert=window.assertions.assertFunction,window.console&&window.console.log&&window.console.log("enabling assert")},window.assertions.disableAssert=function(){window.assert=null,window.console&&window.console.log&&window.console.log("disabling assert")},window.assertions.enableAssertSlow=function(){window.assertSlow=window.assertions.assertFunction,window.console&&window.console.log&&window.console.log("enabling assertSlow")},window.assertions.disableAssertSlow=function(){window.assertSlow=null,window.console&&window.console.log&&window.console.log("disabling assertSlow")}}();
</script>

<script type="text/javascript">
!function(e,a){"use strict";"function"==typeof define&&define.amd?define([],a):"object"==typeof module&&module.exports?module.exports=a():e.QueryStringMachine=a()}(this,function(){"use strict";var e=",";return function(){var a={get:function(e,a){return this.getForString(e,a,window.location.search)},getAll:function(e){return this.getAllForString(e,window.location.search)},getForString:function(e,a,n){if(0!==n.length&&0!==n.indexOf("?"))throw new Error('Query strings should be either the empty string or start with a "?": '+n);r(e,a);var i=c(e,a,t(e,n));return l(e,a,i),i},getAllForString:function(e,a){var t={};for(var r in e)e.hasOwnProperty(r)&&(t[r]=this.getForString(r,e[r],a));return t},containsKey:function(e){return this.containsKeyForString(window.location.search,e)},containsKeyForString:function(e,a){var r=t(a,e);return r.length>0},deepEquals:function(e,t){if(typeof e!=typeof t)return!1;if("string"==typeof e)return e===t;if(null===e&&null===t)return!0;if(void 0===e&&void 0===t)return!0;if(null===e&&void 0===t)return!1;if(void 0===e&&null===t)return!1;var r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;if(0===r.length)return e===t;for(var i=0;i<r.length;i++){if(r[i]!==n[i])return!1;var l=e[r[i]],u=t[r[i]];if(!a.deepEquals(l,u))return!1}return!0}},t=function(e,a){for(var t=[],r=a.slice(1).split("&"),n=0;n<r.length;n++){var i=r[n].split("=");i[0]===e&&(i[1]?t.push(decodeURIComponent(i[1])):t.push(null))}return t},r=function(e,a){O(a.hasOwnProperty("type"),e,"type field is required"),O(b.hasOwnProperty(a.type),e,"invalid type: "+a.type),a.hasOwnProperty("parse")&&O("function"==typeof a.parse,e,"parse must be a function"),O(!(a.hasOwnProperty("validValues")&&a.hasOwnProperty("isValidValue")),e,"validValues and isValidValue are mutually exclusive"),a.hasOwnProperty("validValues")&&O(a.validValues instanceof Array,e,"isValidValue must be a function"),a.hasOwnProperty("isValidValue")&&O("function"==typeof a.isValidValue,e,"isValidValue must be a function"),a.hasOwnProperty("defaultValue")&&b[a.type].validateValue(e,a,a.defaultValue),a.hasOwnProperty("validValues")&&a.validValues.forEach(function(t){b[a.type].validateValue(e,a,t)}),a.hasOwnProperty("defaultValue")&&a.hasOwnProperty("validValues")&&O(w(a.defaultValue,a.validValues),e,"defaultValue must be a member of validValues"),i(e,a,b[a.type].required,b[a.type].optional),b[a.type].validateSchema&&b[a.type].validateSchema(e,a)},n=function(e,a){a.hasOwnProperty("separator")&&O("string"==typeof a.separator&&1===a.separator.length,e,"invalid separator: "+a.separator),r(e+".element",a.elementSchema)},i=function(e,a,t,r){var n=Object.getOwnPropertyNames(a);t.forEach(function(a){O(n.indexOf(a)!==-1,e,"missing required property: "+a)});var i=t.concat(r);n.forEach(function(a){O("type"===a||i.indexOf(a)!==-1,e,"unsupported property: "+a)})},l=function(e,a,t){a.hasOwnProperty("validValues")&&O(w(t,a.validValues),e,"value must be a member of validValues: "+t),a.hasOwnProperty("isValidValue")&&O(a.isValidValue(t),e,"invalid value: "+t),b[a.type].validateValue(e,a,t)},u=function(e,a,t){return o(e,a,t)},o=function(e,a,t){O(t===!0||t===!1,e,"invalid value: "+t)},s=function(e,a,t){O("number"==typeof t&&!isNaN(t),e,"invalid value: "+t)},d=function(e,a,t){O(null===t||"string"==typeof t,e,"invalid value: "+t)},f=function(e,a,t){O(t instanceof Array||null===t,e,"invalid value: "+t)},p=function(e,a,t){},c=function(e,a,t){var r;return O(t.length<=1,e,"query parameter cannot occur multiple times"),"flag"===a.type?r=v(e,a,t[0]):(O(void 0!==t[0]||a.hasOwnProperty("defaultValue"),e,"missing required query parameter"),r=void 0===t[0]?a.defaultValue:b[a.type].parse(e,a,t[0])),r},v=function(e,a,t){return O(void 0===t||null===t,e,"flag type does not support a value: "+t),void 0!==t},V=function(e,a,t){return O("true"===t||"false"===t,e,"invalid value: "+t),"true"===t},y=function(e,a,t){var r=Number(t);return O(!isNaN(r),e,"value must be a number: "+t),r},h=function(e,a,t){return t},m=function(a,t,r){var n;return n=null===r?[]:r.split(t.separator||e).map(function(e){return c(a,t.elementSchema,[e])})},g=function(e,a,t){return a.parse(t)},w=function(e,t){for(var r=!1,n=0;n<t.length&&!r;n++)r=a.deepEquals(t[n],e);return r},O=function(e,a,t){if(!e)throw console&&console.log&&console.log(S(a,t)),new Error("Assertion failed: "+t)},S=function(e,a){return'Error for query parameter "'+e+'": '+a},b={flag:{required:[],optional:[],validateSchema:null,parse:v,validateValue:u},boolean:{required:[],optional:["defaultValue"],validateSchema:null,parse:V,validateValue:o},number:{required:[],optional:["defaultValue","validValues","isValidValue"],validateSchema:null,parse:y,validateValue:s},string:{required:[],optional:["defaultValue","validValues","isValidValue"],validateSchema:null,parse:h,validateValue:d},array:{required:["elementSchema"],optional:["defaultValue","validValues","isValidValue","separator","validValues"],validateSchema:n,parse:m,validateValue:f},custom:{required:["parse"],optional:["defaultValue","validValues","isValidValue"],validateSchema:null,parse:g,validateValue:p}};return a}()});
</script>

<script type="text/javascript">
!function(){"use strict";var e={accessibility:{type:"flag"},allowLinks:{type:"boolean",defaultValue:!0},audioVolume:{type:"number",defaultValue:1,isValidValue:function(e){return e>=0}},brand:{type:"string",defaultValue:"adapted-from-phet",validValues:["phet","phet-io","adapted-from-phet"]},buildCompatible:{type:"flag"},cacheBuster:{type:"boolean",defaultValue:!0},colorProfile:{type:"string",defaultValue:"default"},dev:{type:"flag"},ea:{type:"flag"},eall:{type:"flag"},fuzzMouse:{type:"flag"},fuzzRate:{type:"number",defaultValue:100,isValidValue:function(e){return e>0}},"phet-app":{type:"flag"},"phet-android-app":{type:"flag"},ga:{type:"string",defaultValue:null},ga4:{type:"string",defaultValue:null},gameUp:{type:"flag"},gameUpLogging:{type:"flag"},gaPage:{type:"string",defaultValue:null},homeScreen:{type:"boolean",defaultValue:!0},initialScreen:{type:"number",defaultValue:0},legendsOfLearning:{type:"flag"},locale:{type:"string",defaultValue:"en"},playbackInputEventLog:{type:"flag"},playbackMode:{type:"boolean",defaultValue:!1},postMessageOnBeforeUnload:{type:"flag"},postMessageOnError:{type:"flag"},postMessageOnLoad:{type:"flag"},postMessageOnReady:{type:"flag"},profiler:{type:"flag"},qrCode:{type:"flag"},randomSeed:{type:"number",defaultValue:Math.random()},recordInputEventLog:{type:"flag"},rootRenderer:{type:"string",defaultValue:null,validValues:[null,"canvas","svg","dom","webgl"]},sceneryLog:{type:"array",elementSchema:{type:"string"},defaultValue:null},sceneryStringLog:{type:"flag"},screenIndex:{type:"number",defaultValue:1},screens:{type:"array",elementSchema:{type:"number"},defaultValue:null},showCanvasNodeBounds:{type:"flag"},showFittedBlockBounds:{type:"flag"},showHomeScreen:{type:"boolean",defaultValue:!0},showPointerAreas:{type:"flag"},showPointers:{type:"flag"},showVisibleBounds:{type:"flag"},strings:{type:"string",defaultValue:null},stringTest:{type:"string",defaultValue:null},webgl:{type:"boolean",defaultValue:!0}};!function(){window.phet=window.phet||{},window.phet.chipper=window.phet.chipper||{},window.phet.chipper.queryParameters=QueryStringMachine.getAll(e),window.phet.chipper.getCacheBusterArgs=function(){return phet.chipper.queryParameters.cacheBuster?"bust="+Date.now():""},window.phet.chipper.brand=window.phet.chipper.brand||phet.chipper.queryParameters.brand||"adapted-from-phet",window.phet.chipper.mapString=function(e,a){return null===a?e:"double"===a?e+":"+e:"long"===a?"12345678901234567890123456789012345678901234567890":"rtl"===a?"‫تست (زبان)‬":"xss"===a?e+'<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==" onload="window.location.href=atob(\'aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1kUXc0dzlXZ1hjUQ==\')" />':"none"===a?e:a},QueryStringMachine.containsKey("locale")&&(window.phet.chipper.locale=phet.chipper.queryParameters.locale)}(),window.phet.chipper.randomSeed=phet.chipper.queryParameters.randomSeed,function(){var e="production"===$("meta[name=phet-sim-level]").attr("content"),a=!e&&phet.chipper.queryParameters.eall,t=a||!e&&phet.chipper.queryParameters.ea;t&&window.assertions.enableAssert(),a&&window.assertions.enableAssertSlow(),phet.chipper.queryParameters.postMessageOnError&&window.addEventListener("error",function(e,a,t,r,n){var l="",p="";e&&e.message&&(l=e.message),e&&e.error&&e.error.stack&&(p=e.error.stack),window.parent&&window.parent.postMessage(JSON.stringify({type:"error",url:window.location.href,message:l,stack:p}),"*")}),phet.chipper.queryParameters.postMessageOnBeforeUnload&&window.addEventListener("beforeunload",function(e){window.parent&&window.parent.postMessage(JSON.stringify({type:"beforeUnload"}),"*")})}()}();
</script>

<script type="text/javascript">
!function(e,t){"use strict";"function"==typeof define&&define.amd?define([],t):"object"==typeof module&&module.exports?module.exports=t():e.getVersionForBrand=t()}(this,function(){"use strict";return function(e,t){if("phet-io"===e){var n=t.indexOf("-");return n>=0?t.substring(0,n+1)+"phetio"+t.substring(n+1):t+"-phetio"}return t}});
</script>

<script type="text/javascript">
!function(){"use strict";function e(){function e(e){var t=document.createElement("img");t.src=e}function t(){ga4DataLayer.push(arguments)}function a(){window.dataLayer.push(arguments)}var o=!1;window.addEventListener("error",function(e){e&&e.target&&e.target.src&&e.target.src.indexOf&&e.target.src.indexOf("google-analytics")>=0&&(o=!0)},!0);var r="pingver=3&project="+encodeURIComponent(phet.chipper.project)+"&brand="+encodeURIComponent(phet.chipper.brand)+"&version="+encodeURIComponent(phet.chipper.version)+"&locale="+encodeURIComponent(phet.chipper.locale)+"&buildTimestamp="+encodeURIComponent(phet.chipper.buildTimestamp)+"&domain="+encodeURIComponent(document.domain)+"&href="+encodeURIComponent(window.location.href)+"&type=html&timestamp="+encodeURIComponent(Date.now())+"&loadType="+encodeURIComponent(n)+"&ref="+encodeURIComponent(document.referrer);if(e("https://phet.colorado.edu/yotta/immediate.gif?"+r),window.addEventListener("load",function(t){e("https://phet.colorado.edu/yotta/sanity.gif?"+r+"&gaError="+encodeURIComponent(o)+"&gaLoaded="+encodeURIComponent(!1))},!1),phet.chipper.queryParameters.ga4){window.ga4DataLayer=window.ga4DataLayer||[],t("js",new Date),t("consent","default",{ad_storage:"denied",analytics_storage:"granted"}),t("config",phet.chipper.queryParameters.ga4);var p=document.getElementsByTagName("script")[0],i=document.createElement("script");i.async=!0,i.src="https://www.googletagmanager.com/gtag/js?id="+phet.chipper.queryParameters.ga4+"&l=ga4DataLayer",p.parentNode.insertBefore(i,p)}window.dataLayer=window.dataLayer||[],a("consent","default",{ad_storage:"denied",analytics_storage:"granted"}),window.dataLayer.push({simBrand:phet.chipper.brand,simName:phet.chipper.project,simVersion:phet.chipper.version,simLocale:phet.chipper.locale,simBuildTimestamp:phet.chipper.buildTimestamp,simLoadType:n,documentReferrer:document.referrer}),function(e,t,a,n,o){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var r=t.getElementsByTagName(a)[0],p=t.createElement(a),i="dataLayer"!=n?"&l="+n:"";p.async=!0,p.src="https://www.googletagmanager.com/gtm.js?id="+o+i,r.parentNode.insertBefore(p,r)}(window,document,"script","dataLayer","GTM-WLNGBXD")}var t=navigator.userAgent,a=!!(t.match(/MSIE/)||t.match(/Trident\//)||t.match(/Edge\//));if(!("file:"===window.location.protocol&&a||"phet"!==phet.chipper.brand&&"phet-io"!==phet.chipper.brand)){var n;n=phet.chipper.queryParameters["phet-app"]?"phet-app":phet.chipper.queryParameters["phet-android-app"]?"phet-android-app":top!==self?"embedded":"default","phet-app"===n?window.addEventListener("load",function(){setTimeout(e,0)},!1):e()}}();
</script>

<script type="text/javascript">
!function(n,r){function t(t,c,s){var d=[];c=1==c?{entropy:!0}:c||{};var m=u(i(c.entropy?[t,a(n)]:null==t?f():t,3),d),j=new e(d),S=function(){for(var n=j.g(p),r=y,t=0;n<h;)n=(n+t)*l,r*=l,t=j.g(1);for(;n>=v;)n/=2,r/=2,t>>>=1;return(n+t)/r};return S.int32=function(){return 0|j.g(4)},S.quick=function(){return j.g(4)/4294967296},S.double=S,u(a(j.S),n),(c.pass||s||function(n,t,e,i){return i&&(i.S&&o(i,j),n.state=function(){return o(j,{})}),e?(r[g]=n,t):n})(S,m,"global"in c?c.global:this==r,c.state)}function e(n){var r,t=n.length,e=this,o=0,i=e.i=e.j=0,u=e.S=[];for(t||(n=[t++]);o<l;)u[o]=o++;for(o=0;o<l;o++)u[o]=u[i=m&i+n[o%t]+(r=u[o])],u[i]=r;(e.g=function(n){for(var r,t=0,o=e.i,i=e.j,u=e.S;n--;)r=u[o=m&o+1],t=t*l+u[m&(u[o]=u[i=m&i+r])+(u[i]=r)];return e.i=o,e.j=i,t})(l)}function o(n,r){return r.i=n.i,r.j=n.j,r.S=n.S.slice(),r}function i(n,r){var t,e=[],o=typeof n;if(r&&"object"==o)for(t in n)try{e.push(i(n[t],r-1))}catch(n){}return e.length?e:"string"==o?n:n+"\0"}function u(n,r){for(var t,e=n+"",o=0;o<e.length;)r[m&o]=m&(t^=19*r[m&o])+e.charCodeAt(o++);return a(r)}function f(){try{if(c)return a(c.randomBytes(l));var r=new Uint8Array(l);return(s.crypto||s.msCrypto).getRandomValues(r),a(r)}catch(r){var t=s.navigator,e=t&&t.plugins;return[+new Date,s,e,s.screen,a(n)]}}function a(n){return String.fromCharCode.apply(0,n)}var c,s=this,l=256,p=6,d=52,g="random",y=r.pow(l,p),h=r.pow(2,d),v=2*h,m=l-1;if(r["seed"+g]=t,u(r.random(),n),"object"==typeof module&&module.exports){module.exports=t;try{c=require("crypto")}catch(n){}}else"function"==typeof define&&define.amd&&define(function(){return t})}([],Math);
</script>

<script type="text/javascript">
!function(){"use strict";var e=window.phet.chipper.queryParameters.gameUpLogging,a=window.phet.chipper.queryParameters.gameUp,t=function(a){e&&console.log(a)};if(a){t("Enabled Game Up Camera");var n=".brainpop.com",i=!1,o=0,r=function(){!i&&o<10&&(parent.postMessage("captureReady","*"),o++,t("Posted captureReady, number of checks: "+o),setTimeout(r,1e3))},s=function(e){if(e.origin.indexOf(n,e.origin.length-n.length)!==-1)if("captureImage"===e.data){var a=window.phet.joist.ScreenshotGenerator.generateScreenshot(window.phet.joist.sim,"image/jpeg");p(a,e.origin,e.source),t("Sent image")}else"GameUpCaptureReady"===e.data&&(t("GameUpCaptureReady"),i=!0)},p=function(e,a,t){e=e.replace("data:image/jpeg;base64,",""),t.postMessage(e,a)};window.addEventListener?window.addEventListener("message",s,!1):window.attachEvent&&window.attachEvent("onmessage",s),r()}}();
</script>

<script type="text/javascript">
!function(){"use strict";function r(r){var t=r.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===r[t-2]?2:"="===r[t-1]?1:0}function t(t){return 3*t.length/4-r(t)}function n(t){var n,e,o,a,h,u,d=t.length;h=r(t),u=new i(3*d/4-h),o=h>0?d-4:d;var A=0;for(n=0,e=0;n<o;n+=4,e+=3)a=c[t.charCodeAt(n)]<<18|c[t.charCodeAt(n+1)]<<12|c[t.charCodeAt(n+2)]<<6|c[t.charCodeAt(n+3)],u[A++]=a>>16&255,u[A++]=a>>8&255,u[A++]=255&a;return 2===h?(a=c[t.charCodeAt(n)]<<2|c[t.charCodeAt(n+1)]>>4,u[A++]=255&a):1===h&&(a=c[t.charCodeAt(n)]<<10|c[t.charCodeAt(n+1)]<<4|c[t.charCodeAt(n+2)]>>2,u[A++]=a>>8&255,u[A++]=255&a),u}function e(r){return h[r>>18&63]+h[r>>12&63]+h[r>>6&63]+h[63&r]}function o(r,t,n){for(var o,a=[],h=t;h<n;h+=3)o=(r[h]<<16)+(r[h+1]<<8)+r[h+2],a.push(e(o));return a.join("")}function a(r){for(var t,n=r.length,e=n%3,a="",c=[],i=16383,u=0,d=n-e;u<d;u+=i)c.push(o(r,u,u+i>d?d:u+i));return 1===e?(t=r[n-1],a+=h[t>>2],a+=h[t<<4&63],a+="=="):2===e&&(t=(r[n-2]<<8)+r[n-1],a+=h[t>>10],a+=h[t>>4&63],a+=h[t<<2&63],a+="="),c.push(a),c.join("")}window.byteLength=t,window.toByteArray=n,window.fromByteArray=a;for(var h=[],c=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",d=0,A=u.length;d<A;++d)h[d]=u[d],c[u.charCodeAt(d)]=d;c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63}();
</script>

<script type="text/javascript">
function TextEncoderLite(){}function TextDecoderLite(){}!function(){"use strict";function e(e,n){n=n||1/0;for(var t,r=e.length,i=null,o=[],u=0;u<r;u++){if(t=e.charCodeAt(u),t>55295&&t<57344){if(!i){if(t>56319){(n-=3)>-1&&o.push(239,191,189);continue}if(u+1===r){(n-=3)>-1&&o.push(239,191,189);continue}i=t;continue}if(t<56320){(n-=3)>-1&&o.push(239,191,189),i=t;continue}t=i-55296<<10|t-56320|65536,i=null}else i&&((n-=3)>-1&&o.push(239,191,189),i=null);if(t<128){if((n-=1)<0)break;o.push(t)}else if(t<2048){if((n-=2)<0)break;o.push(t>>6|192,63&t|128)}else if(t<65536){if((n-=3)<0)break;o.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(t<2097152))throw new Error("Invalid code point");if((n-=4)<0)break;o.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return o}function n(e,n,r){var i="",o="";r=Math.min(e.length,r||1/0),n=n||0;for(var u=n;u<r;u++)e[u]<=127?(i+=t(o)+String.fromCharCode(e[u]),o=""):o+="%"+e[u].toString(16);return i+t(o)}function t(e){try{return decodeURIComponent(e)}catch(e){return String.fromCharCode(65533)}}TextEncoderLite.prototype.encode=function(n){var t;return t="undefined"==typeof Uint8Array?e(n):new Uint8Array(e(n))},TextDecoderLite.prototype.decode=function(e){return n(e,0,e.length)}}();
</script>

<script type="text/javascript">
  (function() {
    var stringOverrides = JSON.parse( phet.chipper.queryParameters.strings || '{}' );

    var stringTest = ( typeof window !== 'undefined' && window.phet.chipper.queryParameters.stringTest ) ?
                     window.phet.chipper.queryParameters.stringTest :
                     null;

    window.phet.chipper.strings.get = function( key ) {
      // override strings via the 'strings' query parameter
      var localeStrings = window.phet.chipper.strings[ window.phet.chipper.locale ];
      if ( !localeStrings && window.phet.chipper.locale.indexOf( '_' ) === 2 ) { // e.g. 'zh' for 'zh_CN'
        localeStrings = window.phet.chipper.strings[ window.phet.chipper.locale.slice( 0, 2 ) ];
      }
      if ( !localeStrings  ) {
        localeStrings = window.phet.chipper.strings.en;
      }
      return stringOverrides[ key ] || window.phet.chipper.mapString( localeStrings[ key ], stringTest );
    };
  })();
</script>
<script type="text/javascript">(function () {
/**
 * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
  var main, req, makeMap, handlers,
    defined = {},
    waiting = {},
    config = {},
    defining = {},
    hasOwn = Object.prototype.hasOwnProperty,
    aps = [].slice,
    jsSuffixRegExp = /\.js$/;

  function hasProp(obj, prop) {
    return hasOwn.call(obj, prop);
  }

  /**
   * Given a relative module name, like ./something, normalize it to
   * a real name that can be mapped to a path.
   * @param {String} name the relative name
   * @param {String} baseName a real name that the name arg is relative
   * to.
   * @returns {String} normalized name
   */
  function normalize(name, baseName) {
    var nameParts, nameSegment, mapValue, foundMap, lastIndex,
      foundI, foundStarMap, starI, i, j, part,
      baseParts = baseName && baseName.split("/"),
      map = config.map,
      starMap = (map && map['*']) || {};

    //Adjust any relative paths.
    if (name && name.charAt(0) === ".") {
      //If have a base name, try to normalize against it,
      //otherwise, assume it is a top-level require that will
      //be relative to baseUrl in the end.
      if (baseName) {
        //Convert baseName to array, and lop off the last part,
        //so that . matches that "directory" and not name of the baseName's
        //module. For instance, baseName of "one/two/three", maps to
        //"one/two/three.js", but we want the directory, "one/two" for
        //this normalization.
        baseParts = baseParts.slice(0, baseParts.length - 1);
        name = name.split('/');
        lastIndex = name.length - 1;

        // Node .js allowance:
        if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
          name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
        }

        name = baseParts.concat(name);

        //start trimDots
        for (i = 0; i < name.length; i += 1) {
          part = name[i];
          if (part === ".") {
            name.splice(i, 1);
            i -= 1;
          } else if (part === "..") {
            if (i === 1 && (name[2] === '..' || name[0] === '..')) {
              //End of the line. Keep at least one non-dot
              //path segment at the front so it can be mapped
              //correctly to disk. Otherwise, there is likely
              //no path mapping for a path starting with '..'.
              //This can still fail, but catches the most reasonable
              //uses of ..
              break;
            } else if (i > 0) {
              name.splice(i - 1, 2);
              i -= 2;
            }
          }
        }
        //end trimDots

        name = name.join("/");
      } else if (name.indexOf('./') === 0) {
        // No baseName, so this is ID is resolved relative
        // to baseUrl, pull off the leading dot.
        name = name.substring(2);
      }
    }

    //Apply map config if available.
    if ((baseParts || starMap) && map) {
      nameParts = name.split('/');

      for (i = nameParts.length; i > 0; i -= 1) {
        nameSegment = nameParts.slice(0, i).join("/");

        if (baseParts) {
          //Find the longest baseName segment match in the config.
          //So, do joins on the biggest to smallest lengths of baseParts.
          for (j = baseParts.length; j > 0; j -= 1) {
            mapValue = map[baseParts.slice(0, j).join('/')];

            //baseName segment has  config, find if it has one for
            //this name.
            if (mapValue) {
              mapValue = mapValue[nameSegment];
              if (mapValue) {
                //Match, update name to the new value.
                foundMap = mapValue;
                foundI = i;
                break;
              }
            }
          }
        }

        if (foundMap) {
          break;
        }

        //Check for a star map match, but just hold on to it,
        //if there is a shorter segment match later in a matching
        //config, then favor over this star map.
        if (!foundStarMap && starMap && starMap[nameSegment]) {
          foundStarMap = starMap[nameSegment];
          starI = i;
        }
      }

      if (!foundMap && foundStarMap) {
        foundMap = foundStarMap;
        foundI = starI;
      }

      if (foundMap) {
        nameParts.splice(0, foundI, foundMap);
        name = nameParts.join('/');
      }
    }

    return name;
  }

  function makeRequire(relName, forceSync) {
    return function () {
      //A version of a require function that passes a moduleName
      //value for items that may need to
      //look up paths relative to the moduleName
      return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
    };
  }

  function makeNormalize(relName) {
    return function (name) {
      return normalize(name, relName);
    };
  }

  function makeLoad(depName) {
    return function (value) {
      defined[depName] = value;
    };
  }

  function callDep(name) {
    if (hasProp(waiting, name)) {
      var args = waiting[name];
      delete waiting[name];
      defining[name] = true;
      main.apply(undef, args);
    }

    if (!hasProp(defined, name) && !hasProp(defining, name)) {
      throw new Error('No ' + name);
    }
    return defined[name];
  }

  //Turns a plugin!resource to [plugin, resource]
  //with the plugin being undefined if the name
  //did not have a plugin prefix.
  function splitPrefix(name) {
    var prefix,
      index = name ? name.indexOf('!') : -1;
    if (index > -1) {
      prefix = name.substring(0, index);
      name = name.substring(index + 1, name.length);
    }
    return [prefix, name];
  }

  /**
   * Makes a name map, normalizing the name, and using a plugin
   * for normalization if necessary. Grabs a ref to plugin
   * too, as an optimization.
   */
  makeMap = function (name, relName) {
    var plugin,
      parts = splitPrefix(name),
      prefix = parts[0];

    name = parts[1];

    if (prefix) {
      prefix = normalize(prefix, relName);
      plugin = callDep(prefix);
    }

    //Normalize according
    if (prefix) {
      if (plugin && plugin.normalize) {
        name = plugin.normalize(name, makeNormalize(relName));
      } else {
        name = normalize(name, relName);
      }
    } else {
      name = normalize(name, relName);
      parts = splitPrefix(name);
      prefix = parts[0];
      name = parts[1];
      if (prefix) {
        plugin = callDep(prefix);
      }
    }

    //Using ridiculous property names for space reasons
    return {
      f: prefix ? prefix + '!' + name : name, //fullName
      n: name,
      pr: prefix,
      p: plugin
    };
  };

  function makeConfig(name) {
    return function () {
      return (config && config.config && config.config[name]) || {};
    };
  }

  handlers = {
    require: function (name) {
      return makeRequire(name);
    },
    exports: function (name) {
      var e = defined[name];
      if (typeof e !== 'undefined') {
        return e;
      } else {
        return (defined[name] = {});
      }
    },
    module: function (name) {
      return {
        id: name,
        uri: '',
        exports: defined[name],
        config: makeConfig(name)
      };
    }
  };

  main = function (name, deps, callback, relName) {
    var cjsModule, depName, ret, map, i,
      args = [],
      callbackType = typeof callback,
      usingExports;

    //Use name if no relName
    relName = relName || name;

    //Call the callback to define the module, if necessary.
    if (callbackType === 'undefined' || callbackType === 'function') {
      //Pull out the defined dependencies and pass the ordered
      //values to the callback.
      //Default to [require, exports, module] if no deps
      deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
      for (i = 0; i < deps.length; i += 1) {
        map = makeMap(deps[i], relName);
        depName = map.f;

        //Fast path CommonJS standard dependencies.
        if (depName === "require") {
          args[i] = handlers.require(name);
        } else if (depName === "exports") {
          //CommonJS module spec 1.1
          args[i] = handlers.exports(name);
          usingExports = true;
        } else if (depName === "module") {
          //CommonJS module spec 1.1
          cjsModule = args[i] = handlers.module(name);
        } else if (hasProp(defined, depName) ||
                   hasProp(waiting, depName) ||
                   hasProp(defining, depName)) {
          args[i] = callDep(depName);
        } else if (map.p) {
          map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
          args[i] = defined[depName];
        } else {
          throw new Error(name + ' missing ' + depName);
        }
      }

      ret = callback ? callback.apply(defined[name], args) : undefined;

      if (name) {
        //If setting exports via "module" is in play,
        //favor that over return value and exports. After that,
        //favor a non-undefined return value over exports use.
        if (cjsModule && cjsModule.exports !== undef &&
            cjsModule.exports !== defined[name]) {
          defined[name] = cjsModule.exports;
        } else if (ret !== undef || !usingExports) {
          //Use the return value from the function.
          defined[name] = ret;
        }
      }
    } else if (name) {
      //May just be an object definition for the module. Only
      //worry about defining if have a module name.
      defined[name] = callback;
    }
  };

  requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
    if (typeof deps === "string") {
      if (handlers[deps]) {
        //callback in this case is really relName
        return handlers[deps](callback);
      }
      //Just return the module wanted. In this scenario, the
      //deps arg is the module name, and second arg (if passed)
      //is just the relName.
      //Normalize module name, if it contains . or ..
      return callDep(makeMap(deps, callback).f);
    } else if (!deps.splice) {
      //deps is a config object, not an array.
      config = deps;
      if (config.deps) {
        req(config.deps, config.callback);
      }
      if (!callback) {
        return;
      }

      if (callback.splice) {
        //callback is an array, which means it is a dependency list.
        //Adjust args if there are dependencies
        deps = callback;
        callback = relName;
        relName = null;
      } else {
        deps = undef;
      }
    }

    //Support require(['a'])
    callback = callback || function () {};

    //If relName is a function, it is an errback handler,
    //so remove it.
    if (typeof relName === 'function') {
      relName = forceSync;
      forceSync = alt;
    }

    //Simulate async callback;
    if (forceSync) {
      main(undef, deps, callback, relName);
    } else {
      //Using a non-zero value because of concern for what old browsers
      //do, and latest browsers "upgrade" to 4 if lower value is used:
      //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
      //If want a value immediately, use require('id') instead -- something
      //that works in almond on the global level, but not guaranteed and
      //unlikely to work in other AMD implementations.
      setTimeout(function () {
        main(undef, deps, callback, relName);
      }, 4);
    }

    return req;
  };

  /**
   * Just drops the config on the floor, but returns req in case
   * the config return value is used.
   */
  req.config = function (cfg) {
    return req(cfg);
  };

  /**
   * Expose module registry for debugging and tooling
   */
  requirejs._defined = defined;

  define = function (name, deps, callback) {

    //This module may not have dependencies
    if (!deps.splice) {
      //deps is not an array, so probably means
      //an object literal or factory function for
      //the value. Adjust args.
      callback = deps;
      deps = [];
    }

    if (!hasProp(defined, name) && !hasProp(waiting, name)) {
      waiting[name] = [name, deps, callback];
    }
  };

  define.amd = {
    jQuery: true
  };
}());
define("almond", function(){});

// Copyright 2015, University of Colorado Boulder

/**
 * @author Jonathan Olson
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'PHET_CORE/Namespace',['require'],function( require ) {
  'use strict';

  /**
   * @param {string} name
   * @constructor
   */
  function Namespace( name ) {

    this.name = name; // @public (read-only)

    if ( window.phet ) {
      assert && assert( !window.phet[ name ], 'namespace ' + name + ' already exists' );
      window.phet[ name ] = this;
    }
  }

  Namespace.prototype = {

    constructor: Namespace,

    /**
     * Registers a key-value pair with the namespace.
     *
     * If there are no dots ('.') in the key, it will be assigned to the namespace. For example:
     * - x.register( 'A', A );
     * will set x.A = A.
     *
     * If the key contains one or more dots ('.'), it's treated somewhat like a path expression. For instance, if the
     * following is called:
     * - x.register( 'A.B.C', C );
     * then the register function will navigate to the object x.A.B and add x.A.B.C = C.
     *
     * @param {string} key
     * @param {*} value
     * @public
     */
    register: function( key, value ) {

      // If the key isn't compound (doesn't contain '.'), we can just look it up on this namespace
      if ( key.indexOf( '.' ) < 0 ) {
        assert && assert( !this[ key ], key + ' is already registered for namespace ' + this.name );
        this[ key ] = value;
      }
      // Compound (contains '.' at least once). x.register( 'A.B.C', C ) should set x.A.B.C.
      else {
        var keys = key.split( '.' ); // e.g. [ 'A', 'B', 'C' ]

        // Walk into the namespace, verifying that each level exists. e.g. parent => x.A.B
        var parent = this; // eslint-disable-line consistent-this
        for ( var i = 0; i < keys.length - 1; i++ ) { // for all but the last key
          assert && assert( !!parent[ keys[ i ] ],
            [ this.name ].concat( keys.slice( 0, i + 1 ) ).join( '.' ) + ' needs to be defined to register ' + key );

          parent = parent[ keys[ i ] ];
        }

        // Write into the inner namespace, e.g. x.A.B[ 'C' ] = C
        var lastKey = keys[ keys.length - 1 ];
        assert && assert( !parent[ lastKey ], key + ' is already registered for namespace ' + this.name );
        parent[ lastKey ] = value;
      }

      return value;
    }
  };

  return Namespace;
} );

// Copyright 2013-2015, University of Colorado Boulder

define( 'PHET_CORE/phetCore',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );

  // no phetAllocation initialized, since we don't need it with just phet-core, and this file is required before that

  var phetCore = new Namespace( 'phetCore' );

  // Namespace can't require this file, so we register it as a special case.
  phetCore.register( 'Namespace', Namespace );

  return phetCore;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Like Underscore's _.extend, but with hardcoded support for ES5 getters/setters.
 *
 * See https://github.com/documentcloud/underscore/pull/986.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/extend',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function extend( obj ) {
    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
      if ( source ) {
        for ( var prop in source ) {
          Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
        }
      }
    } );
    return obj;
  }

  phetCore.register( 'extend', extend );

  return extend;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Utility function for setting up prototypal inheritance.
 * Maintains supertype.prototype.constructor while properly copying ES5 getters and setters.
 * Supports adding functions to both the prototype itself and the constructor function.
 *
 * Usage:
 *
 * // Call the supertype constructor somewhere in the subtype's constructor.
 * function A() { scenery.Node.call( this ); };
 *
 * // Add prototype functions and/or 'static' functions
 * return inherit( scenery.Node, A, {
 *   customBehavior: function() { ... },
 *   isAnA: true
 * }, {
 *   someStaticFunction: function() { ...}
 * } );
 *
 * // client calls
 * new A().isAnA; // true
 * new scenery.Node().isAnA; // undefined
 * new A().constructor.name; // 'A'
 * A.someStaticFunction();
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'PHET_CORE/inherit',['require','PHET_CORE/phetCore','PHET_CORE/extend'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );
  var extend = require( 'PHET_CORE/extend' );

  /**
   * @param supertype           Constructor for the supertype.
   * @param subtype             Constructor for the subtype. Generally should contain supertype.call( this, ... )
   * @param prototypeProperties [optional] object containing properties that will be set on the prototype.
   * @param staticProperties [optional] object containing properties that will be set on the constructor function itself
   */
  function inherit( supertype, subtype, prototypeProperties, staticProperties ) {
    assert && assert( typeof supertype === 'function' );

    function F() {}

    F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype

    subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy
      new F(),                  // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely
      { constructor: subtype }, // overrides the constructor properly
      prototypeProperties       // [optional] additional properties for the prototype, as an object.
    );

    //Copy the static properties onto the subtype constructor so they can be accessed 'statically'
    extend( subtype, staticProperties );

    return subtype; // pass back the subtype so it can be returned immediately as a module export
  }

  phetCore.register( 'inherit', inherit );

  return inherit;
} );
// Copyright 2013-2015, University of Colorado Boulder

define( 'AXON/axon',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'axon' );
} );

// Copyright 2016, University of Colorado Boulder

/**
 * This plugin conditionally loads another module based on the brand.  If the brand is phet-io, it loads the module
 * otherwise it returns a no-op function, so that parametric wrapper types will not exception out even in "phet" brand.
 *
 * The module works for requirejs mode and during the build.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'ifphetio',['require'],function( module ) {
  'use strict';

  var buildMap = {};

  return {

    /**
     * Required API function that loads a resource.
     * See http://requirejs.org/docs/plugins.html#apiload for description of parameters.
     */
    load: function( id, require, load, config ) {
      if ( config.isBuild ) {

        var url = require.toUrl( id );

        if ( /\.js$/.test( url ) === false ) {
          url += '.js';
        }

        if ( global.phet && global.phet.chipper && global.phet.chipper.brand === 'phet-io' ) {

          buildMap[ id ] = {
            content: global.phet.chipper.grunt.file.read( url ),
            attach: module.attach
          };

          require( [ id ], load );
        }
        else {
          load();
        }
      }
      else {
        var brand = window.phet && window.phet.chipper && window.phet.chipper.brand;
        if ( brand === 'phet-io' ) {
          require( [ id ], load );
        }
        else {

          // It wasn't phet-io so load a 'no-op function' that returns a function (hack for the parameterized types).
          // See https://github.com/phetsims/phet-io/issues/1074 for more details
          load( function() { return function() {};} );
        }
      }
    },

    /**
     * Used by the optimizer to indicate when the plugin should write out a representation of the resource
     * in the optimized file. See http://requirejs.org/docs/plugins.html#apiwrite for description of parameters.
     */
    write: function( pluginName, moduleName, write ) {
      var text = null;
      if ( global.phet && global.phet.chipper && global.phet.chipper.brand === 'phet-io' ) {
        text = 'define("' + moduleName + '", function(){' + buildMap[ moduleName ].content + '});';
        write.asModule( moduleName, text, buildMap[ moduleName ].content );
      }
      else {

        // It wasn't phet-io so load a 'no-op function' that returns a function (hack for the parameterized types).
        // See https://github.com/phetsims/phet-io/issues/1074 for more details
        text = 'define("' + moduleName + '", function(){return function(){ return function(){}; };});';
        write( text );
      }
    }
  };
} );

define("PHET_IO/assertions/assertInstanceOf", function(){return function(){ return function(){}; };});

define("PHET_IO/phetioInherit", function(){return function(){ return function(){}; };});

define("PHET_IO/types/TObject", function(){return function(){ return function(){}; };});

define("PHET_IO/phetioEvents", function(){return function(){ return function(){}; };});

define("PHET_IO/types/TVoid", function(){return function(){ return function(){}; };});

define("PHET_IO/types/TFunctionWrapper", function(){return function(){ return function(){}; };});
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'AXON/TEmitter',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','AXON/axon','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/phetioEvents','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var axon = require( 'AXON/axon' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var phetioEvents = require( 'ifphetio!PHET_IO/phetioEvents' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );

  /**
   * Wrapper type for Emitter
   * Emitter for 0, 1 or 2 args, or maybe 3.
   * @param {function[]} phetioArgumentTypes - If loaded by phet (not phet-io), the array will be of functions
   *                                          returned by the 'ifphetio!' plugin.
   * @returns {TEmitterImpl}
   * @constructor
   */
  function TEmitter( phetioArgumentTypes ) {

    var TEmitterImpl = function TEmitterImpl( emitter, phetioID ) {
      assert && assert( phetioArgumentTypes, 'phetioArgumentTypes should be defined' );

      TObject.call( this, emitter, phetioID );
      assertInstanceOf( emitter, phet.axon.Emitter );

      // Allow certain Emitters to suppress their data output, such as the frameCompletedEmitter
      if ( emitter.phetioEmitData ) {
        emitter.callbacksStartedEmitter.addListener( function() {
          assert && assert( arguments.length === phetioArgumentTypes.length, 'Wrong number of arguments, expected ' + phetioArgumentTypes.length + ', received ' + arguments.length );
          var parameters = { arguments: Array.prototype.slice.call( arguments ) };
          var messageIndex = phetioEvents.start( 'model', phetioID, TEmitter( phetioArgumentTypes ), 'emitted', parameters );

          emitter.callbacksEndedEmitter.addListener( function listener() {
            assert && assert( arguments.length === 0, 'Wrong number of arguments, expected ' + phetioArgumentTypes.length + ', received ' + arguments.length );
            emitter.callbacksEndedEmitter.removeListener( listener );
            phetioEvents.end( messageIndex );
          } );
        } );
      }
    };

    return phetioInherit( TObject, 'TEmitter', TEmitterImpl, {
      addListener: {
        returnType: TVoid,
        parameterTypes: [ TFunctionWrapper( TVoid, phetioArgumentTypes ) ],
        implementation: function( listener ) {
          this.instance.addListener( listener );
        },
        documentation: 'Add a listener which will be called when the emitter emits.'
      }
    }, {
      documentation: 'Emitters indicate when events have occurred, with optional arguments describing the event',
      events: [ 'emitted' ]
    } );
  }

  axon.register( 'TEmitter', TEmitter );

  return TEmitter;
} );


// Copyright 2015, University of Colorado Boulder

/**
 * Creates the namespace for this repository.  By convention, this should have been declared in a file "tandem.js"
 * But that filename was already used for Tandem.js, so we use the alternate convention discussed in:
 * https://github.com/phetsims/tandem/issues/5#issuecomment-162597651
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'TANDEM/tandemNamespace',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  // modules
  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'tandem' );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Utility function for converting a string to camel case.
 */
define( 'PHET_CORE/toCamelCase',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  /**
   * Converts a string to camel case, eg: 'simula-rasa' -> 'simulaRasa'
   * See http://stackoverflow.com/questions/10425287/convert-string-to-camelcase-with-regular-expression
   *
   * @param {string} str - the input string
   * @returns {string} a new string
   */
  function toCamelCase( str ) {
    return str.toLowerCase().replace( /-(.)/g, function( match, group1 ) {
      return group1.toUpperCase();
    } );
  }

  phetCore.register( 'toCamelCase', toCamelCase );

  return toCamelCase;
} );
/**
 * @license RequireJS text 2.0.12 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
 define, window, process, Packages,
 java, location, Components, FileUtils */

define('text',['module'], function (module) {
  'use strict';

  var text, fs, Cc, Ci, xpcIsWindows,
    progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
    xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
    bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
    hasLocation = typeof location !== 'undefined' && location.href,
    defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
    defaultHostName = hasLocation && location.hostname,
    defaultPort = hasLocation && (location.port || undefined),
    buildMap = {},
    masterConfig = (module.config && module.config()) || {};

  text = {
    version: '2.0.12',

    strip: function (content) {
      //Strips <?xml ...?> declarations so that external SVG and XML
      //documents can be added to a document without worry. Also, if the string
      //is an HTML document, only the part inside the body tag is returned.
      if (content) {
        content = content.replace(xmlRegExp, "");
        var matches = content.match(bodyRegExp);
        if (matches) {
          content = matches[1];
        }
      } else {
        content = "";
      }
      return content;
    },

    jsEscape: function (content) {
      return content.replace(/(['\\])/g, '\\$1')
        .replace(/[\f]/g, "\\f")
        .replace(/[\b]/g, "\\b")
        .replace(/[\n]/g, "\\n")
        .replace(/[\t]/g, "\\t")
        .replace(/[\r]/g, "\\r")
        .replace(/[\u2028]/g, "\\u2028")
        .replace(/[\u2029]/g, "\\u2029");
    },

    createXhr: masterConfig.createXhr || function () {
      //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
      var xhr, i, progId;
      if (typeof XMLHttpRequest !== "undefined") {
        return new XMLHttpRequest();
      } else if (typeof ActiveXObject !== "undefined") {
        for (i = 0; i < 3; i += 1) {
          progId = progIds[i];
          try {
            xhr = new ActiveXObject(progId);
          } catch (e) {}

          if (xhr) {
            progIds = [progId];  // so faster next time
            break;
          }
        }
      }

      return xhr;
    },

    /**
     * Parses a resource name into its component parts. Resource names
     * look like: module/name.ext!strip, where the !strip part is
     * optional.
     * @param {String} name the resource name
     * @returns {Object} with properties "moduleName", "ext" and "strip"
     * where strip is a boolean.
     */
    parseName: function (name) {
      var modName, ext, temp,
        strip = false,
        index = name.indexOf("."),
        isRelative = name.indexOf('./') === 0 ||
                     name.indexOf('../') === 0;

      if (index !== -1 && (!isRelative || index > 1)) {
        modName = name.substring(0, index);
        ext = name.substring(index + 1, name.length);
      } else {
        modName = name;
      }

      temp = ext || modName;
      index = temp.indexOf("!");
      if (index !== -1) {
        //Pull off the strip arg.
        strip = temp.substring(index + 1) === "strip";
        temp = temp.substring(0, index);
        if (ext) {
          ext = temp;
        } else {
          modName = temp;
        }
      }

      return {
        moduleName: modName,
        ext: ext,
        strip: strip
      };
    },

    xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

    /**
     * Is an URL on another domain. Only works for browser use, returns
     * false in non-browser environments. Only used to know if an
     * optimized .js version of a text resource should be loaded
     * instead.
     * @param {String} url
     * @returns Boolean
     */
    useXhr: function (url, protocol, hostname, port) {
      var uProtocol, uHostName, uPort,
        match = text.xdRegExp.exec(url);
      if (!match) {
        return true;
      }
      uProtocol = match[2];
      uHostName = match[3];

      uHostName = uHostName.split(':');
      uPort = uHostName[1];
      uHostName = uHostName[0];

      return (!uProtocol || uProtocol === protocol) &&
             (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
             ((!uPort && !uHostName) || uPort === port);
    },

    finishLoad: function (name, strip, content, onLoad) {
      content = strip ? text.strip(content) : content;
      if (masterConfig.isBuild) {
        buildMap[name] = content;
      }
      onLoad(content);
    },

    load: function (name, req, onLoad, config) {
      //Name has format: some.module.filext!strip
      //The strip part is optional.
      //if strip is present, then that means only get the string contents
      //inside a body tag in an HTML string. For XML/SVG content it means
      //removing the <?xml ...?> declarations so the content can be inserted
      //into the current doc without problems.

      // Do not bother with the work if a build and text will
      // not be inlined.
      if (config && config.isBuild && !config.inlineText) {
        onLoad();
        return;
      }

      masterConfig.isBuild = config && config.isBuild;

      var parsed = text.parseName(name),
        nonStripName = parsed.moduleName +
                       (parsed.ext ? '.' + parsed.ext : ''),
        url = req.toUrl(nonStripName),
        useXhr = (masterConfig.useXhr) ||
                 text.useXhr;

      // Do not load if it is an empty: url
      if (url.indexOf('empty:') === 0) {
        onLoad();
        return;
      }

      //Load the text. Use XHR if possible and in a browser.
      if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
        text.get(url, function (content) {
          text.finishLoad(name, parsed.strip, content, onLoad);
        }, function (err) {
          if (onLoad.error) {
            onLoad.error(err);
          }
        });
      } else {
        //Need to fetch the resource across domains. Assume
        //the resource has been optimized into a JS module. Fetch
        //by the module name + extension, but do not include the
        //!strip part to avoid file system issues.
        req([nonStripName], function (content) {
          text.finishLoad(parsed.moduleName + '.' + parsed.ext,
            parsed.strip, content, onLoad);
        });
      }
    },

    write: function (pluginName, moduleName, write, config) {
      if (buildMap.hasOwnProperty(moduleName)) {
        var content = text.jsEscape(buildMap[moduleName]);
        write.asModule(pluginName + "!" + moduleName,
            "define(function () { return '" +
            content +
            "';});\n");
      }
    },

    writeFile: function (pluginName, moduleName, req, write, config) {
      var parsed = text.parseName(moduleName),
        extPart = parsed.ext ? '.' + parsed.ext : '',
        nonStripName = parsed.moduleName + extPart,
      //Use a '.js' file name so that it indicates it is a
      //script that can be loaded across domains.
        fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

      //Leverage own load() method to load plugin value, but only
      //write out values that do not have the strip argument,
      //to avoid any potential issues with ! in file names.
      text.load(nonStripName, req, function (value) {
        //Use own write() method to construct full module value.
        //But need to create shell that translates writeFile's
        //write() to the right interface.
        var textWrite = function (contents) {
          return write(fileName, contents);
        };
        textWrite.asModule = function (moduleName, contents) {
          return write.asModule(moduleName, fileName, contents);
        };

        text.write(pluginName, nonStripName, textWrite, config);
      }, config);
    }
  };

  if (masterConfig.env === 'node' || (!masterConfig.env &&
                                      typeof process !== "undefined" &&
                                      process.versions &&
                                      !!process.versions.node &&
                                      !process.versions['node-webkit'])) {
    //Using special require.nodeRequire, something added by r.js.
    fs = require.nodeRequire('fs');

    text.get = function (url, callback, errback) {
      try {
        var file = fs.readFileSync(url, 'utf8');
        //Remove BOM (Byte Mark Order) from utf8 files if it is there.
        if (file.indexOf('\uFEFF') === 0) {
          file = file.substring(1);
        }
        callback(file);
      } catch (e) {
        if (errback) {
          errback(e);
        }
      }
    };
  } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
                                            text.createXhr())) {
    text.get = function (url, callback, errback, headers) {
      var xhr = text.createXhr(), header;
      xhr.open('GET', url, true);

      //Allow plugins direct access to xhr headers
      if (headers) {
        for (header in headers) {
          if (headers.hasOwnProperty(header)) {
            xhr.setRequestHeader(header.toLowerCase(), headers[header]);
          }
        }
      }

      //Allow overrides specified in config
      if (masterConfig.onXhr) {
        masterConfig.onXhr(xhr, url);
      }

      xhr.onreadystatechange = function (evt) {
        var status, err;
        //Do not explicitly handle errors, those should be
        //visible via console output in the browser.
        if (xhr.readyState === 4) {
          status = xhr.status || 0;
          if (status > 399 && status < 600) {
            //An http 4xx or 5xx error. Signal an error.
            err = new Error(url + ' HTTP status: ' + status);
            err.xhr = xhr;
            if (errback) {
              errback(err);
            }
          } else {
            callback(xhr.responseText);
          }

          if (masterConfig.onXhrComplete) {
            masterConfig.onXhrComplete(xhr, url);
          }
        }
      };
      xhr.send(null);
    };
  } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
                                              typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
    //Why Java, why is this so awkward?
    text.get = function (url, callback) {
      var stringBuffer, line,
        encoding = "utf-8",
        file = new java.io.File(url),
        lineSeparator = java.lang.System.getProperty("line.separator"),
        input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
        content = '';
      try {
        stringBuffer = new java.lang.StringBuffer();
        line = input.readLine();

        // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
        // http://www.unicode.org/faq/utf_bom.html

        // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
        if (line && line.length() && line.charAt(0) === 0xfeff) {
          // Eat the BOM, since we've already found the encoding on this file,
          // and we plan to concatenating this buffer with others; the BOM should
          // only appear at the top of a file.
          line = line.substring(1);
        }

        if (line !== null) {
          stringBuffer.append(line);
        }

        while ((line = input.readLine()) !== null) {
          stringBuffer.append(lineSeparator);
          stringBuffer.append(line);
        }
        //Make sure we return a JavaScript string and not a Java string.
        content = String(stringBuffer.toString()); //String
      } finally {
        input.close();
      }
      callback(content);
    };
  } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
                                                  typeof Components !== 'undefined' && Components.classes &&
                                                  Components.interfaces)) {
    //Avert your gaze!
    Cc = Components.classes;
    Ci = Components.interfaces;
    Components.utils['import']('resource://gre/modules/FileUtils.jsm');
    xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

    text.get = function (url, callback) {
      var inStream, convertStream, fileObj,
        readData = {};

      if (xpcIsWindows) {
        url = url.replace(/\//g, '\\');
      }

      fileObj = new FileUtils.File(url);

      //XPCOM, you so crazy
      try {
        inStream = Cc['@mozilla.org/network/file-input-stream;1']
          .createInstance(Ci.nsIFileInputStream);
        inStream.init(fileObj, 1, 0, false);

        convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
          .createInstance(Ci.nsIConverterInputStream);
        convertStream.init(inStream, "utf-8", inStream.available(),
          Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

        convertStream.readString(inStream.available(), readData);
        convertStream.close();
        inStream.close();
        callback(readData.value);
      } catch (e) {
        throw new Error((fileObj && fileObj.path || '') + ': ' + e);
      }
    };
  }
  return text;
});

define('text!REPOSITORY/package.json',[],function () { return '{\n  "name": "pendulum-lab",\n  "version": "1.0.27",\n  "license": "GPL-3.0",\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/phetsims/pendulum-lab.git"\n  },\n  "devDependencies": {\n    "grunt": "~1.0.0"\n  },\n  "phet": {\n    "requirejsNamespace": "PENDULUM_LAB",\n    "screenNameKeys": [\n      "PENDULUM_LAB/screen.intro",\n      "PENDULUM_LAB/screen.energy",\n      "PENDULUM_LAB/screen.lab"\n    ]\n  }\n}';});

// Copyright 2015, University of Colorado Boulder

/**
 * Tandem is a general instance registry that can be used to track creation/disposal of instances in PhET Simulations.
 * It is used for phetio.js instrumentation for PhET-iO support.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'TANDEM/Tandem',['require','PHET_CORE/inherit','TANDEM/tandemNamespace','PHET_CORE/toCamelCase','text!REPOSITORY/package.json'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var tandemNamespace = require( 'TANDEM/tandemNamespace' );
  var toCamelCase = require( 'PHET_CORE/toCamelCase' );

  // text
  var packageString = require( 'text!REPOSITORY/package.json' );

  // constants
  var packageJSON = JSON.parse( packageString );

  // variables
  var launched = false;

  // increment names of required tandems to avoid collisions for uninstrumented sims with phetioValidateTandems=false
  var requiredTandemIndex = 0;

  // increment names of optional tandems to avoid collisions for uninstrumented sims with phetioValidateTandems=false
  var optionalTandemIndex = 0;

  // increment names of uninstrumented common code tandems to avoid collisions for uninstrumented sims with phetioValidateTandems=false
  var uninstrumentedCodeIndex = 0;

  /**
   * @param {string} id - id as a string (or '' for a root id)
   * @param {Object} [options]
   * @constructor
   */
  function Tandem( id, options ) {

    // @private - these options are stored on the instance so they can be passed through the super type inheritance chain.
    // Note: Make sure that added options here are also added to options for inheritance (createSuperTypeTandem)
    // and/or for composition (createTandem) as they make sense.
    this.options = _.extend( {

      // Non-static tandems are registered as they are created. Static tandems are buffered, then the
      // buffer is flushed once the sim starts. Static tandems (for instances created outside of
      // SimLauncher) must be stored until listeners are attached so they won't be missed.
      static: false,

      // Enabled tandems notify listeners when they are added. Disabled tandems do not notify listeners,
      // but children of a disabled tandem may be enabled.
      enabled: true,

      supplied: true, // if the tandem is not supplied and required, an error will be thrown.
      required: true // require === false means it is an optional tandem
    }, options );

    // @public (read-only)
    this.id = ( id !== undefined ) ? id : '';
    this.required = this.options.required;
    this.supplied = this.options.supplied;

    // @private (read-only)
    this.static = this.options.static;
    this.enabled = this.options.enabled;
  }

  var staticInstances = [];

  tandemNamespace.register( 'Tandem', Tandem );

  // Listeners that will be notified when items are registered/deregistered
  var instanceListeners = [];

  inherit( Object, Tandem, {

    // @public (read-only) permit checking whether something is probably a Tandem instance for error checking
    isTandem: true,

    /**
     * Adds an instance of any type.  For example, it could be an axon Property, scenery Node or Sun button.  Each
     * item should only be added to the registry once, but that is not enforced here in Tandem.  For PhET-iO, phetio.js
     * enforces one entry per ID in phetio.addInstance
     *
     * This is used to register instances with PhET-iO.
     * @param {Object} instance - the instance to add
     * @param {function} type - the PhET-iO type function, such as TString or TProperty(TNumber('volts'))
     * @public
     */
    addInstance: function( instance, type ) {

      if ( window.phet && phet.phetio && this.enabled ) {

        // Throw an error if the tandem is tandemRequired() but not supplied
        if ( phet.phetio.queryParameters.phetioValidateTandems ) {
          assert && assert( !(this.required && !this.supplied), 'Tandem was required but not supplied' );
        }

        // ValidateTandems is false and printMissingTandems flag is present for a tandem that is required but not supplied.
        if ( phet.phetio.queryParameters.printMissingTandems && (this.required && !this.supplied) ) {
          console.log( 'Required Tandem not supplied.\n' +
                       'this.id = ' + this.id + '\n' +
                       'Stack trace: ' + new Error().stack );
        }

        // ifphetio returns a no-op function, so to test whether a valid "T" wrapper type was passed, we search for the typeName
        assert && assert( type && type.typeName, 'type must be specified and have a typeName for ' + this.id );

        // If tandem is tandemOptional, then don't add the instance
        if ( !this.required && !this.supplied ) {
          if ( phet.phetio.queryParameters.printMissingTandems ) {
            var stackTrace = new Error().stack;

            // Generally PhETFont is not desired because there are so many untandemized instances.
            if ( stackTrace.indexOf( 'PhetFont' ) === -1 ) {
              console.log( 'Optional Tandem not supplied.\n' +
                           'this.id = ' + this.id + '\n' +
                           'Stack trace: ' + stackTrace );
            }
          }

          // For optionally instrumented types that are not provided tandems, the instance isn't really "added"
          // but likewise, it in not an error
          return;
        }

        if ( this.static && !launched ) {
          staticInstances.push( { tandem: this, instance: instance, type: type } );
        }
        else {
          for ( var i = 0; i < instanceListeners.length; i++ ) {
            instanceListeners[ i ].addInstance( this.id, instance, type );
          }
        }
      }
    },

    /**
     * Removes an instance from the
     * @param {Object} instance - the instance to remove
     * @public
     */
    removeInstance: function( instance ) {

      // Only active when running as phet-io
      if ( window.phet && phet.phetio && this.enabled ) {
        for ( var i = 0; i < instanceListeners.length; i++ ) {
          instanceListeners[ i ].removeInstance( this.id, instance );
        }
      }
    },

    /**
     * Create a new Tandem by appending the given id
     * @param {string} id
     * @param {Object} [options]
     * @returns {Tandem}
     * @public
     */
    createTandem: function( id, options ) {

      // Make sure the id was provided
      assert && assert( typeof id === 'string' && id.length > 0, 'id must be defined' );

      var string = ( this.id.length > 0 ) ? ( this.id + '.' + id ) : id;

      // Any child of something static is also static
      options = _.extend( { static: this.static, enabled: this.enabled }, options );

      return new Tandem( string, options );
    },

    /**
     * Creates a group tandem for creating multiple indexed child tandems, such as:
     * sim.screen.model.electron_0
     * sim.screen.model.electron_1
     *
     * In this case, 'sim.screen.model.electron' is the group tandem id.
     *
     * Used for arrays, observable arrays, or when many elements of the same type are created and they do not otherwise
     * have unique identifiers.
     * @param id
     * @returns {GroupTandem}
     */
    createGroupTandem: function( id ) {

      // Unfortunately we must resort to globals here since loading through the namespace would create a cycle
      return new GroupTandem( this.id + '.' + id );
    },

    /**
     * Get the last part of the tandem (after the last .), used in Joist for creating button names dynamically based
     * on screen names
     * @returns {string} the tail of the tandem
     */
    get tail() {
      assert && assert( this.id.indexOf( '.' ) >= 0, 'tandem ID does not have a tail' );

      var lastIndexOfDot = this.id.lastIndexOf( '.' );
      var tail = this.id.substring( lastIndexOfDot + 1 );
      assert && assert( tail.length > 0, 'tandem ID did not have a tail' );
      return tail;
    },

    /**
     * Returns a Tandem for everything except the tail.
     * @returns {Tandem}
     */
    get parentTandem() {
      assert && assert( this.id.indexOf( '.' ) >= 0, 'tandem ID does not have a tail' );

      var lastIndexOfDot = this.id.lastIndexOf( '.' );
      var headID = this.id.substring( 0, lastIndexOfDot );

      return new Tandem( headID, {
        static: this.static,
        required: this.required,
        supplied: this.supplied,
        enabled: this.enabled
      } );
    },

    /**
     * When using subtyping, the instance listeners must only be notified once rather than once for every level
     * in the inheritance hierarchy.  When a subtype constructor has a tandem.addInstance call, it should
     * pass a supertype tandem to the parent constructor so that it won't try to register the item twice.
     * @returns {SupertypeTandem}
     */
    createSupertypeTandem: function() {
      return new SupertypeTandem( this.id, this.options );
    },

    /**
     * Return true if this tandem is legal and can be used by the phet-io system.
     * @returns {boolean}
     */
    isLegalAndUsable: function() {

      // A tandem is legal if it has been supplied or, if it hasn't been supplied, if it is optional.
      return this.supplied || (this.optional && !this.supplied);
    }
  }, {

    /**
     * Some common code (such as CheckBox or RadioButton) must always be instrumented and hence requires a tandem to be
     * passed in.  The options hash indicates this with {tandem: Tandem.tandemRequired()}
     * @returns {Tandem}
     */
    tandemRequired: function() {
      return rootTandem.createTandem( 'requiredTandem' + (requiredTandemIndex++), {
        required: true,
        supplied: false
      } );
    },

    /**
     *
     * Used to indicate a common code component that supports tandem, but doesn't not require it.
     * If a tandem is not passed through to this instance, then it will not be instrumented.
     * @returns {Tandem}
     */
    tandemOptional: function() {
      return rootTandem.createTandem( 'optionalTandem' + (optionalTandemIndex++), {
        required: false,
        supplied: false
      } );
    },

    /**
     * Adds a listener that will be notified when items are registered/deregistered
     * Listeners have the form
     * {
     *   addInstance(id,instance),
     *   removeInstance(id,instance)
     * }
     * where id is of type {string} and instance is of type {Object}
     *
     * @param {Object} instanceListener - described above
     * @public
     * @static
     */
    addInstanceListener: function( instanceListener ) {
      instanceListeners.push( instanceListener );
    },

    /**
     * Create a tandem based on the name of the running simulation.
     * @returns {Tandem}
     */
    createRootTandem: function() {
      return new Tandem( toCamelCase( packageJSON.name ) );
    },

    /**
     * Create a child of the root tandem.
     * @param {string} name
     * @returns {Tandem}
     */
    createStaticTandem: function( name ) {
      return Tandem.createRootTandem().createTandem( name, { static: true } );
    },

    /**
     * When the simulation is launched, all static instances are registered.
     */
    launch: function() {
      assert && assert( !launched, 'Tandem was launched twice' );
      launched = true;
      while ( staticInstances.length > 0 ) {
        var staticInstance = staticInstances.shift();
        staticInstance.tandem.addInstance( staticInstance.instance, staticInstance.type );
      }
    },

    /**
     * Catch cases where tandem is being supplied to a class that doesn't support tandem.
     * @param options
     */
    disallowTandem: function( options ) {

      if ( Tandem.validationEnabled() ) {
        assert && assert( !options.tandem, 'tandem is not allowed' );
      }
    },

    /**
     * When running in PhET-iO brand, some code (such as user interface components) must be instrumented for PhET-iO.
     * Uninstrumented files should call this function to indicate they still need to be instrumented, so they aren't
     * missed.  See https://github.com/phetsims/phet-io/issues/668
     */
    indicateUninstrumentedCode: function() {

      // Guard against undefined errors
      if ( window.phet && phet.phetio ) {

        // Assert if validating tandems
        if ( phet.phetio.queryParameters.phetioValidateTandems ) {
          assert && assert( false, 'Uninstrumented code detected' );
        }

        // Print stack trace if query parameter supplied
        if ( phet.phetio.queryParameters.printMissingTandems ) {
          var stackTrace = new Error().stack;
          console.log( 'Uninstrumented Code! Tandem not supplied: ' + (uninstrumentedCodeIndex++) + '.\n' +
                       'Stack trace: ' + stackTrace );
        }

      }
    },

    /**
     * Determine whether or not tandem validation is turned on for the sim.
     * @returns {Boolean} If tandems are being validated or not.
     */
    validationEnabled: function() {
      return window.phet && phet.phetio && phet.phetio.queryParameters.phetioValidateTandems;
    }
  } );

  var rootTandem = Tandem.createRootTandem();

  // Tandem checks for listeners added before the Tandem module was loaded.  This is necessary so that phetio.js can
  // receive notifications about items created during static initialization such as Solute.js
  // which is created before Sim.js runs.
  if ( window.tandemPreloadInstanceListeners ) {
    for ( var i = 0; i < window.tandemPreloadInstanceListeners.length; i++ ) {
      Tandem.addInstanceListener( window.tandemPreloadInstanceListeners[ i ] );
    }
  }

  /**
   * @param {string} id - id as a string (or '' for a root id)
   * @constructor
   * @private create with Tandem.createGroupTandem
   * Declared in the same file to avoid circular reference errors in module loading.
   */
  function GroupTandem( id ) {

    Tandem.call( this, id );

    // @private for generating indices from a pool
    this.groupElementIndex = 0;
  }

  tandemNamespace.register( 'Tandem.GroupTandem', GroupTandem );

  inherit( Tandem, GroupTandem, {

    // @public
    createNextTandem: function() {
      return new Tandem( this.id + '_' + ( this.groupElementIndex++ ) );
    }
  } );

  /**
   * @param {string} id - id as a string (or '' for a root id)
   * @param {Object} options
   * @constructor
   * @private create with Tandem.createSupertypeTandem
   */
  function SupertypeTandem( id, options ) {
    Tandem.call( this, id, options );
  }

  tandemNamespace.register( 'Tandem.SupertypeTandem', SupertypeTandem );

  inherit( Tandem, SupertypeTandem, {

    // @public - Override to make no-op, see createSupertypeTandem
    addInstance: function( instance, type ) {},

    // @public - Override to make no-op, see createSupertypeTandem
    removeInstance: function( instance ) {}
  } );

  return Tandem;
} );


// Copyright 2015, University of Colorado Boulder

/**
 * Lightweight event & listener abstraction for a single event type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'AXON/Emitter',['require','AXON/axon','AXON/TEmitter','PHET_CORE/inherit','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );
  var TEmitter = require( 'AXON/TEmitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   *
   * @constructor
   */
  function Emitter( options ) {

    // @private {Function[]} - the listeners to emit to
    this.listeners = [];

    // @private - during emit() keep track of which listeners should receive events in order to manage removal of
    //          - listeners during emit()
    this.listenersToEmitTo = [];

    options = _.extend( {

      // Typically, Emitters created by a simulation indicate when they begin and end processing callbacks to deliver
      // nested data to the phet-io data stream. This is moderated by special "callback" emitters (which do not need
      // to send data to phet-io).
      indicateCallbacks: true,
      phetioArgumentTypes: [], // {TType[]} - for serializing/displaying the values during emit
      tandem: Tandem.tandemOptional(),
      phetioEmitData: true // Can be overriden to suppress data from the phet-io data stream.  For example, clock tick
                           // emits would spam the console, but the wrapper may still want to listen for the emits
    }, options );

    var self = this;

    // @private - indicates whether data should appear on the data stream.
    this.phetioEmitData = options.phetioEmitData;

    // @private (phet-io)
    this.callbacksStartedEmitter = options.indicateCallbacks ? new Emitter( {
      indicateCallbacks: false,
      phetioArgumentTypes: options.phetioArgumentTypes
    } ) : null;

    // @private (phet-io)
    this.callbacksEndedEmitter = options.indicateCallbacks ? new Emitter( {
      indicateCallbacks: false,
      phetioArgumentTypes: []
    } ) : null;

    // Tandem registration
    options.tandem.addInstance( this, TEmitter( options.phetioArgumentTypes ) );

    // @private
    this.disposeEmitter = function() {

      // See https://github.com/phetsims/axon/issues/124
      self.listeners.length = 0;

      // Tandem de-registration
      options.tandem.removeInstance( self );
    };
  }

  axon.register( 'Emitter', Emitter );

  return inherit( Object, Emitter, {

    /**
     * Dispose an Emitter that is no longer used.  Like Property.dispose, this method checks that there are no leaked
     * listeners.
     */
    dispose: function() {
      this.disposeEmitter();
    },

    /**
     * Adds a listener
     * @param {function} listener
     * @public
     */
    addListener: function( listener ) {

      assert && assert( this.listeners.indexOf( listener ) === -1, 'Cannot add the same listener twice' );

      // If callbacks are in progress, make a copy of the current list of listeners--the newly added listener
      // will be available for the next emit() but not the one in progress.  This is to match behavior with removeListener
      this.defendCallbacks();

      this.listeners.push( listener );
    },

    /**
     * Removes a listener
     * @param {function} listener
     * @public
     */
    removeListener: function( listener ) {

      var index = this.listeners.indexOf( listener );
      assert && assert( index >= 0, 'tried to removeListener on something that wasnt a listener' );

      // If callbacks are in progress, make a copy of the current list of listeners--the removed listener
      // will remain in the list and receive a callback for this emit call, see #72
      this.defendCallbacks();

      this.listeners.splice( index, 1 );
    },

    /**
     * Removes all the listeners
     * @public
     */
    removeAllListeners: function() {
      while ( this.listeners.length > 0 ) {
        this.removeListener( this.listeners[ 0 ] );
      }
    },

    /**
     * If processing callbacks during an emit() call and addListener/removeListener() is called,
     * make a defensive copy of the array of listener before changing the array, and use it for
     * the rest of the callbacks until the emit call has completed.
     * @private
     */
    defendCallbacks: function() {

      for ( var i = this.listenersToEmitTo.length - 1; i >= 0; i-- ) {

        // Once we meet a level that was already defended, we can stop, since all previous levels are also defended
        if ( this.listenersToEmitTo[ i ].defended ) {
          break;
        }
        else {
          var defendedListeners = this.listeners.slice();

          // Mark copies as 'defended' so that it will use the original listeners when emit started and not the modified list.
          defendedListeners.defended = true;
          this.listenersToEmitTo[ i ] = defendedListeners;
        }
      }
    },

    /**
     * Emits a single event.
     * This method is called many times in a simulation and must be well-optimized.
     * @public
     */
    emit: function() {
      this.callbacksStartedEmitter && this.callbacksStartedEmitter.emit();
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;

      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]();
      }

      this.listenersToEmitTo.pop();
      this.callbacksEndedEmitter && this.callbacksEndedEmitter.emit();
    },

    /**
     * Emits a single event with one argument.  This is a copy-paste of emit() for performance reasons.
     * @param {*} arg1
     * @public
     */
    emit1: function( arg1 ) {
      this.callbacksStartedEmitter && this.callbacksStartedEmitter.emit1( arg1 );
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;

      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]( arg1 );
      }

      this.listenersToEmitTo.pop();
      this.callbacksEndedEmitter && this.callbacksEndedEmitter.emit();
    },

    /**
     * Emits a single event with two arguments.  This is a copy-paste of emit() for performance reasons.
     * @param {*} arg1
     * @param {*} arg2
     * @public
     */
    emit2: function( arg1, arg2 ) {
      this.callbacksStartedEmitter && this.callbacksStartedEmitter.emit2( arg1, arg2 );
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;

      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]( arg1, arg2 );
      }

      this.listenersToEmitTo.pop();
      this.callbacksEndedEmitter && this.callbacksEndedEmitter.emit();
    },

    /**
     * Emits a single event with three arguments.  This is a copy-paste of emit() for performance reasons.
     * @param {*} arg1
     * @param {*} arg2
     * @param {*} arg3
     * @public
     */
    emit3: function( arg1, arg2, arg3 ) {
      this.callbacksStartedEmitter && this.callbacksStartedEmitter.emit3( arg1, arg2, arg3 );
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;

      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]( arg1, arg2, arg3 );
      }

      this.listenersToEmitTo.pop();
      this.callbacksEndedEmitter && this.callbacksEndedEmitter.emit();
    },

    /**
     * Checks whether a listener is registered with this Emitter
     * @param {function} listener
     * @returns {boolean}
     * @public
     */
    hasListener: function( listener ) {
      assert && assert( arguments.length === 1, 'Emitter.hasListener should be called with 1 argument' );
      return this.listeners.indexOf( listener ) >= 0;
    },

    /**
     * Returns true if there are any listeners.
     * @returns {boolean}
     * @public
     */
    hasListeners: function() {
      assert && assert( arguments.length === 0, 'Emitter.hasListeners should be called without arguments' );
      return this.listeners.length > 0;
    }
  } );
} );
// Copyright 2014-2016, University of Colorado Boulder

/**
 * A Multilink is an instance that can be used to link to multiple properties.  It is very similar to a DerivedProperty,
 * but has no value and does not conform to the Property API because it is intended for use with callbacks that do not
 * compute a value.  Multilink should not be created through calling its constructor directly, but through the
 * Property.multilink and Property.lazyMultilink functions.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'AXON/Multilink',['require','AXON/axon','PHET_CORE/inherit'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );

  /**
   * @param {Property[]} dependencies
   * @param {function} callback function that expects args in the same order as dependencies
   * @param {boolean} [lazy] Optional parameter that can be set to true if this should be a lazy multilink (no immediate callback)
   * @constructor
   */
  function Multilink( dependencies, callback, lazy ) {

    this.dependencies = dependencies; // @private

    // @private Keep track of each dependency and only update the changed value, for speed
    this.dependencyValues = dependencies.map( function( property ) {return property.get();} );

    var self = this;

    // @private Keep track of listeners so they can be detached
    this.dependencyListeners = [];

    //When a dependency value changes, update the list of dependencies and call back to the callback
    dependencies.forEach( function( dependency, i ) {
      var listener = function( value ) {
        self.dependencyValues[ i ] = value;
        callback.apply( null, self.dependencyValues );
      };
      self.dependencyListeners.push( listener );
      dependency.lazyLink( listener );
    } );

    //Send initial call back but only if we are non-lazy
    if ( !lazy ) {
      callback.apply( null, this.dependencyValues );
    }
  }

  axon.register( 'Multilink', Multilink );

  return inherit( Object, Multilink, {

    // @public
    dispose: function() {
      assert && assert( this.dependencies, 'A Multilink cannot be disposed twice.' );

      // Unlink from dependent properties
      for ( var i = 0; i < this.dependencies.length; i++ ) {
        this.dependencies[ i ].unlink( this.dependencyListeners[ i ] );
      }
      this.dependencies = null;
      this.dependencyListeners = null;
      this.dependencyValues = null;
    }
  } );
} );

define("PHET_IO/toEventOnEmit", function(){return function(){ return function(){}; };});

define("PHET_IO/phetio", function(){return function(){ return function(){}; };});
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'AXON/TProperty',['require','AXON/axon','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TFunctionWrapper','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/toEventOnEmit','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/phetio'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );

  /**
   * An observable property that triggers notifications when the value changes.
   * @param {function} phetioValueType - If loaded by phet (not phet-io) it will be the function returned by the
   *                                     'ifphetio!' plugin.
   * @param options
   * @module TProperty
   * @constructor
   */
  function TProperty( phetioValueType, options ) {

    options = _.extend( {

      // Properties can opt-out of appearing in the phetio.getState() and phetio.setState() where the values are redundant or easily recomputed
      // in the playback simulation.
      phetioStateElement: true
    }, options );

    var TPropertyImpl = function TPropertyImpl( property, phetioID ) {
      assert && assert( !!phetioValueType, 'TProperty needs phetioValueType' );
      assert && assert( property, 'Property should exist' );
      assert && assert( _.endsWith( phetioID, 'Property' ), 'TProperty instances should end with the "Property" suffix, for ' + phetioID );

      assertInstanceOf( property, phet.axon.Property );
      TObject.call( this, property, phetioID );

      this.phetioStateElement = options.phetioStateElement;

      toEventOnEmit(
        property.startedCallbacksForChangedEmitter,
        property.endedCallbacksForChangedEmitter,
        'model',
        phetioID,
        this.constructor,
        'changed',
        function( newValue, oldValue ) {
          return {
            oldValue: phetioValueType.toStateObject( oldValue ),
            newValue: phetioValueType.toStateObject( newValue ),

            // Pass through the value type units.  Undefined are filtered out
            units: phetioValueType.units
          };
        } );
    };

    // Add the valueType to the typeName
    var typeName = 'TProperty.<' + phetioValueType.typeName + '>';
    return phetioInherit( TObject, typeName, TPropertyImpl, {

      getValue: {
        returnType: phetioValueType,
        parameterTypes: [],
        implementation: function() {
          return this.instance.get();
        },
        documentation: 'Gets the current value.'
      },

      setValue: {
        returnType: TVoid,
        parameterTypes: [ phetioValueType ],
        implementation: function( value ) {
          this.instance.set( value );
        },
        documentation: 'Sets the value of the property, and triggers notifications if the value is different'
      },

      link: {
        returnType: TVoid,
        parameterTypes: [ TFunctionWrapper( TVoid, [ phetioValueType, phetioValueType ] ) ],
        implementation: function( listener ) {
          this.instance.link( listener );
        },
        documentation: 'Add a listener which will be called when the value changes.  The listener also gets an ' +
                       'immediate callback with the current value.'
      },

      lazyLink: {
        returnType: TVoid,
        parameterTypes: [ TFunctionWrapper( TVoid, [ phetioValueType, phetioValueType ] ) ],
        implementation: function( listener ) {
          this.instance.lazyLink( listener );
        },
        documentation: 'Add a listener which will be called when the value changes, but not for the initial value.'
      },

      unlink: {
        returnType: TVoid,
        parameterTypes: [ TFunctionWrapper( TVoid, [ phetioValueType ] ) ],
        implementation: function( listener ) {
          this.instance.unlink( listener );
        },
        documentation: 'Removes a listener'
      }
    }, {

      phetioStateElement: options.phetioStateElement,

      documentation: 'Model values that can send out notifications when the value changes. This is different from the ' +
                     'traditional listener pattern in that listeners also receive a callback with the current value ' +
                     'when the listeners are registered.',
      valueType: phetioValueType,
      events: [ 'changed' ],

      getAPI: function() {
        return {
          valueType: phetio.getAPIForType( phetioValueType )
        };
      },

      /**
       * Decodes a state into a Property.
       * @param {Object} stateObject
       * @returns {Object}
       */
      fromStateObject: function( stateObject ) {
        return phetioValueType.fromStateObject( stateObject );
      },

      /**
       * Encodes a DerivedProperty instance to a state.
       * @param {Object} instance
       * @returns {Object} - a state object
       */
      toStateObject: function( instance ) {
        assert && assert( instance, 'instance should be defined' );
        assert && assert( phetioValueType.toStateObject, 'toStateObject doesnt exist for ' + phetioValueType.typeName );
        return phetioValueType.toStateObject( instance.value );
      },

      /**
       * Used to set the value when loading a state
       * @param instance
       * @param value
       */
      setValue: function( instance, value ) {
        instance.set( value );
      },

      options: options
    } );
  }

  axon.register( 'TProperty', TProperty );

  return TProperty;
} );


// Copyright 2013-2016, University of Colorado Boulder

/**
 * An observable property which notifies listeners when the value changes.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'AXON/Property',['require','AXON/axon','PHET_CORE/inherit','AXON/Emitter','AXON/Multilink','TANDEM/Tandem','AXON/TProperty','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var Multilink = require( 'AXON/Multilink' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TProperty = require( 'AXON/TProperty' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );

  /**
   * @param {*} value - the initial value of the property
   * @param {Object} [options] - options
   * @constructor
   */
  function Property( value, options ) {

    var self = this;

    // Check duck type for incorrect Tandem argument
    if ( options && options.isTandem ) {
      assert && assert( false, 'Options should be an Object, not a Tandem' );
    }

    options = _.extend( {
      tandem: Tandem.tandemOptional(),
      phetioValueType: null, // {function | null} phet-io type wrapper like TString, TNumber, etc.

      // {*[]|null} valid values for this Property. Mutually exclusive with options.isValidValue
      validValues: null,

      // {function|null} single parameter is a value to validate, returns true if valid, false if invalid
      // If null and validValues is provided, a value is valid if it is a member of validValues.
      // If null and no validValues are provided, all values are considered valid.
      isValidValue: null,

      // A place to add annotation or notes for a property
      phetioInstanceDocumentation: '',

      // Properties can opt-out of appearing in the phetio.getState() and phetio.setState() where the values are redundant or easily recomputed
      // in the playback simulation.
      phetioStateElement: true,

      // useDeepEquality: true => Use the `equals` method on the values
      // useDeepEquality: false => Use === for equality test
      useDeepEquality: false
    }, options );

    // value validation
    assert && assert( !( options.validValues && options.isValidValue ), 'validValues and isValidValue are mutually exclusive' );

    // @public (read-only) whether to use the values' equals method or === equality
    // useDeepEquality: true => Use the `equals` method on the values
    // useDeepEquality: false => Use === for equality test
    this.useDeepEquality = options.useDeepEquality;

    this.isValidValue = options.isValidValue; // @private
    if ( !this.isValidValue && options.validValues ) {

      // validation is based on the set of validValues
      this.isValidValue = function( value ) {
        return options.validValues.indexOf( value ) !== -1;
      };
    }
    assert && this.isValidValue && assert( this.isValidValue( value ), 'invalid initial value: ' + value );

    // @public - export the phet-io element type
    this.phetioValueType = options.phetioValueType;

    // When running as phet-io, if the tandem is specified, the type must be specified.
    // This assertion helps in instrumenting code that has the tandem but not type
    Tandem.validationEnabled() && options.tandem.isLegalAndUsable() && assert && assert( !!options.phetioValueType,
      'Type passed to Property must be specified. Tandem.id: ' + options.tandem.id );

    // @public (read-only) Emitters that indicate the start/end of processing callbacks for a change.  Also used for PhET-iO data stream
    this.startedCallbacksForChangedEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForChangedEmitter = new Emitter( { indicateCallbacks: false } );

    // @private - Store the internal value and the initial value
    this._value = value;

    // @private - Initial value
    this._initialValue = value;

    // @private (unit-tests) - emit1 is called when the value changes (or on link)
    // Also used in ShapePlacementBoard.js at the moment
    this.changedEmitter = new Emitter();

    // Register with tandem. TVoid is needed when not running in phet-io mode, because the phetioValueType is often
    // unsupplied. This causes downstream errors in TProperty.
    options.tandem.addInstance( this, TProperty( options.phetioValueType || TVoid, {
      phetioInstanceDocumentation: options.phetioInstanceDocumentation,
      phetioStateElement: options.phetioStateElement
    } ) );

    // @private
    this.disposeProperty = function() {

      // remove any listeners that are still attached to this property
      self.changedEmitter.listeners.length = 0;

      // remove tandem instance
      options.tandem.removeInstance( self );
    };
  }

  axon.register( 'Property', Property );

  return inherit( Object, Property, {

      /**
       * Gets the value.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.
       * @returns {*}
       * @public
       */
      get: function() {
        return this._value;
      },

      /**
       * Sets the value and notifies listeners.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.
       * If the value hasn't changed, this is a no-op.
       *
       * @param {*} value
       * @public
       */
      set: function( value ) {
        assert && this.isValidValue && assert( this.isValidValue( value ), 'invalid value: ' + value );
        if ( !this.equalsValue( value ) ) {
          this._setAndNotifyListeners( value );
        }
        return this;
      },

      /**
       * Returns true if and only if the specified value equals the value of this property
       * @param {Object} value
       * @returns {boolean}
       * @private
       */
      equalsValue: function( value ) {
        return this.areValuesEqual( value, this._value );
      },

      /**
       * Determines equality semantics for the wrapped type, including whether notifications are sent out when the
       * wrapped value changes, and whether onValue is triggered.
       *
       * useDeepEquality: true => Use the `equals` method on the values
       * useDeepEquality: false => Use === for equality test
       *
       * Alternatively different implementation can be provided by subclasses or instances to change the equals
       * definition. See #10 and #73 and #115
       * @param {Object} a - should have the same type as Property element type
       * @param {Object} b - should have the same type as Property element type
       * @returns {boolean}
       * @private
       */
      areValuesEqual: function( a, b ) {
        if ( this.useDeepEquality && a && b && a.constructor === b.constructor ) {

          assert && assert( !!a.equals, 'no equals function for 1st arg' );
          assert && assert( !!b.equals, 'no equals function for 2nd arg' );
          assert && assert( a.equals( b ) === b.equals( a ), 'incompatible equality checks' );
          return a.equals( b );
        }
        else {

          // Reference equality for objects, value equality for primitives
          return a === b;
        }
      },

      // @public
      get initialValue() {
        return this._initialValue;
      },

      // @private
      _setAndNotifyListeners: function( value ) {
        var oldValue = this.get();
        this._value = value;
        this._notifyListeners( oldValue );
      },

      // @private
      _notifyListeners: function( oldValue ) {

        // Note the current value, since it will be sent to possibly multiple listeners.
        var value = this.get();

        this.startedCallbacksForChangedEmitter.emit2( value, oldValue );

        this.changedEmitter.emit2( value, oldValue );

        this.endedCallbacksForChangedEmitter.emit();
      },

      /**
       * Use this method when mutating a value (not replacing with a new instance) and you want to send notifications about the change.
       * This is different from the normal axon strategy, but may be necessary to prevent memory allocations.
       * This method is unsafe for removing listeners because it assumes the listener list not modified, to save another allocation
       * Only provides the new reference as a callback (no oldvalue)
       * See https://github.com/phetsims/axon/issues/6
       * @public
       */
      notifyListenersStatic: function() {
        this.changedEmitter.emit1( this.get() );
      },

      /**
       * Resets the value to the initial value.
       * @public
       */
      reset: function() {
        this.set( this._initialValue );
      },

      // @public
      get value() { return this.get(); },

      // @public
      set value( newValue ) { this.set( newValue ); },

      /**
       * Adds listener and calls it immediately. If listener is already registered, this is a no-op. The initial
       * notification provides the current value for newValue and null for oldValue.
       *
       * @param {function} listener a function of the form listener(newValue,oldValue)
       * @public
       */
      link: function( listener ) {
        if ( !this.changedEmitter.hasListener( listener ) ) {
          this.changedEmitter.addListener( listener );
          listener( this.get(), null ); // null should be used when an object is expected but unavailable
        }
      },

      /**
       * Add an listener to the Property, without calling it back right away.
       * This is used when you need to register a listener without an immediate callback.
       *
       * @param {function} listener - a function with a single argument, which is the value of the property at the time the function is called.
       * @public
       */
      lazyLink: function( listener ) {
        this.changedEmitter.addListener( listener );
      },

      /**
       * Removes a listener. If listener is not registered, this is a no-op.
       *
       * @param {function} listener
       * @public
       */
      unlink: function( listener ) {
        if ( this.changedEmitter.hasListener( listener ) ) {
          this.changedEmitter.removeListener( listener );
        }
      },

      /**
       * Removes all listeners. If no listeners are registered, this is a no-op.
       */
      unlinkAll: function() {
        this.changedEmitter.removeAllListeners();
      },

      /**
       * Links an object's named attribute to this property.  Returns a handle so it can be removed using Property.unlink();
       * Example: modelVisibleProperty.linkAttribute(view,'visible');
       *
       * @param object
       * @param attributeName
       * @public
       */
      linkAttribute: function( object, attributeName ) {
        var handle = function( value ) {object[ attributeName ] = value;};
        this.link( handle );
        return handle;
      },

      /**
       * Unlink an listener added with linkAttribute.  Note: the args of linkAttribute do not match the args of
       * unlinkAttribute: here, you must pass the listener handle returned by linkAttribute rather than object and attributeName
       *
       * @param {function} listener
       * @public
       */
      unlinkAttribute: function( listener ) {
        this.unlink( listener );
      },

      // @public Provide toString for console debugging, see http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript
      toString: function() {return 'Property{' + this.get() + '}'; },

      // @public
      valueOf: function() {return this.toString();},

      /**
       * Add a listener so that it will only fire once (and not on registration)
       *
       * I can see two ways to implement this:
       * (a) add a field to the listener so after notifications it can be checked and possibly removed. Disadvantage: will make everything slower even if not using 'once'
       * (b) wrap the listener in a new function which will call the listener and then remove itself.  Disadvantage: cannot remove an listener added using 'once'
       * To avoid possible performance problems, use a wrapper function, and return it as a handle in case the 'once' listener must be removed before it is called once
       *
       * @param {function} listener the listener which should be called back only for one property change (and not on registration)
       * @returns {function} the wrapper handle in case the wrapped function needs to be removed with 'unlink' before it is called once
       * @public
       */
      once: function( listener ) {
        var self = this;
        var wrapper = function( newValue, oldValue ) {
          self.unlink( wrapper );
          listener( newValue, oldValue );
        };
        this.lazyLink( wrapper );
        return wrapper;
      },

      /**
       * Convenience function for debugging a property values.  It prints the new value on registration and when changed.
       * @param name debug name to be printed on the console
       * @returns {function} the handle to the linked listener in case it needs to be removed later
       * @public
       */
      debug: function( name ) {
        var listener = function( value ) { console.log( name, value ); };
        this.link( listener );
        return listener;
      },

      /**
       * Modifies the value of this Property with the ! operator.  Works for booleans and non-booleans.
       * @public
       */
      toggle: function() {
        this.value = !this.value;
      },

      /**
       * Adds a listener that is fired when the property takes the specified value.  If the property has the value already,
       * the listener is called back immediately.  A reference to the listener is returned so that it can be removed.
       *
       * @param {Object} value - the value to match
       * @param {function} listener - the listener that is called when this Property
       * @public
       */
      onValue: function( value, listener ) {
        assert && this.isValidValue && assert( this.isValidValue( value ), 'attempt to observe invalid value: ' + value );
        var self = this;
        var onValueListener = function( v ) {
          if ( self.areValuesEqual( v, value ) ) {
            listener();
          }
        };
        this.link( onValueListener );
        return onValueListener;
      },

      // @public Ensures that the Property is eligible for GC
      dispose: function() {
        this.disposeProperty();
      },

      /**
       * Checks whether a listener is registered with this Property
       * @param {function} listener
       * @returns {boolean}
       * @public
       */
      hasListener: function( listener ) {
        return this.changedEmitter.hasListener( listener );
      },

      /**
       * Returns true if there are any listeners.
       * @returns {boolean}
       * @public
       */
      hasListeners: function() {
        assert && assert( arguments.length === 0, 'Property.hasListeners should be called without arguments' );
        return this.changedEmitter.hasListeners();
      },

      getDeclarator: function( options ) {

        var self = this;
        return {

          // Getter proxies to Model#get()...
          get: function() {
            return self.get();
          },

          // Setter proxies to Model#set(attributes)
          set: function( value ) { self.set( value ); },

          // Make it configurable and enumerable so it's easy to override...
          configurable: true,
          enumerable: true
        };
      }
    },

    //statics
    {
      /**
       * Registers a listener with multiple properties, then notifies the listener immediately.
       * @param {Property[]} properties
       * @param {function} listener function that takes values from the properties and returns nothing
       * @returns {Multilink}
       * @static
       */
      multilink: function( properties, listener ) {
        return new Multilink( properties, listener, false );
      },

      /**
       * Registers an listener with multiple properties *without* an immediate callback with current values.
       * @param {Property[]} properties
       * @param {function} listener function that takes values from the properties and returns nothing
       * @returns {Multilink}
       * @static
       */
      lazyMultilink: function( properties, listener ) {
        return new Multilink( properties, listener, true );
      },

      /**
       * Unlinks an listener that was added with multilink or lazyMultilink.
       * @param {Multilink} multilink
       * @static
       */
      unmultilink: function( multilink ) {
        multilink.dispose();
      },

      /**
       * When porting simulations away from PropertySet, it is useful to have a way to guarantee that all ES5
       * getters and setters have been refactored.  This method can help you identify ES5 get/set calls that still exist
       * if they are triggered in the code at runtime.
       * @param {Object} object
       * @param {string} prop
       * @deprecated this is for debugging only - do not leave calls to this function in production code
       */
      preventGetSet: function( object, prop ) {
        Object.defineProperty( object, prop, {

          get: function() {
            assert && assert( false, 'getter prevented for prop: ' + prop );
          },

          set: function( value ) {
            assert && assert( false, 'setter prevented for prop: ' + prop );
          },

          // Make it configurable and enumerable so it's easy to override.
          configurable: true,
          enumerable: true
        } );
      }
    } );
} );


define("PHET_IO/types/TBoolean", function(){return function(){ return function(){}; };});
// Copyright 2016, University of Colorado Boulder

/**
 * Convenience subclass of Property that constrains values to be true or false.
 * Truthy/falsy values are considered invalid.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'AXON/BooleanProperty',['require','PHET_CORE/inherit','AXON/Property','AXON/axon','ifphetio!PHET_IO/types/TBoolean'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );

  // phet-io modules
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );

  // constants
  /**
   * @param value
   * @returns {boolean}
   */
  var IS_BOOLEAN = function( value ) {
    return typeof value === 'boolean';
  };

  /**
   * Convenience constructor that constrains values to be true/false.
   * @param {boolean} value - initial value
   * @param {Object} [options]
   * @constructor
   */
  function BooleanProperty( value, options ) {
    assert && assert( !options || !options.phetioValueType, 'phetioValueType is provided by BooleanProperty' );
    options = _.extend( {
      phetioValueType: TBoolean
    }, options );
    assert && assert( !options.validValues, 'BooleanProperty cannot use validValues' );
    assert && assert( !options.isValidValue, 'BooleanProperty implements its own isValidValue' );
    options.isValidValue = IS_BOOLEAN;

    Property.call( this, value, options );
  }

  axon.register( 'BooleanProperty', BooleanProperty );

  return inherit( Property, BooleanProperty );
} );
// Copyright 2016, University of Colorado Boulder

/**
 * Creates the namespace for this simulation.
 */
define( 'PENDULUM_LAB/pendulumLab',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  // modules
  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'pendulumLab' );
} );

/**
 * @license
 * Lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 */
;(function(){function n(n,t){return n.set(t[0],t[1]),n}function t(n,t){return n.add(t),n}function r(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function e(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&false!==t(n[r],r,n););return n}function i(n,t){for(var r=null==n?0:n.length;r--&&false!==t(n[r],r,n););
  return n}function o(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return false;return true}function f(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function c(n,t){return!(null==n||!n.length)&&-1<d(n,t,0)}function a(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return true;return false}function l(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function s(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];
  return n}function h(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function p(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function _(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return true;return false}function v(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,false}),e}function g(n,t,r,e){var u=n.length;for(r+=e?1:-1;e?r--:++r<u;)if(t(n[r],r,n))return r;return-1}function d(n,t,r){if(t===t)n:{
  --r;for(var e=n.length;++r<e;)if(n[r]===t){n=r;break n}n=-1}else n=g(n,b,r);return n}function y(n,t,r,e){--r;for(var u=n.length;++r<u;)if(e(n[r],t))return r;return-1}function b(n){return n!==n}function x(n,t){var r=null==n?0:n.length;return r?k(n,t)/r:P}function j(n){return function(t){return null==t?F:t[n]}}function w(n){return function(t){return null==n?F:n[t]}}function m(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=false,n):t(r,n,u,i)}),r}function A(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;
  return n}function k(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==F&&(r=r===F?i:r+i)}return r}function E(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function O(n,t){return l(t,function(t){return[t,n[t]]})}function S(n){return function(t){return n(t)}}function I(n,t){return l(t,function(t){return n[t]})}function R(n,t){return n.has(t)}function z(n,t){for(var r=-1,e=n.length;++r<e&&-1<d(t,n[r],0););return r}function W(n,t){for(var r=n.length;r--&&-1<d(t,n[r],0););return r}function B(n){
  return"\\"+Tn[n]}function L(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function U(n,t){return function(r){return n(t(r))}}function C(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&"__lodash_placeholder__"!==o||(n[r]="__lodash_placeholder__",i[u++]=r)}return i}function D(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function M(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function T(n){if(Bn.test(n)){
  for(var t=zn.lastIndex=0;zn.test(n);)++t;n=t}else n=tt(n);return n}function $(n){return Bn.test(n)?n.match(zn)||[]:n.split("")}var F,N=1/0,P=NaN,Z=[["ary",128],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",32],["partialRight",64],["rearg",256]],q=/\b__p\+='';/g,V=/\b(__p\+=)''\+/g,K=/(__e\(.*?\)|\b__t\))\+'';/g,G=/&(?:amp|lt|gt|quot|#39);/g,H=/[&<>"']/g,J=RegExp(G.source),Y=RegExp(H.source),Q=/<%-([\s\S]+?)%>/g,X=/<%([\s\S]+?)%>/g,nn=/<%=([\s\S]+?)%>/g,tn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,rn=/^\w*$/,en=/^\./,un=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,on=/[\\^$.*+?()[\]{}|]/g,fn=RegExp(on.source),cn=/^\s+|\s+$/g,an=/^\s+/,ln=/\s+$/,sn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,hn=/\{\n\/\* \[wrapped with (.+)\] \*/,pn=/,? & /,_n=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,vn=/\\(\\)?/g,gn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,dn=/\w*$/,yn=/^[-+]0x[0-9a-f]+$/i,bn=/^0b[01]+$/i,xn=/^\[object .+?Constructor\]$/,jn=/^0o[0-7]+$/i,wn=/^(?:0|[1-9]\d*)$/,mn=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,An=/($^)/,kn=/['\n\r\u2028\u2029\\]/g,En="[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",On="(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])"+En,Sn="(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",In=RegExp("['\u2019]","g"),Rn=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]","g"),zn=RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|"+Sn+En,"g"),Wn=RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)|\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)|\\d+",On].join("|"),"g"),Bn=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),Ln=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Un="Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),Cn={};
  Cn["[object Float32Array]"]=Cn["[object Float64Array]"]=Cn["[object Int8Array]"]=Cn["[object Int16Array]"]=Cn["[object Int32Array]"]=Cn["[object Uint8Array]"]=Cn["[object Uint8ClampedArray]"]=Cn["[object Uint16Array]"]=Cn["[object Uint32Array]"]=true,Cn["[object Arguments]"]=Cn["[object Array]"]=Cn["[object ArrayBuffer]"]=Cn["[object Boolean]"]=Cn["[object DataView]"]=Cn["[object Date]"]=Cn["[object Error]"]=Cn["[object Function]"]=Cn["[object Map]"]=Cn["[object Number]"]=Cn["[object Object]"]=Cn["[object RegExp]"]=Cn["[object Set]"]=Cn["[object String]"]=Cn["[object WeakMap]"]=false;
  var Dn={};Dn["[object Arguments]"]=Dn["[object Array]"]=Dn["[object ArrayBuffer]"]=Dn["[object DataView]"]=Dn["[object Boolean]"]=Dn["[object Date]"]=Dn["[object Float32Array]"]=Dn["[object Float64Array]"]=Dn["[object Int8Array]"]=Dn["[object Int16Array]"]=Dn["[object Int32Array]"]=Dn["[object Map]"]=Dn["[object Number]"]=Dn["[object Object]"]=Dn["[object RegExp]"]=Dn["[object Set]"]=Dn["[object String]"]=Dn["[object Symbol]"]=Dn["[object Uint8Array]"]=Dn["[object Uint8ClampedArray]"]=Dn["[object Uint16Array]"]=Dn["[object Uint32Array]"]=true,
    Dn["[object Error]"]=Dn["[object Function]"]=Dn["[object WeakMap]"]=false;var Mn,Tn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},$n=parseFloat,Fn=parseInt,Nn=typeof global=="object"&&global&&global.Object===Object&&global,Pn=typeof self=="object"&&self&&self.Object===Object&&self,Zn=Nn||Pn||Function("return this")(),qn=typeof exports=="object"&&exports&&!exports.nodeType&&exports,Vn=qn&&typeof module=="object"&&module&&!module.nodeType&&module,Kn=Vn&&Vn.exports===qn,Gn=Kn&&Nn.process;
  n:{try{Mn=Gn&&Gn.binding&&Gn.binding("util");break n}catch(n){}Mn=void 0}var Hn=Mn&&Mn.isArrayBuffer,Jn=Mn&&Mn.isDate,Yn=Mn&&Mn.isMap,Qn=Mn&&Mn.isRegExp,Xn=Mn&&Mn.isSet,nt=Mn&&Mn.isTypedArray,tt=j("length"),rt=w({"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I",
    "\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C",
    "\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i",
    "\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S",
    "\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe",
    "\u0149":"'n","\u017f":"s"}),et=w({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),ut=w({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),it=function w(En){function On(n){if(xu(n)&&!af(n)&&!(n instanceof Mn)){if(n instanceof zn)return n;if(ci.call(n,"__wrapped__"))return Pe(n)}return new zn(n)}function Sn(){}function zn(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=F}function Mn(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,
    this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Tn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Nn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Pn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function qn(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new Pn;++t<r;)this.add(n[t])}function Vn(n){
    this.size=(this.__data__=new Nn(n)).size}function Gn(n,t){var r,e=af(n),u=!e&&cf(n),i=!e&&!u&&sf(n),o=!e&&!u&&!i&&gf(n),u=(e=e||u||i||o)?E(n.length,ri):[],f=u.length;for(r in n)!t&&!ci.call(n,r)||e&&("length"==r||i&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||Re(r,f))||u.push(r);return u}function tt(n){var t=n.length;return t?n[cr(0,t-1)]:F}function ot(n,t){return Te(Mr(n),gt(t,0,n.length))}function ft(n){return Te(Mr(n))}function ct(n,t,r){(r===F||hu(n[t],r))&&(r!==F||t in n)||_t(n,t,r);
  }function at(n,t,r){var e=n[t];ci.call(n,t)&&hu(e,r)&&(r!==F||t in n)||_t(n,t,r)}function lt(n,t){for(var r=n.length;r--;)if(hu(n[r][0],t))return r;return-1}function st(n,t,r,e){return oo(n,function(n,u,i){t(e,n,r(n),i)}),e}function ht(n,t){return n&&Tr(t,Lu(t),n)}function pt(n,t){return n&&Tr(t,Uu(t),n)}function _t(n,t,r){"__proto__"==t&&Ei?Ei(n,t,{configurable:true,enumerable:true,value:r,writable:true}):n[t]=r}function vt(n,t){for(var r=-1,e=t.length,u=Hu(e),i=null==n;++r<e;)u[r]=i?F:Wu(n,t[r]);return u;
  }function gt(n,t,r){return n===n&&(r!==F&&(n=n<=r?n:r),t!==F&&(n=n>=t?n:t)),n}function dt(n,t,r,e,i,o){var f,c=1&t,a=2&t,l=4&t;if(r&&(f=i?r(n,e,i,o):r(n)),f!==F)return f;if(!bu(n))return n;if(e=af(n)){if(f=Ee(n),!c)return Mr(n,f)}else{var s=yo(n),h="[object Function]"==s||"[object GeneratorFunction]"==s;if(sf(n))return Wr(n,c);if("[object Object]"==s||"[object Arguments]"==s||h&&!i){if(f=a||h?{}:Oe(n),!c)return a?Fr(n,pt(f,n)):$r(n,ht(f,n))}else{if(!Dn[s])return i?n:{};f=Se(n,s,dt,c)}}if(o||(o=new Vn),
      i=o.get(n))return i;o.set(n,f);var a=l?a?ye:de:a?Uu:Lu,p=e?F:a(n);return u(p||n,function(e,u){p&&(u=e,e=n[u]),at(f,u,dt(e,t,r,u,n,o))}),f}function yt(n){var t=Lu(n);return function(r){return bt(r,n,t)}}function bt(n,t,r){var e=r.length;if(null==n)return!e;for(n=ni(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===F&&!(u in n)||!i(o))return false}return true}function xt(n,t,r){if(typeof n!="function")throw new ei("Expected a function");return jo(function(){n.apply(F,r)},t)}function jt(n,t,r,e){var u=-1,i=c,o=true,f=n.length,s=[],h=t.length;
    if(!f)return s;r&&(t=l(t,S(r))),e?(i=a,o=false):200<=t.length&&(i=R,o=false,t=new qn(t));n:for(;++u<f;){var p=n[u],_=null==r?p:r(p),p=e||0!==p?p:0;if(o&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function wt(n,t){var r=true;return oo(n,function(n,e,u){return r=!!t(n,e,u)}),r}function mt(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===F?o===o&&!Au(o):r(o,f)))var f=o,c=i}return c}function At(n,t){var r=[];return oo(n,function(n,e,u){
    t(n,e,u)&&r.push(n)}),r}function kt(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Ie),u||(u=[]);++i<o;){var f=n[i];0<t&&r(f)?1<t?kt(f,t-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function Et(n,t){return n&&co(n,t,Lu)}function Ot(n,t){return n&&ao(n,t,Lu)}function St(n,t){return f(t,function(t){return gu(n[t])})}function It(n,t){t=Rr(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[$e(t[r++])];return r&&r==e?n:F}function Rt(n,t,r){return t=t(n),af(n)?t:s(t,r(n))}function zt(n){if(null==n)n=n===F?"[object Undefined]":"[object Null]";else if(ki&&ki in ni(n)){
    var t=ci.call(n,ki),r=n[ki];try{n[ki]=F;var e=true}catch(n){}var u=si.call(n);e&&(t?n[ki]=r:delete n[ki]),n=u}else n=si.call(n);return n}function Wt(n,t){return n>t}function Bt(n,t){return null!=n&&ci.call(n,t)}function Lt(n,t){return null!=n&&t in ni(n)}function Ut(n,t,r){for(var e=r?a:c,u=n[0].length,i=n.length,o=i,f=Hu(i),s=1/0,h=[];o--;){var p=n[o];o&&t&&(p=l(p,S(t))),s=Mi(p.length,s),f[o]=!r&&(t||120<=u&&120<=p.length)?new qn(o&&p):F}var p=n[0],_=-1,v=f[0];n:for(;++_<u&&h.length<s;){var g=p[_],d=t?t(g):g,g=r||0!==g?g:0;
    if(v?!R(v,d):!e(h,d,r)){for(o=i;--o;){var y=f[o];if(y?!R(y,d):!e(n[o],d,r))continue n}v&&v.push(d),h.push(g)}}return h}function Ct(n,t,r){var e={};return Et(n,function(n,u,i){t(e,r(n),u,i)}),e}function Dt(n,t,e){return t=Rr(t,n),n=2>t.length?n:It(n,vr(t,0,-1)),t=null==n?n:n[$e(Ge(t))],null==t?F:r(t,n,e)}function Mt(n){return xu(n)&&"[object Arguments]"==zt(n)}function Tt(n){return xu(n)&&"[object ArrayBuffer]"==zt(n)}function $t(n){return xu(n)&&"[object Date]"==zt(n)}function Ft(n,t,r,e,u){if(n===t)t=true;else if(null==n||null==t||!xu(n)&&!xu(t))t=n!==n&&t!==t;else n:{
    var i=af(n),o=af(t),f=i?"[object Array]":yo(n),c=o?"[object Array]":yo(t),f="[object Arguments]"==f?"[object Object]":f,c="[object Arguments]"==c?"[object Object]":c,a="[object Object]"==f,o="[object Object]"==c;if((c=f==c)&&sf(n)){if(!sf(t)){t=false;break n}i=true,a=false}if(c&&!a)u||(u=new Vn),t=i||gf(n)?_e(n,t,r,e,Ft,u):ve(n,t,f,r,e,Ft,u);else{if(!(1&r)&&(i=a&&ci.call(n,"__wrapped__"),f=o&&ci.call(t,"__wrapped__"),i||f)){n=i?n.value():n,t=f?t.value():t,u||(u=new Vn),t=Ft(n,t,r,e,u);break n}if(c)t:if(u||(u=new Vn),
        i=1&r,f=de(n),o=f.length,c=de(t).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in t:ci.call(t,l))){t=false;break t}}if((c=u.get(n))&&u.get(t))t=c==t;else{c=true,u.set(n,t),u.set(t,n);for(var s=i;++a<o;){var l=f[a],h=n[l],p=t[l];if(e)var _=i?e(p,h,l,t,n,u):e(h,p,l,n,t,u);if(_===F?h!==p&&!Ft(h,p,r,e,u):!_){c=false;break}s||(s="constructor"==l)}c&&!s&&(r=n.constructor,e=t.constructor,r!=e&&"constructor"in n&&"constructor"in t&&!(typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)&&(c=false)),
      u.delete(n),u.delete(t),t=c}}else t=false;else t=false}}return t}function Nt(n){return xu(n)&&"[object Map]"==yo(n)}function Pt(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=ni(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return false}for(;++u<i;){var f=r[u],c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===F&&!(c in n))return false}else{if(f=new Vn,e)var s=e(a,l,c,n,t,f);if(s===F?!Ft(l,a,3,e,f):!s)return false}}return true}function Zt(n){return!(!bu(n)||li&&li in n)&&(gu(n)?_i:xn).test(Fe(n))}function qt(n){
    return xu(n)&&"[object RegExp]"==zt(n)}function Vt(n){return xu(n)&&"[object Set]"==yo(n)}function Kt(n){return xu(n)&&yu(n.length)&&!!Cn[zt(n)]}function Gt(n){return typeof n=="function"?n:null==n?Nu:typeof n=="object"?af(n)?Xt(n[0],n[1]):Qt(n):Vu(n)}function Ht(n){if(!Le(n))return Ci(n);var t,r=[];for(t in ni(n))ci.call(n,t)&&"constructor"!=t&&r.push(t);return r}function Jt(n,t){return n<t}function Yt(n,t){var r=-1,e=pu(n)?Hu(n.length):[];return oo(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Qt(n){
    var t=me(n);return 1==t.length&&t[0][2]?Ue(t[0][0],t[0][1]):function(r){return r===n||Pt(r,n,t)}}function Xt(n,t){return We(n)&&t===t&&!bu(t)?Ue($e(n),t):function(r){var e=Wu(r,n);return e===F&&e===t?Bu(r,n):Ft(t,e,3)}}function nr(n,t,r,e,u){n!==t&&co(t,function(i,o){if(bu(i)){u||(u=new Vn);var f=u,c=n[o],a=t[o],l=f.get(a);if(l)ct(n,o,l);else{var l=e?e(c,a,o+"",n,t,f):F,s=l===F;if(s){var h=af(a),p=!h&&sf(a),_=!h&&!p&&gf(a),l=a;h||p||_?af(c)?l=c:_u(c)?l=Mr(c):p?(s=false,l=Wr(a,true)):_?(s=false,l=Lr(a,true)):l=[]:wu(a)||cf(a)?(l=c,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        cf(c)?l=Ru(c):(!bu(c)||r&&gu(c))&&(l=Oe(a))):s=false}s&&(f.set(a,l),nr(l,a,r,e,f),f.delete(a)),ct(n,o,l)}}else f=e?e(n[o],i,o+"",n,t,u):F,f===F&&(f=i),ct(n,o,f)},Uu)}function tr(n,t){var r=n.length;if(r)return t+=0>t?r:0,Re(t,r)?n[t]:F}function rr(n,t,r){var e=-1;return t=l(t.length?t:[Nu],S(je())),n=Yt(n,function(n){return{a:l(t,function(t){return t(n)}),b:++e,c:n}}),A(n,function(n,t){var e;n:{e=-1;for(var u=n.a,i=t.a,o=u.length,f=r.length;++e<o;){var c=Ur(u[e],i[e]);if(c){e=e>=f?c:c*("desc"==r[e]?-1:1);
    break n}}e=n.b-t.b}return e})}function er(n,t){return ur(n,t,function(t,r){return Bu(n,r)})}function ur(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=It(n,o);r(f,o)&&pr(i,Rr(o,n),f)}return i}function ir(n){return function(t){return It(t,n)}}function or(n,t,r,e){var u=e?y:d,i=-1,o=t.length,f=n;for(n===t&&(t=Mr(t)),r&&(f=l(n,S(r)));++i<o;)for(var c=0,a=t[i],a=r?r(a):a;-1<(c=u(f,a,c,e));)f!==n&&wi.call(f,c,1),wi.call(n,c,1);return n}function fr(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];
    if(r==e||u!==i){var i=u;Re(u)?wi.call(n,u,1):mr(n,u)}}}function cr(n,t){return n+zi(Fi()*(t-n+1))}function ar(n,t){var r="";if(!n||1>t||9007199254740991<t)return r;do t%2&&(r+=n),(t=zi(t/2))&&(n+=n);while(t);return r}function lr(n,t){return wo(Ce(n,t,Nu),n+"")}function sr(n){return tt(Du(n))}function hr(n,t){var r=Du(n);return Te(r,gt(t,0,r.length))}function pr(n,t,r,e){if(!bu(n))return n;t=Rr(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=$e(t[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):F;
    a===F&&(a=bu(l)?l:Re(t[u+1])?[]:{})}at(f,c,a),f=f[c]}return n}function _r(n){return Te(Du(n))}function vr(n,t,r){var e=-1,u=n.length;for(0>t&&(t=-t>u?0:u+t),r=r>u?u:r,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Hu(u);++e<u;)r[e]=n[e+t];return r}function gr(n,t){var r;return oo(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function dr(n,t,r){var e=0,u=null==n?e:n.length;if(typeof t=="number"&&t===t&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!Au(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return yr(n,t,Nu,r);
  }function yr(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,c=Au(t),a=t===F;u<i;){var l=zi((u+i)/2),s=r(n[l]),h=s!==F,p=null===s,_=s===s,v=Au(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=t:s<t)?u=l+1:i=l}return Mi(i,4294967294)}function br(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!hu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function xr(n){return typeof n=="number"?n:Au(n)?P:+n}function jr(n){if(typeof n=="string")return n;
    if(af(n))return l(n,jr)+"";if(Au(n))return uo?uo.call(n):"";var t=n+"";return"0"==t&&1/n==-N?"-0":t}function wr(n,t,r){var e=-1,u=c,i=n.length,o=true,f=[],l=f;if(r)o=false,u=a;else if(200<=i){if(u=t?null:po(n))return D(u);o=false,u=R,l=new qn}else l=t?[]:f;n:for(;++e<i;){var s=n[e],h=t?t(s):s,s=r||0!==s?s:0;if(o&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue n;t&&l.push(h),f.push(s)}else u(l,h,r)||(l!==f&&l.push(h),f.push(s))}return f}function mr(n,t){return t=Rr(t,n),n=2>t.length?n:It(n,vr(t,0,-1)),
  null==n||delete n[$e(Ge(t))]}function Ar(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?vr(n,e?0:i,e?i+1:u):vr(n,e?i+1:0,e?u:i)}function kr(n,t){var r=n;return r instanceof Mn&&(r=r.value()),h(t,function(n,t){return t.func.apply(t.thisArg,s([n],t.args))},r)}function Er(n,t,r){var e=n.length;if(2>e)return e?wr(n[0]):[];for(var u=-1,i=Hu(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=jt(i[u]||o,n[f],t,r));return wr(kt(i,1),t,r)}function Or(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;)r(o,n[e],e<i?t[e]:F);
    return o}function Sr(n){return _u(n)?n:[]}function Ir(n){return typeof n=="function"?n:Nu}function Rr(n,t){return af(n)?n:We(n,t)?[n]:mo(zu(n))}function zr(n,t,r){var e=n.length;return r=r===F?e:r,!t&&r>=e?n:vr(n,t,r)}function Wr(n,t){if(t)return n.slice();var r=n.length,r=yi?yi(r):new n.constructor(r);return n.copy(r),r}function Br(n){var t=new n.constructor(n.byteLength);return new di(t).set(new di(n)),t}function Lr(n,t){return new n.constructor(t?Br(n.buffer):n.buffer,n.byteOffset,n.length)}function Ur(n,t){
    if(n!==t){var r=n!==F,e=null===n,u=n===n,i=Au(n),o=t!==F,f=null===t,c=t===t,a=Au(t);if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Cr(n,t,r,e){var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Di(i-o,0),l=Hu(c+a);for(e=!e;++f<c;)l[f]=t[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l}function Dr(n,t,r,e){var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Di(i-f,0),s=Hu(l+a);
    for(e=!e;++u<l;)s[u]=n[u];for(l=u;++c<a;)s[l+c]=t[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=n[u++]);return s}function Mr(n,t){var r=-1,e=n.length;for(t||(t=Hu(e));++r<e;)t[r]=n[r];return t}function Tr(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):F;c===F&&(c=n[f]),u?_t(r,f,c):at(r,f,c)}return r}function $r(n,t){return Tr(n,vo(n),t)}function Fr(n,t){return Tr(n,go(n),t)}function Nr(n,t){return function(r,u){var i=af(r)?e:st,o=t?t():{};return i(r,n,je(u,2),o);
  }}function Pr(n){return lr(function(t,r){var e=-1,u=r.length,i=1<u?r[u-1]:F,o=2<u?r[2]:F,i=3<n.length&&typeof i=="function"?(u--,i):F;for(o&&ze(r[0],r[1],o)&&(i=3>u?F:i,u=1),t=ni(t);++e<u;)(o=r[e])&&n(t,o,e,i);return t})}function Zr(n,t){return function(r,e){if(null==r)return r;if(!pu(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=ni(r);(t?i--:++i<u)&&false!==e(o[i],i,o););return r}}function qr(n){return function(t,r,e){var u=-1,i=ni(t);e=e(t);for(var o=e.length;o--;){var f=e[n?o:++u];if(false===r(i[f],f,i))break;
  }return t}}function Vr(n,t,r){function e(){return(this&&this!==Zn&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=1&t,i=Hr(n);return e}function Kr(n){return function(t){t=zu(t);var r=Bn.test(t)?$(t):F,e=r?r[0]:t.charAt(0);return t=r?zr(r,1).join(""):t.slice(1),e[n]()+t}}function Gr(n){return function(t){return h($u(Tu(t).replace(In,"")),n,"")}}function Hr(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:
    return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=io(n.prototype),t=n.apply(r,t);return bu(t)?t:r}}function Jr(n,t,e){function u(){for(var o=arguments.length,f=Hu(o),c=o,a=xe(u);c--;)f[c]=arguments[c];return c=3>o&&f[0]!==a&&f[o-1]!==a?[]:C(f,a),o-=c.length,o<e?fe(n,t,Xr,u.placeholder,F,f,c,F,F,e-o):r(this&&this!==Zn&&this instanceof u?i:n,this,f);
  }var i=Hr(n);return u}function Yr(n){return function(t,r,e){var u=ni(t);if(!pu(t)){var i=je(r,3);t=Lu(t),r=function(n){return i(u[n],n,u)}}return r=n(t,r,e),-1<r?u[i?t[r]:r]:F}}function Qr(n){return ge(function(t){var r=t.length,e=r,u=zn.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if(typeof i!="function")throw new ei("Expected a function");if(u&&!o&&"wrapper"==be(i))var o=new zn([],true)}for(e=o?e:r;++e<r;)var i=t[e],u=be(i),f="wrapper"==u?_o(i):F,o=f&&Be(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[be(f[0])].apply(o,f[3]):1==i.length&&Be(i)?o[u]():o.thru(i);
    return function(){var n=arguments,e=n[0];if(o&&1==n.length&&af(e))return o.plant(e).value();for(var u=0,n=r?t[u].apply(this,n):e;++u<r;)n=t[u].call(this,n);return n}})}function Xr(n,t,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Hu(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=xe(l),b=y.length;for(x=0;b--;)y[b]===j&&++x}if(e&&(y=Cr(y,e,u,_)),i&&(y=Dr(y,i,o,_)),d-=x,_&&d<a)return j=C(y,j),fe(n,t,Xr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[n]:n,d=y.length,f){x=y.length;for(var w=Mi(f.length,x),m=Mr(y);w--;){
    var A=f[w];y[w]=Re(A,x)?m[A]:F}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==Zn&&this instanceof l&&(b=g||Hr(b)),b.apply(j,y)}var s=128&t,h=1&t,p=2&t,_=24&t,v=512&t,g=p?F:Hr(n);return l}function ne(n,t){return function(r,e){return Ct(r,n,t(e))}}function te(n,t){return function(r,e){var u;if(r===F&&e===F)return t;if(r!==F&&(u=r),e!==F){if(u===F)return e;typeof r=="string"||typeof e=="string"?(r=jr(r),e=jr(e)):(r=xr(r),e=xr(e)),u=n(r,e)}return u}}function re(n){return ge(function(t){
    return t=l(t,S(je())),lr(function(e){var u=this;return n(t,function(n){return r(n,u,e)})})})}function ee(n,t){t=t===F?" ":jr(t);var r=t.length;return 2>r?r?ar(t,n):t:(r=ar(t,Ri(n/T(t))),Bn.test(t)?zr($(r),0,n).join(""):r.slice(0,n))}function ue(n,t,e,u){function i(){for(var t=-1,c=arguments.length,a=-1,l=u.length,s=Hu(l+c),h=this&&this!==Zn&&this instanceof i?f:n;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++t];return r(h,o?e:this,s)}var o=1&t,f=Hr(n);return i}function ie(n){return function(t,r,e){
    e&&typeof e!="number"&&ze(t,r,e)&&(r=e=F),t=Eu(t),r===F?(r=t,t=0):r=Eu(r),e=e===F?t<r?1:-1:Eu(e);var u=-1;r=Di(Ri((r-t)/(e||1)),0);for(var i=Hu(r);r--;)i[n?r:++u]=t,t+=e;return i}}function oe(n){return function(t,r){return typeof t=="string"&&typeof r=="string"||(t=Iu(t),r=Iu(r)),n(t,r)}}function fe(n,t,r,e,u,i,o,f,c,a){var l=8&t,s=l?o:F;o=l?F:o;var h=l?i:F;return i=l?F:i,t=(t|(l?32:64))&~(l?64:32),4&t||(t&=-4),u=[n,t,u,h,s,i,o,f,c,a],r=r.apply(F,u),Be(n)&&xo(r,u),r.placeholder=e,De(r,n,t)}function ce(n){
    var t=Xu[n];return function(n,r){if(n=Iu(n),r=null==r?0:Mi(Ou(r),292)){var e=(zu(n)+"e").split("e"),e=t(e[0]+"e"+(+e[1]+r)),e=(zu(e)+"e").split("e");return+(e[0]+"e"+(+e[1]-r))}return t(n)}}function ae(n){return function(t){var r=yo(t);return"[object Map]"==r?L(t):"[object Set]"==r?M(t):O(t,n(t))}}function le(n,t,r,e,u,i,o,f){var c=2&t;if(!c&&typeof n!="function")throw new ei("Expected a function");var a=e?e.length:0;if(a||(t&=-97,e=u=F),o=o===F?o:Di(Ou(o),0),f=f===F?f:Ou(f),a-=u?u.length:0,64&t){
    var l=e,s=u;e=u=F}var h=c?F:_o(n);return i=[n,t,r,e,u,l,s,i,o,f],h&&(r=i[1],n=h[1],t=r|n,e=128==n&&8==r||128==n&&256==r&&i[7].length<=h[8]||384==n&&h[7].length<=h[8]&&8==r,131>t||e)&&(1&n&&(i[2]=h[2],t|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Cr(e,r,h[4]):r,i[4]=e?C(i[3],"__lodash_placeholder__"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Dr(e,r,h[6]):r,i[6]=e?C(i[5],"__lodash_placeholder__"):h[6]),(r=h[7])&&(i[7]=r),128&n&&(i[8]=null==i[8]?h[8]:Mi(i[8],h[8])),null==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=t),n=i[0],t=i[1],
    r=i[2],e=i[3],u=i[4],f=i[9]=i[9]===F?c?0:n.length:Di(i[9]-a,0),!f&&24&t&&(t&=-25),De((h?lo:xo)(t&&1!=t?8==t||16==t?Jr(n,t,f):32!=t&&33!=t||u.length?Xr.apply(F,i):ue(n,t,r,e):Vr(n,t,r),i),n,t)}function se(n,t,r,e){return n===F||hu(n,ii[r])&&!ci.call(e,r)?t:n}function he(n,t,r,e,u,i){return bu(n)&&bu(t)&&(i.set(t,n),nr(n,t,F,he,i),i.delete(t)),n}function pe(n){return wu(n)?F:n}function _e(n,t,r,e,u,i){var o=1&r,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(n))&&i.get(t))return c==t;var c=-1,a=true,l=2&r?new qn:F;
    for(i.set(n,t),i.set(t,n);++c<f;){var s=n[c],h=t[c];if(e)var p=o?e(h,s,c,t,n,i):e(s,h,c,n,t,i);if(p!==F){if(p)continue;a=false;break}if(l){if(!_(t,function(n,t){if(!R(l,t)&&(s===n||u(s,n,r,e,i)))return l.push(t)})){a=false;break}}else if(s!==h&&!u(s,h,r,e,i)){a=false;break}}return i.delete(n),i.delete(t),a}function ve(n,t,r,e,u,i,o){switch(r){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)break;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":if(n.byteLength!=t.byteLength||!i(new di(n),new di(t)))break;
    return true;case"[object Boolean]":case"[object Date]":case"[object Number]":return hu(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=L;case"[object Set]":if(f||(f=D),n.size!=t.size&&!(1&e))break;return(r=o.get(n))?r==t:(e|=2,o.set(n,t),t=_e(f(n),f(t),e,u,i,o),o.delete(n),t);case"[object Symbol]":if(eo)return eo.call(n)==eo.call(t)}return false}function ge(n){return wo(Ce(n,F,Ve),n+"")}function de(n){
    return Rt(n,Lu,vo)}function ye(n){return Rt(n,Uu,go)}function be(n){for(var t=n.name+"",r=Ji[t],e=ci.call(Ji,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function xe(n){return(ci.call(On,"placeholder")?On:n).placeholder}function je(){var n=On.iteratee||Pu,n=n===Pu?Gt:n;return arguments.length?n(arguments[0],arguments[1]):n}function we(n,t){var r=n.__data__,e=typeof t;return("string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t)?r[typeof t=="string"?"string":"hash"]:r.map;
  }function me(n){for(var t=Lu(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,u===u&&!bu(u)]}return t}function Ae(n,t){var r=null==n?F:n[t];return Zt(r)?r:F}function ke(n,t,r){t=Rr(t,n);for(var e=-1,u=t.length,i=false;++e<u;){var o=$e(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&yu(u)&&Re(o,u)&&(af(n)||cf(n)))}function Ee(n){var t=n.length,r=n.constructor(t);return t&&"string"==typeof n[0]&&ci.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Oe(n){
    return typeof n.constructor!="function"||Le(n)?{}:io(bi(n))}function Se(r,e,u,i){var o=r.constructor;switch(e){case"[object ArrayBuffer]":return Br(r);case"[object Boolean]":case"[object Date]":return new o(+r);case"[object DataView]":return e=i?Br(r.buffer):r.buffer,new r.constructor(e,r.byteOffset,r.byteLength);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":
    case"[object Uint16Array]":case"[object Uint32Array]":return Lr(r,i);case"[object Map]":return e=i?u(L(r),1):L(r),h(e,n,new r.constructor);case"[object Number]":case"[object String]":return new o(r);case"[object RegExp]":return e=new r.constructor(r.source,dn.exec(r)),e.lastIndex=r.lastIndex,e;case"[object Set]":return e=i?u(D(r),1):D(r),h(e,t,new r.constructor);case"[object Symbol]":return eo?ni(eo.call(r)):{}}}function Ie(n){return af(n)||cf(n)||!!(mi&&n&&n[mi])}function Re(n,t){return t=null==t?9007199254740991:t,
  !!t&&(typeof n=="number"||wn.test(n))&&-1<n&&0==n%1&&n<t}function ze(n,t,r){if(!bu(r))return false;var e=typeof t;return!!("number"==e?pu(r)&&Re(t,r.length):"string"==e&&t in r)&&hu(r[t],n)}function We(n,t){if(af(n))return false;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!Au(n))||(rn.test(n)||!tn.test(n)||null!=t&&n in ni(t))}function Be(n){var t=be(n),r=On[t];return typeof r=="function"&&t in Mn.prototype&&(n===r||(t=_o(r),!!t&&n===t[0]))}function Le(n){var t=n&&n.constructor;
    return n===(typeof t=="function"&&t.prototype||ii)}function Ue(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==F||n in ni(r)))}}function Ce(n,t,e){return t=Di(t===F?n.length-1:t,0),function(){for(var u=arguments,i=-1,o=Di(u.length-t,0),f=Hu(o);++i<o;)f[i]=u[t+i];for(i=-1,o=Hu(t+1);++i<t;)o[i]=u[i];return o[t]=e(f),r(n,this,o)}}function De(n,t,r){var e=t+"";t=wo;var u,i=Ne;return u=(u=e.match(hn))?u[1].split(pn):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?"& ":"")+r[u],r=r.join(2<i?", ":" "),
    e=e.replace(sn,"{\n/* [wrapped with "+r+"] */\n")),t(n,e)}function Me(n){var t=0,r=0;return function(){var e=Ti(),u=16-(e-r);if(r=e,0<u){if(800<=++t)return arguments[0]}else t=0;return n.apply(F,arguments)}}function Te(n,t){var r=-1,e=n.length,u=e-1;for(t=t===F?e:t;++r<t;){var e=cr(r,u),i=n[e];n[e]=n[r],n[r]=i}return n.length=t,n}function $e(n){if(typeof n=="string"||Au(n))return n;var t=n+"";return"0"==t&&1/n==-N?"-0":t}function Fe(n){if(null!=n){try{return fi.call(n)}catch(n){}return n+""}return"";
  }function Ne(n,t){return u(Z,function(r){var e="_."+r[0];t&r[1]&&!c(n,e)&&n.push(e)}),n.sort()}function Pe(n){if(n instanceof Mn)return n.clone();var t=new zn(n.__wrapped__,n.__chain__);return t.__actions__=Mr(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function Ze(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Ou(r),0>r&&(r=Di(e+r,0)),g(n,je(t,3),r)):-1}function qe(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==F&&(u=Ou(r),u=0>r?Di(e+u,0):Mi(u,e-1)),
    g(n,je(t,3),u,true)}function Ve(n){return(null==n?0:n.length)?kt(n,1):[]}function Ke(n){return n&&n.length?n[0]:F}function Ge(n){var t=null==n?0:n.length;return t?n[t-1]:F}function He(n,t){return n&&n.length&&t&&t.length?or(n,t):n}function Je(n){return null==n?n:Ni.call(n)}function Ye(n){if(!n||!n.length)return[];var t=0;return n=f(n,function(n){if(_u(n))return t=Di(n.length,t),true}),E(t,function(t){return l(n,j(t))})}function Qe(n,t){if(!n||!n.length)return[];var e=Ye(n);return null==t?e:l(e,function(n){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  return r(t,F,n)})}function Xe(n){return n=On(n),n.__chain__=true,n}function nu(n,t){return t(n)}function tu(){return this}function ru(n,t){return(af(n)?u:oo)(n,je(t,3))}function eu(n,t){return(af(n)?i:fo)(n,je(t,3))}function uu(n,t){return(af(n)?l:Yt)(n,je(t,3))}function iu(n,t,r){return t=r?F:t,t=n&&null==t?n.length:t,le(n,128,F,F,F,F,t)}function ou(n,t){var r;if(typeof t!="function")throw new ei("Expected a function");return n=Ou(n),function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=F),
    r}}function fu(n,t,r){return t=r?F:t,n=le(n,8,F,F,F,F,F,t),n.placeholder=fu.placeholder,n}function cu(n,t,r){return t=r?F:t,n=le(n,16,F,F,F,F,F,t),n.placeholder=cu.placeholder,n}function au(n,t,r){function e(t){var r=c,e=a;return c=a=F,_=t,s=n.apply(e,r)}function u(n){var r=n-p;return n-=_,p===F||r>=t||0>r||g&&n>=l}function i(){var n=Jo();if(u(n))return o(n);var r,e=jo;r=n-_,n=t-(n-p),r=g?Mi(n,l-r):n,h=e(i,r)}function o(n){return h=F,d&&c?e(n):(c=a=F,s)}function f(){var n=Jo(),r=u(n);if(c=arguments,
      a=this,p=n,r){if(h===F)return _=n=p,h=jo(i,t),v?e(n):s;if(g)return h=jo(i,t),e(p)}return h===F&&(h=jo(i,t)),s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof n!="function")throw new ei("Expected a function");return t=Iu(t)||0,bu(r)&&(v=!!r.leading,l=(g="maxWait"in r)?Di(Iu(r.maxWait)||0,t):l,d="trailing"in r?!!r.trailing:d),f.cancel=function(){h!==F&&ho(h),_=0,c=p=a=h=F},f.flush=function(){return h===F?s:o(Jo())},f}function lu(n,t){function r(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=n.apply(this,e),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                r.cache=i.set(u,e)||i,e)}if(typeof n!="function"||null!=t&&typeof t!="function")throw new ei("Expected a function");return r.cache=new(lu.Cache||Pn),r}function su(n){if(typeof n!="function")throw new ei("Expected a function");return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function hu(n,t){return n===t||n!==n&&t!==t}function pu(n){return null!=n&&yu(n.length)&&!gu(n);
  }function _u(n){return xu(n)&&pu(n)}function vu(n){if(!xu(n))return false;var t=zt(n);return"[object Error]"==t||"[object DOMException]"==t||typeof n.message=="string"&&typeof n.name=="string"&&!wu(n)}function gu(n){return!!bu(n)&&(n=zt(n),"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n)}function du(n){return typeof n=="number"&&n==Ou(n)}function yu(n){return typeof n=="number"&&-1<n&&0==n%1&&9007199254740991>=n}function bu(n){var t=typeof n;return null!=n&&("object"==t||"function"==t);
  }function xu(n){return null!=n&&typeof n=="object"}function ju(n){return typeof n=="number"||xu(n)&&"[object Number]"==zt(n)}function wu(n){return!(!xu(n)||"[object Object]"!=zt(n))&&(n=bi(n),null===n||(n=ci.call(n,"constructor")&&n.constructor,typeof n=="function"&&n instanceof n&&fi.call(n)==hi))}function mu(n){return typeof n=="string"||!af(n)&&xu(n)&&"[object String]"==zt(n)}function Au(n){return typeof n=="symbol"||xu(n)&&"[object Symbol]"==zt(n)}function ku(n){if(!n)return[];if(pu(n))return mu(n)?$(n):Mr(n);
    if(Ai&&n[Ai]){n=n[Ai]();for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}return t=yo(n),("[object Map]"==t?L:"[object Set]"==t?D:Du)(n)}function Eu(n){return n?(n=Iu(n),n===N||n===-N?1.7976931348623157e308*(0>n?-1:1):n===n?n:0):0===n?n:0}function Ou(n){n=Eu(n);var t=n%1;return n===n?t?n-t:n:0}function Su(n){return n?gt(Ou(n),0,4294967295):0}function Iu(n){if(typeof n=="number")return n;if(Au(n))return P;if(bu(n)&&(n=typeof n.valueOf=="function"?n.valueOf():n,n=bu(n)?n+"":n),typeof n!="string")return 0===n?n:+n;
    n=n.replace(cn,"");var t=bn.test(n);return t||jn.test(n)?Fn(n.slice(2),t?2:8):yn.test(n)?P:+n}function Ru(n){return Tr(n,Uu(n))}function zu(n){return null==n?"":jr(n)}function Wu(n,t,r){return n=null==n?F:It(n,t),n===F?r:n}function Bu(n,t){return null!=n&&ke(n,t,Lt)}function Lu(n){return pu(n)?Gn(n):Ht(n)}function Uu(n){if(pu(n))n=Gn(n,true);else if(bu(n)){var t,r=Le(n),e=[];for(t in n)("constructor"!=t||!r&&ci.call(n,t))&&e.push(t);n=e}else{if(t=[],null!=n)for(r in ni(n))t.push(r);n=t}return n}function Cu(n,t){
    if(null==n)return{};var r=l(ye(n),function(n){return[n]});return t=je(t),ur(n,r,function(n,r){return t(n,r[0])})}function Du(n){return null==n?[]:I(n,Lu(n))}function Mu(n){return Nf(zu(n).toLowerCase())}function Tu(n){return(n=zu(n))&&n.replace(mn,rt).replace(Rn,"")}function $u(n,t,r){return n=zu(n),t=r?F:t,t===F?Ln.test(n)?n.match(Wn)||[]:n.match(_n)||[]:n.match(t)||[]}function Fu(n){return function(){return n}}function Nu(n){return n}function Pu(n){return Gt(typeof n=="function"?n:dt(n,1))}function Zu(n,t,r){
    var e=Lu(t),i=St(t,e);null!=r||bu(t)&&(i.length||!e.length)||(r=t,t=n,n=this,i=St(t,Lu(t)));var o=!(bu(r)&&"chain"in r&&!r.chain),f=gu(n);return u(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Mr(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,s([this.value()],arguments))})}),n}function qu(){}function Vu(n){return We(n)?j($e(n)):ir(n)}function Ku(){return[]}function Gu(){
    return false}En=null==En?Zn:it.defaults(Zn.Object(),En,it.pick(Zn,Un));var Hu=En.Array,Ju=En.Date,Yu=En.Error,Qu=En.Function,Xu=En.Math,ni=En.Object,ti=En.RegExp,ri=En.String,ei=En.TypeError,ui=Hu.prototype,ii=ni.prototype,oi=En["__core-js_shared__"],fi=Qu.prototype.toString,ci=ii.hasOwnProperty,ai=0,li=function(){var n=/[^.]+$/.exec(oi&&oi.keys&&oi.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),si=ii.toString,hi=fi.call(ni),pi=Zn._,_i=ti("^"+fi.call(ci).replace(on,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),vi=Kn?En.Buffer:F,gi=En.Symbol,di=En.Uint8Array,yi=vi?vi.f:F,bi=U(ni.getPrototypeOf,ni),xi=ni.create,ji=ii.propertyIsEnumerable,wi=ui.splice,mi=gi?gi.isConcatSpreadable:F,Ai=gi?gi.iterator:F,ki=gi?gi.toStringTag:F,Ei=function(){
    try{var n=Ae(ni,"defineProperty");return n({},"",{}),n}catch(n){}}(),Oi=En.clearTimeout!==Zn.clearTimeout&&En.clearTimeout,Si=Ju&&Ju.now!==Zn.Date.now&&Ju.now,Ii=En.setTimeout!==Zn.setTimeout&&En.setTimeout,Ri=Xu.ceil,zi=Xu.floor,Wi=ni.getOwnPropertySymbols,Bi=vi?vi.isBuffer:F,Li=En.isFinite,Ui=ui.join,Ci=U(ni.keys,ni),Di=Xu.max,Mi=Xu.min,Ti=Ju.now,$i=En.parseInt,Fi=Xu.random,Ni=ui.reverse,Pi=Ae(En,"DataView"),Zi=Ae(En,"Map"),qi=Ae(En,"Promise"),Vi=Ae(En,"Set"),Ki=Ae(En,"WeakMap"),Gi=Ae(ni,"create"),Hi=Ki&&new Ki,Ji={},Yi=Fe(Pi),Qi=Fe(Zi),Xi=Fe(qi),no=Fe(Vi),to=Fe(Ki),ro=gi?gi.prototype:F,eo=ro?ro.valueOf:F,uo=ro?ro.toString:F,io=function(){
    function n(){}return function(t){return bu(t)?xi?xi(t):(n.prototype=t,t=new n,n.prototype=F,t):{}}}();On.templateSettings={escape:Q,evaluate:X,interpolate:nn,variable:"",imports:{_:On}},On.prototype=Sn.prototype,On.prototype.constructor=On,zn.prototype=io(Sn.prototype),zn.prototype.constructor=zn,Mn.prototype=io(Sn.prototype),Mn.prototype.constructor=Mn,Tn.prototype.clear=function(){this.__data__=Gi?Gi(null):{},this.size=0},Tn.prototype.delete=function(n){return n=this.has(n)&&delete this.__data__[n],
    this.size-=n?1:0,n},Tn.prototype.get=function(n){var t=this.__data__;return Gi?(n=t[n],"__lodash_hash_undefined__"===n?F:n):ci.call(t,n)?t[n]:F},Tn.prototype.has=function(n){var t=this.__data__;return Gi?t[n]!==F:ci.call(t,n)},Tn.prototype.set=function(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=Gi&&t===F?"__lodash_hash_undefined__":t,this},Nn.prototype.clear=function(){this.__data__=[],this.size=0},Nn.prototype.delete=function(n){var t=this.__data__;return n=lt(t,n),!(0>n)&&(n==t.length-1?t.pop():wi.call(t,n,1),
    --this.size,true)},Nn.prototype.get=function(n){var t=this.__data__;return n=lt(t,n),0>n?F:t[n][1]},Nn.prototype.has=function(n){return-1<lt(this.__data__,n)},Nn.prototype.set=function(n,t){var r=this.__data__,e=lt(r,n);return 0>e?(++this.size,r.push([n,t])):r[e][1]=t,this},Pn.prototype.clear=function(){this.size=0,this.__data__={hash:new Tn,map:new(Zi||Nn),string:new Tn}},Pn.prototype.delete=function(n){return n=we(this,n).delete(n),this.size-=n?1:0,n},Pn.prototype.get=function(n){return we(this,n).get(n);
  },Pn.prototype.has=function(n){return we(this,n).has(n)},Pn.prototype.set=function(n,t){var r=we(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this},qn.prototype.add=qn.prototype.push=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this},qn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.clear=function(){this.__data__=new Nn,this.size=0},Vn.prototype.delete=function(n){var t=this.__data__;return n=t.delete(n),this.size=t.size,n},Vn.prototype.get=function(n){
    return this.__data__.get(n)},Vn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.set=function(n,t){var r=this.__data__;if(r instanceof Nn){var e=r.__data__;if(!Zi||199>e.length)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new Pn(e)}return r.set(n,t),this.size=r.size,this};var oo=Zr(Et),fo=Zr(Ot,true),co=qr(),ao=qr(true),lo=Hi?function(n,t){return Hi.set(n,t),n}:Nu,so=Ei?function(n,t){return Ei(n,"toString",{configurable:true,enumerable:false,value:Fu(t),writable:true})}:Nu,ho=Oi||function(n){
      return Zn.clearTimeout(n)},po=Vi&&1/D(new Vi([,-0]))[1]==N?function(n){return new Vi(n)}:qu,_o=Hi?function(n){return Hi.get(n)}:qu,vo=Wi?function(n){return null==n?[]:(n=ni(n),f(Wi(n),function(t){return ji.call(n,t)}))}:Ku,go=Wi?function(n){for(var t=[];n;)s(t,vo(n)),n=bi(n);return t}:Ku,yo=zt;(Pi&&"[object DataView]"!=yo(new Pi(new ArrayBuffer(1)))||Zi&&"[object Map]"!=yo(new Zi)||qi&&"[object Promise]"!=yo(qi.resolve())||Vi&&"[object Set]"!=yo(new Vi)||Ki&&"[object WeakMap]"!=yo(new Ki))&&(yo=function(n){
    var t=zt(n);if(n=(n="[object Object]"==t?n.constructor:F)?Fe(n):"")switch(n){case Yi:return"[object DataView]";case Qi:return"[object Map]";case Xi:return"[object Promise]";case no:return"[object Set]";case to:return"[object WeakMap]"}return t});var bo=oi?gu:Gu,xo=Me(lo),jo=Ii||function(n,t){return Zn.setTimeout(n,t)},wo=Me(so),mo=function(n){n=lu(n,function(n){return 500===t.size&&t.clear(),n});var t=n.cache;return n}(function(n){var t=[];return en.test(n)&&t.push(""),n.replace(un,function(n,r,e,u){
    t.push(e?u.replace(vn,"$1"):r||n)}),t}),Ao=lr(function(n,t){return _u(n)?jt(n,kt(t,1,_u,true)):[]}),ko=lr(function(n,t){var r=Ge(t);return _u(r)&&(r=F),_u(n)?jt(n,kt(t,1,_u,true),je(r,2)):[]}),Eo=lr(function(n,t){var r=Ge(t);return _u(r)&&(r=F),_u(n)?jt(n,kt(t,1,_u,true),F,r):[]}),Oo=lr(function(n){var t=l(n,Sr);return t.length&&t[0]===n[0]?Ut(t):[]}),So=lr(function(n){var t=Ge(n),r=l(n,Sr);return t===Ge(r)?t=F:r.pop(),r.length&&r[0]===n[0]?Ut(r,je(t,2)):[]}),Io=lr(function(n){var t=Ge(n),r=l(n,Sr);return(t=typeof t=="function"?t:F)&&r.pop(),
    r.length&&r[0]===n[0]?Ut(r,F,t):[]}),Ro=lr(He),zo=ge(function(n,t){var r=null==n?0:n.length,e=vt(n,t);return fr(n,l(t,function(n){return Re(n,r)?+n:n}).sort(Ur)),e}),Wo=lr(function(n){return wr(kt(n,1,_u,true))}),Bo=lr(function(n){var t=Ge(n);return _u(t)&&(t=F),wr(kt(n,1,_u,true),je(t,2))}),Lo=lr(function(n){var t=Ge(n),t=typeof t=="function"?t:F;return wr(kt(n,1,_u,true),F,t)}),Uo=lr(function(n,t){return _u(n)?jt(n,t):[]}),Co=lr(function(n){return Er(f(n,_u))}),Do=lr(function(n){var t=Ge(n);return _u(t)&&(t=F),
    Er(f(n,_u),je(t,2))}),Mo=lr(function(n){var t=Ge(n),t=typeof t=="function"?t:F;return Er(f(n,_u),F,t)}),To=lr(Ye),$o=lr(function(n){var t=n.length,t=1<t?n[t-1]:F,t=typeof t=="function"?(n.pop(),t):F;return Qe(n,t)}),Fo=ge(function(n){function t(t){return vt(t,n)}var r=n.length,e=r?n[0]:0,u=this.__wrapped__;return!(1<r||this.__actions__.length)&&u instanceof Mn&&Re(e)?(u=u.slice(e,+e+(r?1:0)),u.__actions__.push({func:nu,args:[t],thisArg:F}),new zn(u,this.__chain__).thru(function(n){return r&&!n.length&&n.push(F),
                                                                                                                                                                                                                                                                                                                                                                                       n})):this.thru(t)}),No=Nr(function(n,t,r){ci.call(n,r)?++n[r]:_t(n,r,1)}),Po=Yr(Ze),Zo=Yr(qe),qo=Nr(function(n,t,r){ci.call(n,r)?n[r].push(t):_t(n,r,[t])}),Vo=lr(function(n,t,e){var u=-1,i=typeof t=="function",o=pu(n)?Hu(n.length):[];return oo(n,function(n){o[++u]=i?r(t,n,e):Dt(n,t,e)}),o}),Ko=Nr(function(n,t,r){_t(n,r,t)}),Go=Nr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Ho=lr(function(n,t){if(null==n)return[];var r=t.length;return 1<r&&ze(n,t[0],t[1])?t=[]:2<r&&ze(t[0],t[1],t[2])&&(t=[t[0]]),
    rr(n,kt(t,1),[])}),Jo=Si||function(){return Zn.Date.now()},Yo=lr(function(n,t,r){var e=1;if(r.length)var u=C(r,xe(Yo)),e=32|e;return le(n,e,t,r,u)}),Qo=lr(function(n,t,r){var e=3;if(r.length)var u=C(r,xe(Qo)),e=32|e;return le(t,e,n,r,u)}),Xo=lr(function(n,t){return xt(n,1,t)}),nf=lr(function(n,t,r){return xt(n,Iu(t)||0,r)});lu.Cache=Pn;var tf=lr(function(n,t){t=1==t.length&&af(t[0])?l(t[0],S(je())):l(kt(t,1),S(je()));var e=t.length;return lr(function(u){for(var i=-1,o=Mi(u.length,e);++i<o;)u[i]=t[i].call(this,u[i]);
    return r(n,this,u)})}),rf=lr(function(n,t){return le(n,32,F,t,C(t,xe(rf)))}),ef=lr(function(n,t){return le(n,64,F,t,C(t,xe(ef)))}),uf=ge(function(n,t){return le(n,256,F,F,F,t)}),of=oe(Wt),ff=oe(function(n,t){return n>=t}),cf=Mt(function(){return arguments}())?Mt:function(n){return xu(n)&&ci.call(n,"callee")&&!ji.call(n,"callee")},af=Hu.isArray,lf=Hn?S(Hn):Tt,sf=Bi||Gu,hf=Jn?S(Jn):$t,pf=Yn?S(Yn):Nt,_f=Qn?S(Qn):qt,vf=Xn?S(Xn):Vt,gf=nt?S(nt):Kt,df=oe(Jt),yf=oe(function(n,t){return n<=t}),bf=Pr(function(n,t){
    if(Le(t)||pu(t))Tr(t,Lu(t),n);else for(var r in t)ci.call(t,r)&&at(n,r,t[r])}),xf=Pr(function(n,t){Tr(t,Uu(t),n)}),jf=Pr(function(n,t,r,e){Tr(t,Uu(t),n,e)}),wf=Pr(function(n,t,r,e){Tr(t,Lu(t),n,e)}),mf=ge(vt),Af=lr(function(n){return n.push(F,se),r(jf,F,n)}),kf=lr(function(n){return n.push(F,he),r(Rf,F,n)}),Ef=ne(function(n,t,r){n[t]=r},Fu(Nu)),Of=ne(function(n,t,r){ci.call(n,t)?n[t].push(r):n[t]=[r]},je),Sf=lr(Dt),If=Pr(function(n,t,r){nr(n,t,r)}),Rf=Pr(function(n,t,r,e){nr(n,t,r,e)}),zf=ge(function(n,t){
    var r={};if(null==n)return r;var e=false;t=l(t,function(t){return t=Rr(t,n),e||(e=1<t.length),t}),Tr(n,ye(n),r),e&&(r=dt(r,7,pe));for(var u=t.length;u--;)mr(r,t[u]);return r}),Wf=ge(function(n,t){return null==n?{}:er(n,t)}),Bf=ae(Lu),Lf=ae(Uu),Uf=Gr(function(n,t,r){return t=t.toLowerCase(),n+(r?Mu(t):t)}),Cf=Gr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Df=Gr(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Mf=Kr("toLowerCase"),Tf=Gr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase();
  }),$f=Gr(function(n,t,r){return n+(r?" ":"")+Nf(t)}),Ff=Gr(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),Nf=Kr("toUpperCase"),Pf=lr(function(n,t){try{return r(n,F,t)}catch(n){return vu(n)?n:new Yu(n)}}),Zf=ge(function(n,t){return u(t,function(t){t=$e(t),_t(n,t,Yo(n[t],n))}),n}),qf=Qr(),Vf=Qr(true),Kf=lr(function(n,t){return function(r){return Dt(r,n,t)}}),Gf=lr(function(n,t){return function(r){return Dt(n,r,t)}}),Hf=re(l),Jf=re(o),Yf=re(_),Qf=ie(),Xf=ie(true),nc=te(function(n,t){return n+t},0),tc=ce("ceil"),rc=te(function(n,t){
    return n/t},1),ec=ce("floor"),uc=te(function(n,t){return n*t},1),ic=ce("round"),oc=te(function(n,t){return n-t},0);return On.after=function(n,t){if(typeof t!="function")throw new ei("Expected a function");return n=Ou(n),function(){if(1>--n)return t.apply(this,arguments)}},On.ary=iu,On.assign=bf,On.assignIn=xf,On.assignInWith=jf,On.assignWith=wf,On.at=mf,On.before=ou,On.bind=Yo,On.bindAll=Zf,On.bindKey=Qo,On.castArray=function(){if(!arguments.length)return[];var n=arguments[0];return af(n)?n:[n]},
    On.chain=Xe,On.chunk=function(n,t,r){if(t=(r?ze(n,t,r):t===F)?1:Di(Ou(t),0),r=null==n?0:n.length,!r||1>t)return[];for(var e=0,u=0,i=Hu(Ri(r/t));e<r;)i[u++]=vr(n,e,e+=t);return i},On.compact=function(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u},On.concat=function(){var n=arguments.length;if(!n)return[];for(var t=Hu(n-1),r=arguments[0];n--;)t[n-1]=arguments[n];return s(af(r)?Mr(r):[r],kt(t,1))},On.cond=function(n){var t=null==n?0:n.length,e=je();return n=t?l(n,function(n){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if("function"!=typeof n[1])throw new ei("Expected a function");return[e(n[0]),n[1]]}):[],lr(function(e){for(var u=-1;++u<t;){var i=n[u];if(r(i[0],this,e))return r(i[1],this,e)}})},On.conforms=function(n){return yt(dt(n,1))},On.constant=Fu,On.countBy=No,On.create=function(n,t){var r=io(n);return null==t?r:ht(r,t)},On.curry=fu,On.curryRight=cu,On.debounce=au,On.defaults=Af,On.defaultsDeep=kf,On.defer=Xo,On.delay=nf,On.difference=Ao,On.differenceBy=ko,On.differenceWith=Eo,On.drop=function(n,t,r){var e=null==n?0:n.length;
    return e?(t=r||t===F?1:Ou(t),vr(n,0>t?0:t,e)):[]},On.dropRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Ou(t),t=e-t,vr(n,0,0>t?0:t)):[]},On.dropRightWhile=function(n,t){return n&&n.length?Ar(n,je(t,3),true,true):[]},On.dropWhile=function(n,t){return n&&n.length?Ar(n,je(t,3),true):[]},On.fill=function(n,t,r,e){var u=null==n?0:n.length;if(!u)return[];for(r&&typeof r!="number"&&ze(n,t,r)&&(r=0,e=u),u=n.length,r=Ou(r),0>r&&(r=-r>u?0:u+r),e=e===F||e>u?u:Ou(e),0>e&&(e+=u),e=r>e?0:Su(e);r<e;)n[r++]=t;
    return n},On.filter=function(n,t){return(af(n)?f:At)(n,je(t,3))},On.flatMap=function(n,t){return kt(uu(n,t),1)},On.flatMapDeep=function(n,t){return kt(uu(n,t),N)},On.flatMapDepth=function(n,t,r){return r=r===F?1:Ou(r),kt(uu(n,t),r)},On.flatten=Ve,On.flattenDeep=function(n){return(null==n?0:n.length)?kt(n,N):[]},On.flattenDepth=function(n,t){return null!=n&&n.length?(t=t===F?1:Ou(t),kt(n,t)):[]},On.flip=function(n){return le(n,512)},On.flow=qf,On.flowRight=Vf,On.fromPairs=function(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){
    var u=n[t];e[u[0]]=u[1]}return e},On.functions=function(n){return null==n?[]:St(n,Lu(n))},On.functionsIn=function(n){return null==n?[]:St(n,Uu(n))},On.groupBy=qo,On.initial=function(n){return(null==n?0:n.length)?vr(n,0,-1):[]},On.intersection=Oo,On.intersectionBy=So,On.intersectionWith=Io,On.invert=Ef,On.invertBy=Of,On.invokeMap=Vo,On.iteratee=Pu,On.keyBy=Ko,On.keys=Lu,On.keysIn=Uu,On.map=uu,On.mapKeys=function(n,t){var r={};return t=je(t,3),Et(n,function(n,e,u){_t(r,t(n,e,u),n)}),r},On.mapValues=function(n,t){
    var r={};return t=je(t,3),Et(n,function(n,e,u){_t(r,e,t(n,e,u))}),r},On.matches=function(n){return Qt(dt(n,1))},On.matchesProperty=function(n,t){return Xt(n,dt(t,1))},On.memoize=lu,On.merge=If,On.mergeWith=Rf,On.method=Kf,On.methodOf=Gf,On.mixin=Zu,On.negate=su,On.nthArg=function(n){return n=Ou(n),lr(function(t){return tr(t,n)})},On.omit=zf,On.omitBy=function(n,t){return Cu(n,su(je(t)))},On.once=function(n){return ou(2,n)},On.orderBy=function(n,t,r,e){return null==n?[]:(af(t)||(t=null==t?[]:[t]),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            r=e?F:r,af(r)||(r=null==r?[]:[r]),rr(n,t,r))},On.over=Hf,On.overArgs=tf,On.overEvery=Jf,On.overSome=Yf,On.partial=rf,On.partialRight=ef,On.partition=Go,On.pick=Wf,On.pickBy=Cu,On.property=Vu,On.propertyOf=function(n){return function(t){return null==n?F:It(n,t)}},On.pull=Ro,On.pullAll=He,On.pullAllBy=function(n,t,r){return n&&n.length&&t&&t.length?or(n,t,je(r,2)):n},On.pullAllWith=function(n,t,r){return n&&n.length&&t&&t.length?or(n,t,F,r):n},On.pullAt=zo,On.range=Qf,On.rangeRight=Xf,On.rearg=uf,On.reject=function(n,t){
    return(af(n)?f:At)(n,su(je(t,3)))},On.remove=function(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=je(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return fr(n,u),r},On.rest=function(n,t){if(typeof n!="function")throw new ei("Expected a function");return t=t===F?t:Ou(t),lr(n,t)},On.reverse=Je,On.sampleSize=function(n,t,r){return t=(r?ze(n,t,r):t===F)?1:Ou(t),(af(n)?ot:hr)(n,t)},On.set=function(n,t,r){return null==n?n:pr(n,t,r)},On.setWith=function(n,t,r,e){return e=typeof e=="function"?e:F,
    null==n?n:pr(n,t,r,e)},On.shuffle=function(n){return(af(n)?ft:_r)(n)},On.slice=function(n,t,r){var e=null==n?0:n.length;return e?(r&&typeof r!="number"&&ze(n,t,r)?(t=0,r=e):(t=null==t?0:Ou(t),r=r===F?e:Ou(r)),vr(n,t,r)):[]},On.sortBy=Ho,On.sortedUniq=function(n){return n&&n.length?br(n):[]},On.sortedUniqBy=function(n,t){return n&&n.length?br(n,je(t,2)):[]},On.split=function(n,t,r){return r&&typeof r!="number"&&ze(n,t,r)&&(t=r=F),r=r===F?4294967295:r>>>0,r?(n=zu(n))&&(typeof t=="string"||null!=t&&!_f(t))&&(t=jr(t),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                !t&&Bn.test(n))?zr($(n),0,r):n.split(t,r):[]},On.spread=function(n,t){if(typeof n!="function")throw new ei("Expected a function");return t=null==t?0:Di(Ou(t),0),lr(function(e){var u=e[t];return e=zr(e,0,t),u&&s(e,u),r(n,this,e)})},On.tail=function(n){var t=null==n?0:n.length;return t?vr(n,1,t):[]},On.take=function(n,t,r){return n&&n.length?(t=r||t===F?1:Ou(t),vr(n,0,0>t?0:t)):[]},On.takeRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Ou(t),t=e-t,vr(n,0>t?0:t,e)):[]},On.takeRightWhile=function(n,t){
    return n&&n.length?Ar(n,je(t,3),false,true):[]},On.takeWhile=function(n,t){return n&&n.length?Ar(n,je(t,3)):[]},On.tap=function(n,t){return t(n),n},On.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new ei("Expected a function");return bu(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),au(n,t,{leading:e,maxWait:t,trailing:u})},On.thru=nu,On.toArray=ku,On.toPairs=Bf,On.toPairsIn=Lf,On.toPath=function(n){return af(n)?l(n,$e):Au(n)?[n]:Mr(mo(zu(n)))},On.toPlainObject=Ru,
    On.transform=function(n,t,r){var e=af(n),i=e||sf(n)||gf(n);if(t=je(t,4),null==r){var o=n&&n.constructor;r=i?e?new o:[]:bu(n)&&gu(o)?io(bi(n)):{}}return(i?u:Et)(n,function(n,e,u){return t(r,n,e,u)}),r},On.unary=function(n){return iu(n,1)},On.union=Wo,On.unionBy=Bo,On.unionWith=Lo,On.uniq=function(n){return n&&n.length?wr(n):[]},On.uniqBy=function(n,t){return n&&n.length?wr(n,je(t,2)):[]},On.uniqWith=function(n,t){return t=typeof t=="function"?t:F,n&&n.length?wr(n,F,t):[]},On.unset=function(n,t){return null==n||mr(n,t);
    },On.unzip=Ye,On.unzipWith=Qe,On.update=function(n,t,r){return null==n?n:pr(n,t,Ir(r)(It(n,t)),void 0)},On.updateWith=function(n,t,r,e){return e=typeof e=="function"?e:F,null!=n&&(n=pr(n,t,Ir(r)(It(n,t)),e)),n},On.values=Du,On.valuesIn=function(n){return null==n?[]:I(n,Uu(n))},On.without=Uo,On.words=$u,On.wrap=function(n,t){return rf(Ir(t),n)},On.xor=Co,On.xorBy=Do,On.xorWith=Mo,On.zip=To,On.zipObject=function(n,t){return Or(n||[],t||[],at)},On.zipObjectDeep=function(n,t){return Or(n||[],t||[],pr);
    },On.zipWith=$o,On.entries=Bf,On.entriesIn=Lf,On.extend=xf,On.extendWith=jf,Zu(On,On),On.add=nc,On.attempt=Pf,On.camelCase=Uf,On.capitalize=Mu,On.ceil=tc,On.clamp=function(n,t,r){return r===F&&(r=t,t=F),r!==F&&(r=Iu(r),r=r===r?r:0),t!==F&&(t=Iu(t),t=t===t?t:0),gt(Iu(n),t,r)},On.clone=function(n){return dt(n,4)},On.cloneDeep=function(n){return dt(n,5)},On.cloneDeepWith=function(n,t){return t=typeof t=="function"?t:F,dt(n,5,t)},On.cloneWith=function(n,t){return t=typeof t=="function"?t:F,dt(n,4,t)},
    On.conformsTo=function(n,t){return null==t||bt(n,t,Lu(t))},On.deburr=Tu,On.defaultTo=function(n,t){return null==n||n!==n?t:n},On.divide=rc,On.endsWith=function(n,t,r){n=zu(n),t=jr(t);var e=n.length,e=r=r===F?e:gt(Ou(r),0,e);return r-=t.length,0<=r&&n.slice(r,e)==t},On.eq=hu,On.escape=function(n){return(n=zu(n))&&Y.test(n)?n.replace(H,et):n},On.escapeRegExp=function(n){return(n=zu(n))&&fn.test(n)?n.replace(on,"\\$&"):n},On.every=function(n,t,r){var e=af(n)?o:wt;return r&&ze(n,t,r)&&(t=F),e(n,je(t,3));
    },On.find=Po,On.findIndex=Ze,On.findKey=function(n,t){return v(n,je(t,3),Et)},On.findLast=Zo,On.findLastIndex=qe,On.findLastKey=function(n,t){return v(n,je(t,3),Ot)},On.floor=ec,On.forEach=ru,On.forEachRight=eu,On.forIn=function(n,t){return null==n?n:co(n,je(t,3),Uu)},On.forInRight=function(n,t){return null==n?n:ao(n,je(t,3),Uu)},On.forOwn=function(n,t){return n&&Et(n,je(t,3))},On.forOwnRight=function(n,t){return n&&Ot(n,je(t,3))},On.get=Wu,On.gt=of,On.gte=ff,On.has=function(n,t){return null!=n&&ke(n,t,Bt);
    },On.hasIn=Bu,On.head=Ke,On.identity=Nu,On.includes=function(n,t,r,e){return n=pu(n)?n:Du(n),r=r&&!e?Ou(r):0,e=n.length,0>r&&(r=Di(e+r,0)),mu(n)?r<=e&&-1<n.indexOf(t,r):!!e&&-1<d(n,t,r)},On.indexOf=function(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Ou(r),0>r&&(r=Di(e+r,0)),d(n,t,r)):-1},On.inRange=function(n,t,r){return t=Eu(t),r===F?(r=t,t=0):r=Eu(r),n=Iu(n),n>=Mi(t,r)&&n<Di(t,r)},On.invoke=Sf,On.isArguments=cf,On.isArray=af,On.isArrayBuffer=lf,On.isArrayLike=pu,On.isArrayLikeObject=_u,
    On.isBoolean=function(n){return true===n||false===n||xu(n)&&"[object Boolean]"==zt(n)},On.isBuffer=sf,On.isDate=hf,On.isElement=function(n){return xu(n)&&1===n.nodeType&&!wu(n)},On.isEmpty=function(n){if(null==n)return true;if(pu(n)&&(af(n)||typeof n=="string"||typeof n.splice=="function"||sf(n)||gf(n)||cf(n)))return!n.length;var t=yo(n);if("[object Map]"==t||"[object Set]"==t)return!n.size;if(Le(n))return!Ht(n).length;for(var r in n)if(ci.call(n,r))return false;return true},On.isEqual=function(n,t){return Ft(n,t);
    },On.isEqualWith=function(n,t,r){var e=(r=typeof r=="function"?r:F)?r(n,t):F;return e===F?Ft(n,t,F,r):!!e},On.isError=vu,On.isFinite=function(n){return typeof n=="number"&&Li(n)},On.isFunction=gu,On.isInteger=du,On.isLength=yu,On.isMap=pf,On.isMatch=function(n,t){return n===t||Pt(n,t,me(t))},On.isMatchWith=function(n,t,r){return r=typeof r=="function"?r:F,Pt(n,t,me(t),r)},On.isNaN=function(n){return ju(n)&&n!=+n},On.isNative=function(n){if(bo(n))throw new Yu("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
      return Zt(n)},On.isNil=function(n){return null==n},On.isNull=function(n){return null===n},On.isNumber=ju,On.isObject=bu,On.isObjectLike=xu,On.isPlainObject=wu,On.isRegExp=_f,On.isSafeInteger=function(n){return du(n)&&-9007199254740991<=n&&9007199254740991>=n},On.isSet=vf,On.isString=mu,On.isSymbol=Au,On.isTypedArray=gf,On.isUndefined=function(n){return n===F},On.isWeakMap=function(n){return xu(n)&&"[object WeakMap]"==yo(n)},On.isWeakSet=function(n){return xu(n)&&"[object WeakSet]"==zt(n)},On.join=function(n,t){
      return null==n?"":Ui.call(n,t)},On.kebabCase=Cf,On.last=Ge,On.lastIndexOf=function(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;if(r!==F&&(u=Ou(r),u=0>u?Di(e+u,0):Mi(u,e-1)),t===t){for(r=u+1;r--&&n[r]!==t;);n=r}else n=g(n,b,u,true);return n},On.lowerCase=Df,On.lowerFirst=Mf,On.lt=df,On.lte=yf,On.max=function(n){return n&&n.length?mt(n,Nu,Wt):F},On.maxBy=function(n,t){return n&&n.length?mt(n,je(t,2),Wt):F},On.mean=function(n){return x(n,Nu)},On.meanBy=function(n,t){return x(n,je(t,2))},On.min=function(n){
      return n&&n.length?mt(n,Nu,Jt):F},On.minBy=function(n,t){return n&&n.length?mt(n,je(t,2),Jt):F},On.stubArray=Ku,On.stubFalse=Gu,On.stubObject=function(){return{}},On.stubString=function(){return""},On.stubTrue=function(){return true},On.multiply=uc,On.nth=function(n,t){return n&&n.length?tr(n,Ou(t)):F},On.noConflict=function(){return Zn._===this&&(Zn._=pi),this},On.noop=qu,On.now=Jo,On.pad=function(n,t,r){n=zu(n);var e=(t=Ou(t))?T(n):0;return!t||e>=t?n:(t=(t-e)/2,ee(zi(t),r)+n+ee(Ri(t),r))},On.padEnd=function(n,t,r){
      n=zu(n);var e=(t=Ou(t))?T(n):0;return t&&e<t?n+ee(t-e,r):n},On.padStart=function(n,t,r){n=zu(n);var e=(t=Ou(t))?T(n):0;return t&&e<t?ee(t-e,r)+n:n},On.parseInt=function(n,t,r){return r||null==t?t=0:t&&(t=+t),$i(zu(n).replace(an,""),t||0)},On.random=function(n,t,r){if(r&&typeof r!="boolean"&&ze(n,t,r)&&(t=r=F),r===F&&(typeof t=="boolean"?(r=t,t=F):typeof n=="boolean"&&(r=n,n=F)),n===F&&t===F?(n=0,t=1):(n=Eu(n),t===F?(t=n,n=0):t=Eu(t)),n>t){var e=n;n=t,t=e}return r||n%1||t%1?(r=Fi(),Mi(n+r*(t-n+$n("1e-"+((r+"").length-1))),t)):cr(n,t);
    },On.reduce=function(n,t,r){var e=af(n)?h:m,u=3>arguments.length;return e(n,je(t,4),r,u,oo)},On.reduceRight=function(n,t,r){var e=af(n)?p:m,u=3>arguments.length;return e(n,je(t,4),r,u,fo)},On.repeat=function(n,t,r){return t=(r?ze(n,t,r):t===F)?1:Ou(t),ar(zu(n),t)},On.replace=function(){var n=arguments,t=zu(n[0]);return 3>n.length?t:t.replace(n[1],n[2])},On.result=function(n,t,r){t=Rr(t,n);var e=-1,u=t.length;for(u||(u=1,n=F);++e<u;){var i=null==n?F:n[$e(t[e])];i===F&&(e=u,i=r),n=gu(i)?i.call(n):i;
    }return n},On.round=ic,On.runInContext=w,On.sample=function(n){return(af(n)?tt:sr)(n)},On.size=function(n){if(null==n)return 0;if(pu(n))return mu(n)?T(n):n.length;var t=yo(n);return"[object Map]"==t||"[object Set]"==t?n.size:Ht(n).length},On.snakeCase=Tf,On.some=function(n,t,r){var e=af(n)?_:gr;return r&&ze(n,t,r)&&(t=F),e(n,je(t,3))},On.sortedIndex=function(n,t){return dr(n,t)},On.sortedIndexBy=function(n,t,r){return yr(n,t,je(r,2))},On.sortedIndexOf=function(n,t){var r=null==n?0:n.length;if(r){
      var e=dr(n,t);if(e<r&&hu(n[e],t))return e}return-1},On.sortedLastIndex=function(n,t){return dr(n,t,true)},On.sortedLastIndexBy=function(n,t,r){return yr(n,t,je(r,2),true)},On.sortedLastIndexOf=function(n,t){if(null==n?0:n.length){var r=dr(n,t,true)-1;if(hu(n[r],t))return r}return-1},On.startCase=$f,On.startsWith=function(n,t,r){return n=zu(n),r=null==r?0:gt(Ou(r),0,n.length),t=jr(t),n.slice(r,r+t.length)==t},On.subtract=oc,On.sum=function(n){return n&&n.length?k(n,Nu):0},On.sumBy=function(n,t){return n&&n.length?k(n,je(t,2)):0;
    },On.template=function(n,t,r){var e=On.templateSettings;r&&ze(n,t,r)&&(t=F),n=zu(n),t=jf({},t,e,se),r=jf({},t.imports,e.imports,se);var u,i,o=Lu(r),f=I(r,o),c=0;r=t.interpolate||An;var a="__p+='";r=ti((t.escape||An).source+"|"+r.source+"|"+(r===nn?gn:An).source+"|"+(t.evaluate||An).source+"|$","g");var l="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,o,f,l){return e||(e=o),a+=n.slice(c,l).replace(kn,B),r&&(u=true,a+="'+__e("+r+")+'"),f&&(i=true,a+="';"+f+";\n__p+='"),
      e&&(a+="'+((__t=("+e+"))==null?'':__t)+'"),c=l+t.length,t}),a+="';",(t=t.variable)||(a="with(obj){"+a+"}"),a=(i?a.replace(q,""):a).replace(V,"$1").replace(K,"$1;"),a="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(u?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+a+"return __p}",t=Pf(function(){return Qu(o,l+"return "+a).apply(F,f)}),t.source=a,vu(t))throw t;return t},On.times=function(n,t){if(n=Ou(n),1>n||9007199254740991<n)return[];
      var r=4294967295,e=Mi(n,4294967295);for(t=je(t),n-=4294967295,e=E(e,t);++r<n;)t(r);return e},On.toFinite=Eu,On.toInteger=Ou,On.toLength=Su,On.toLower=function(n){return zu(n).toLowerCase()},On.toNumber=Iu,On.toSafeInteger=function(n){return n?gt(Ou(n),-9007199254740991,9007199254740991):0===n?n:0},On.toString=zu,On.toUpper=function(n){return zu(n).toUpperCase()},On.trim=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(cn,""):n&&(t=jr(t))?(n=$(n),r=$(t),t=z(n,r),r=W(n,r)+1,zr(n,t,r).join("")):n;
    },On.trimEnd=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(ln,""):n&&(t=jr(t))?(n=$(n),t=W(n,$(t))+1,zr(n,0,t).join("")):n},On.trimStart=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(an,""):n&&(t=jr(t))?(n=$(n),t=z(n,$(t)),zr(n,t).join("")):n},On.truncate=function(n,t){var r=30,e="...";if(bu(t))var u="separator"in t?t.separator:u,r="length"in t?Ou(t.length):r,e="omission"in t?jr(t.omission):e;n=zu(n);var i=n.length;if(Bn.test(n))var o=$(n),i=o.length;if(r>=i)return n;if(i=r-T(e),1>i)return e;
      if(r=o?zr(o,0,i).join(""):n.slice(0,i),u===F)return r+e;if(o&&(i+=r.length-i),_f(u)){if(n.slice(i).search(u)){var f=r;for(u.global||(u=ti(u.source,zu(dn.exec(u))+"g")),u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===F?i:c)}}else n.indexOf(jr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},On.unescape=function(n){return(n=zu(n))&&J.test(n)?n.replace(G,ut):n},On.uniqueId=function(n){var t=++ai;return zu(n)+t},On.upperCase=Ff,On.upperFirst=Nf,On.each=ru,On.eachRight=eu,On.first=Ke,
    Zu(On,function(){var n={};return Et(On,function(t,r){ci.call(On.prototype,r)||(n[r]=t)}),n}(),{chain:false}),On.VERSION="4.17.4",u("bind bindKey curry curryRight partial partialRight".split(" "),function(n){On[n].placeholder=On}),u(["drop","take"],function(n,t){Mn.prototype[n]=function(r){r=r===F?1:Di(Ou(r),0);var e=this.__filtered__&&!t?new Mn(this):this.clone();return e.__filtered__?e.__takeCount__=Mi(r,e.__takeCount__):e.__views__.push({size:Mi(r,4294967295),type:n+(0>e.__dir__?"Right":"")}),e},Mn.prototype[n+"Right"]=function(t){
      return this.reverse()[n](t).reverse()}}),u(["filter","map","takeWhile"],function(n,t){var r=t+1,e=1==r||3==r;Mn.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:je(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),u(["head","last"],function(n,t){var r="take"+(t?"Right":"");Mn.prototype[n]=function(){return this[r](1).value()[0]}}),u(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Mn.prototype[n]=function(){return this.__filtered__?new Mn(this):this[r](1);
    }}),Mn.prototype.compact=function(){return this.filter(Nu)},Mn.prototype.find=function(n){return this.filter(n).head()},Mn.prototype.findLast=function(n){return this.reverse().find(n)},Mn.prototype.invokeMap=lr(function(n,t){return typeof n=="function"?new Mn(this):this.map(function(r){return Dt(r,n,t)})}),Mn.prototype.reject=function(n){return this.filter(su(je(n)))},Mn.prototype.slice=function(n,t){n=Ou(n);var r=this;return r.__filtered__&&(0<n||0>t)?new Mn(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            t!==F&&(t=Ou(t),r=0>t?r.dropRight(-t):r.take(t-n)),r)},Mn.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Mn.prototype.toArray=function(){return this.take(4294967295)},Et(Mn.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=On[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(On.prototype[t]=function(){function t(n){return n=u.apply(On,s([n],f)),e&&h?n[0]:n}var o=this.__wrapped__,f=e?[1]:arguments,c=o instanceof Mn,a=f[0],l=c||af(o);
      l&&r&&typeof a=="function"&&1!=a.length&&(c=l=false);var h=this.__chain__,p=!!this.__actions__.length,a=i&&!h,c=c&&!p;return!i&&l?(o=c?o:new Mn(this),o=n.apply(o,f),o.__actions__.push({func:nu,args:[t],thisArg:F}),new zn(o,h)):a&&c?n.apply(this,f):(o=this.thru(t),a?e?o.value()[0]:o.value():o)})}),u("pop push shift sort splice unshift".split(" "),function(n){var t=ui[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);On.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){
      var u=this.value();return t.apply(af(u)?u:[],n)}return this[r](function(r){return t.apply(af(r)?r:[],n)})}}),Et(Mn.prototype,function(n,t){var r=On[t];if(r){var e=r.name+"";(Ji[e]||(Ji[e]=[])).push({name:t,func:r})}}),Ji[Xr(F,2).name]=[{name:"wrapper",func:F}],Mn.prototype.clone=function(){var n=new Mn(this.__wrapped__);return n.__actions__=Mr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Mr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Mr(this.__views__),
      n},Mn.prototype.reverse=function(){if(this.__filtered__){var n=new Mn(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},Mn.prototype.value=function(){var n,t=this.__wrapped__.value(),r=this.__dir__,e=af(t),u=0>r,i=e?t.length:0;n=i;for(var o=this.__views__,f=0,c=-1,a=o.length;++c<a;){var l=o[c],s=l.size;switch(l.type){case"drop":f+=s;break;case"dropRight":n-=s;break;case"take":n=Mi(n,f+s);break;case"takeRight":f=Di(f,n-s)}}if(n={start:f,end:n},o=n.start,f=n.end,n=f-o,
        o=u?f:o-1,f=this.__iteratees__,c=f.length,a=0,l=Mi(n,this.__takeCount__),!e||!u&&i==n&&l==n)return kr(t,this.__actions__);e=[];n:for(;n--&&a<l;){for(o+=r,u=-1,i=t[o];++u<c;){var h=f[u],s=h.type,h=(0,h.iteratee)(i);if(2==s)i=h;else if(!h){if(1==s)continue n;break n}}e[a++]=i}return e},On.prototype.at=Fo,On.prototype.chain=function(){return Xe(this)},On.prototype.commit=function(){return new zn(this.value(),this.__chain__)},On.prototype.next=function(){this.__values__===F&&(this.__values__=ku(this.value()));
      var n=this.__index__>=this.__values__.length;return{done:n,value:n?F:this.__values__[this.__index__++]}},On.prototype.plant=function(n){for(var t,r=this;r instanceof Sn;){var e=Pe(r);e.__index__=0,e.__values__=F,t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},On.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Mn?(this.__actions__.length&&(n=new Mn(this)),n=n.reverse(),n.__actions__.push({func:nu,args:[Je],thisArg:F}),new zn(n,this.__chain__)):this.thru(Je);
    },On.prototype.toJSON=On.prototype.valueOf=On.prototype.value=function(){return kr(this.__wrapped__,this.__actions__)},On.prototype.first=On.prototype.head,Ai&&(On.prototype[Ai]=tu),On}();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Zn._=it, define('../../sherpa/lib/lodash-4.17.4.min',[],function(){return it})):Vn?((Vn.exports=it)._=it,qn._=it):Zn._=it}).call(this);
// Copyright 2015, University of Colorado Boulder

/**
 * Locale information for all locales that we support
 *
 * Auto-generated by ExportPhetcommonLocales.java. We have decided that we will not auto-generate this file again,
 * so it is okay to modify this file if things need to be corrected or added.
 *
 * language codes are ISO 639-1, see http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
 * country codes are ISO 3166-1 alpha2, see http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
 *
 * NOTE: We are using an older version of ISO 639-1 because java.util.Locale maps some of the newer language codes to
 * older codes. See Locale.convertOldISOCodes.
 * The affected country codes are:
 * he -> iw (Hebrew)
 * yi -> ji (Yiddish)
 * id -> in (Indonesian)
 *
 * ALSO NOTE: We had a request to support Lakota, which is not included in ISO 639-1, and is only defined as a three-
 * letter code in ISO 639-3.  The locale combination 'lk' was not taken in ISO 639-1, so we added it.  Strictly
 * speaking, this is a deviation from the spec.
 */

/* eslint-env browser, node */


(function( global ) {

  var locales = {
    aa: {
      name: 'Afar',
      localizedName: 'Afar',
      direction: 'ltr'
    },
    ab: {
      name: 'Abkhazian',
      localizedName: 'Abkhazian',
      direction: 'ltr'
    },
    ae: {
      name: 'Avestan',
      localizedName: 'Avestan',
      direction: 'rtl'
    },
    af: {
      name: 'Afrikaans',
      localizedName: 'Afrikaans',
      direction: 'ltr'
    },
    ak: {
      name: 'Akan',
      localizedName: 'Akan',
      direction: 'ltr'
    },
    am: {
      name: 'Amharic',
      localizedName: 'Amharic',
      direction: 'ltr'
    },
    an: {
      name: 'Aragonese',
      localizedName: 'Aragonese',
      direction: 'ltr'
    },
    ar: {
      name: 'Arabic',
      localizedName: 'العربية',
      direction: 'rtl'
    },
    ar_MA: {
      name: 'Arabic, Morocco',
      localizedName: 'العربية (المغرب)',
      direction: 'rtl'
    },
    ar_SA: {
      name: 'Arabic, Saudi Arabia',
      localizedName: 'العربية (السعودية)',
      direction: 'rtl'
    },
    as: {
      name: 'Assamese',
      localizedName: 'Assamese',
      direction: 'ltr'
    },
    av: {
      name: 'Avaric',
      localizedName: 'Avaric',
      direction: 'ltr'
    },
    ay: {
      name: 'Aymara',
      localizedName: 'Aymara',
      direction: 'ltr'
    },
    az: {
      name: 'Azerbaijani',
      localizedName: 'Azerbaijani',
      direction: 'ltr'
    },
    ba: {
      name: 'Bashkir',
      localizedName: 'Bashkir',
      direction: 'ltr'
    },
    be: {
      name: 'Belarusian',
      localizedName: 'беларускі',
      direction: 'ltr'
    },
    bg: {
      name: 'Bulgarian',
      localizedName: 'български',
      direction: 'ltr'
    },
    bh: {
      name: 'Bihari',
      localizedName: 'Bihari',
      direction: 'ltr'
    },
    bi: {
      name: 'Bislama',
      localizedName: 'Bislama',
      direction: 'ltr'
    },
    bm: {
      name: 'Bambara',
      localizedName: 'Bambara',
      direction: 'ltr'
    },
    bn: {
      name: 'Bengali',
      localizedName: 'Bengali',
      direction: 'ltr'
    },
    bo: {
      name: 'Tibetan',
      localizedName: 'Tibetan',
      direction: 'ltr'
    },
    br: {
      name: 'Breton',
      localizedName: 'Breton',
      direction: 'ltr'
    },
    bs: {
      name: 'Bosnian',
      localizedName: 'Bosnian',
      direction: 'ltr'
    },
    ca: {
      name: 'Catalan',
      localizedName: 'català',
      direction: 'ltr'
    },
    ce: {
      name: 'Chechen',
      localizedName: 'Chechen',
      direction: 'ltr'
    },
    ch: {
      name: 'Chamorro',
      localizedName: 'Chamorro',
      direction: 'ltr'
    },
    co: {
      name: 'Corsican',
      localizedName: 'Corsican',
      direction: 'ltr'
    },
    cr: {
      name: 'Cree',
      localizedName: 'Cree',
      direction: 'ltr'
    },
    cs: {
      name: 'Czech',
      localizedName: 'čeština',
      direction: 'ltr'
    },
    cu: {
      name: 'Church Slavic',
      localizedName: 'Church Slavic',
      direction: 'ltr'
    },
    cv: {
      name: 'Chuvash',
      localizedName: 'Chuvash',
      direction: 'ltr'
    },
    cy: {
      name: 'Welsh',
      localizedName: 'Welsh',
      direction: 'ltr'
    },
    da: {
      name: 'Danish',
      localizedName: 'Dansk',
      direction: 'ltr'
    },
    de: {
      name: 'German',
      localizedName: 'Deutsch',
      direction: 'ltr'
    },
    dv: {
      name: 'Divehi',
      localizedName: 'Divehi',
      direction: 'ltr'
    },
    dz: {
      name: 'Dzongkha',
      localizedName: 'Dzongkha',
      direction: 'ltr'
    },
    ee: {
      name: 'Ewe',
      localizedName: 'Ewe',
      direction: 'ltr'
    },
    el: {
      name: 'Greek',
      localizedName: 'Ελληνικά',
      direction: 'ltr'
    },
    en: {
      name: 'English',
      localizedName: 'English',
      direction: 'ltr'
    },
    en_CA: {
      name: 'English, Canada',
      localizedName: 'English (Canada)',
      direction: 'ltr'
    },
    en_GB: {
      name: 'English, United Kingdom',
      localizedName: 'English (United Kingdom)',
      direction: 'ltr'
    },
    eo: {
      name: 'Esperanto',
      localizedName: 'Esperanto',
      direction: 'ltr'
    },
    es: {
      name: 'Spanish',
      localizedName: 'español',
      direction: 'ltr'
    },
    es_CO: {
      name: 'Spanish, Colombia',
      localizedName: 'español (Colombia)',
      direction: 'ltr'
    },
    es_CR: {
      name: 'Spanish, Costa Rica',
      localizedName: 'español (Costa Rica)',
      direction: 'ltr'
    },
    es_ES: {
      name: 'Spanish, Spain',
      localizedName: 'español (España)',
      direction: 'ltr'
    },
    es_MX: {
      name: 'Spanish, Mexico',
      localizedName: 'español (México)',
      direction: 'ltr'
    },
    es_PE: {
      name: 'Spanish, Peru',
      localizedName: 'español (Perú)',
      direction: 'ltr'
    },
    et: {
      name: 'Estonian',
      localizedName: 'Eesti',
      direction: 'ltr'
    },
    eu: {
      name: 'Basque',
      localizedName: 'Basque',
      direction: 'ltr'
    },
    fa: {
      name: 'Persian',
      localizedName: 'Persian',
      direction: 'rtl'
    },
    ff: {
      name: 'Fulah',
      localizedName: 'Fulah',
      direction: 'ltr'
    },
    fi: {
      name: 'Finnish',
      localizedName: 'suomi',
      direction: 'ltr'
    },
    fj: {
      name: 'Fijian',
      localizedName: 'Fijian',
      direction: 'ltr'
    },
    fo: {
      name: 'Faroese',
      localizedName: 'Faroese',
      direction: 'ltr'
    },
    fr: {
      name: 'French',
      localizedName: 'français',
      direction: 'ltr'
    },
    fu: {
      name: 'Friulian',
      localizedName: 'fu',
      direction: 'ltr'
    },
    fy: {
      name: 'Western Frisian',
      localizedName: 'Frisian',
      direction: 'ltr'
    },
    ga: {
      name: 'Irish',
      localizedName: 'Gaeilge',
      direction: 'ltr'
    },
    gd: {
      name: 'Scottish Gaelic',
      localizedName: 'Scottish Gaelic',
      direction: 'ltr'
    },
    gl: {
      name: 'Galician',
      localizedName: 'Gallegan',
      direction: 'ltr'
    },
    gn: {
      name: 'Guarani',
      localizedName: 'Guarani',
      direction: 'ltr'
    },
    gu: {
      name: 'Gujarati',
      localizedName: 'Gujarati',
      direction: 'ltr'
    },
    gv: {
      name: 'Manx',
      localizedName: 'Manx',
      direction: 'ltr'
    },
    ha: {
      name: 'Hausa',
      localizedName: 'Hausa',
      direction: 'ltr'
    },
    hi: {
      name: 'Hindi',
      localizedName: 'हिंदी',
      direction: 'ltr'
    },
    ho: {
      name: 'Hiri Motu',
      localizedName: 'Hiri Motu',
      direction: 'ltr'
    },
    hr: {
      name: 'Croatian',
      localizedName: 'hrvatski',
      direction: 'ltr'
    },
    ht: {
      name: 'Haitian',
      localizedName: 'Haitian',
      direction: 'ltr'
    },
    hu: {
      name: 'Hungarian',
      localizedName: 'magyar',
      direction: 'ltr'
    },
    hy: {
      name: 'Armenian',
      localizedName: 'Armenian',
      direction: 'ltr'
    },
    hz: {
      name: 'Herero',
      localizedName: 'Herero',
      direction: 'ltr'
    },
    ia: {
      name: 'Interlingua',
      localizedName: 'Interlingua',
      direction: 'ltr'
    },
    ie: {
      name: 'Interlingue',
      localizedName: 'Interlingue',
      direction: 'ltr'
    },
    ig: {
      name: 'Igbo',
      localizedName: 'Igbo',
      direction: 'ltr'
    },
    ii: {
      name: 'Sichuan Yi',
      localizedName: 'Sichuan Yi',
      direction: 'ltr'
    },
    ik: {
      name: 'Inupiaq',
      localizedName: 'Inupiaq',
      direction: 'ltr'
    },
    in: {
      name: 'Indonesian',
      localizedName: 'Bahasa Indonesia',
      direction: 'ltr'
    },
    io: {
      name: 'Ido',
      localizedName: 'Ido',
      direction: 'ltr'
    },
    is: {
      name: 'Icelandic',
      localizedName: 'íslenska',
      direction: 'ltr'
    },
    it: {
      name: 'Italian',
      localizedName: 'italiano',
      direction: 'ltr'
    },
    iu: {
      name: 'Inuktitut',
      localizedName: 'Inuktitut',
      direction: 'ltr'
    },
    iw: {
      name: 'Hebrew',
      localizedName: 'עברית',
      direction: 'rtl'
    },
    ja: {
      name: 'Japanese',
      localizedName: '日本語',
      direction: 'ltr'
    },
    ji: {
      name: 'Yiddish',
      localizedName: 'Yiddish',
      direction: 'ltr'
    },
    jv: {
      name: 'Javanese',
      localizedName: 'Javanese',
      direction: 'ltr'
    },
    ka: {
      name: 'Georgian',
      localizedName: 'Georgian',
      direction: 'ltr'
    },
    kg: {
      name: 'Kongo',
      localizedName: 'Kongo',
      direction: 'ltr'
    },
    ki: {
      name: 'Kikuyu',
      localizedName: 'Kikuyu',
      direction: 'ltr'
    },
    kj: {
      name: 'Kwanyama',
      localizedName: 'Kwanyama',
      direction: 'ltr'
    },
    kk: {
      name: 'Kazakh',
      localizedName: 'Kazakh',
      direction: 'ltr'
    },
    kl: {
      name: 'Kalaallisut',
      localizedName: 'Greenlandic',
      direction: 'ltr'
    },
    km: {
      name: 'Khmer',
      localizedName: 'Khmer',
      direction: 'ltr'
    },
    kn: {
      name: 'Kannada',
      localizedName: 'Kannada',
      direction: 'ltr'
    },
    ko: {
      name: 'Korean',
      localizedName: '한국어',
      direction: 'ltr'
    },
    kr: {
      name: 'Kanuri',
      localizedName: 'Kanuri',
      direction: 'ltr'
    },
    ks: {
      name: 'Kashmiri',
      localizedName: 'Kashmiri',
      direction: 'ltr'
    },
    ku: {
      name: 'Kurdish',
      localizedName: 'Kurdish',
      direction: 'ltr'
    },
    ku_TR: {
      name: 'Kurdish, Turkey',
      localizedName: 'Kurdish (Turkey)',
      direction: 'ltr'
    },
    kv: {
      name: 'Komi',
      localizedName: 'Komi',
      direction: 'ltr'
    },
    kw: {
      name: 'Cornish',
      localizedName: 'Cornish',
      direction: 'ltr'
    },
    ky: {
      name: 'Kirghiz',
      localizedName: 'Kirghiz',
      direction: 'ltr'
    },
    la: {
      name: 'Latin',
      localizedName: 'Latin',
      direction: 'ltr'
    },
    lb: {
      name: 'Luxembourgish',
      localizedName: 'Luxembourgish',
      direction: 'ltr'
    },
    lg: {
      name: 'Ganda',
      localizedName: 'Ganda',
      direction: 'ltr'
    },
    li: {
      name: 'Limburgish',
      localizedName: 'Limburgish',
      direction: 'ltr'
    },
    lk: {
      name: 'Lakota',
      localizedName: 'Lakota',
      direction: 'ltr'
    },
    ln: {
      name: 'Lingala',
      localizedName: 'Lingala',
      direction: 'ltr'
    },
    lo: {
      name: 'Lao',
      localizedName: 'Lao',
      direction: 'ltr'
    },
    lt: {
      name: 'Lithuanian',
      localizedName: 'Lietuvių',
      direction: 'ltr'
    },
    lu: {
      name: 'Luba-Katanga',
      localizedName: 'Luba-Katanga',
      direction: 'ltr'
    },
    lv: {
      name: 'Latvian',
      localizedName: 'Latviešu',
      direction: 'ltr'
    },
    mg: {
      name: 'Malagasy',
      localizedName: 'Malagasy',
      direction: 'ltr'
    },
    mh: {
      name: 'Marshallese',
      localizedName: 'Marshallese',
      direction: 'ltr'
    },
    mi: {
      name: 'Maori',
      localizedName: 'Maori',
      direction: 'ltr'
    },
    mk: {
      name: 'Macedonian',
      localizedName: 'македонски',
      direction: 'ltr'
    },
    ml: {
      name: 'Malayalam',
      localizedName: 'Malayalam',
      direction: 'ltr'
    },
    mn: {
      name: 'Mongolian',
      localizedName: 'Mongolian',
      direction: 'ltr'
    },
    mo: {
      name: 'Moldavian',
      localizedName: 'Moldavian',
      direction: 'ltr'
    },
    mr: {
      name: 'Marathi',
      localizedName: 'Marathi',
      direction: 'ltr'
    },
    ms: {
      name: 'Malay',
      localizedName: 'Bahasa Melayu',
      direction: 'ltr'
    },
    mt: {
      name: 'Maltese',
      localizedName: 'Malti',
      direction: 'ltr'
    },
    my: {
      name: 'Burmese',
      localizedName: 'Burmese',
      direction: 'ltr'
    },
    na: {
      name: 'Nauru',
      localizedName: 'Nauru',
      direction: 'ltr'
    },
    nb: {
      name: 'Norwegian Bokmal',
      localizedName: 'Norwegian Bokmål',
      direction: 'ltr'
    },
    nd: {
      name: 'North Ndebele',
      localizedName: 'North Ndebele',
      direction: 'ltr'
    },
    ne: {
      name: 'Nepali',
      localizedName: 'Nepali',
      direction: 'ltr'
    },
    ng: {
      name: 'Ndonga',
      localizedName: 'Ndonga',
      direction: 'ltr'
    },
    nl: {
      name: 'Dutch',
      localizedName: 'Nederlands',
      direction: 'ltr'
    },
    nn: {
      name: 'Norwegian Nynorsk',
      localizedName: 'Norwegian Nynorsk',
      direction: 'ltr'
    },
    nr: {
      name: 'South Ndebele',
      localizedName: 'South Ndebele',
      direction: 'ltr'
    },
    nv: {
      name: 'Navajo',
      localizedName: 'Navajo',
      direction: 'ltr'
    },
    ny: {
      name: 'Chichewa',
      localizedName: 'Nyanja',
      direction: 'ltr'
    },
    oc: {
      name: 'Occitan',
      localizedName: 'Occitan',
      direction: 'ltr'
    },
    oj: {
      name: 'Ojibwa',
      localizedName: 'Ojibwa',
      direction: 'ltr'
    },
    om: {
      name: 'Oromo',
      localizedName: 'Oromo',
      direction: 'ltr'
    },
    or: {
      name: 'Oriya',
      localizedName: 'Oriya',
      direction: 'ltr'
    },
    os: {
      name: 'Ossetian',
      localizedName: 'Ossetian',
      direction: 'ltr'
    },
    pa: {
      name: 'Panjabi',
      localizedName: 'Panjabi',
      direction: 'ltr'
    },
    pi: {
      name: 'Pali',
      localizedName: 'Pali',
      direction: 'ltr'
    },
    pl: {
      name: 'Polish',
      localizedName: 'polski',
      direction: 'ltr'
    },
    ps: {
      name: 'Pashto',
      localizedName: 'Pushto',
      direction: 'ltr'
    },
    pt: {
      name: 'Portuguese',
      localizedName: 'português',
      direction: 'ltr'
    },
    pt_BR: {
      name: 'Portuguese, Brazil',
      localizedName: 'português (Brasil)',
      direction: 'ltr'
    },
    qu: {
      name: 'Quechua',
      localizedName: 'Quechua',
      direction: 'ltr'
    },
    rm: {
      name: 'Raeto-Romance',
      localizedName: 'Raeto-Romance',
      direction: 'ltr'
    },
    rn: {
      name: 'Kirundi',
      localizedName: 'Rundi',
      direction: 'ltr'
    },
    ro: {
      name: 'Romanian',
      localizedName: 'română',
      direction: 'ltr'
    },
    ru: {
      name: 'Russian',
      localizedName: 'русский',
      direction: 'ltr'
    },
    rw: {
      name: 'Kinyarwanda',
      localizedName: 'Kinyarwanda',
      direction: 'ltr'
    },
    ry: {
      name: 'Rusyn',
      localizedName: 'ry',
      direction: 'ltr'
    },
    sa: {
      name: 'Sanskrit',
      localizedName: 'Sanskrit',
      direction: 'ltr'
    },
    sc: {
      name: 'Sardinian',
      localizedName: 'Sardinian',
      direction: 'ltr'
    },
    sd: {
      name: 'Sindhi',
      localizedName: 'Sindhi',
      direction: 'ltr'
    },
    se: {
      name: 'Northern Sami',
      localizedName: 'Northern Sami',
      direction: 'ltr'
    },
    sg: {
      name: 'Sango',
      localizedName: 'Sango',
      direction: 'ltr'
    },
    sh: {
      name: 'Serbo-Croatian',
      localizedName: 'sh',
      direction: 'ltr'
    },
    si: {
      name: 'Sinhalese',
      localizedName: 'Sinhalese',
      direction: 'ltr'
    },
    sk: {
      name: 'Slovak',
      localizedName: 'Slovenčina',
      direction: 'ltr'
    },
    sl: {
      name: 'Slovenian',
      localizedName: 'Slovenščina',
      direction: 'ltr'
    },
    sm: {
      name: 'Samoan',
      localizedName: 'Samoan',
      direction: 'ltr'
    },
    sn: {
      name: 'Shona',
      localizedName: 'Shona',
      direction: 'ltr'
    },
    so: {
      name: 'Somali',
      localizedName: 'Somali',
      direction: 'ltr'
    },
    sq: {
      name: 'Albanian',
      localizedName: 'shqipe',
      direction: 'ltr'
    },
    sr: {
      name: 'Serbian',
      localizedName: 'Српски',
      direction: 'ltr'
    },
    ss: {
      name: 'Swati',
      localizedName: 'Swati',
      direction: 'ltr'
    },
    st: {
      name: 'Sotho',
      localizedName: 'Southern Sotho',
      direction: 'ltr'
    },
    su: {
      name: 'Sundanese',
      localizedName: 'Sundanese',
      direction: 'ltr'
    },
    sv: {
      name: 'Swedish',
      localizedName: 'svenska',
      direction: 'ltr'
    },
    sw: {
      name: 'Swahili',
      localizedName: 'Swahili',
      direction: 'ltr'
    },
    ta: {
      name: 'Tamil',
      localizedName: 'Tamil',
      direction: 'ltr'
    },
    te: {
      name: 'Telugu',
      localizedName: 'Telugu',
      direction: 'ltr'
    },
    tg: {
      name: 'Tajik',
      localizedName: 'Tajik',
      direction: 'ltr'
    },
    th: {
      name: 'Thai',
      localizedName: 'ไทย',
      direction: 'ltr'
    },
    ti: {
      name: 'Tigrinya',
      localizedName: 'Tigrinya',
      direction: 'ltr'
    },
    tk: {
      name: 'Turkmen',
      localizedName: 'Turkmen',
      direction: 'ltr'
    },
    tl: {
      name: 'Tagalog',
      localizedName: 'Tagalog',
      direction: 'ltr'
    },
    tn: {
      name: 'Tswana',
      localizedName: 'Tswana',
      direction: 'ltr'
    },
    to: {
      name: 'Tonga',
      localizedName: 'Tonga',
      direction: 'ltr'
    },
    tr: {
      name: 'Turkish',
      localizedName: 'Türkçe',
      direction: 'ltr'
    },
    ts: {
      name: 'Tsonga',
      localizedName: 'Tsonga',
      direction: 'ltr'
    },
    tt: {
      name: 'Tatar',
      localizedName: 'Tatar',
      direction: 'ltr'
    },
    tw: {
      name: 'Twi',
      localizedName: 'Twi',
      direction: 'ltr'
    },
    ty: {
      name: 'Tahitian',
      localizedName: 'Tahitian',
      direction: 'ltr'
    },
    ug: {
      name: 'Uighur',
      localizedName: 'Uighur',
      direction: 'ltr'
    },
    uk: {
      name: 'Ukrainian',
      localizedName: 'українська',
      direction: 'ltr'
    },
    ur: {
      name: 'Urdu',
      localizedName: 'Urdu',
      direction: 'rtl'
    },
    uz: {
      name: 'Uzbek',
      localizedName: 'Uzbek',
      direction: 'ltr'
    },
    ve: {
      name: 'Venda',
      localizedName: 'Venda',
      direction: 'ltr'
    },
    vi: {
      name: 'Vietnamese',
      localizedName: 'Tiếng Việt',
      direction: 'ltr'
    },
    vo: {
      name: 'Volapuk',
      localizedName: 'Volapük',
      direction: 'ltr'
    },
    wa: {
      name: 'Walloon',
      localizedName: 'Walloon',
      direction: 'ltr'
    },
    wo: {
      name: 'Wolof',
      localizedName: 'Wolof',
      direction: 'ltr'
    },
    xh: {
      name: 'Xhosa',
      localizedName: 'Xhosa',
      direction: 'ltr'
    },
    yo: {
      name: 'Yoruba',
      localizedName: 'Yoruba',
      direction: 'ltr'
    },
    za: {
      name: 'Zhuang',
      localizedName: 'Zhuang',
      direction: 'ltr'
    },
    zh_CN: {
      name: 'Chinese, Simplified',
      localizedName: '中文 (中国)',
      direction: 'ltr'
    },
    zh_HK: {
      name: 'Chinese, Hong Kong',
      localizedName: '中文 (香港)',
      direction: 'ltr'
    },
    zh_TW: {
      name: 'Chinese, Traditional',
      localizedName: '中文 (台灣)',
      direction: 'ltr'
    },
    zu: {
      name: 'Zulu',
      localizedName: 'Zulu',
      direction: 'ltr'
    }
  };

  // browser require.js-compatible definition
  global.define && global.define( function() {
    return locales;
  } );

  // Node.js-compatible definition
  if ( typeof module !== 'undefined' ) {
    module.exports = locales;
  }
})( this );

define("../../chipper/js/data/localeInfo", function(){});

// Copyright 2015, University of Colorado Boulder

/**
 * Constants used throughout chipper.
 * All fields are @public (read-only)
 *
 * @author Sam Reid
 * @author Chris Malley (PixelZoom, Inc.)
 */

/* eslint-env browser, node */


(function() {

  var ChipperConstants = {

    // Locale to use when no locale is specified
    FALLBACK_LOCALE: 'en',

    // Media types, also the directory names where the media files live
    MEDIA_TYPES: [ 'audio', 'images' ],

    // Used to fill in sim.html, the sim template
    START_THIRD_PARTY_LICENSE_ENTRIES: '### START THIRD PARTY LICENSE ENTRIES ###',

    // Used to fill in sim.html, the sim template
    END_THIRD_PARTY_LICENSE_ENTRIES: '### END THIRD PARTY LICENSE ENTRIES ###',

    // name of build directory
    BUILD_DIR: 'build'
  };

  // browser require.js-compatible definition
  if ( typeof define !== 'undefined' ) {
    define( '../../chipper/js/common/ChipperConstants',[],function() {
      return ChipperConstants;
    } );
  }

  // Node.js-compatible definition
  if ( typeof module !== 'undefined' ) {
    module.exports = ChipperConstants;
  }

})();
// Copyright 2015, University of Colorado Boulder

/**
 * String utilities used throughout chipper.
 *
 * @Chris Malley (PixelZoom, Inc.)
 */

/* eslint-env browser, node */


(function() {

  var ChipperStringUtils = {

    /**
     * Pad LTR/RTL language values with unicode embedding marks (see https://github.com/phetsims/joist/issues/152)
     * Uses directional formatting characters: http://unicode.org/reports/tr9/#Directional_Formatting_Characters
     *
     * @param {string} str
     * @param {boolean} isRTL
     * @returns {string} the input string padded with the embedding marks, or an empty string if the input was empty
     */
    addDirectionalFormatting: function( str, isRTL ) {
      if ( str.length > 0 ) {
        return ( isRTL ? '\u202b' : '\u202a' ) + str + '\u202c';
      }
      else {
        return str;
      }
    },

    /**
     * Converts a string to camel case, eg: 'simula-rasa' -> 'simulaRasa'
     * See http://stackoverflow.com/questions/10425287/convert-string-to-camelcase-with-regular-expression
     *
     * @param {string} str - the input string
     * @returns {string} a new string
     */
    toCamelCase: function( str ) {
      return str.toLowerCase().replace( /-(.)/g, function( match, group1 ) {
        return group1.toUpperCase();
      } );
    },

    /**
     * Coerces a repository name to a sim title, eg, 'simula-rasa' -> 'Simula Rasa'
     * @param {string} simName - the input string like 'build-an-atom'
     * @returns {string}
     */
    toTitle: function toTitle( simName ) {
      var tmpString = simName.replace( /-(.)/g, function( match, group1 ) {
        return ' ' + group1.toUpperCase();
      } );
      return tmpString.substring( 0, 1 ).toUpperCase() + tmpString.substring( 1 );
    },

    /**
     * Appends spaces to a string
     *
     * @param {string} str - the input string
     * @param {number} n - number of spaces to append
     * @returns {string} a new string
     */
    padString: function( str, n ) {
      while ( str.length < n ) {
        str += ' ';
      }
      return str;
    },

    /**
     * Replaces all occurrences of {string} find with {string} replace in {string} str
     *
     * @param {string} str - the input string
     * @param {string} find - the string to find
     * @param {string} replaceWith - the string to replace find with
     * @returns {string} a new string
     */
    replaceAll: function( str, find, replaceWith ) {
      return str.replace( new RegExp( find.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' ), 'g' ), replaceWith );
    },

    //TODO chipper#316 determine why this behaves differently than str.replace for some cases (eg, 'MAIN_INLINE_JAVASCRIPT')
    /**
     * Replaces the first occurrence of {string} find with {string} replace in {string} str
     *
     * @param {string} str - the input string
     * @param {string} find - the string to find
     * @param {string} replaceWith - the string to replace find with
     * @returns {string} a new string
     */
    replaceFirst: function( str, find, replaceWith ) {
      var idx = str.indexOf( find );
      if ( str.indexOf( find ) !== -1 ) {
        return str.slice( 0, idx ) + replaceWith + str.slice( idx + find.length );
      }
      else {
        return str;
      }
    },

    /**
     * Returns true if one string ends with another.  See http://stackoverflow.com/questions/280634/endswith-in-javascript
     * @param {string} string - the parent string within which to search
     * @param {string} suffix - the suffix
     * @returns {boolean}
     */
    endsWith: function( string, suffix ) {
      return string.indexOf( suffix, string.length - suffix.length ) !== -1;
    },

    /**
     * Return the first line that contains the substring 'find'
     * @param {string} string - the parent string within which to search
     * @param {string} find - the legal regex string to be found
     * @returns {array} - the whole line containing the matched substring
     */
    firstLineThatContains: function( string, find ) {
      var findRE = '.*' + find.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' ) + '.*';
      var theReturn = string.match( new RegExp( findRE, 'g' ) );
      return theReturn ? theReturn[ 0 ] : null;
    }
  };

  // browser require.js-compatible definition
  if ( typeof define !== 'undefined' ) {
    define( '../../chipper/js/common/ChipperStringUtils',[],function() {
      return ChipperStringUtils;
    } );
  }

  // Node.js-compatible definition
  if ( typeof module !== 'undefined' ) {
    module.exports = ChipperStringUtils;
  }

})();

define('string',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});

define("string!PENDULUM_LAB/custom",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/custom");});


define("string!PENDULUM_LAB/earth",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/earth");});


define("string!PENDULUM_LAB/jupiter",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/jupiter");});


define("string!PENDULUM_LAB/moon",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/moon");});


define("string!PENDULUM_LAB/planetX",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/planetX");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Body model for gravitational acceleration
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/common/model/Body',['require','PENDULUM_LAB/pendulumLab','string!PENDULUM_LAB/custom','string!PENDULUM_LAB/earth','string!PENDULUM_LAB/jupiter','string!PENDULUM_LAB/moon','string!PENDULUM_LAB/planetX'],function( require ) {
  'use strict';

  // modules
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );

  // strings
  var customString = require( 'string!PENDULUM_LAB/custom' );
  var earthString = require( 'string!PENDULUM_LAB/earth' );
  var jupiterString = require( 'string!PENDULUM_LAB/jupiter' );
  var moonString = require( 'string!PENDULUM_LAB/moon' );
  var planetXString = require( 'string!PENDULUM_LAB/planetX' );

  /**
   * @constructor
   *
   * @param {string} title
   * @param {number|null} gravity - Gravitational acceleration on body (m/s^2) if defined.
   */
  function Body( title, gravity ) {
    // @public {string} (read-only)
    this.title = title;

    // @public {number|null} (read-only) - Gravitation acceleration (if available) in meters/second^2
    this.gravity = gravity;
  }

  pendulumLab.register( 'Body', Body );

  Body.MOON = new Body( moonString, 1.62 );
  Body.EARTH = new Body( earthString, 9.81 );
  Body.JUPITER = new Body( jupiterString, 24.79 );
  Body.PLANET_X = new Body( planetXString, 14.2 );
  Body.CUSTOM = new Body( customString, null );

  // array of all the bodies used in the simulation.
  Body.BODIES = [
    Body.MOON,
    Body.EARTH,
    Body.JUPITER,
    Body.PLANET_X,
    Body.CUSTOM
  ];

  // verify that enumeration is immutable, without the runtime penalty in production code
  if ( assert ) { Object.freeze( Body ); }

  return Body;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Property whose value must be a number, with optional range validation.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'AXON/NumberProperty',['require','PHET_CORE/inherit','AXON/Property','AXON/axon'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );

  // constants
  /**
   * @param {*} value
   * @returns {boolean}
   */
  var IS_NUMBER = function( value ) {
    return ( typeof value === 'number' );
  };

  /**
   * @param {number} value - initial value
   * @param {Object} [options]
   * @constructor
   */
  function NumberProperty( value, options ) {

    options = _.extend( {
      range: null // {null|Range|{min:number, max:number}} range of the value
    }, options );

    assert && assert( !options.validValues, 'NumberProperty cannot use validValues' );
    assert && assert( !options.isValidValue, 'NumberProperty implements its own isValidValue' );

    if ( options.range ) {
      options.isValidValue = function( value ) {
        return IS_NUMBER( value ) && ( value >= options.range.min ) && ( value <= options.range.max );
      };
    }
    else {
      options.isValidValue = IS_NUMBER;
    }

    Property.call( this, value, options );
  }

  axon.register( 'NumberProperty', NumberProperty );

  return inherit( Property, NumberProperty );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Object instance allocation tracking, so we can cut down on garbage collection.
 *
 * Sample usage:
 * 1. Run the sim and set up the scenario that you wish to profile
 * 2. In the JS console, type: window.alloc={}
 * 3. Wait until you have taken enough data
 * 4. Type x = window.alloc; delete window.alloc;
 *
 * To record 1 second of data after a 2 second delay
 * 1. window.phetAllocationRecord()
 *
 * Now you can inspect the x variable which contains the allocation information.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'PHET_CORE/phetAllocation',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  window.phetAllocationRecord = function() {

    console.log( 'ready, set...' );

    // start after 2 sec
    setTimeout( function() {
      console.log( 'go!' );
      window.alloc = {};

      setTimeout( function() {
        window.recordedAllocations = window.alloc;
        delete window.alloc;
        console.log( 'after ' + window.recordedAllocations.loop.count + ' loops: window.recordedAllocations = ' );
        console.log( window.recordedAllocations );
      }, 1000 );
    }, 2000 );
  };

  function phetAllocation( name ) {
    if ( window.alloc ) {
      var stack;
      try { throw new Error(); }
      catch( e ) { stack = e.stack; }

      if ( !window.alloc[ name ] ) {
        window.alloc[ name ] = { count: 0, stacks: {} };
      }
      var log = window.alloc[ name ];

      log.count++;
      if ( !log.stacks[ stack ] ) {
        log.stacks[ stack ] = 1;
      }
      else {
        log.stacks[ stack ] += 1;
      }
      log.report = function() {
        var stacks = Object.keys( log.stacks );
        stacks = _.sortBy( stacks, function( key ) { return log.stacks[ key ]; } );
        _.each( stacks, function( stack ) {
          console.log( log.stacks[ stack ] + ' occurrences for this stack: ' + stack );
        } );
      };
    }
  }

  phetCore.register( 'phetAllocation', phetAllocation );

  return phetAllocation;
} );
// Copyright 2013-2015, University of Colorado Boulder

define( 'DOT/dot',['require','PHET_CORE/Namespace','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );

  // object allocation tracking
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );

  var dot = new Namespace( 'dot' );

  dot.register( 'v2', function( x, y ) { return new dot.Vector2( x, y ); } );
  dot.register( 'v3', function( x, y, z ) { return new dot.Vector3( x, y, z ); } );
  dot.register( 'v4', function( x, y, z, w ) { return new dot.Vector4( x, y, z, w ); } );

  // TODO: performance: check browser speed to compare how fast this is. We may need to add a 32 option for GL ES.
  dot.register( 'FastArray', window.Float64Array ? window.Float64Array : window.Array );

  // will be filled in by other modules
  return dot;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Object pooling mix-in, for cases where creating new objects is expensive, and we'd rather mark some objects as able
 * to be reused (i.e. 'in the pool'). This provides a pool of objects for each type it is invoked on. It allows for
 * getting "new" objects that can either be constructed OR pulled in from a pool, and requires that the objects are
 * essentially able to "re-run" the constructor.
 *
 * This is usually done by having an initialize() method on the objects with the same call signature as the constructor,
 * and the constructor basically forwards to initialize(). Thus most "construction" logic is in the initialize() call.
 * Then when putting the object back in the pool, references should be released, so memory isn't leaked. The initialize()
 * function needs to support being called multiple times, and generally shouldn't create additional objects on calls
 * after the first.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/Poolable',['require','PHET_CORE/phetCore','PHET_CORE/extend'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );
  var extend = require( 'PHET_CORE/extend' );

  var Poolable = {
    /**
     * Adds the pool and some static methods to the type, and adds the instance method freeToPool() to the type's
     * prototype.
     * @public
     *
     * Options available:
     * - maxPoolSize {number} - Maximum number of items that can be allowed in the pool
     * - initialSize {number} - If non-zero, that many fresh items will be constructed if there is a defaultFactory
     * - defaultFactory {function() => Type} - Factory function with no parameters that creates an instance of the type.
     *     Allows Type.dirtyFromPool() and Type.fillPool()
     * - constructorDuplicateFactory { function( pool ) => function( ... ) => Type}
     *     Creates a factory function that takes the same parameters as the type's constructors. Allows
     *     Type.createFromPool( ... )
     *
     * @param {function} type - The constructor for the type
     * @param {Object} [options] -
     */
    mixin: function( type, options ) {
      var proto = type.prototype;

      // defaults
      options = extend( {
        maxPoolSize: 50, // since we don't want to blow too much memory
        initialSize: 0
      }, options );

      var pool = type.pool = [];

      /*
       * For example: defaultFactory: function() { return new Vector2(); }
       */
      if ( options.defaultFactory ) {
        // @public
        type.dirtyFromPool = function() {
          if ( pool.length ) {
            // return an instance in an arbitrary (dirty) state
            return pool.pop();
          }
          else {
            // else return a new default instance
            return options.defaultFactory();
          }
        };

        // @public - fills the object pool up to n instances
        type.fillPool = function( n ) {
          // fill up the object pool to the initial size
          while ( pool.length < n ) {
            pool.push( options.defaultFactory() );
          }
        };

        // fill the pool initially to the initial size
        type.fillPool( options.initialSize );
      }

      /*
       * For example: constructorDuplicateFactory:
       *                function( pool ) {
       *                  return function( x, y ) {
       *                    if ( pool.length ) {
       *                      return pool.pop().set( x, y );
       *                    } else {
       *                      return new Vector2( x, y );
       *                    }
       *                  }
       *                }
       * It allows arbitrary creation (from the constructor / etc) or mutation (from the pooled instance).
       */
      if ( options.constructorDuplicateFactory ) {
        // @public
        type.createFromPool = options.constructorDuplicateFactory( pool );
      }

      /*
       * @public
       * Frees the object to the pool (instance.freeToPool())
       */
      proto.freeToPool = function() {
        if ( pool.length < options.maxPoolSize ) {
          pool.push( this );
        }
      };
    }
  };
  phetCore.register( 'Poolable', Poolable );

  return Poolable;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Utility functions for Dot, placed into the dot.X namespace.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Util',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  // require( 'DOT/Vector2' ); // Require.js doesn't like the circular reference

  // constants
  var EPSILON = Number.MIN_VALUE;
  var TWO_PI = 2 * Math.PI;

  // "static" variables used in boxMullerTransform
  var generate;
  var z0;
  var z1;

  var Util = {
    /**
     * Returns the original value if it is inclusively within the [max,min] range. If it's below the range, min is
     * returned, and if it's above the range, max is returned.
     * @public
     *
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {number}
     */
    clamp: function( value, min, max ) {
      if ( value < min ) {
        return min;
      }
      else if ( value > max ) {
        return max;
      }
      else {
        return value;
      }
    },

    /**
     * Returns a number in the range $n\in[\mathrm{min},\mathrm{max})$ with the same equivalence class as the input
     * value mod (max-min), i.e. for a value $m$, $m\equiv n\ (\mathrm{mod}\ \mathrm{max}-\mathrm{min})$.
     * @public
     *
     * The 'down' indicates that if the value is equal to min or max, the max is returned.
     *
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {number}
     */
    moduloBetweenDown: function( value, min, max ) {
      assert && assert( max > min, 'max > min required for moduloBetween' );

      var divisor = max - min;

      // get a partial result of value-min between [0,divisor)
      var partial = ( value - min ) % divisor;
      if ( partial < 0 ) {
        // since if value-min < 0, the remainder will give us a negative number
        partial += divisor;
      }

      return partial + min; // add back in the minimum value
    },

    /**
     * Returns a number in the range $n\in(\mathrm{min},\mathrm{max}]$ with the same equivalence class as the input
     * value mod (max-min), i.e. for a value $m$, $m\equiv n\ (\mathrm{mod}\ \mathrm{max}-\mathrm{min})$.
     * @public
     *
     * The 'up' indicates that if the value is equal to min or max, the min is returned.
     *
     * @param {number} value
     * @param {number} min
     * @param {number} max
     * @returns {number}
     */
    moduloBetweenUp: function( value, min, max ) {
      return -Util.moduloBetweenDown( -value, -max, -min );
    },

    /**
     * Returns an array of integers from A to B (inclusive), e.g. rangeInclusive( 4, 7 ) maps to [ 4, 5, 6, 7 ].
     * @public
     *
     * @param {number} a
     * @param {number} b
     * @returns {Array.<number>}
     */
    rangeInclusive: function( a, b ) {
      if ( b < a ) {
        return [];
      }
      var result = new Array( b - a + 1 );
      for ( var i = a; i <= b; i++ ) {
        result[ i - a ] = i;
      }
      return result;
    },

    /**
     * Returns an array of integers from A to B (exclusive), e.g. rangeExclusive( 4, 7 ) maps to [ 5, 6 ].
     * @public
     *
     * @param {number} a
     * @param {number} b
     * @returns {Array.<number>}
     */
    rangeExclusive: function( a, b ) {
      return Util.rangeInclusive( a + 1, b - 1 );
    },

    /**
     * Converts degrees to radians.
     * @public
     *
     * @param {number} degrees
     * @returns {number}
     */
    toRadians: function( degrees ) {
      return Math.PI * degrees / 180;
    },

    /**
     * Converts radians to degrees.
     * @public
     *
     * @param {number} radians
     * @returns {number}
     */
    toDegrees: function( radians ) {
      return 180 * radians / Math.PI;
    },

    /**
     * Greatest Common Denominator, using https://en.wikipedia.org/wiki/Euclidean_algorithm
     * @public
     *
     * @param {number} a
     * @param {number} b
     */
    gcd: function( a, b ) {
      return b === 0 ? a : this.gcd( b, a % b );
    },

    /**
     * Intersection point between the lines defined by the line segments p1-2 and p3-p4. If the
     * lines are not properly defined, null is returned. If there are no intersections or infinitely many,
     * e.g. parallel lines, null is returned.
     * @public
     *
     * @param {Vector2} p1
     * @param {Vector2} p2
     * @param {Vector2} p3
     * @param {Vector2} p4
     * @returns {Vector2|null}
     */
    lineLineIntersection: function( p1, p2, p3, p4 ) {
      var epsilon = 1e-5;

      // If the endpoints are the same, they don't properly define a line
      if ( p1.equals( p2 ) || p3.equals( p4 ) ) {
        return null;
      }

      // Taken from an answer in 
      // http://stackoverflow.com/questions/385305/efficient-maths-algorithm-to-calculate-intersections
      var x12 = p1.x - p2.x;
      var x34 = p3.x - p4.x;
      var y12 = p1.y - p2.y;
      var y34 = p3.y - p4.y;

      var denom = x12 * y34 - y12 * x34;

      // If the denominator is 0, lines are parallel or coincident
      if ( Math.abs( denom ) < epsilon ) {
        return null;
      }

      // define intersection using determinants, see https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
      var a = p1.x * p2.y - p1.y * p2.x;
      var b = p3.x * p4.y - p3.y * p4.x;

      return new dot.Vector2(
        ( a * x34 - x12 * b ) / denom,
        ( a * y34 - y12 * b ) / denom
      );
    },

    /**
     * Ray-sphere intersection, returning information about the closest intersection. Assumes the sphere is centered
     * at the origin (for ease of computation), transform the ray to compensate if needed.
     * @public
     *
     * If there is no intersection, null is returned. Otherwise an object will be returned like:
     * <pre class="brush: js">
     * {
     *   distance: {number}, // distance from the ray position to the intersection
     *   hitPoint: {Vector3}, // location of the intersection
     *   normal: {Vector3}, // the normal of the sphere's surface at the intersection
     *   fromOutside: {boolean}, // whether the ray intersected the sphere from outside the sphere first
     * }
     * </pre>
     *
     * @param {number} radius
     * @param {Ray3} ray
     * @param {number} epsilon
     * @returns {Object}
     */
    // assumes a sphere with the specified radius, centered at the origin
    sphereRayIntersection: function( radius, ray, epsilon ) {
      epsilon = epsilon === undefined ? 1e-5 : epsilon;

      // center is the origin for now, but leaving in computations so that we can change that in the future. optimize away if needed
      var center = new dot.Vector3();

      var rayDir = ray.direction;
      var pos = ray.position;
      var centerToRay = pos.minus( center );

      // basically, we can use the quadratic equation to solve for both possible hit points (both +- roots are the hit points)
      var tmp = rayDir.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - radius * radius );
      if ( det < epsilon ) {
        // ray misses sphere entirely
        return null;
      }

      var base = rayDir.dot( center ) - rayDir.dot( pos );
      var sqt = Math.sqrt( det ) / 2;

      // the "first" entry point distance into the sphere. if we are inside the sphere, it is behind us
      var ta = base - sqt;

      // the "second" entry point distance
      var tb = base + sqt;

      if ( tb < epsilon ) {
        // sphere is behind ray, so don't return an intersection
        return null;
      }

      var hitPositionB = ray.pointAtDistance( tb );
      var normalB = hitPositionB.minus( center ).normalized();

      if ( ta < epsilon ) {
        // we are inside the sphere
        // in => out
        return {
          distance: tb,
          hitPoint: hitPositionB,
          normal: normalB.negated(),
          fromOutside: false
        };
      }
      else {
        // two possible hits
        var hitPositionA = ray.pointAtDistance( ta );
        var normalA = hitPositionA.minus( center ).normalized();

        // close hit, we have out => in
        return {
          distance: ta,
          hitPoint: hitPositionA,
          normal: normalA,
          fromOutside: true
        };
      }
    },

    /**
     * Returns an array of the real roots of the quadratic equation $ax^2 + bx + c=0$ (there will be between 0 and 2 roots).
     * @public
     *
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @returns {Array.<number>}
     */
    solveQuadraticRootsReal: function( a, b, c ) {
      var epsilon = 1E7;

      //We need to test whether a is several orders of magnitude less than b or c. If so, return the result as a solution to the linear (easy) equation
      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon ) {
        return [ -c / b ];
      }

      var discriminant = b * b - 4 * a * c;
      if ( discriminant < 0 ) {
        return [];
      }
      var sqrt = Math.sqrt( discriminant );
      // TODO: how to handle if discriminant is 0? give unique root or double it?
      // TODO: probably just use Complex for the future
      return [
        ( -b - sqrt ) / ( 2 * a ),
        ( -b + sqrt ) / ( 2 * a )
      ];
    },

    /**
     * Returns an array of the real roots of the quadratic equation $ax^3 + bx^2 + cx + d=0$ (there will be between 0 and 3 roots).
     * @public
     *
     * @param {number} a
     * @param {number} b
     * @param {number} c
     * @param {number} d
     * @returns {Array.<number>}
     */
    solveCubicRootsReal: function( a, b, c, d ) {
      // TODO: a Complex type!

      //We need to test whether a is several orders of magnitude less than b, c, d
      var epsilon = 1E7;

      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon || Math.abs( d / a ) > epsilon ) {
        return Util.solveQuadraticRootsReal( b, c, d );
      }
      if ( d === 0 || Math.abs( a / d ) > epsilon || Math.abs( b / d ) > epsilon || Math.abs( c / d ) > epsilon ) {
        return Util.solveQuadraticRootsReal( a, b, c );
      }

      b /= a;
      c /= a;
      d /= a;

      var q = ( 3.0 * c - ( b * b ) ) / 9;
      var r = ( -(27 * d) + b * (9 * c - 2 * (b * b)) ) / 54;
      var discriminant = q * q * q + r * r;
      var b3 = b / 3;

      if ( discriminant > 0 ) {
        // a single real root
        var dsqrt = Math.sqrt( discriminant );
        return [ Util.cubeRoot( r + dsqrt ) + Util.cubeRoot( r - dsqrt ) - b3 ];
      }

      // three real roots
      if ( discriminant === 0 ) {
        // contains a double root
        var rsqrt = Util.cubeRoot( r );
        var doubleRoot = b3 - rsqrt;
        return [ -b3 + 2 * rsqrt, doubleRoot, doubleRoot ];
      }
      else {
        // all unique
        var qX = -q * q * q;
        qX = Math.acos( r / Math.sqrt( qX ) );
        var rr = 2 * Math.sqrt( -q );
        return [
          -b3 + rr * Math.cos( qX / 3 ),
          -b3 + rr * Math.cos( ( qX + 2 * Math.PI ) / 3 ),
          -b3 + rr * Math.cos( ( qX + 4 * Math.PI ) / 3 )
        ];
      }
    },

    /**
     * Returns the unique real cube root of x, such that $y^3=x$.
     * @public
     *
     * @param {number} x
     * @returns {number}
     */
    cubeRoot: function( x ) {
      return x >= 0 ? Math.pow( x, 1 / 3 ) : -Math.pow( -x, 1 / 3 );
    },

    /**
     * Defines and evaluates a linear mapping. The mapping is defined so that $f(a_1)=b_1$ and $f(a_2)=b_2$, and other
     * values are interpolated along the linear equation. The returned value is $f(a_3)$.
     * @public
     *
     * @param {number} a1
     * @param {number} a2
     * @param {number} b1
     * @param {number} b2
     * @param {number} a3
     * @returns {number}
     */
    linear: function( a1, a2, b1, b2, a3 ) {
      return ( b2 - b1 ) / ( a2 - a1 ) * ( a3 - a1 ) + b1;
    },

    /**
     * Rounds using "Round half away from zero" algorithm. See dot#35.
     * @public
     *
     * JavaScript's Math.round is not symmetric for positive and negative numbers, it uses IEEE 754 "Round half up".
     * See https://en.wikipedia.org/wiki/Rounding#Round_half_up.
     * For sims, we want to treat positive and negative values symmetrically, which is IEEE 754 "Round half away from zero",
     * See https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero
     *
     * Note that -0 is rounded to 0, since we typically do not want to display -0 in sims.
     *
     * @param {number} value                               `
     * @returns {number}
     */
    roundSymmetric: function( value ) {
      return ( ( value < 0 ) ? -1 : 1 ) * Math.round( Math.abs( value ) );
    },

    /**
     * A predictable implementation of toFixed.
     * @public
     *
     * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,
     * because the spec doesn't specify whether to round or floor.
     * Rounding is symmetric for positive and negative values, see Util.roundSymmetric.
     *
     * @param {number} value
     * @param {number} decimalPlaces
     * @returns {string}
     */
    toFixed: function( value, decimalPlaces ) {
      var multiplier = Math.pow( 10, decimalPlaces );
      var newValue = Util.roundSymmetric( value * multiplier ) / multiplier;
      return newValue.toFixed( decimalPlaces );
    },

    /**
     * A predictable implementation of toFixed, where the result is returned as a number instead of a string.
     * @public
     *
     * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,
     * because the spec doesn't specify whether to round or floor.
     * Rounding is symmetric for positive and negative values, see Util.roundSymmetric.
     *
     * @param {number} value
     * @param {number} decimalPlaces
     * @returns {number}
     */
    toFixedNumber: function( value, decimalPlaces ) {
      return parseFloat( Util.toFixed( value, decimalPlaces ) );
    },

    /**
     * Returns whether the input is a number that is an integer (no fractional part).
     * @public
     *
     * @param {number} n
     * @returns {boolean}
     */
    isInteger: function( n ) {
      assert && assert( typeof n === 'number', 'isInteger requires its argument to be a number: ' + n );
      return n % 1 === 0;
    },

    /**
     * Computes the intersection of the two line segments $(x_1,y_1)(x_2,y_2)$ and $(x_3,y_3)(x_4,y_4)$. If there is no
     * intersection, null is returned.
     * @public
     *
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {number} x4
     * @param {number} y4
     * @returns {Vector2|null}
     */
    lineSegmentIntersection: function( x1, y1, x2, y2, x3, y3, x4, y4 ) {

      // @private
      // Determines counterclockwiseness. Positive if counterclockwise, negative if clockwise, zero if straight line
      // Point1(a,b), Point2(c,d), Point3(e,f)
      // See http://jeffe.cs.illinois.edu/teaching/373/notes/x05-convexhull.pdf
      // @returns {number}
      var ccw = function( a, b, c, d, e, f ) {
        return (f - b) * (c - a) - (d - b) * (e - a);
      };

      // Check if intersection doesn't exist. See http://jeffe.cs.illinois.edu/teaching/373/notes/x06-sweepline.pdf
      // If point1 and point2 are on opposite sides of line 3 4, exactly one of the two triples 1, 3, 4 and 2, 3, 4
      // is in counterclockwise order.
      if ( ccw( x1, y1, x3, y3, x4, y4 ) * ccw( x2, y2, x3, y3, x4, y4 ) > 0 ||
           ccw( x3, y3, x1, y1, x2, y2 ) * ccw( x4, y4, x1, y1, x2, y2 ) > 0
      ) {
        return null;
      }

      var denom = ( x1 - x2 ) * ( y3 - y4 ) - ( y1 - y2 ) * ( x3 - x4 );
      // If denominator is 0, the lines are parallel or coincident
      if ( denom === 0 ) {
        return null;
      }

      // Use determinants to calculate intersection, see https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
      var intersectionX = ( ( x1 * y2 - y1 * x2 ) * ( x3 - x4 ) - ( x1 - x2 ) * ( x3 * y4 - y3 * x4 ) ) / denom;
      var intersectionY = ( ( x1 * y2 - y1 * x2 ) * ( y3 - y4 ) - ( y1 - y2 ) * ( x3 * y4 - y3 * x4 ) ) / denom;
      return new dot.Vector2( intersectionX, intersectionY );
    },


    /**
     * Squared distance from a point to a line segment squared.
     * See http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
     * @public
     *
     * @param {Vector2} point - The point
     * @param {Vector2} a - Starting point of the line segment
     * @param {Vector2} b - Ending point of the line segment
     * @returns {number}
     */
    distToSegmentSquared: function( point, a, b ) {
      // the square of the distance between a and b,
      var segmentSquaredLength = a.distanceSquared( b );

      // if the segment length is zero, the a and b point are coincident. return the squared distance between a and point  
      if ( segmentSquaredLength === 0 ) { return point.distanceSquared( a ); }

      // the t value parametrize the projection of the point onto the a b line
      var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / segmentSquaredLength;

      var distanceSquared;

      if ( t < 0 ) {
        // if t<0, the projection point is outside the ab line, beyond a
        distanceSquared = point.distanceSquared( a );
      }
      else if ( t > 1 ) {
        // if t>1, the projection past is outside the ab segment, beyond b,
        distanceSquared = point.distanceSquared( b );
      }
      else {
        // if 0<t<1, the projection point lies along the line joining a and b.
        distanceSquared = point.distanceSquared( new dot.Vector2( a.x + t * (b.x - a.x), a.y + t * (b.y - a.y) ) );
      }

      return distanceSquared;

    },

    /**
     * distance from a point to a line segment squared.
     * @public
     *
     * @param {Vector2} point - The point
     * @param {Vector2} a - Starting point of the line segment
     * @param {Vector2} b - Ending point of the line segment
     * @returns {number}
     */
    distToSegment: function( point, a, b ) { return Math.sqrt( this.distToSegmentSquared( point, a, b ) ); },

    /**
     * Determines whether the three points are approximately collinear.
     * @public
     *
     * @param {Vector2} a
     * @param {Vector2} b
     * @param {Vector2} c
     * @param {number} epsilon
     * @returns {boolean}
     */
    arePointsCollinear: function( a, b, c, epsilon ) {
      if ( epsilon === undefined ) {
        epsilon = 0;
      }
      return Util.triangleArea( a, b, c ) <= epsilon;
    },

    /**
     * The area inside the triangle defined by the three vertices.
     * @public
     *
     * @param {Vector2} a
     * @param {Vector2} b
     * @param {Vector2} c
     * @returns {number}
     */
    triangleArea: function( a, b, c ) {
      return Math.abs( Util.triangleAreaSigned( a, b, c ) );
    },

    /**
     * The area inside the triangle defined by the three vertices, but with the sign determined by whether the vertices
     * provided are clockwise or counter-clockwise.
     * @public
     *
     * @param {Vector2} a
     * @param {Vector2} b
     * @param {Vector2} c
     * @returns {number}
     */
    triangleAreaSigned: function( a, b, c ) {
      // TODO: investigate which way we want the sign (Canvas or WebGL style)
      return a.x * ( b.y - c.y ) + b.x * ( c.y - a.y ) + c.x * ( a.y - b.y );
    },


    /**
     * Function that returns the hyperbolic cosine of a number
     * @public
     *
     * @param {number} value
     * @returns {number}
     */
    cosh: function( value ) {
      return (Math.exp( value ) + Math.exp( -value )) / 2;
    },

    /**
     * Function that returns the hyperbolic sine of a number
     * @public
     *
     * @param {number} value
     * @returns {number}
     */
    sinh: function( value ) {
      return (Math.exp( value ) - Math.exp( -value )) / 2;
    },

    /**
     * Log base-10, since it wasn't included in every supported browser.
     * @public
     *
     * @param {number} val
     * @returns {number}
     */
    log10: function( val ) {
      return Math.log( val ) / Math.LN10;
    },

    /**
     * Generates a random Gaussian sample with the given mean and standard deviation.
     * This method relies on the "static" variables generate, z0, and z1 defined above.
     * Random.js is the primary client of this function, but it is defined here so it can be
     * used other places more easily if need be.
     * Code inspired by example here: https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform.
     * @public
     *
     * @param {number} mu - The mean of the Gaussian
     * @param {number} sigma - The standard deviation of the Gaussian
     * @param {Random} random - the source of randomness
     * @returns {number}
     */
    boxMullerTransform: function( mu, sigma, random ) {
      generate = !generate;

      if ( !generate ) {
        return z1 * sigma + mu;
      }

      var u1;
      var u2;
      do {
        u1 = random.nextDouble();
        u2 = random.nextDouble();
      }
      while ( u1 <= EPSILON );

      z0 = Math.sqrt( -2.0 * Math.log( u1 ) ) * Math.cos( TWO_PI * u2 );
      z1 = Math.sqrt( -2.0 * Math.log( u1 ) ) * Math.sin( TWO_PI * u2 );
      return z0 * sigma + mu;
    }
  };
  dot.register( 'Util', Util );

  // make these available in the main namespace directly (for now)
  dot.clamp = Util.clamp;
  dot.moduloBetweenDown = Util.moduloBetweenDown;
  dot.moduloBetweenUp = Util.moduloBetweenUp;
  dot.rangeInclusive = Util.rangeInclusive;
  dot.rangeExclusive = Util.rangeExclusive;
  dot.toRadians = Util.toRadians;
  dot.toDegrees = Util.toDegrees;
  dot.lineLineIntersection = Util.lineLineIntersection;
  dot.lineSegmentIntersection = Util.lineSegmentIntersection;
  dot.sphereRayIntersection = Util.sphereRayIntersection;
  dot.solveQuadraticRootsReal = Util.solveQuadraticRootsReal;
  dot.solveCubicRootsReal = Util.solveCubicRootsReal;
  dot.cubeRoot = Util.cubeRoot;
  dot.linear = Util.linear;
  dot.boxMullerTransform = Util.boxMullerTransform;

  return Util;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Basic 2-dimensional vector, represented as (x,y).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Vector2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  require( 'DOT/Util' );

  // require( 'DOT/Vector3' ); // commented out since Require.js complains about the circular dependency

  /**
   * Creates a 2-dimensional vector with the specified X and Y values.
   * @constructor
   * @public
   *
   * @param {number} [x] - X coordinate, defaults to 0 if not provided
   * @param {number} [y] - Y coordinate, defaults to 0 if not provided
   */
  function Vector2( x, y ) {
    // @public {number} - The X coordinate of the vector.
    this.x = x !== undefined ? x : 0;

    // @public {number} - The Y coordinate of the vector.
    this.y = y !== undefined ? y : 0;

    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );

    phetAllocation && phetAllocation( 'Vector2' );
  }

  dot.register( 'Vector2', Vector2 );

  inherit( Object, Vector2, {
    // @public (read-only) - Helps to identify the dimension of the vector
    isVector2: true,
    dimension: 2,

    /**
     * The magnitude (Euclidean/L2 Norm) of this vector, i.e. $\sqrt{x^2+y^2}$.
     * @public
     *
     * @returns {number}
     */
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    /**
     * The squared magnitude (square of the Euclidean/L2 Norm) of this vector, i.e. $x^2+y^2$.
     * @public
     *
     * @returns {number}
     */
    magnitudeSquared: function() {
      return this.x * this.x + this.y * this.y;
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    distance: function( point ) {
      return Math.sqrt( this.distanceSquared( point ) );
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point (x,y).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @returns {number}
     */
    distanceXY: function( x, y ) {
      var dx = this.x - x;
      var dy = this.y - y;
      return Math.sqrt( dx * dx + dy * dy );
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    distanceSquared: function( point ) {
      var dx = this.x - point.x;
      var dy = this.y - point.y;
      return dx * dx + dy * dy;
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point with coordinates (x,y).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @returns {number}
     */
    distanceSquaredXY: function( x, y ) {
      var dx = this.x - x;
      var dy = this.y - y;
      return dx * dx + dy * dy;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector v.
     * @public
     *
     * @param {Vector2} v
     * @returns {number}
     */
    dot: function( v ) {
      return this.x * v.x + this.y * v.y;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector (x,y).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @returns {number}
     */
    dotXY: function( x, y ) {
      return this.x * x + this.y * y;
    },

    /**
     * The angle $\theta$ of this vector, such that this vector is equal to
     * $$ u = \begin{bmatrix} r\cos\theta \\ r\sin\theta \end{bmatrix} $$
     * for the magnitude $r \ge 0$ of the vector, with $\theta\in(-\pi,\pi]$
     * @public
     *
     * @returns {number}
     */
    angle: function() {
      return Math.atan2( this.y, this.x );
    },

    /**
     * The angle between this vector and another vector, in the range $\theta\in[0, \pi]$.
     * @public
     *
     * Equal to $\theta = \cos^{-1}( \hat{u} \cdot \hat{v} )$ where $\hat{u}$ is this vector (normalized) and $\hat{v}$
     * is the input vector (normalized).
     *
     * @param {Vector2} v
     * @returns {number}
     */
    angleBetween: function( v ) {
      var thisMagnitude = this.magnitude();
      var vMagnitude = v.magnitude();
      return Math.acos( dot.clamp( ( this.x * v.x + this.y * v.y ) / ( thisMagnitude * vMagnitude ), -1, 1 ) );
    },

    /**
     * Exact equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector2} other
     * @returns {boolean} - Whether the two vectors have equal components
     */
    equals: function( other ) {
      return this.x === other.x && this.y === other.y;
    },

    /**
     * Approximate equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector2} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two vectors has no component with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.max( Math.abs( this.x - other.x ), Math.abs( this.y - other.y ) ) <= epsilon;
    },

    /**
     * Whether all of the components are numbers (not NaN) that are not infinity or -infinity.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y );
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this vector, or if a vector is passed in, set that vector's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a vector is provided. This will return a new vector, and
     * will not modify this vector.
     *
     * @param {Vector2} [vector] - If not provided, creates a new Vector2 with filled in values. Otherwise, fills in the
     *                             values of the provided vector so that it equals this vector.
     * @returns {Vector2}
     */
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector2( this.x, this.y );
      }
    },

    /**
     * The scalar value of the z-component of the equivalent 3-dimensional cross product:
     * $$ f( u, v ) = \left( \begin{bmatrix} u_x \\ u_y \\ 0 \end{bmatrix} \times \begin{bmatrix} v_x \\ v_y \\ 0 \end{bmatrix} \right)_z = u_x v_y - u_y v_x $$
     * @public
     *
     * @param {Vector2} v
     * @returns {number}
     */
    crossScalar: function( v ) {
      return this.x * v.y - this.y * v.x;
    },

    /**
     * Normalized (re-scaled) copy of this vector such that its magnitude is 1. If its initial magnitude is zero, an
     * error is thrown.
     * @public
     *
     * This is the immutable form of the function normalize(). This will return a new vector, and will not modify this
     * vector.
     *
     * @returns {Vector2}
     */
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return new Vector2( this.x / mag, this.y / mag );
      }
    },

    /**
     * Returns a copy of this vector with each component rounded by Util.roundSymmetric.
     * @public
     *
     * This is the immutable form of the function roundSymmetric(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector2}
     */
    roundedSymmetric: function() {
      return this.copy().roundSymmetric();
    },

    /**
     * Re-scaled copy of this vector such that it has the desired magnitude. If its initial magnitude is zero, an error
     * is thrown. If the passed-in magnitude is negative, the direction of the resulting vector will be reversed.
     * @public
     *
     * This is the immutable form of the function setMagnitude(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} magnitude
     * @returns {Vector2}
     */
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },

    /**
     * Copy of this vector, scaled by the desired scalar value.
     * @public
     *
     * This is the immutable form of the function multiplyScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    timesScalar: function( scalar ) {
      return new Vector2( this.x * scalar, this.y * scalar );
    },

    /**
     * Same as timesScalar.
     * @public
     *
     * This is the immutable form of the function multiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },

    /**
     * Copy of this vector, multiplied component-wise by the passed-in vector v.
     * @public
     *
     * This is the immutable form of the function componentMultiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    componentTimes: function( v ) {
      return new Vector2( this.x * v.x, this.y * v.y );
    },

    /**
     * Addition of this vector and another vector, returning a copy.
     * @public
     *
     * This is the immutable form of the function add(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    plus: function( v ) {
      return new Vector2( this.x + v.x, this.y + v.y );
    },

    /**
     * Addition of this vector and another vector (x,y), returning a copy.
     * @public
     *
     * This is the immutable form of the function addXY(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    plusXY: function( x, y ) {
      return new Vector2( this.x + x, this.y + y );
    },

    /**
     * Addition of this vector with a scalar (adds the scalar to every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function addScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    plusScalar: function( scalar ) {
      return new Vector2( this.x + scalar, this.y + scalar );
    },

    /**
     * Subtraction of this vector by another vector v, returning a copy.
     * @public
     *
     * This is the immutable form of the function subtract(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    minus: function( v ) {
      return new Vector2( this.x - v.x, this.y - v.y );
    },

    /**
     * Subtraction of this vector by another vector (x,y), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractXY(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    minusXY: function( x, y ) {
      return new Vector2( this.x - x, this.y - y );
    },

    /**
     * Subtraction of this vector by a scalar (subtracts the scalar from every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    minusScalar: function( scalar ) {
      return new Vector2( this.x - scalar, this.y - scalar );
    },

    /**
     * Division of this vector by a scalar (divides every component by the scalar), returning a copy.
     * @public
     *
     * This is the immutable form of the function divideScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    dividedScalar: function( scalar ) {
      return new Vector2( this.x / scalar, this.y / scalar );
    },

    /**
     * Negated copy of this vector (multiplies every component by -1).
     * @public
     *
     * This is the immutable form of the function negate(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector2}
     */
    negated: function() {
      return new Vector2( -this.x, -this.y );
    },

    /**
     * Rotated by -pi/2 (perpendicular to this vector), returned as a copy.
     * @public
     *
     * @returns {Vector2}
     */
    perpendicular: function() {
      return new Vector2( this.y, -this.x );
    },

    /**
     * Rotated by an arbitrary angle, in radians. Returned as a copy.
     * @public
     *
     * This is the immutable form of the function rotate(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} angle - In radians
     * @returns {Vector2}
     */
    rotated: function( angle ) {
      var newAngle = this.angle() + angle;
      var mag = this.magnitude();
      return new Vector2( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
    },

    /**
     * Mutable method that rotates this vector about an x,y point.
     * @public
     *
     * @param {number} x - origin of rotation in x
     * @param {number} y - origin of rotation in y
     * @param {number} angle - radians to rotate
     * @returns {Vector2} this for chaining
     */
    rotateAboutXY: function( x, y, angle ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var cos = Math.cos( angle );
      var sin = Math.sin( angle );
      this.x = x + dx * cos - dy * sin;
      this.y = y + dx * sin + dy * cos;
      return this; // for chaining
    },

    /**
     * Same as rotateAboutXY but with a point argument.
     * @public
     *
     * @param {Vector2} point
     * @param {number} angle
     * @returns {Vector2} this for chaining
     */
    rotateAboutPoint: function( point, angle ) {
      return this.rotateAboutXY( point.x, point.y, angle );
    },

    /**
     * Immutable method that returns a new Vector2 that is rotated about the given point.
     * @public
     *
     * @param {number} x - origin for rotation in x
     * @param {number} y - origin for rotation in y
     * @param {number} angle - radians to rotate
     * @returns {Vector2} the new Vector2
     */
    rotatedAboutXY: function( x, y, angle ) {
      return new Vector2( this.x, this.y ).rotateAboutXY( x, y, angle );
    },

    /**
     * Immutable method that returns a new Vector2 rotated about the given point.
     * @public
     *
     * @param {Vector2} point
     * @param {number} angle
     * @returns {Vector2} the new Vector2
     */
    rotatedAboutPoint: function( point, angle ) {
      return this.rotatedAboutXY( point.x, point.y, angle );
    },

    /**
     * A linear interpolation between this vector (ratio=0) and another vector (ratio=1).
     * @public
     *
     * @param {Vector2} vector
     * @param {number} ratio - Not necessarily constrained in [0, 1]
     * @returns {Vector2}
     */
    blend: function( vector, ratio ) {
      return new Vector2( this.x + (vector.x - this.x) * ratio, this.y + (vector.y - this.y) * ratio );
    },

    /**
     * The average (midpoint) between this vector and another vector.
     * @public
     *
     * @param {Vector2} vector
     * @returns {Vector2}
     */
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },

    /**
     * Debugging string for the vector.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return 'Vector2(' + this.x + ', ' + this.y + ')';
    },

    /**
     * Converts this to a 3-dimensional vector, with the z-component equal to 0.
     * @public
     *
     * @returns {Vector3}
     */
    toVector3: function() {
      return new dot.Vector3( this.x, this.y, 0 );
    },

    /*---------------------------------------------------------------------------*
     * Mutables
     * - all mutation should go through setXY / setX / setY
     *---------------------------------------------------------------------------*/

    /**
     * Sets all of the components of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    setXY: function( x, y ) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * Sets the x-component of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @returns {Vector2}
     */
    setX: function( x ) {
      this.x = x;
      return this;
    },

    /**
     * Sets the y-component of this vector, returning this.
     * @public
     *
     * @param {number} y
     * @returns {Vector2}
     */
    setY: function( y ) {
      this.y = y;
      return this;
    },

    /**
     * Sets this vector to be a copy of another vector.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this vector, in addition to returning
     * this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    set: function( v ) {
      return this.setXY( v.x, v.y );
    },

    /**
     * Sets the magnitude of this vector. If the passed-in magnitude is negative, this flips the vector and sets its
     * magnitude to abs( magnitude ).
     * @public
     *
     * This is the mutable form of the function withMagnitude(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} magnitude
     * @returns {Vector2}
     */
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },

    /**
     * Adds another vector to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    add: function( v ) {
      return this.setXY( this.x + v.x, this.y + v.y );
    },

    /**
     * Adds another vector (x,y) to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plusXY(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    addXY: function( x, y ) {
      return this.setXY( this.x + x, this.y + y );
    },

    /**
     * Adds a scalar to this vector (added to every component), changing this vector.
     * @public
     *
     * This is the mutable form of the function plusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    addScalar: function( scalar ) {
      return this.setXY( this.x + scalar, this.y + scalar );
    },

    /**
     * Subtracts this vector by another vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function minus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    subtract: function( v ) {
      return this.setXY( this.x - v.x, this.y - v.y );
    },

    /**
     * Subtracts this vector by another vector (x,y), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusXY(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Vector2}
     */
    subtractXY: function( x, y ) {
      return this.setXY( this.x - x, this.y - y );
    },

    /**
     * Subtracts this vector by a scalar (subtracts each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    subtractScalar: function( scalar ) {
      return this.setXY( this.x - scalar, this.y - scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function timesScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    multiplyScalar: function( scalar ) {
      return this.setXY( this.x * scalar, this.y * scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * Same as multiplyScalar.
     * @public
     *
     * This is the mutable form of the function times(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },

    /**
     * Multiplies this vector by another vector component-wise, changing this vector.
     * @public
     *
     * This is the mutable form of the function componentTimes(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    componentMultiply: function( v ) {
      return this.setXY( this.x * v.x, this.y * v.y );
    },

    /**
     * Divides this vector by a scalar (divides each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function dividedScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector2}
     */
    divideScalar: function( scalar ) {
      return this.setXY( this.x / scalar, this.y / scalar );
    },

    /**
     * Negates this vector (multiplies each component by -1), changing this vector.
     * @public
     *
     * This is the mutable form of the function negated(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector2}
     */
    negate: function() {
      return this.setXY( -this.x, -this.y );
    },

    /**
     * Normalizes this vector (rescales to where the magnitude is 1), changing this vector.
     * @public
     *
     * This is the mutable form of the function normalized(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector2}
     */
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return this.divideScalar( mag );
      }
    },

    /**
     * Rounds each component of this vector with Util.roundSymmetric.
     * @public
     *
     * This is the mutable form of the function roundedSymmetric(). This will mutate (change) this vector, in addition
     * to returning the vector itself.
     *
     * @returns {Vector2}
     */
    roundSymmetric: function() {
      return this.setXY( dot.Util.roundSymmetric( this.x ),
        dot.Util.roundSymmetric( this.y ) );
    },

    /**
     * Rotates this vector by the angle (in radians), changing this vector.
     * @public
     *
     * This is the mutable form of the function rotated(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} angle - In radians
     * @returns {Vector2}
     */
    rotate: function( angle ) {
      var newAngle = this.angle() + angle;
      var mag = this.magnitude();
      return this.setXY( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
    },

    /**
     * Sets this vector's value to be the x,y values matching the given magnitude and angle (in radians), changing
     * this vector, and returning itself.
     * @public
     *
     * @param {number} magnitude
     * @param {number} angle - In radians
     * @returns {Vector2}
     */
    setPolar: function( magnitude, angle ) {
      return this.setXY( magnitude * Math.cos( angle ), magnitude * Math.sin( angle ) );
    },

    /**
     * Returns a duck-typed object meant for use with tandem/phet-io serialization.
     *
     * @returns {Object}
     */
    toStateObject: function() {
      return { x: this.x, y: this.y };
    }
  }, { // static functions on Vector2 itself
    /**
     * Returns a Vector2 with the specified magnitude $r$ and angle $\theta$ (in radians), with the formula:
     * $$ f( r, \theta ) = \begin{bmatrix} r\cos\theta \\ r\sin\theta \end{bmatrix} $$
     * @public
     *
     * @param {number} magnitude
     * @param {number} angle
     * @returns {Vector2}
     */
    createPolar: function( magnitude, angle ) {
      return new Vector2().setPolar( magnitude, angle );
    },

    /**
     * Constructs a Vector2 from a duck-typed { x: {number}, y: {number} } object, meant for use with
     * tandem/phet-io deserialization.
     * @public
     *
     * @param {Object} stateObject - Like { x: {number}, y: {number} }
     * @returns {Vector2}
     */
    fromStateObject: function( stateObject ) {
      return new Vector2( stateObject.x, stateObject.y );
    },

    /**
     * Allocation-free implementation that gets the angle between two vectors
     *
     * @param {Vector2} startVector
     * @param {Vector2} endVector
     * @returns {number} the angle between the vectors
     */
    getAngleBetweenVectors: function( startVector, endVector ) {
      var dx = endVector.x - startVector.x;
      var dy = endVector.y - startVector.y;
      return Math.atan2( dy, dx );
    },

    /**
     * Allocation-free way to get the distance between vectors.
     * @param {Vector2} startVector
     * @param {Vector2} endVector
     * @returns {number} the angle between the vectors
     */
    getDistanceBetweenVectors: function( startVector, endVector ) {
      var dx = endVector.x - startVector.x;
      var dy = endVector.y - startVector.y;
      return Math.sqrt( dx * dx + dy * dy );
    }
  } );

  // Sets up pooling on Vector2
  Poolable.mixin( Vector2, {
    defaultFactory: function() { return new Vector2(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y );
        }
        else {
          return new Vector2( x, y );
        }
      };
    }
  } );

  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *---------------------------------------------------------------------------*/

  // @private
  Vector2.Immutable = function ImmutableVector2( x, y ) {
    Vector2.call( this, x, y );
  };
  var Immutable = Vector2.Immutable;

  inherit( Vector2, Immutable );

  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector2' );
    };
  };

  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXY' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );

  /**
   * Immutable zero vector: $\begin{bmatrix} 0\\0 \end{bmatrix}$
   * @public
   *
   * @constant {Vector2} ZERO
   */
  Vector2.ZERO = assert ? new Immutable( 0, 0 ) : new Vector2( 0, 0 );

  /**
   * Immutable vector: $\begin{bmatrix} 1\\0 \end{bmatrix}$
   * @public
   *
   * @constant {Vector2} X_UNIT
   */
  Vector2.X_UNIT = assert ? new Immutable( 1, 0 ) : new Vector2( 1, 0 );

  /**
   * Immutable vector: $\begin{bmatrix} 0\\1 \end{bmatrix}$
   * @public
   *
   * @constant {Vector2} Y_UNIT
   */
  Vector2.Y_UNIT = assert ? new Immutable( 0, 1 ) : new Vector2( 0, 1 );

  return Vector2;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A 2D rectangle-shaped bounded area (bounding box).
 *
 * There are a number of convenience functions to get locations and points on the Bounds. Currently we do not
 * store these with the Bounds2 instance, since we want to lower the memory footprint.
 *
 * minX, minY, maxX, and maxY are actually stored. We don't do x,y,width,height because this can't properly express
 * semi-infinite bounds (like a half-plane), or easily handle what Bounds2.NOTHING and Bounds2.EVERYTHING do with
 * the constructive solid areas.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Bounds2',['require','DOT/dot','DOT/Vector2','PHET_CORE/inherit','PHET_CORE/Poolable'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var Vector2 = require( 'DOT/Vector2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  // Temporary instances to be used in the transform method.
  var scratchVector2 = new dot.Vector2();

  /**
   * Creates a 2-dimensional bounds (bounding box).
   * @constructor
   * @public
   *
   * @param {number} minX - The initial minimum X coordinate of the bounds.
   * @param {number} minY - The initial minimum Y coordinate of the bounds.
   * @param {number} maxX - The initial maximum X coordinate of the bounds.
   * @param {number} maxY - The initial maximum Y coordinate of the bounds.
   */
  function Bounds2( minX, minY, maxX, maxY ) {
    assert && assert( maxY !== undefined, 'Bounds2 requires 4 parameters' );

    // @public {number} - The minimum X coordinate of the bounds.
    this.minX = minX;

    // @public {number} - The minimum Y coordinate of the bounds.
    this.minY = minY;

    // @public {number} - The maximum X coordinate of the bounds.
    this.maxX = maxX;

    // @public {number} - The maximum Y coordinate of the bounds.
    this.maxY = maxY;

    phetAllocation && phetAllocation( 'Bounds2' );
  }

  dot.register( 'Bounds2', Bounds2 );

  inherit( Object, Bounds2, {
    // @public (read-only) - Helps to identify the dimension of the bounds
    isBounds: true,
    dimension: 2,

    /*---------------------------------------------------------------------------*
     * Properties
     *---------------------------------------------------------------------------*/

    /**
     * The width of the bounds, defined as maxX - minX.
     * @public
     *
     * @returns {number}
     */
    getWidth: function() { return this.maxX - this.minX; },
    get width() { return this.getWidth(); },

    /**
     * The height of the bounds, defined as maxY - minY.
     * @public
     *
     * @returns {number}
     */
    getHeight: function() { return this.maxY - this.minY; },
    get height() { return this.getHeight(); },

    /*
     * Convenience locations
     * upper is in terms of the visual layout in Scenery and other programs, so the minY is the "upper", and minY is the "lower"
     *
     *             minX (x)     centerX        maxX
     *          ---------------------------------------
     * minY (y) | leftTop     centerTop     rightTop
     * centerY  | leftCenter  center        rightCenter
     * maxY     | leftBottom  centerBottom  rightBottom
     */

    /**
     * Alias for minX, when thinking of the bounds as an (x,y,width,height) rectangle.
     * @public
     *
     * @returns {number}
     */
    getX: function() { return this.minX; },
    get x() { return this.getX(); },

    /**
     * Alias for minY, when thinking of the bounds as an (x,y,width,height) rectangle.
     * @public
     *
     * @returns {number}
     */
    getY: function() { return this.minY; },
    get y() { return this.getY(); },

    /**
     * Alias for minX, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMinX: function() { return this.minX; },

    /**
     * Alias for minY, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMinY: function() { return this.minY; },

    /**
     * Alias for maxX, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMaxX: function() { return this.maxX; },

    /**
     * Alias for maxY, supporting the explicit getter function style.
     * @public
     *
     * @returns {number}
     */
    getMaxY: function() { return this.maxY; },

    /**
     * Alias for minX, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getLeft: function() { return this.minX; },
    get left() { return this.minX; },

    /**
     * Alias for minY, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getTop: function() { return this.minY; },
    get top() { return this.minY; },

    /**
     * Alias for maxX, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getRight: function() { return this.maxX; },
    get right() { return this.maxX; },

    /**
     * Alias for maxY, when thinking in the UI-layout manner.
     * @public
     *
     * @returns {number}
     */
    getBottom: function() { return this.maxY; },
    get bottom() { return this.maxY; },

    /**
     * The horizontal (X-coordinate) center of the bounds, averaging the minX and maxX.
     * @public
     *
     * @returns {number}
     */
    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },
    get centerX() { return this.getCenterX(); },

    /**
     * The vertical (Y-coordinate) center of the bounds, averaging the minY and maxY.
     * @public
     *
     * @returns {number}
     */
    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },
    get centerY() { return this.getCenterY(); },

    /**
     * The point (minX, minY), in the UI-coordinate upper-left.
     * @public
     *
     * @returns {Vector2}
     */
    getLeftTop: function() { return new dot.Vector2( this.minX, this.minY ); },
    get leftTop() { return this.getLeftTop(); },

    /**
     * The point (centerX, minY), in the UI-coordinate upper-center.
     * @public
     *
     * @returns {Vector2}
     */
    getCenterTop: function() { return new dot.Vector2( this.getCenterX(), this.minY ); },
    get centerTop() { return this.getCenterTop(); },

    /**
     * The point (right, minY), in the UI-coordinate upper-right.
     * @public
     *
     * @returns {Vector2}
     */
    getRightTop: function() { return new dot.Vector2( this.maxX, this.minY ); },
    get rightTop() { return this.getRightTop(); },

    /**
     * The point (left, centerY), in the UI-coordinate center-left.
     * @public
     *
     * @returns {Vector2}
     */
    getLeftCenter: function() { return new dot.Vector2( this.minX, this.getCenterY() ); },
    get leftCenter() { return this.getLeftCenter(); },

    /**
     * The point (centerX, centerY), in the center of the bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getCenter: function() { return new dot.Vector2( this.getCenterX(), this.getCenterY() ); },
    get center() { return this.getCenter(); },

    /**
     * The point (maxX, centerY), in the UI-coordinate center-right
     * @public
     *
     * @returns {Vector2}
     */
    getRightCenter: function() { return new dot.Vector2( this.maxX, this.getCenterY() ); },
    get rightCenter() { return this.getRightCenter(); },

    /**
     * The point (minX, maxY), in the UI-coordinate lower-left
     * @public
     *
     * @returns {Vector2}
     */
    getLeftBottom: function() { return new dot.Vector2( this.minX, this.maxY ); },
    get leftBottom() { return this.getLeftBottom(); },

    /**
     * The point (centerX, maxY), in the UI-coordinate lower-center
     * @public
     *
     * @returns {Vector2}
     */
    getCenterBottom: function() { return new dot.Vector2( this.getCenterX(), this.maxY ); },
    get centerBottom() { return this.getCenterBottom(); },

    /**
     * The point (maxX, maxY), in the UI-coordinate lower-right
     * @public
     *
     * @returns {Vector2}
     */
    getRightBottom: function() { return new dot.Vector2( this.maxX, this.maxY ); },
    get rightBottom() { return this.getRightBottom(); },

    /**
     * Whether we have negative width or height. Bounds2.NOTHING is a prime example of an empty Bounds2.
     * Bounds with width = height = 0 are considered not empty, since they include the single (0,0) point.
     * @public
     *
     * @returns {boolean}
     */
    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0; },

    /**
     * Whether our minimums and maximums are all finite numbers. This will exclude Bounds2.NOTHING and Bounds2.EVERYTHING.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.maxX ) && isFinite( this.maxY );
    },

    /**
     * Whether this bounds has a non-zero area (non-zero positive width and height).
     * @public
     *
     * @returns {boolean}
     */
    hasNonzeroArea: function() {
      return this.getWidth() > 0 && this.getHeight() > 0;
    },

    /**
     * Whether this bounds has a finite and non-negative width and height.
     * @public
     *
     * @returns {boolean}
     */
    isValid: function() {
      return !this.isEmpty() && this.isFinite();
    },

    /**
     * If the location is inside the bounds, the location will be returned. Otherwise, this will return a new location
     * on the edge of the bounds that is the closest to the provided location.
     * @public
     *
     * @param {Vector2} location
     * @returns {Vector2}
     */
    closestPointTo: function( location ) {
      if ( this.containsCoordinates( location.x, location.y ) ) {
        return location;
      }
      else {
        var xConstrained = Math.max( Math.min( location.x, this.maxX ), this.x );
        var yConstrained = Math.max( Math.min( location.y, this.maxY ), this.y );
        return new Vector2( xConstrained, yConstrained );
      }
    },

    /**
     * Whether the coordinates are contained inside the bounding box, or are on the boundary.
     * @public
     *
     * @param {number} x - X coordinate of the point to check
     * @param {number} y - Y coordinate of the point to check
     * @returns {boolean}
     */
    containsCoordinates: function( x, y ) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    },

    /**
     * Whether the point is contained inside the bounding box, or is on the boundary.
     * @public
     *
     * @param {Vector2} point
     * @returns {boolean}
     */
    containsPoint: function( point ) {
      return this.containsCoordinates( point.x, point.y );
    },

    /**
     * Whether this bounding box completely contains the bounding box passed as a parameter. The boundary of a box is
     * considered to be "contained".
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {boolean}
     */
    containsBounds: function( bounds ) {
      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY;
    },

    /**
     * Whether this and another bounding box have any points of intersection (including touching boundaries).
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {boolean}
     */
    intersectsBounds: function( bounds ) {
      var minX = Math.max( this.minX, bounds.minX );
      var minY = Math.max( this.minY, bounds.minY );
      var maxX = Math.min( this.maxX, bounds.maxX );
      var maxY = Math.min( this.maxY, bounds.maxY );
      return ( maxX - minX ) >= 0 && ( maxY - minY >= 0 );
    },

    /**
     * The squared distance from the input point to the point closest to it inside the bounding box.
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    minimumDistanceToPointSquared: function( point ) {
      var closeX = point.x < this.minX ? this.minX : ( point.x > this.maxX ? this.maxX : null );
      var closeY = point.y < this.minY ? this.minY : ( point.y > this.maxY ? this.maxY : null );
      var d;
      if ( closeX === null && closeY === null ) {
        // inside, or on the boundary
        return 0;
      }
      else if ( closeX === null ) {
        // vertically directly above/below
        d = closeY - point.y;
        return d * d;
      }
      else if ( closeY === null ) {
        // horizontally directly to the left/right
        d = closeX - point.x;
        return d * d;
      }
      else {
        // corner case
        var dx = closeX - point.x;
        var dy = closeY - point.y;
        return dx * dx + dy * dy;
      }
    },

    /**
     * The squared distance from the input point to the point furthest from it inside the bounding box.
     * @public
     *
     * @param {Vector2} point
     * @returns {number}
     */
    maximumDistanceToPointSquared: function( point ) {
      var x = point.x > this.getCenterX() ? this.minX : this.maxX;
      var y = point.y > this.getCenterY() ? this.minY : this.maxY;
      x -= point.x;
      y -= point.y;
      return x * x + y * y;
    },

    /**
     * Debugging string for the bounds.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + ')]';
    },

    /**
     * Exact equality comparison between this bounds and another bounds.
     * @public
     *
     * @param {Bounds2} other
     * @returns {boolean} - Whether the two bounds are equal
     */
    equals: function( other ) {
      return this.minX === other.minX && this.minY === other.minY && this.maxX === other.maxX && this.maxY === other.maxY;
    },

    /**
     * Approximate equality comparison between this bounds and another bounds.
     * @public
     *
     * @param {Bounds2} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two bounds has no min/max with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      epsilon = epsilon !== undefined ? epsilon : 0;
      var thisFinite = this.isFinite();
      var otherFinite = other.isFinite();
      if ( thisFinite && otherFinite ) {
        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity
        return Math.abs( this.minX - other.minX ) < epsilon &&
               Math.abs( this.minY - other.minY ) < epsilon &&
               Math.abs( this.maxX - other.maxX ) < epsilon &&
               Math.abs( this.maxY - other.maxY ) < epsilon;
      }
      else if ( thisFinite !== otherFinite ) {
        return false; // one is finite, the other is not. definitely not equal
      }
      else if ( this === other ) {
        return true; // exact same instance, must be equal
      }
      else {
        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both
        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&
               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&
               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&
               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) );
      }
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this bounds, or if a bounds is passed in, set that bounds's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a bounds is provided. This will return a new bounds, and
     * will not modify this bounds.
     *
     * @param {Bounds2} [bounds] - If not provided, creates a new Bounds2 with filled in values. Otherwise, fills in the
     *                             values of the provided bounds so that it equals this bounds.
     * @returns {Bounds2}
     */
    copy: function( bounds ) {
      if ( bounds ) {
        return bounds.set( this );
      }
      else {
        return new Bounds2( this.minX, this.minY, this.maxX, this.maxY );
      }
    },

    /**
     * The smallest bounds that contains both this bounds and the input bounds, returned as a copy.
     * @public
     *
     * This is the immutable form of the function includeBounds(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    union: function( bounds ) {
      return new Bounds2(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY )
      );
    },

    /**
     * The smallest bounds that is contained by both this bounds and the input bounds, returned as a copy.
     * @public
     *
     * This is the immutable form of the function constrainBounds(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    intersection: function( bounds ) {
      return new Bounds2(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY )
      );
    },
    // TODO: difference should be well-defined, but more logic is needed to compute

    /**
     * The smallest bounds that contains this bounds and the point (x,y), returned as a copy.
     * @public
     *
     * This is the immutable form of the function addCoordinates(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    withCoordinates: function( x, y ) {
      return new Bounds2(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y )
      );
    },

    /**
     * The smallest bounds that contains this bounds and the input point, returned as a copy.
     * @public
     *
     * This is the immutable form of the function addPoint(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Vector2} point
     * @returns {Bounds2}
     */
    withPoint: function( point ) {
      return this.withCoordinates( point.x, point.y );
    },

    /**
     * A copy of this bounds, with minX replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMinX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} minX
     * @returns {Bounds2}
     */
    withMinX: function( minX ) {
      return new Bounds2( minX, this.minY, this.maxX, this.maxY );
    },

    /**
     * A copy of this bounds, with minY replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMinY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} minY
     * @returns {Bounds2}
     */
    withMinY: function( minY ) {
      return new Bounds2( this.minX, minY, this.maxX, this.maxY );
    },

    /**
     * A copy of this bounds, with maxX replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMaxX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} maxX
     * @returns {Bounds2}
     */
    withMaxX: function( maxX ) {
      return new Bounds2( this.minX, this.minY, maxX, this.maxY );
    },

    /**
     * A copy of this bounds, with maxY replaced with the input.
     * @public
     *
     * This is the immutable form of the function setMaxY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} maxY
     * @returns {Bounds2}
     */
    withMaxY: function( maxY ) {
      return new Bounds2( this.minX, this.minY, this.maxX, maxY );
    },

    /**
     * A copy of this bounds, with the minimum values rounded down to the nearest integer, and the maximum values
     * rounded up to the nearest integer. This causes the bounds to expand as necessary so that its boundaries
     * are integer-aligned.
     * @public
     *
     * This is the immutable form of the function roundOut(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @returns {Bounds2}
     */
    roundedOut: function() {
      return new Bounds2(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY )
      );
    },

    /**
     * A copy of this bounds, with the minimum values rounded up to the nearest integer, and the maximum values
     * rounded down to the nearest integer. This causes the bounds to contract as necessary so that its boundaries
     * are integer-aligned.
     * @public
     *
     * This is the immutable form of the function roundIn(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @returns {Bounds2}
     */
    roundedIn: function() {
      return new Bounds2(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY )
      );
    },

    /**
     * A bounding box (still axis-aligned) that contains the transformed shape of this bounds, applying the matrix as
     * an affine transformation.
     * @public
     *
     * NOTE: bounds.transformed( matrix ).transformed( inverse ) may be larger than the original box, if it includes
     * a rotation that isn't a multiple of $\pi/2$. This is because the returned bounds may expand in area to cover
     * ALL of the corners of the transformed bounding box.
     *
     * This is the immutable form of the function transform(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    transformed: function( matrix ) {
      return this.copy().transform( matrix );
    },

    /**
     * A bounding box that is expanded on all sides by the specified amount.)
     * @public
     *
     * This is the immutable form of the function dilate(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} d
     * @returns {Bounds2}
     */
    dilated: function( d ) {
      return new Bounds2( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
    },

    /**
     * A bounding box that is expanded horizontally (on the left and right) by the specified amount.
     * @public
     *
     * This is the immutable form of the function dilateX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    dilatedX: function( x ) {
      return new Bounds2( this.minX - x, this.minY, this.maxX + x, this.maxY );
    },

    /**
     * A bounding box that is expanded vertically (on the top and bottom) by the specified amount.
     * @public
     *
     * This is the immutable form of the function dilateY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    dilatedY: function( y ) {
      return new Bounds2( this.minX, this.minY - y, this.maxX, this.maxY + y );
    },

    /**
     * A bounding box that is expanded on all sides, with different amounts of expansion horizontally and vertically.
     * Will be identical to the bounds returned by calling bounds.dilatedX( x ).dilatedY( y ).
     * @public
     *
     * This is the immutable form of the function dilateXY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x - Amount to dilate horizontally (for each side)
     * @param {number} y - Amount to dilate vertically (for each side)
     * @returns {Bounds2}
     */
    dilatedXY: function( x, y ) {
      return new Bounds2( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
    },

    /**
     * A bounding box that is contracted on all sides by the specified amount.
     * @public
     *
     * This is the immutable form of the function erode(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} amount
     * @returns {Bounds2}
     */
    eroded: function( amount ) { return this.dilated( -amount ); },

    /**
     * A bounding box that is contracted horizontally (on the left and right) by the specified amount.
     * @public
     *
     * This is the immutable form of the function erodeX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    erodedX: function( x ) { return this.dilatedX( -x ); },

    /**
     * A bounding box that is contracted vertically (on the top and bottom) by the specified amount.
     * @public
     *
     * This is the immutable form of the function erodeY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    erodedY: function( y ) { return this.dilatedY( -y ); },

    /**
     * A bounding box that is contracted on all sides, with different amounts of contraction horizontally and vertically.
     * @public
     *
     * This is the immutable form of the function erodeXY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x - Amount to erode horizontally (for each side)
     * @param {number} y - Amount to erode vertically (for each side)
     * @returns {Bounds2}
     */
    erodedXY: function( x, y ) { return this.dilatedXY( -x, -y ); },

    /**
     * A bounding box that is expanded by a specific amount on all sides (or if some offsets are negative, will contract
     * those sides).
     * @public
     *
     * This is the immutable form of the function offset(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} left - Amount to expand to the left (subtracts from minX)
     * @param {number} top - Amount to expand to the top (subtracts from minY)
     * @param {number} right - Amount to expand to the right (adds to maxX)
     * @param {number} bottom - Amount to expand to the bottom (adds to maxY)
     * @returns {Bounds2}
     */
    withOffsets: function( left, top, right, bottom ) {
      return new Bounds2( this.minX - left, this.minY - top, this.maxX + right, this.maxY + bottom );
    },

    /**
     * Our bounds, translated horizontally by x, returned as a copy.
     * @public
     *
     * This is the immutable form of the function shiftX(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    shiftedX: function( x ) {
      return new Bounds2( this.minX + x, this.minY, this.maxX + x, this.maxY );
    },

    /**
     * Our bounds, translated vertically by y, returned as a copy.
     * @public
     *
     * This is the immutable form of the function shiftY(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    shiftedY: function( y ) {
      return new Bounds2( this.minX, this.minY + y, this.maxX, this.maxY + y );
    },

    /**
     * Our bounds, translated by (x,y), returned as a copy.
     * @public
     *
     * This is the immutable form of the function shift(). This will return a new bounds, and will not modify
     * this bounds.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    shifted: function( x, y ) {
      return new Bounds2( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
    },

    /*---------------------------------------------------------------------------*
     * Mutable operations
     *
     * All mutable operations should call one of the following:
     *   setMinMax, setMinX, setMinY, setMaxX, setMaxY
     *---------------------------------------------------------------------------*/

    /**
     * Sets each value for this bounds, and returns itself.
     * @public
     *
     * @param {number} minX
     * @param {number} minY
     * @param {number} maxX
     * @param {number} maxY
     * @returns {Bounds2}
     */
    setMinMax: function( minX, minY, maxX, maxY ) {
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
      return this;
    },

    /**
     * Sets the value of minX.
     * @public
     *
     * This is the mutable form of the function withMinX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} minX
     * @returns {Bounds2}
     */
    setMinX: function( minX ) {
      this.minX = minX;
      return this;
    },

    /**
     * Sets the value of minY.
     * @public
     *
     * This is the mutable form of the function withMinY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} minY
     * @returns {Bounds2}
     */
    setMinY: function( minY ) {
      this.minY = minY;
      return this;
    },

    /**
     * Sets the value of maxX.
     * @public
     *
     * This is the mutable form of the function withMaxX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} maxX
     * @returns {Bounds2}
     */
    setMaxX: function( maxX ) {
      this.maxX = maxX;
      return this;
    },

    /**
     * Sets the value of maxY.
     * @public
     *
     * This is the mutable form of the function withMaxY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} maxY
     * @returns {Bounds2}
     */
    setMaxY: function( maxY ) {
      this.maxY = maxY;
      return this;
    },

    /**
     * Sets the values of this bounds to be equal to the input bounds.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    set: function( bounds ) {
      return this.setMinMax( bounds.minX, bounds.minY, bounds.maxX, bounds.maxY );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input bounds.
     * @public
     *
     * This is the mutable form of the function union(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    includeBounds: function( bounds ) {
      return this.setMinMax(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY )
      );
    },

    /**
     * Modifies this bounds so that it is the largest bounds contained both in its original bounds and in the input bounds.
     * @public
     *
     * This is the mutable form of the function intersection(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    constrainBounds: function( bounds ) {
      return this.setMinMax(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY )
      );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input point (x,y).
     * @public
     *
     * This is the mutable form of the function withCoordinates(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    addCoordinates: function( x, y ) {
      return this.setMinMax(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y )
      );
    },

    /**
     * Modifies this bounds so that it contains both its original bounds and the input point.
     * @public
     *
     * This is the mutable form of the function withPoint(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Vector2} point
     * @returns {Bounds2}
     */
    addPoint: function( point ) {
      return this.addCoordinates( point.x, point.y );
    },

    /**
     * Modifies this bounds so that its boundaries are integer-aligned, rounding the minimum boundaries down and the
     * maximum boundaries up (expanding as necessary).
     * @public
     *
     * This is the mutable form of the function roundedOut(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @returns {Bounds2}
     */
    roundOut: function() {
      return this.setMinMax(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY )
      );
    },

    /**
     * Modifies this bounds so that its boundaries are integer-aligned, rounding the minimum boundaries up and the
     * maximum boundaries down (contracting as necessary).
     * @public
     *
     * This is the mutable form of the function roundedIn(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @returns {Bounds2}
     */
    roundIn: function() {
      return this.setMinMax(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY )
      );
    },

    /**
     * Modifies this bounds so that it would fully contain a transformed version if its previous value, applying the
     * matrix as an affine transformation.
     * @public
     *
     * NOTE: bounds.transform( matrix ).transform( inverse ) may be larger than the original box, if it includes
     * a rotation that isn't a multiple of $\pi/2$. This is because the bounds may expand in area to cover
     * ALL of the corners of the transformed bounding box.
     *
     * This is the mutable form of the function transformed(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    transform: function( matrix ) {
      // if we contain no area, no change is needed
      if ( this.isEmpty() ) {
        return this;
      }

      // optimization to bail for identity matrices
      if ( matrix.isIdentity() ) {
        return this;
      }

      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.set( dot.Bounds2.NOTHING );

      // using mutable vector so we don't create excessive instances of Vector2 during this
      // make sure all 4 corners are inside this transformed bounding box

      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, minY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, maxY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, minY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, maxY ) ) );
      return this;
    },

    /**
     * Expands this bounds on all sides by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilated(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} d
     * @returns {Bounds2}
     */
    dilate: function( d ) {
      return this.setMinMax( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
    },

    /**
     * Expands this bounds horizontally (left and right) by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilatedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    dilateX: function( x ) {
      return this.setMinMax( this.minX - x, this.minY, this.maxX + x, this.maxY );
    },

    /**
     * Expands this bounds vertically (top and bottom) by the specified amount.
     * @public
     *
     * This is the mutable form of the function dilatedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    dilateY: function( y ) {
      return this.setMinMax( this.minX, this.minY - y, this.maxX, this.maxY + y );
    },

    /**
     * Expands this bounds independently in the horizontal and vertical directions. Will be equal to calling
     * bounds.dilateX( x ).dilateY( y ).
     * @public
     *
     * This is the mutable form of the function dilatedXY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    dilateXY: function( x, y ) {
      return this.setMinMax( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
    },

    /**
     * Contracts this bounds on all sides by the specified amount.
     * @public
     *
     * This is the mutable form of the function eroded(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} d
     * @returns {Bounds2}
     */
    erode: function( d ) { return this.dilate( -d ); },

    /**
     * Contracts this bounds horizontally (left and right) by the specified amount.
     * @public
     *
     * This is the mutable form of the function erodedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    erodeX: function( x ) { return this.dilateX( -x ); },

    /**
     * Contracts this bounds vertically (top and bottom) by the specified amount.
     * @public
     *
     * This is the mutable form of the function erodedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    erodeY: function( y ) { return this.dilateY( -y ); },

    /**
     * Contracts this bounds independently in the horizontal and vertical directions. Will be equal to calling
     * bounds.erodeX( x ).erodeY( y ).
     * @public
     *
     * This is the mutable form of the function erodedXY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    erodeXY: function( x, y ) { return this.dilateXY( -x, -y ); },

    /**
     * Expands this bounds independently for each side (or if some offsets are negative, will contract those sides).
     * @public
     *
     * This is the mutable form of the function withOffsets(). This will mutate (change) this bounds, in addition to
     * returning this bounds itself.
     *
     * @param {number} left - Amount to expand to the left (subtracts from minX)
     * @param {number} top - Amount to expand to the top (subtracts from minY)
     * @param {number} right - Amount to expand to the right (adds to maxX)
     * @param {number} bottom - Amount to expand to the bottom (adds to maxY)
     * @returns {Bounds2}
     */
    offset: function( left, top, right, bottom ) {
      return new Bounds2( this.minX - left, this.minY - top, this.maxX + right, this.maxY + bottom );
    },

    /**
     * Translates our bounds horizontally by x.
     * @public
     *
     * This is the mutable form of the function shiftedX(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @returns {Bounds2}
     */
    shiftX: function( x ) {
      return this.setMinMax( this.minX + x, this.minY, this.maxX + x, this.maxY );
    },

    /**
     * Translates our bounds vertically by y.
     * @public
     *
     * This is the mutable form of the function shiftedY(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} y
     * @returns {Bounds2}
     */
    shiftY: function( y ) {
      return this.setMinMax( this.minX, this.minY + y, this.maxX, this.maxY + y );
    },

    /**
     * Translates our bounds by (x,y).
     * @public
     *
     * This is the mutable form of the function shifted(). This will mutate (change) this bounds, in addition to returning
     * this bounds itself.
     *
     * @param {number} x
     * @param {number} y
     * @returns {Bounds2}
     */
    shift: function( x, y ) {
      return this.setMinMax( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
    },

    /**
     * Find a point in the bounds closest to the specified point.
     * @public
     *
     * @param {number} x - X coordinate of the point to test.
     * @param {number} y - Y coordinate of the point to test.
     * @param {Vector2} [result] - Vector2 that can store the return value to avoid allocations.
     * @returns {Vector2}
     */
    getClosestPoint: function( x, y, result ) {
      if ( result ) {
        result.setXY( x, y );
      }
      else {
        result = new dot.Vector2( x, y );
      }
      if ( result.x < this.minX ) { result.x = this.minX; }
      if ( result.x > this.maxX ) { result.x = this.maxX; }
      if ( result.y < this.minY ) { result.y = this.minY; }
      if ( result.y > this.maxY ) { result.y = this.maxY; }
      return result;
    }
  }, {
    /**
     * Returns a new Bounds2 object, with the familiar rectangle construction with x, y, width, and height.
     * @public
     *
     * @param {number} x - The minimum value of X for the bounds.
     * @param {number} y - The minimum value of Y for the bounds.
     * @param {number} width - The width (maxX - minX) of the bounds.
     * @param {number} height - The height (maxY - minY) of the bounds.
     * @returns {Bounds2}
     */
    rect: function( x, y, width, height ) {
      return new Bounds2( x, y, x + width, y + height );
    },

    /**
     * Returns a new Bounds2 object that only contains the specified point (x,y). Useful for being dilated to form a
     * bounding box around a point. Note that the bounds will not be "empty" as it contains (x,y), but it will have
     * zero area. The x and y coordinates can be specified by numbers or with at Vector2
     * @public
     *
     * @param {number|Vector2} x
     * @param [number] y
     * @returns {Bounds2}
     */
    point: function( x, y ) {
      if ( x instanceof dot.Vector2 ) {
        var p = x;
        return new Bounds2( p.x, p.y, p.x, p.y );
      }
      else {
        return new Bounds2( x, y, x, y );
      }
    }
  } );

  Poolable.mixin( Bounds2, {
    defaultFactory: function() { return Bounds2.NOTHING.copy(); },
    constructorDuplicateFactory: function( pool ) {
      return function( minX, minY, maxX, maxY ) {
        if ( pool.length ) {
          return pool.pop().setMinMax( minX, minY, maxX, maxY );
        }
        else {
          return new Bounds2( minX, minY, maxX, maxY );
        }
      };
    }
  } );

  /**
   * A contant Bounds2 with minimums = $\infty$, maximums = $-\infty$, so that it represents "no bounds whatsoever".
   * @public
   *
   * This allows us to take the union (union/includeBounds) of this and any other Bounds2 to get the other bounds back,
   * e.g. Bounds2.NOTHING.union( bounds ).equals( bounds ). This object naturally serves as the base case as a union of
   * zero bounds objects.
   *
   * Additionally, intersections with NOTHING will always return a Bounds2 equivalent to NOTHING.
   *
   * @constant {Bounds2} NOTHING
   */
  Bounds2.NOTHING = new Bounds2( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );

  /**
   * A contant Bounds2 with minimums = $-\infty$, maximums = $\infty$, so that it represents "all bounds".
   * @public
   *
   * This allows us to take the intersection (intersection/constrainBounds) of this and any other Bounds2 to get the
   * other bounds back, e.g. Bounds2.EVERYTHING.intersection( bounds ).equals( bounds ). This object naturally serves as
   * the base case as an intersection of zero bounds objects.
   *
   * Additionally, unions with EVERYTHING will always return a Bounds2 equivalent to EVERYTHING.
   *
   * @constant {Bounds2} EVERYTHING
   */
  Bounds2.EVERYTHING = new Bounds2( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );

  function catchImmutableSetterLowHangingFruit( bounds ) {
    bounds.setMinMax = function() { throw new Error( 'Attempt to set \"setMinMax\" of an immutable Bounds2 object' ); };
    bounds.set = function() { throw new Error( 'Attempt to set \"set\" of an immutable Bounds2 object' ); };
    bounds.includeBounds = function() { throw new Error( 'Attempt to set \"includeBounds\" of an immutable Bounds2 object' ); };
    bounds.constrainBounds = function() { throw new Error( 'Attempt to set \"constrainBounds\" of an immutable Bounds2 object' ); };
    bounds.addCoordinates = function() { throw new Error( 'Attempt to set \"addCoordinates\" of an immutable Bounds2 object' ); };
    bounds.transform = function() { throw new Error( 'Attempt to set \"transform\" of an immutable Bounds2 object' ); };
  }

  if ( assert ) {
    catchImmutableSetterLowHangingFruit( Bounds2.EVERYTHING );
    catchImmutableSetterLowHangingFruit( Bounds2.NOTHING );
  }

  return Bounds2;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Given inheritance using inherit, this will give the full prototype chain.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/inheritance',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  /*
   * @param {*} type - Constructor for the type in question.
   * @returns {Array.<*>}
   */
  function inheritance( type ) {
    var types = [ type ];

    var proto = type.prototype;
    while ( proto && ( proto = Object.getPrototypeOf( proto ) ) ) {
      if ( proto.constructor ) {
        types.push( proto.constructor );
      }
    }
    return types;
  }

  phetCore.register( 'inheritance', inheritance );

  return inheritance;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * The main 'kite' namespace object for the exported (non-Require.js) API. Used internally
 * since it prevents Require.js issues with circular dependencies.
 *
 * The returned kite object namespace may be incomplete if not all modules are listed as
 * dependencies. Please use the 'main' module for that purpose if all of Kite is desired.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/kite',['require','PHET_CORE/Namespace','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';

  var Namespace = require( 'PHET_CORE/Namespace' );

  // object allocation tracking
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );

  var kite = new Namespace( 'kite' );

  // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
  // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
  // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
  // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
  kite.register( 'svgNumber', function( n ) {
    return n.toFixed( 20 );
  } );

  // will be filled in by other modules
  return kite;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * The main 'scenery' namespace object for the exported (non-Require.js) API. Used internally
 * since it prevents Require.js issues with circular dependencies.
 *
 * The returned scenery object namespace may be incomplete if not all modules are listed as
 * dependencies. Please use the 'main' module for that purpose if all of Scenery is desired.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/scenery',['require','AXON/axon','DOT/dot','PHET_CORE/extend','PHET_CORE/inheritance','KITE/kite','PHET_CORE/Namespace','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';

  var axon = require( 'AXON/axon' );
  var dot = require( 'DOT/dot' );
  var extend = require( 'PHET_CORE/extend' );
  var inheritance = require( 'PHET_CORE/inheritance' );
  var kite = require( 'KITE/kite' );
  var Namespace = require( 'PHET_CORE/Namespace' );

  // @public (scenery-internal)
  window.sceneryLog = null;
  window.sceneryAccessibilityLog = null;

  // Initialize object allocation tracking, if it hasn't been already.
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );

  var scratchCanvas = document.createElement( 'canvas' );
  var scratchContext = scratchCanvas.getContext( '2d' );

  var logPadding = '';

  var scenery = new Namespace( 'scenery' );

  // @public - A Canvas and 2D Canvas context used for convenience functions (think of it as having arbitrary state).
  scenery.register( 'scratchCanvas', scratchCanvas );
  scenery.register( 'scratchContext', scratchContext );

  // @public - SVG namespace, used for document.createElementNS( scenery.svgns, name );
  scenery.register( 'svgns', 'http://www.w3.org/2000/svg' );

  // @public - X-link namespace, used for SVG image URLs (xlink:href)
  scenery.register( 'xlinkns', 'http://www.w3.org/1999/xlink' );

  /*---------------------------------------------------------------------------*
   * Logging
   * TODO: Move this out of scenery.js if possible
   *---------------------------------------------------------------------------*/

  // @private - Scenery internal log function to be used to log to scenery.logString (does not include color/css)
  function stringLogFunction( message ) {
    scenery.logString += message.replace( /%c/g, '' ) + '\n';
  }

  // @private - Scenery internal log function to be used to log to the console.
  function consoleLogFunction() {
    // allow for the console to not exist
    window.console && window.console.log && window.console.log.apply( window.console, Array.prototype.slice.call( arguments, 0 ) );
  }

  // @private - List of Scenery's loggers, with their display name and (if using console) the display style.
  var logProperties = {
    dirty: { name: 'dirty', style: 'color: #aaa;' },
    bounds: { name: 'bounds', style: 'color: #aaa;' },
    hitTest: { name: 'hitTest', style: 'color: #aaa;' },
    hitTestInternal: { name: 'hitTestInternal', style: 'color: #aaa;' },
    PerfCritical: { name: 'Perf', style: 'color: #f00;' },
    PerfMajor: { name: 'Perf', style: 'color: #aa0;' },
    PerfMinor: { name: 'Perf', style: 'color: #088;' },
    PerfVerbose: { name: 'Perf', style: 'color: #888;' },
    Cursor: { name: 'Cursor', style: 'color: #000;' },
    Stitch: { name: 'Stitch', style: 'color: #000;' },
    StitchDrawables: { name: 'Stitch', style: 'color: #000;' },
    GreedyStitcher: { name: 'Greedy', style: 'color: #088;' },
    GreedyVerbose: { name: 'Greedy', style: 'color: #888;' },
    RelativeTransform: { name: 'RelativeTransform', style: 'color: #606;' },
    BackboneDrawable: { name: 'Backbone', style: 'color: #a00;' },
    CanvasBlock: { name: 'Canvas', style: 'color: #000;' },
    WebGLBlock: { name: 'WebGL', style: 'color: #000;' },
    Display: { name: 'Display', style: 'color: #000;' },
    DOMBlock: { name: 'DOM', style: 'color: #000;' },
    Drawable: { name: '', style: 'color: #000;' },
    FittedBlock: { name: 'FittedBlock', style: 'color: #000;' },
    Input: { name: 'Input', style: 'color: #000;' },
    InputEvent: { name: 'InputEvent', style: 'color: #000;' },
    OnInput: { name: 'OnInput', style: 'color: #000;' },
    InputListener: { name: 'InputListener', style: 'color: #000;' },
    Instance: { name: 'Instance', style: 'color: #000;' },
    InstanceTree: { name: 'InstanceTree', style: 'color: #000;' },
    ChangeInterval: { name: 'ChangeInterval', style: 'color: #0a0;' },
    SVGBlock: { name: 'SVG', style: 'color: #000;' },
    SVGGroup: { name: 'SVGGroup', style: 'color: #000;' },
    ImageSVGDrawable: { name: 'ImageSVGDrawable', style: 'color: #000;' },
    Paints: { name: 'Paints', style: 'color: #000;' },
    Accessibility: { name: 'Accessibility', style: 'color: #000;' },
    AccessibleInstance: { name: 'AccessibleInstance', style: 'color: #000;' },
    AlignBox: { name: 'AlignBox', style: 'color: #000;' },
    AlignGroup: { name: 'AlignGroup', style: 'color: #000;' },
    RichText: { name: 'RichText', style: 'color: #000;' }
  };

  // will be filled in by other modules
  extend( scenery, {
    // @public - Scenery log string (accumulated if switchLogToString() is used).
    logString: '',

    // @private - Scenery internal log function (switchable implementation, the main reference)
    logFunction: function() {
      // allow for the console to not exist
      window.console && window.console.log && window.console.log.apply( window.console, Array.prototype.slice.call( arguments, 0 ) );
    },

    // @public - Switches Scenery's logging to print to the developer console.
    switchLogToConsole: function() {
      scenery.logFunction = consoleLogFunction;
    },

    // @public - Switches Scenery's logging to append to scenery.logString
    switchLogToString: function() {
      window.console && window.console.log( 'switching to string log' );
      scenery.logFunction = stringLogFunction;
    },

    // @public - Enables a specific single logger, OR a composite logger ('stitch'/'perf')
    enableIndividualLog: function( name ) {
      if ( name === 'stitch' ) {
        this.enableIndividualLog( 'Stitch' );
        this.enableIndividualLog( 'StitchDrawables' );
        this.enableIndividualLog( 'GreedyStitcher' );
        this.enableIndividualLog( 'GreedyVerbose' );
        return;
      }

      if ( name === 'perf' ) {
        this.enableIndividualLog( 'PerfCritical' );
        this.enableIndividualLog( 'PerfMajor' );
        this.enableIndividualLog( 'PerfMinor' );
        this.enableIndividualLog( 'PerfVerbose' );
        return;
      }

      if ( name ) {
        assert && assert( logProperties[ name ],
          'Unknown logger: ' + name + ', please use periods (.) to separate different log names' );

        window.sceneryLog[ name ] = window.sceneryLog[ name ] || function( ob, styleOverride ) {
            var data = logProperties[ name ];

            var prefix = data.name ? '[' + data.name + '] ' : '';
            var padStyle = 'color: #ddd;';
            scenery.logFunction( '%c' + logPadding + '%c' + prefix + ob, padStyle, styleOverride ? styleOverride : data.style );
          };
      }
    },

    // @public - Disables a specific log. TODO: handle stitch and perf composite loggers
    disableIndividualLog: function( name ) {
      if ( name ) {
        delete window.sceneryLog[ name ];
      }
    },

    /**
     * Enables multiple loggers.
     * @public
     *
     * @param {Array.<string>} logNames - keys from logProperties
     */
    enableLogging: function( logNames ) {
      window.sceneryLog = function( ob ) { scenery.logFunction( ob ); };

      window.sceneryLog.push = function() {
        logPadding += '| ';
      };
      window.sceneryLog.pop = function() {
        logPadding = logPadding.slice( 0, -2 );
      };
      window.sceneryLog.getDepth = function() {
        return logPadding.length / 2;
      };

      for ( var i = 0; i < logNames.length; i++ ) {
        this.enableIndividualLog( logNames[ i ] );
      }
    },

    // @public - Disables Scenery logging
    disableLogging: function() {
      window.sceneryLog = null;
    },

    // @public (scenery-internal) - Whether performance logging is active (may actually reduce performance)
    isLoggingPerformance: function() {
      return window.sceneryLog.PerfCritical || window.sceneryLog.PerfMajor ||
             window.sceneryLog.PerfMinor || window.sceneryLog.PerfVerbose;
    },

    // @public
    copy: function( value ) {
      return scenery.deserialize( scenery.serialize( value ) );
    },

    /**
     * Serializes a Scenery-related value.
     * @public
     *
     * @param {*} value
     */
    serialize: function( value ) {
      if ( value instanceof dot.Vector2 ) {
        return {
          type: 'Vector2',
          x: value.x,
          y: value.y
        };
      }
      else if ( value instanceof dot.Matrix3 ) {
        return {
          type: 'Matrix3',
          m00: value.m00(),
          m01: value.m01(),
          m02: value.m02(),
          m10: value.m10(),
          m11: value.m11(),
          m12: value.m12(),
          m20: value.m20(),
          m21: value.m21(),
          m22: value.m22()
        };
      }
      else if ( value instanceof dot.Bounds2 ) {
        return {
          type: 'Bounds2',
          maxX: value.maxX,
          maxY: value.maxY,
          minX: value.minX,
          minY: value.minY
        };
      }
      else if ( value instanceof kite.Shape ) {
        return {
          type: 'Shape',
          path: value.getSVGPath()
        };
      }
      else if ( value instanceof Array ) {
        return {
          type: 'Array',
          value: value.map( scenery.serialize )
        };
      }
      else if ( value instanceof scenery.Color ) {
        return {
          type: 'Color',
          red: value.red,
          green: value.green,
          blue: value.blue,
          alpha: value.alpha
        };
      }
      else if ( value instanceof axon.Property ) {
        return {
          type: 'Property',
          value: scenery.serialize( value.value )
        };
      }
      else if ( scenery.Paint && value instanceof scenery.Paint ) {
        var paintSerialization = {};

        if ( value.transformMatrix ) {
          paintSerialization.transformMatrix = scenery.serialize( value.transformMatrix );
        }

        if ( scenery.Gradient && value instanceof scenery.Gradient ) {
          paintSerialization.stops = value.stops.map( function( stop ) {
            return {
              ratio: stop.ratio,
              stop: scenery.serialize( stop.color )
            };
          } );

          paintSerialization.start = scenery.serialize( value.start );
          paintSerialization.end = scenery.serialize( value.end );

          if ( scenery.LinearGradient && value instanceof scenery.LinearGradient ) {
            paintSerialization.type = 'LinearGradient';
          }
          else if ( scenery.RadialGradient && value instanceof scenery.RadialGradient ) {
            paintSerialization.type = 'RadialGradient';
            paintSerialization.startRadius = value.startRadius;
            paintSerialization.endRadius = value.endRadius;
          }
        }

        if ( scenery.Pattern && value instanceof scenery.Pattern ) {
          paintSerialization.type = 'Pattern';
          paintSerialization.url = value.image.src;
        }

        return paintSerialization;
      }
      else if ( value instanceof scenery.Node ) {
        var node = value;

        var options = {};
        var setup = {
          // maxWidth
          // maxHeight
          // clipArea
          // mouseArea
          // touchArea
          // matrix
          // localBounds
          // children {Array.<number>} - IDs
          // hasInputListeners {boolean}

        };

        [
          'visible',
          'opacity',
          'pickable',
          'inputEnabled',
          'cursor',
          'transformBounds',
          'renderer',
          'usesOpacity',
          'layerSplit',
          'cssTransform',
          'excludeInvisible',
          'webglScale',
          'preventFit'
        ].forEach( function( simpleKey ) {
          if ( node[ simpleKey ] !== scenery.Node.DEFAULT_OPTIONS[ simpleKey ] ) {
            options[ simpleKey ] = node[ simpleKey ];
          }
        } );

        [
          'maxWidth',
          'maxHeight',
          'clipArea',
          'mouseArea',
          'touchArea'
        ].forEach( function( serializedKey ) {
          if ( node[ serializedKey ] !== scenery.Node.DEFAULT_OPTIONS[ serializedKey ] ) {
            setup[ serializedKey ] = scenery.serialize( node[ serializedKey ] );
          }
        } );
        if ( !node.matrix.isIdentity() ) {
          setup.matrix = scenery.serialize( node.matrix );
        }
        if ( node._localBoundsOverridden ) {
          setup.localBounds = scenery.serialize( node.localBounds );
        }
        setup.children = node.children.map( function( child ) {
          return child.id;
        } );
        setup.hasInputListeners = node.inputListeners.length > 0;

        var serialization = {
          id: node.id,
          type: 'Node',
          types: inheritance( node.constructor ).map( function( type ) { return type.name; } ).filter( function( name ) {
            return name && name !== 'Object' && name !== 'Node';
          } ),
          name: node.constructor.name,
          options: options,
          setup: setup
        };

        if ( scenery.Path && node instanceof scenery.Path ) {
          serialization.type = 'Path';
          setup.path = scenery.serialize( node.shape );
          if ( node.boundsMethod !== scenery.Path.DEFAULT_OPTIONS.boundsMethod ) {
            options.boundsMethod = node.boundsMethod;
          }
        }

        if ( scenery.Circle && node instanceof scenery.Circle ) {
          serialization.type = 'Circle';
          options.radius = node.radius;
        }

        if ( scenery.Line && node instanceof scenery.Line ) {
          serialization.type = 'Line';
          options.x1 = node.x1;
          options.y1 = node.y1;
          options.x2 = node.x2;
          options.y2 = node.y2;
        }

        if ( scenery.Rectangle && node instanceof scenery.Rectangle ) {
          serialization.type = 'Rectangle';
          options.rectX = node.rectX;
          options.rectY = node.rectY;
          options.rectWidth = node.rectWidth;
          options.rectHeight = node.rectHeight;
          options.cornerXRadius = node.cornerXRadius;
          options.cornerYRadius = node.cornerYRadius;
        }

        if ( scenery.Text && node instanceof scenery.Text ) {
          serialization.type = 'Text';
          // TODO: defaults for Text?
          if ( node.boundsMethod !== 'hybrid' ) {
            options.boundsMethod = node.boundsMethod;
          }
          options.text = node.text;
          options.font = node.font;
        }

        if ( scenery.HTMLText && node instanceof scenery.HTMLText ) {
          serialization.type = 'HTMLText';
        }

        if ( scenery.Image && node instanceof scenery.Image ) {
          serialization.type = 'Image';
          [
            'imageOpacity',
            'initialWidth',
            'initialHeight',
            'mipmapBias',
            'mipmapInitialLevel',
            'mipmapMaxLevel'
          ].forEach( function( simpleKey ) {
            if ( node[ simpleKey ] !== scenery.Image.DEFAULT_OPTIONS[ simpleKey ] ) {
              options[ simpleKey ] = node[ simpleKey ];
            }
          } );

          setup.width = node.imageWidth;
          setup.height = node.imageHeight;

          // Initialized with a mipmap
          if ( node._mipmapData ) {
            setup.imageType = 'mipmapData';
            setup.mipmapData = node._mipmapData.map( function( level ) {
              return {
                url: level.url,
                width: level.width,
                height: level.height
                // will reconstitute img {HTMLImageElement} and canvas {HTMLCanvasElement}
              };
            } );
          }
          else {
            if ( node._mipmap ) {
              setup.generateMipmaps = true;
            }
            if ( node._image instanceof HTMLImageElement ) {
              setup.imageType = 'image';
              setup.src = node._image.src;
            }
            else if ( node._image instanceof HTMLCanvasElement ) {
              setup.imageType = 'canvas';
              setup.src = node._image.toDataURL();
            }
          }
        }

        if ( ( scenery.CanvasNode && node instanceof scenery.CanvasNode ) ||
             ( scenery.WebGLNode && node instanceof scenery.WebGLNode ) ) {
          serialization.type = ( scenery.CanvasNode && node instanceof scenery.CanvasNode ) ? 'CanvasNode' : 'WebGLNode';

          setup.canvasBounds = scenery.serialize( node.canvasBounds );

          // Identify the approximate scale of the node
          var scale = Math.min( 5, node._drawables.length ? ( 1 / _.mean( node._drawables.map( function( drawable ) {
            var scaleVector = drawable.instance.trail.getMatrix().getScaleVector();
            return ( scaleVector.x + scaleVector.y ) / 2;
          } ) ) ) : 1 );
          scale = 1;
          var canvas = document.createElement( 'canvas' );
          canvas.width = Math.ceil( node.canvasBounds.width * scale );
          canvas.height = Math.ceil( node.canvasBounds.height * scale );
          var context = canvas.getContext( '2d' );
          var wrapper = new scenery.CanvasContextWrapper( canvas, context );
          var matrix = dot.Matrix3.scale( 1 / scale );
          wrapper.context.setTransform( scale, 0, 0, scale, -node.canvasBounds.left, -node.canvasBounds.top );
          node.renderToCanvasSelf( wrapper, matrix );
          setup.url = canvas.toDataURL();
          setup.scale = scale;
          setup.offset = scenery.serialize( node.canvasBounds.leftTop );
        }

        if ( scenery.DOM && node instanceof scenery.DOM ) {
          serialization.type = 'DOM';
          setup.element = new window.XMLSerializer().serializeToString( node.element );
        }

        // Paintable
        if ( ( scenery.Path && node instanceof scenery.Path ) ||
             ( scenery.Text && node instanceof scenery.Text ) ) {

          [
            'fillPickable',
            'strokePickable',
            'lineWidth',
            'lineCap',
            'lineJoin',
            'lineDashOffset',
            'miterLimit'
          ].forEach( function( simpleKey ) {
            if ( node[ simpleKey ] !== scenery.Paintable.DEFAULT_OPTIONS[ simpleKey ] ) {
              options[ simpleKey ] = node[ simpleKey ];
            }
          } );

          // Ignoring cachedPaints, since we'd 'double' it anyways

          if ( node.fill !== scenery.Paintable.DEFAULT_OPTIONS.fill ) {
            setup.fill = scenery.serialize( node.fill );
          }
          if ( node.stroke !== scenery.Paintable.DEFAULT_OPTIONS.stroke ) {
            setup.stroke = scenery.serialize( node.stroke );
          }
          if ( node.lineDash.length ) {
            setup.lineDash = scenery.serialize( node.lineDash );
          }
        }

        return serialization;
      }
      else if ( value instanceof scenery.Display ) {
        return {
          type: 'Display',
          width: value.width,
          height: value.height,
          backgroundColor: scenery.serialize( value.backgroundColor ),
          tree: {
            type: 'Subtree',
            rootNodeId: value.rootNode.id,
            nodes: scenery.serializeConnectedNodes( value.rootNode )
          }
        };
      }
      else {
        return {
          type: 'value',
          value: value
        };
      }
    },

    // @public
    deserialize: function( value ) {
      var nodeTypes = [
        'Node', 'Path', 'Circle', 'Line', 'Rectangle', 'Text', 'HTMLText', 'Image', 'CanvasNode', 'WebGLNode', 'DOM'
      ];

      if ( value.type === 'Vector2' ) {
        return new dot.Vector2( value.x, value.y );
      }
      if ( value.type === 'Matrix3' ) {
        return new dot.Matrix3().rowMajor( value.m00, value.m01, value.m02,
                                           value.m10, value.m11, value.m12,
                                           value.m20, value.m21, value.m22 );
      }
      else if ( value.type === 'Bounds2' ) {
        return new dot.Bounds2( value.minX, value.minY, value.maxX, value.maxY );
      }
      else if ( value.type === 'Shape' ) {
        return new kite.Shape( value.path );
      }
      else if ( value.type === 'Array' ) {
        return value.value.map( scenery.deserialize );
      }
      else if ( value.type === 'Color' ) {
        return new scenery.Color( value.red, value.green, value.blue, value.alpha );
      }
      else if ( value.type === 'Property' ) {
        return new axon.Property( scenery.deserialize( value.value ) );
      }
      else if ( value.type === 'Pattern' || value.type === 'LinearGradient' || value.type === 'RadialGradient' ) {
        var paint;

        if ( value.type === 'Pattern' ) {
          var img = new window.Image();
          img.src = value.url;
          paint = new scenery.Pattern( img );
        }
        // Gradients
        else {
          var start = scenery.deserialize( value.start );
          var end = scenery.deserialize( value.end );
          if ( value.type === 'LinearGradient' ) {
            paint = new scenery.LinearGradient( start.x, start.y, end.x, end.y );
          }
          else if ( value.type === 'RadialGradient' ) {
            paint = new scenery.RadialGradient( start.x, start.y, value.startRadius, end.x, end.y, value.endRadius );
          }

          value.stops.forEach( function( stop ) {
            paint.addColorStop( stop.ratio, scenery.deserialize( stop.stop ) );
          } );
        }

        if ( value.transformMatrix ) {
          paint.setTransformMatrix( scenery.deserialize( value.transformMatrix ) );
        }

        return paint;
      }
      else if ( _.includes( nodeTypes, value.type ) ) {
        var node;

        var setup = value.setup;

        if ( value.type === 'Node' ) {
          node = new scenery.Node();
        }
        else if ( value.type === 'Path' ) {
          node = new scenery.Path( scenery.deserialize( setup.path ) );
        }
        else if ( value.type === 'Circle' ) {
          node = new scenery.Circle( {} );
        }
        else if ( value.type === 'Line' ) {
          node = new scenery.Line( {} );
        }
        else if ( value.type === 'Rectangle' ) {
          node = new scenery.Rectangle( {} );
        }
        else if ( value.type === 'Text' ) {
          node = new scenery.Text( '' );
        }
        else if ( value.type === 'HTMLText' ) {
          node = new scenery.HTMLText( '' );
        }
        else if ( value.type === 'Image' ) {
          if ( setup.imageType === 'image' || setup.imageType === 'canvas' ) {
            node = new scenery.Image( setup.src );
            if ( setup.generateMipmaps ) {
              node.mipmaps = true;
            }
          }
          else if ( setup.imageType === 'mipmapData' ) {
            var mipmapData = setup.mipmapData.map( function( level ) {
              var result = {
                width: level.width,
                height: level.height,
                url: level.url
              };
              result.img = new window.Image();
              result.img.src = level.url;
              result.canvas = document.createElement( 'canvas' );
              result.canvas.width = level.width;
              result.canvas.height = level.height;
              var context = result.canvas.getContext( '2d' );
              // delayed loading like in mipmap plugin
              result.updateCanvas = function() {
                if ( result.img.complete && ( typeof result.img.naturalWidth === 'undefined' || result.img.naturalWidth > 0 ) ) {
                  context.drawImage( result.img, 0, 0 );
                  delete result.updateCanvas;
                }
              };
              return result;
            } );
            node = new scenery.Image( mipmapData );
          }
          node.initialWidth = setup.width;
          node.initialHeight = setup.height;
        }
        else if ( value.type === 'CanvasNode' || value.type === 'WebGLNode' ) {
          // TODO: Record Canvas/WebGL calls? (conditionals would be harder!)
          node = new scenery.Node( {
            children: [
              new scenery.Image( setup.url, {
                translation: scenery.deserialize( setup.offset ),
                scale: 1 / setup.scale
              } )
            ]
          } );
        }
        else if ( value.type === 'DOM' ) {
          var div = document.createElement( 'div' );
          div.innerHTML = value.element;
          var element = div.childNodes[ 0 ];
          div.removeChild( element );
          node = new scenery.DOM( element );
        }

        if ( setup.clipArea ) {
          node.clipArea = scenery.deserialize( setup.clipArea );
        }
        if ( setup.mouseArea ) {
          node.mouseArea = scenery.deserialize( setup.mouseArea );
        }
        if ( setup.touchArea ) {
          node.touchArea = scenery.deserialize( setup.touchArea );
        }
        if ( setup.matrix ) {
          node.matrix = scenery.deserialize( setup.matrix );
        }
        if ( setup.localBounds ) {
          node.localBounds = scenery.deserialize( setup.localBounds );
        }

        // Paintable, if they exist
        if ( setup.fill ) {
          node.fill = scenery.deserialize( setup.fill );
        }
        if ( setup.stroke ) {
          node.stroke = scenery.deserialize( setup.stroke );
        }
        if ( setup.lineDash ) {
          node.lineDash = scenery.deserialize( setup.lineDash );
        }

        node.mutate( value.options );

        node._serialization = value;

        return node;
      }
      else if ( value.type === 'Subtree' ) {
        var nodeMap = {};
        var nodes = value.nodes.map( scenery.deserialize );

        // Index them
        nodes.forEach( function( node ) {
          nodeMap[ node._serialization.id ] = node;
        } );

        // Connect children
        nodes.forEach( function( node ) {
          node._serialization.setup.children.forEach( function( childId ) {
            node.addChild( nodeMap[ childId ] );
          } );
        } );

        // The root should be the first one
        return nodeMap[ value.rootNodeId ];
      }
      else if ( value.type === 'value' ) {
        return value.value;
      }
    },

    serializeConnectedNodes: function( rootNode ) {
      return rootNode.getSubtreeNodes().map( scenery.serialize );
    }
  } );

  return scenery;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * If given an Array, removes all of its elements and returns it. Otherwise, if given a falsy value
 * (null/undefined/etc.), it will create and return a fresh Array.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/cleanArray',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function cleanArray( arr ) {
    assert && assert( !arr || ( arr instanceof Array ), 'cleanArray either takes an Array' );

    if ( arr ) {
      // fastest way to clear an array (http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript, http://jsperf.com/array-destroy/32)
      // also, better than length=0, since it doesn't create significant garbage collection (like length=0), tested on Chrome 34.
      while ( arr.length ) {
        arr.pop();
      }
      return arr;
    }
    else {
      return [];
    }
  }

  phetCore.register( 'cleanArray', cleanArray );

  return cleanArray;
} );
// Copyright 2013-2016, University of Colorado Boulder

/**
 * Lightweight event & listener abstraction.
 *
 * @deprecated - use Emitter.js instead
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'AXON/Events',['require','AXON/axon','PHET_CORE/cleanArray'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );

  /**
   * @constructor
   */
  function Events() {
    this._eventListeners = {}; // @private
    this._staticEventListeners = {}; // @private
  }

  axon.register( 'Events', Events );

  Events.prototype = {

    // @public
    dispose: function() {
    },

    /////////////////////////////////////////////
    // Below this point are the functions for event handling, basically orthogonal to property value change notifications

    /**
     * Register a listener when the specified eventName is triggered. Use off() to remove.
     * Concurrent modification of listeners (on/off) from within the callback is acceptable.
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @public
     */
    on: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      this._eventListeners[ eventName ] = this._eventListeners[ eventName ] || [];
      this._eventListeners[ eventName ].push( callback );
    },

    /**
     * Register a listener when the specified eventName is triggered. Listener should be "static", meaning:
     *   1. It shall not add/remove any "static" listeners (including itself) while it is being called (as any type of side-effect), and
     *   2. "static" listeners should not be added while a non-static listener (on the same object) is being called.
     * These restrictions allow us to guarantee that all listeners attached when an event is triggered are called.
     * Since static listeners are stored separately, use offStatic() to remove listeners added with onStatic()
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @public
     */
    onStatic: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      this._staticEventListeners[ eventName ] = this._staticEventListeners[ eventName ] || [];
      this._staticEventListeners[ eventName ].push( callback );
    },

    /**
     * Adds a function which will only be called back once, after which it is removed as a listener.
     * If you need to remove a function added with 'once' you will have to remove its handle, which is returned by the function.
     * @param {string} eventName the name for the event channel
     * @param {function} callback function to be called back once (if at all)
     * @public
     */
    once: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var self = this;
      var wrappedCallback = function() {
        self.off( eventName, wrappedCallback );

        //If no arguments being passed through, call back without processing arguments, for possible speed
        if ( arguments.length === 0 ) {
          callback();
        }
        else {

          //General case of passing events through to the wrapped callback function
          callback.apply( this, Array.prototype.slice.call( arguments, 0 ) );
        }
      };
      this.on( eventName, wrappedCallback );

      //Return the handle in case it needs to be removed.
      return wrappedCallback;
    },

    /**
     * Remove a listener added with on() from the specified event type.  Does nothing if the listener did not exist.
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @public
     */
    off: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var index = -1;
      if ( this._eventListeners[ eventName ] ) {
        index = this._eventListeners[ eventName ].indexOf( callback );
        if ( index !== -1 ) {
          this._eventListeners[ eventName ].splice( index, 1 );
        }
      }

      return index; // so we can tell if we actually removed a listener
    },

    /**
     * Remove a listener added with onStatic() from the specified event type.  Does nothing if the listener did not exist.
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @public
     */
    offStatic: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var index = -1;
      if ( this._staticEventListeners[ eventName ] ) {
        index = this._staticEventListeners[ eventName ].indexOf( callback );
        if ( index !== -1 ) {
          this._staticEventListeners[ eventName ].splice( index, 1 );
        }
      }

      return index; // so we can tell if we actually removed a listener
    },

    /**
     * Checks for the existence of a specific listener, attached to a specific event name. Doesn't check for static listeners
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @returns {boolean}
     * @public
     */
    hasListener: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var array = this._eventListeners[ eventName ];
      return !!array && array.indexOf( callback ) >= 0;
    },

    /**
     * Checks for the existence of a specific static listener, attached to a specific event name. Doesn't check for non-static listeners
     * @param {string} eventName the name for the event channel
     * @param {function} callback
     * @returns {boolean}
     * @public
     */
    hasStaticListener: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );

      var array = this._staticEventListeners[ eventName ];
      return !!array && array.indexOf( callback ) >= 0;
    },

    /**
     * Removes all listeners added with on() and onStatic().
     * @public
     */
    removeAllEventListeners: function() {
      var eventName;
      for ( eventName in this._eventListeners ) {
        cleanArray( this._eventListeners[ eventName ] );
      }
      for ( eventName in this._staticEventListeners ) {
        cleanArray( this._staticEventListeners[ eventName ] );
      }
    },

    /**
     * Trigger an event with the specified name and arguments.
     * @param {string} eventName the name for the event channel
     * @param args... optional arguments to pass to the listeners
     * @public
     */
    trigger: function( eventName ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );

      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];

      // listener quantities for normal and static
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;

      // only compute our arguments suffix once, instead of in our inner loop
      var suffix;
      var hasNoArguments = arguments.length === 1;
      if ( !hasNoArguments && ( count > 0 || staticCount > 0 ) ) {
        phetAllocation && phetAllocation( 'Array' );
        suffix = Array.prototype.slice.call( arguments, 1 );
      }

      // make a copy of non-static listeners, in case callback removes listener
      if ( count > 0 ) {
        listeners = listeners.slice();
      }

      var i;

      for ( i = 0; i < count; i++ ) {
        var listener = listeners[ i ];

        //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)
        if ( hasNoArguments ) {
          listener();
        }
        else {
          listener.apply( this, suffix );
        }

        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }

      for ( i = 0; i < staticCount; i++ ) {
        var staticListener = staticListeners[ i ];

        //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)
        if ( hasNoArguments ) {
          staticListener( arguments );
        }
        else {
          staticListener.apply( this, suffix );
        }

        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },

    /**
     * Trigger an event with the specified name, with no arguments.  Since the number of arguments is known
     * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).
     * @param {string} eventName the name for the event channel
     * @public
     */
    trigger0: function( eventName ) {
      assert && assert( arguments.length === 1 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );

      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];

      // listener quantities for normal and static
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;

      // make a copy of non-static listeners, in case callback removes listener
      if ( count > 0 ) {
        listeners = listeners.slice();
      }

      var i;

      for ( i = 0; i < count; i++ ) {
        listeners[ i ]();

        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }

      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]();

        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },

    /**
     * Trigger an event with the specified name, with a single argument.  Since the number of arguments is known
     * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).
     * @param {string} eventName the name for the event channel
     * @param {Object} param1 - the argument to pass through to the listeners
     * @public
     */
    trigger1: function( eventName, param1 ) {
      assert && assert( arguments.length === 2 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );

      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];

      // listener quantities for normal and static
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;

      // make a copy of non-static listeners, in case callback removes listener
      if ( count > 0 ) {
        listeners = listeners.slice();
      }

      var i;

      for ( i = 0; i < count; i++ ) {
        listeners[ i ]( param1 );

        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }

      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]( param1 );

        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },

    /**
     * Trigger an event with the specified name, with two arguments.  Since the number of arguments is known
     * no additional work is required to process and pass through the arguments (as opposed to trigger() itself).
     * @param {string} eventName the name for the event channel
     * @param {Object} param1 - the first parameter
     * @param {Object} param2 - the second parameter
     * @public
     */
    trigger2: function( eventName, param1, param2 ) {
      assert && assert( arguments.length === 3 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );

      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];

      // listener quantities for normal and static
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;

      // make a copy of non-static listeners, in case callback removes listener
      if ( count > 0 ) {
        listeners = listeners.slice();
      }

      var i;

      for ( i = 0; i < count; i++ ) {
        listeners[ i ]( param1, param2 );

        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }

      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]( param1, param2 );

        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    }
  };

  return Events;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Basic 4-dimensional vector, represented as (x,y).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Vector4',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  require( 'DOT/Util' );
  // require( 'DOT/Vector3' ); // commented out so Require.js doesn't complain about the circular dependency

  /**
   * Creates a 4-dimensional vector with the specified X, Y, Z and W values.
   * @constructor
   * @public
   *
   * @param {number} [x] - X coordinate, defaults to 0 if not provided
   * @param {number} [y] - Y coordinate, defaults to 0 if not provided
   * @param {number} [z] - Z coordinate, defaults to 0 if not provided
   * @param {number} [w] - W coordinate, defaults to 1 if not provided (convenience for homogeneous coordinates)
   */
  function Vector4( x, y, z, w ) {
    // @public {number} - The X coordinate of the vector.
    this.x = x !== undefined ? x : 0;

    // @public {number} - The Y coordinate of the vector.
    this.y = y !== undefined ? y : 0;

    // @public {number} - The Z coordinate of the vector.
    this.z = z !== undefined ? z : 0;

    // @public {number} - The W coordinate of the vector. Default is 1, for ease with homogeneous coordinates.
    this.w = w !== undefined ? w : 1;

    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );
    assert && assert( typeof this.z === 'number', 'z needs to be a number' );
    assert && assert( typeof this.w === 'number', 'w needs to be a number' );

    phetAllocation && phetAllocation( 'Vector4' );
  }

  dot.register( 'Vector4', Vector4 );

  inherit( Object, Vector4, {
    // @public (read-only) - Helps to identify the dimension of the vector
    isVector4: true,
    dimension: 4,

    /**
     * The magnitude (Euclidean/L2 Norm) of this vector, i.e. $\sqrt{x^2+y^2+z^2+w^2}$.
     * @public
     *
     * @returns {number}
     */
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    /**
     * The squared magnitude (square of the Euclidean/L2 Norm) of this vector, i.e. $x^2+y^2+z^2+w^2$.
     * @public
     *
     * @returns {number}
     */
    magnitudeSquared: function() {
      this.dot( this );
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector4} point
     * @returns {number}
     */
    distance: function( point ) {
      return this.minus( point ).magnitude();
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point (x,y,z,w).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {number}
     */
    distanceXYZW: function( x, y, z, w ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      var dw = this.w - w;
      return Math.sqrt( dx * dx + dy * dy + dz * dz + dw * dw );
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector4} point
     * @returns {number}
     */
    distanceSquared: function( point ) {
      return this.minus( point ).magnitudeSquared();
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point (x,y,z,w).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {number}
     */
    distanceSquaredXYZW: function( x, y, z, w ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      var dw = this.w - w;
      return dx * dx + dy * dy + dz * dz + dw * dw;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector v.
     * @public
     *
     * @param {Vector4} v
     * @returns {number}
     */
    dot: function( v ) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector (x,y,z,w).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {number}
     */
    dotXYZW: function( x, y, z, w ) {
      return this.x * x + this.y * y + this.z * z + this.w * w;
    },

    /**
     * The angle between this vector and another vector, in the range $\theta\in[0, \pi]$.
     * @public
     *
     * Equal to $\theta = \cos^{-1}( \hat{u} \cdot \hat{v} )$ where $\hat{u}$ is this vector (normalized) and $\hat{v}$
     * is the input vector (normalized).
     *
     * @param {Vector4} v
     * @returns {number}
     */
    angleBetween: function( v ) {
      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
    },

    /**
     * Exact equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector4} other
     * @returns {boolean} - Whether the two vectors have equal components
     */
    equals: function( other ) {
      return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
    },

    /**
     * Approximate equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector4} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two vectors has no component with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) + Math.abs( this.w - other.w ) <= epsilon;
    },

    /**
     * Whether all of the components are numbers (not NaN) that are not infinity or -infinity.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z ) && isFinite( this.w );
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this vector, or if a vector is passed in, set that vector's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a vector is provided. This will return a new vector, and
     * will not modify this vector.
     *
     * @param {Vector4} [vector] - If not provided, creates a new Vector4 with filled in values. Otherwise, fills in the
     *                             values of the provided vector so that it equals this vector.
     * @returns {Vector4}
     */
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector4( this.x, this.y, this.z, this.w );
      }
    },

    /**
     * Normalized (re-scaled) copy of this vector such that its magnitude is 1. If its initial magnitude is zero, an
     * error is thrown.
     * @public
     *
     * This is the immutable form of the function normalize(). This will return a new vector, and will not modify this
     * vector.
     *
     * @returns {Vector4}
     */
    normalized: function() {
      var magnitude = this.magnitude();
      assert && assert( magnitude !== 0, 'Cannot normalize a zero-magnitude vector' );
      return this.dividedScalar( magnitude );
    },

    /**
     * Returns a copy of this vector with each component rounded by Util.roundSymmetric.
     * @public
     *
     * This is the immutable form of the function roundSymmetric(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector2}
     */
    roundedSymmetric: function() {
      return this.copy().roundSymmetric();
    },

    /**
     * Re-scaled copy of this vector such that it has the desired magnitude. If its initial magnitude is zero, an error
     * is thrown. If the passed-in magnitude is negative, the direction of the resulting vector will be reversed.
     * @public
     *
     * This is the immutable form of the function setMagnitude(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} magnitude
     * @returns {Vector4}
     */
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },

    /**
     * Copy of this vector, scaled by the desired scalar value.
     * @public
     *
     * This is the immutable form of the function multiplyScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    timesScalar: function( scalar ) {
      return new Vector4( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
    },

    /**
     * Same as timesScalar.
     * @public
     *
     * This is the immutable form of the function multiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },

    /**
     * Copy of this vector, multiplied component-wise by the passed-in vector v.
     * @public
     *
     * This is the immutable form of the function componentMultiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    componentTimes: function( v ) {
      return new Vector4( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
    },

    /**
     * Addition of this vector and another vector, returning a copy.
     * @public
     *
     * This is the immutable form of the function add(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    plus: function( v ) {
      return new Vector4( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
    },

    /**
     * Addition of this vector and another vector (x,y,z,w), returning a copy.
     * @public
     *
     * This is the immutable form of the function addXYZW(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    plusXYZW: function( x, y, z, w ) {
      return new Vector4( this.x + x, this.y + y, this.z + z, this.w + w );
    },

    /**
     * Addition of this vector with a scalar (adds the scalar to every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function addScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    plusScalar: function( scalar ) {
      return new Vector4( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
    },

    /**
     * Subtraction of this vector by another vector v, returning a copy.
     * @public
     *
     * This is the immutable form of the function subtract(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    minus: function( v ) {
      return new Vector4( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
    },

    /**
     * Subtraction of this vector by another vector (x,y,z,w), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractXYZW(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    minusXYZW: function( x, y, z, w ) {
      return new Vector4( this.x - x, this.y - y, this.z - z, this.w - w );
    },

    /**
     * Subtraction of this vector by a scalar (subtracts the scalar from every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    minusScalar: function( scalar ) {
      return new Vector4( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
    },

    /**
     * Division of this vector by a scalar (divides every component by the scalar), returning a copy.
     * @public
     *
     * This is the immutable form of the function divideScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    dividedScalar: function( scalar ) {
      return new Vector4( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
    },

    /**
     * Negated copy of this vector (multiplies every component by -1).
     * @public
     *
     * This is the immutable form of the function negate(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector4}
     */
    negated: function() {
      return new Vector4( -this.x, -this.y, -this.z, -this.w );
    },

    /**
     * A linear interpolation between this vector (ratio=0) and another vector (ratio=1).
     * @public
     *
     * @param {Vector4} vector
     * @param {number} ratio - Not necessarily constrained in [0, 1]
     * @returns {Vector4}
     */
    blend: function( vector, ratio ) {
      return this.plus( vector.minus( this ).times( ratio ) );
    },

    /**
     * The average (midpoint) between this vector and another vector.
     * @public
     *
     * @param {Vector4} vector
     * @returns {Vector4}
     */
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },

    /**
     * Debugging string for the vector.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return 'Vector4(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
    },

    /**
     * Converts this to a 3-dimensional vector, discarding the w-component.
     * @public
     *
     * @returns {Vector3}
     */
    toVector3: function() {
      return new dot.Vector3( this.x, this.y, this.z );
    },

    /*---------------------------------------------------------------------------*
     * Mutables
     * - all mutation should go through setXYZW / setX / setY / setZ / setW
     *---------------------------------------------------------------------------*/

    /**
     * Sets all of the components of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    setXYZW: function( x, y, z, w ) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    },

    /**
     * Sets the x-component of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @returns {Vector4}
     */
    setX: function( x ) {
      this.x = x;
      return this;
    },

    /**
     * Sets the y-component of this vector, returning this.
     * @public
     *
     * @param {number} y
     * @returns {Vector4}
     */
    setY: function( y ) {
      this.y = y;
      return this;
    },

    /**
     * Sets the z-component of this vector, returning this.
     * @public
     *
     * @param {number} z
     * @returns {Vector4}
     */
    setZ: function( z ) {
      this.z = z;
      return this;
    },

    /**
     * Sets the w-component of this vector, returning this.
     * @public
     *
     * @param {number} w
     * @returns {Vector4}
     */
    setW: function( w ) {
      this.w = w;
      return this;
    },

    /**
     * Sets this vector to be a copy of another vector.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this vector, in addition to returning
     * this vector itself.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    set: function( v ) {
      return this.setXYZW( v.x, v.y, v.z, v.w );
    },

    /**
     * Sets the magnitude of this vector. If the passed-in magnitude is negative, this flips the vector and sets its
     * magnitude to abs( magnitude ).
     * @public
     *
     * This is the mutable form of the function withMagnitude(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} magnitude
     * @returns {Vector4}
     */
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },

    /**
     * Adds another vector to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    add: function( v ) {
      return this.setXYZW( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
    },

    /**
     * Adds another vector (x,y,z,w) to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plusXYZW(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    addXYZW: function( x, y, z, w ) {
      return this.setXYZW( this.x + x, this.y + y, this.z + z, this.w + w );
    },

    /**
     * Adds a scalar to this vector (added to every component), changing this vector.
     * @public
     *
     * This is the mutable form of the function plusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    addScalar: function( scalar ) {
      return this.setXYZW( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
    },

    /**
     * Subtracts this vector by another vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function minus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    subtract: function( v ) {
      return this.setXYZW( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
    },

    /**
     * Subtracts this vector by another vector (x,y,z,w), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusXYZW(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @param {number} w
     * @returns {Vector4}
     */
    subtractXYZW: function( x, y, z, w ) {
      return this.setXYZW( this.x - x, this.y - y, this.z - z, this.w - w );
    },

    /**
     * Subtracts this vector by a scalar (subtracts each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    subtractScalar: function( scalar ) {
      return this.setXYZW( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function timesScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    multiplyScalar: function( scalar ) {
      return this.setXYZW( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * Same as multiplyScalar.
     * @public
     *
     * This is the mutable form of the function times(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },

    /**
     * Multiplies this vector by another vector component-wise, changing this vector.
     * @public
     *
     * This is the mutable form of the function componentTimes(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector4} v
     * @returns {Vector4}
     */
    componentMultiply: function( v ) {
      return this.setXYZW( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
    },

    /**
     * Divides this vector by a scalar (divides each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function dividedScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector4}
     */
    divideScalar: function( scalar ) {
      return this.setXYZW( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
    },

    /**
     * Negates this vector (multiplies each component by -1), changing this vector.
     * @public
     *
     * This is the mutable form of the function negated(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector4}
     */
    negate: function() {
      return this.setXYZW( -this.x, -this.y, -this.z, -this.w );
    },

    /**
     * Normalizes this vector (rescales to where the magnitude is 1), changing this vector.
     * @public
     *
     * This is the mutable form of the function normalized(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector4}
     */
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      return this.divideScalar( mag );
    },

    /**
     * Rounds each component of this vector with Util.roundSymmetric.
     * @public
     *
     * This is the mutable form of the function roundedSymmetric(). This will mutate (change) this vector, in addition
     * to returning the vector itself.
     *
     * @returns {Vector4}
     */
    roundSymmetric: function() {
      return this.setXYZW( dot.Util.roundSymmetric( this.x ),
                           dot.Util.roundSymmetric( this.y ),
                           dot.Util.roundSymmetric( this.z ),
                           dot.Util.roundSymmetric( this.w ) );
    }
  } );

  // Sets up pooling on Vector4
  Poolable.mixin( Vector4, {
    defaultFactory: function() { return new Vector4(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y, z, w ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y, z, w );
        }
        else {
          return new Vector4( x, y, z, w );
        }
      };
    }
  } );

  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *---------------------------------------------------------------------------*/

  // @private
  Vector4.Immutable = function( x, y, z, w ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
    this.w = w !== undefined ? w : 1;
  };
  var Immutable = Vector4.Immutable;

  inherit( Vector4, Immutable );

  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector4' );
    };
  };

  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXYZW' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Immutable.mutableOverrideHelper( 'setZ' );
  Immutable.mutableOverrideHelper( 'setW' );

  // @public {Vector4} - helpful immutable constants
  Vector4.ZERO = assert ? new Immutable( 0, 0, 0, 0 ) : new Vector4( 0, 0, 0, 0 );
  Vector4.X_UNIT = assert ? new Immutable( 1, 0, 0, 0 ) : new Vector4( 1, 0, 0, 0 );
  Vector4.Y_UNIT = assert ? new Immutable( 0, 1, 0, 0 ) : new Vector4( 0, 1, 0, 0 );
  Vector4.Z_UNIT = assert ? new Immutable( 0, 0, 1, 0 ) : new Vector4( 0, 0, 1, 0 );
  Vector4.W_UNIT = assert ? new Immutable( 0, 0, 0, 1 ) : new Vector4( 0, 0, 0, 1 );

  return Vector4;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Basic 3-dimensional vector, represented as (x,y,z).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'DOT/Vector3',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util','DOT/Vector2','DOT/Vector4'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  require( 'DOT/Util' );
  require( 'DOT/Vector2' );
  require( 'DOT/Vector4' );

  /**
   * Creates a 3-dimensional vector with the specified X, Y and Z values.
   * @constructor
   * @public
   *
   * @param {number} [x] - X coordinate, defaults to 0 if not provided
   * @param {number} [y] - Y coordinate, defaults to 0 if not provided
   * @param {number} [z] - Z coordinate, defaults to 0 if not provided
   */
  function Vector3( x, y, z ) {
    // @public {number} - The X coordinate of the vector.
    this.x = x !== undefined ? x : 0;

    // @public {number} - The Y coordinate of the vector.
    this.y = y !== undefined ? y : 0;

    // @public {number} - The Z coordinate of the vector.
    this.z = z !== undefined ? z : 0;

    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );
    assert && assert( typeof this.z === 'number', 'z needs to be a number' );

    phetAllocation && phetAllocation( 'Vector3' );
  }

  dot.register( 'Vector3', Vector3 );

  inherit( Object, Vector3, {
    // @public (read-only) - Helps to identify the dimension of the vector
    isVector3: true,
    dimension: 3,

    /**
     * The magnitude (Euclidean/L2 Norm) of this vector, i.e. $\sqrt{x^2+y^2+z^2}$.
     * @public
     *
     * @returns {number}
     */
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },

    /**
     * T squared magnitude (square of the Euclidean/L2 Norm) of this vector, i.e. $x^2+y^2+z^2$.
     * @public
     *
     * @returns {number}
     */
    magnitudeSquared: function() {
      return this.dot( this );
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector3} point
     * @returns {number}
     */
    distance: function( point ) {
      return Math.sqrt( this.distanceSquared( point ) );
    },

    /**
     * The Euclidean distance between this vector (treated as a point) and another point (x,y,z).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {number}
     */
    distanceXYZ: function( x, y, z ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      return Math.sqrt( dx * dx + dy * dy + dz * dz );
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point.
     * @public
     *
     * @param {Vector3} point
     * @returns {number}
     */
    distanceSquared: function( point ) {
      var dx = this.x - point.x;
      var dy = this.y - point.y;
      var dz = this.z - point.z;
      return dx * dx + dy * dy + dz * dz;
    },

    /**
     * The squared Euclidean distance between this vector (treated as a point) and another point (x,y,z).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {number}
     */
    distanceSquaredXYZ: function( x, y, z ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      return dx * dx + dy * dy + dz * dz;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector v.
     * @public
     *
     * @param {Vector3} v
     * @returns {number}
     */
    dot: function( v ) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },

    /**
     * The dot-product (Euclidean inner product) between this vector and another vector (x,y,z).
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {number}
     */
    dotXYZ: function( x, y, z ) {
      return this.x * x + this.y * y + this.z * z;
    },

    /**
     * The angle between this vector and another vector, in the range $\theta\in[0, \pi]$.
     * @public
     *
     * Equal to $\theta = \cos^{-1}( \hat{u} \cdot \hat{v} )$ where $\hat{u}$ is this vector (normalized) and $\hat{v}$
     * is the input vector (normalized).
     *
     * @param {Vector3} v
     * @returns {number}
     */
    angleBetween: function( v ) {
      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
    },

    /**
     * Exact equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector3} other
     * @returns {boolean} - Whether the two vectors have equal components
     */
    equals: function( other ) {
      return this.x === other.x && this.y === other.y && this.z === other.z;
    },

    /**
     * Approximate equality comparison between this vector and another vector.
     * @public
     *
     * @param {Vector3} other
     * @param {number} epsilon
     * @returns {boolean} - Whether difference between the two vectors has no component with an absolute value greater
     *                      than epsilon.
     */
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) <= epsilon;
    },

    /**
     * Whether all of the components are numbers (not NaN) that are not infinity or -infinity.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z );
    },

    /*---------------------------------------------------------------------------*
     * Immutables
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this vector, or if a vector is passed in, set that vector's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a vector is provided. This will return a new vector, and
     * will not modify this vector.
     *
     * @param {Vector3} [vector] - If not provided, creates a new Vector3 with filled in values. Otherwise, fills in the
     *                             values of the provided vector so that it equals this vector.
     * @returns {Vector3}
     */
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector3( this.x, this.y, this.z );
      }
    },

    /**
     * The Euclidean 3-dimensional cross-product of this vector by the passed-in vector.
     * @public
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    cross: function( v ) {
      return new Vector3(
        this.y * v.z - this.z * v.y,
        this.z * v.x - this.x * v.z,
        this.x * v.y - this.y * v.x
      );
    },

    /**
     * Normalized (re-scaled) copy of this vector such that its magnitude is 1. If its initial magnitude is zero, an
     * error is thrown.
     * @public
     *
     * This is the immutable form of the function normalize(). This will return a new vector, and will not modify this
     * vector.
     *
     * @returns {Vector3}
     */
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return new Vector3( this.x / mag, this.y / mag, this.z / mag );
      }
    },

    /**
     * Returns a copy of this vector with each component rounded by Util.roundSymmetric.
     * @public
     *
     * This is the immutable form of the function roundSymmetric(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector3}
     */
    roundedSymmetric: function() {
      return this.copy().roundSymmetric();
    },

    /**
     * Re-scaled copy of this vector such that it has the desired magnitude. If its initial magnitude is zero, an error
     * is thrown. If the passed-in magnitude is negative, the direction of the resulting vector will be reversed.
     * @public
     *
     * This is the immutable form of the function setMagnitude(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} magnitude
     * @returns {Vector3}
     */
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },

    /**
     * Copy of this vector, scaled by the desired scalar value.
     * @public
     *
     * This is the immutable form of the function multiplyScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    timesScalar: function( scalar ) {
      return new Vector3( this.x * scalar, this.y * scalar, this.z * scalar );
    },

    /**
     * Same as timesScalar.
     * @public
     *
     * This is the immutable form of the function multiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    times: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },

    /**
     * Copy of this vector, multiplied component-wise by the passed-in vector v.
     * @public
     *
     * This is the immutable form of the function componentMultiply(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    componentTimes: function( v ) {
      return new Vector3( this.x * v.x, this.y * v.y, this.z * v.z );
    },

    /**
     * Addition of this vector and another vector, returning a copy.
     * @public
     *
     * This is the immutable form of the function add(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    plus: function( v ) {
      return new Vector3( this.x + v.x, this.y + v.y, this.z + v.z );
    },

    /**
     * Addition of this vector and another vector (x,y,z), returning a copy.
     * @public
     *
     * This is the immutable form of the function addXYZ(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    plusXYZ: function( x, y, z ) {
      return new Vector3( this.x + x, this.y + y, this.z + z );
    },

    /**
     * Addition of this vector with a scalar (adds the scalar to every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function addScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    plusScalar: function( scalar ) {
      return new Vector3( this.x + scalar, this.y + scalar, this.z + scalar );
    },

    /**
     * Subtraction of this vector by another vector v, returning a copy.
     * @public
     *
     * This is the immutable form of the function subtract(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    minus: function( v ) {
      return new Vector3( this.x - v.x, this.y - v.y, this.z - v.z );
    },

    /**
     * Subtraction of this vector by another vector (x,y,z), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractXYZ(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    minusXYZ: function( x, y, z ) {
      return new Vector3( this.x - x, this.y - y, this.z - z );
    },

    /**
     * Subtraction of this vector by a scalar (subtracts the scalar from every component), returning a copy.
     * @public
     *
     * This is the immutable form of the function subtractScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    minusScalar: function( scalar ) {
      return new Vector3( this.x - scalar, this.y - scalar, this.z - scalar );
    },

    /**
     * Division of this vector by a scalar (divides every component by the scalar), returning a copy.
     * @public
     *
     * This is the immutable form of the function divideScalar(). This will return a new vector, and will not modify
     * this vector.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    dividedScalar: function( scalar ) {
      return new Vector3( this.x / scalar, this.y / scalar, this.z / scalar );
    },

    /**
     * Negated copy of this vector (multiplies every component by -1).
     * @public
     *
     * This is the immutable form of the function negate(). This will return a new vector, and will not modify
     * this vector.
     *
     * @returns {Vector3}
     */
    negated: function() {
      return new Vector3( -this.x, -this.y, -this.z );
    },

    /**
     * A linear interpolation between this vector (ratio=0) and another vector (ratio=1).
     * @public
     *
     * @param {Vector3} vector
     * @param {number} ratio - Not necessarily constrained in [0, 1]
     * @returns {Vector3}
     */
    blend: function( vector, ratio ) {
      return this.plus( vector.minus( this ).times( ratio ) );
    },

    /**
     * The average (midpoint) between this vector and another vector.
     * @public
     *
     * @param {Vector3} vector
     * @returns {Vector3}
     */
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },

    /**
     * Debugging string for the vector.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return 'Vector3(' + this.x + ', ' + this.y + ', ' + this.z + ')';
    },

    /**
     * Converts this to a 2-dimensional vector, discarding the z-component.
     * @public
     *
     * @returns {Vector2}
     */
    toVector2: function() {
      return new dot.Vector2( this.x, this.y );
    },

    /**
     * Converts this to a 4-dimensional vector, with the z-component equal to 1 (useful for homogeneous coordinates).
     * @public
     *
     * @returns {Vector4}
     */
    toVector4: function() {
      return new dot.Vector4( this.x, this.y, this.z, 1 );
    },

    /*---------------------------------------------------------------------------*
     * Mutables
     * - all mutation should go through setXYZ / setX / setY / setZ
     *---------------------------------------------------------------------------*/

    /**
     * Sets all of the components of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    setXYZ: function( x, y, z ) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    },

    /**
     * Sets the x-component of this vector, returning this.
     * @public
     *
     * @param {number} x
     * @returns {Vector3}
     */
    setX: function( x ) {
      this.x = x;
      return this;
    },

    /**
     * Sets the y-component of this vector, returning this.
     * @public
     *
     * @param {number} y
     * @returns {Vector3}
     */
    setY: function( y ) {
      this.y = y;
      return this;
    },

    /**
     * Sets the z-component of this vector, returning this.
     * @public
     *
     * @param {number} z
     * @returns {Vector3}
     */
    setZ: function( z ) {
      this.z = z;
      return this;
    },

    /**
     * Sets this vector to be a copy of another vector.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this vector, in addition to returning
     * this vector itself.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    set: function( v ) {
      return this.setXYZ( v.x, v.y, v.z );
    },

    /**
     * Sets the magnitude of this vector. If the passed-in magnitude is negative, this flips the vector and sets its
     * magnitude to abs( magnitude ).
     * @public
     *
     * This is the mutable form of the function withMagnitude(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} magnitude
     * @returns {Vector3}
     */
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },

    /**
     * Adds another vector to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    add: function( v ) {
      return this.setXYZ( this.x + v.x, this.y + v.y, this.z + v.z );
    },

    /**
     * Adds another vector (x,y,z) to this vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function plusXYZ(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    addXYZ: function( x, y, z ) {
      return this.setXYZ( this.x + x, this.y + y, this.z + z );
    },

    /**
     * Adds a scalar to this vector (added to every component), changing this vector.
     * @public
     *
     * This is the mutable form of the function plusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    addScalar: function( scalar ) {
      return this.setXYZ( this.x + scalar, this.y + scalar, this.z + scalar );
    },

    /**
     * Subtracts this vector by another vector, changing this vector.
     * @public
     *
     * This is the mutable form of the function minus(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    subtract: function( v ) {
      return this.setXYZ( this.x - v.x, this.y - v.y, this.z - v.z );
    },

    /**
     * Subtracts this vector by another vector (x,y,z), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusXYZ(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} x
     * @param {number} y
     * @param {number} z
     * @returns {Vector3}
     */
    subtractXYZ: function( x, y, z ) {
      return this.setXYZ( this.x - x, this.y - y, this.z - z );
    },

    /**
     * Subtracts this vector by a scalar (subtracts each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function minusScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    subtractScalar: function( scalar ) {
      return this.setXYZ( this.x - scalar, this.y - scalar, this.z - scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function timesScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    multiplyScalar: function( scalar ) {
      return this.setXYZ( this.x * scalar, this.y * scalar, this.z * scalar );
    },

    /**
     * Multiplies this vector by a scalar (multiplies each component by the scalar), changing this vector.
     * Same as multiplyScalar.
     * @public
     *
     * This is the mutable form of the function times(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    multiply: function( scalar ) {
      // make sure it's not a vector!
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },

    /**
     * Multiplies this vector by another vector component-wise, changing this vector.
     * @public
     *
     * This is the mutable form of the function componentTimes(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {Vector3} v
     * @returns {Vector3}
     */
    componentMultiply: function( v ) {
      return this.setXYZ( this.x * v.x, this.y * v.y, this.z * v.z );
    },

    /**
     * Divides this vector by a scalar (divides each component by the scalar), changing this vector.
     * @public
     *
     * This is the mutable form of the function dividedScalar(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @param {number} scalar
     * @returns {Vector3}
     */
    divideScalar: function( scalar ) {
      return this.setXYZ( this.x / scalar, this.y / scalar, this.z / scalar );
    },

    /**
     * Negates this vector (multiplies each component by -1), changing this vector.
     * @public
     *
     * This is the mutable form of the function negated(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector3}
     */
    negate: function() {
      return this.setXYZ( -this.x, -this.y, -this.z );
    },

    /**
     * Normalizes this vector (rescales to where the magnitude is 1), changing this vector.
     * @public
     *
     * This is the mutable form of the function normalized(). This will mutate (change) this vector, in addition to
     * returning this vector itself.
     *
     * @returns {Vector3}
     */
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return this.divideScalar( mag );
      }
    },

    /**
     * Rounds each component of this vector with Util.roundSymmetric.
     * @public
     *
     * This is the mutable form of the function roundedSymmetric(). This will mutate (change) this vector, in addition
     * to returning the vector itself.
     *
     * @returns {Vector3}
     */
    roundSymmetric: function() {
      return this.setXYZ( dot.Util.roundSymmetric( this.x ),
                          dot.Util.roundSymmetric( this.y ),
                          dot.Util.roundSymmetric( this.z ) );
    }
  }, {
    /**
     * Spherical linear interpolation between two unit vectors.
     * @public
     *
     * @param {Vector3} start - Start unit vector
     * @param {Vector3} end - End unit vector
     * @param {number} ratio  - Between 0 (at start vector) and 1 (at end vector)
     * @returns {Vector3} Spherical linear interpolation between the start and end
     */
    slerp: function( start, end, ratio ) {
      // NOTE: we can't create a require() loop here
      return dot.Quaternion.slerp( new dot.Quaternion(), dot.Quaternion.getRotationQuaternion( start, end ), ratio ).timesVector3( start );
    }
  } );

  // Sets up pooling on Vector3
  Poolable.mixin( Vector3, {
    defaultFactory: function() { return new Vector3(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y, z ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y, z );
        }
        else {
          return new Vector3( x, y, z );
        }
      };
    }
  } );

  /*---------------------------------------------------------------------------*
   * Immutable Vector form
   *---------------------------------------------------------------------------*/

  // @private
  Vector3.Immutable = function( x, y, z ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
  };
  var Immutable = Vector3.Immutable;

  inherit( Vector3, Immutable );

  // throw errors whenever a mutable method is called on our immutable vector
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector3' );
    };
  };

  // TODO: better way to handle this list?
  Immutable.mutableOverrideHelper( 'setXYZ' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Immutable.mutableOverrideHelper( 'setZ' );

  // @public {Vector3} - helpful immutable constants
  Vector3.ZERO = assert ? new Immutable( 0, 0, 0 ) : new Vector3( 0, 0, 0 );
  Vector3.X_UNIT = assert ? new Immutable( 1, 0, 0 ) : new Vector3( 1, 0, 0 );
  Vector3.Y_UNIT = assert ? new Immutable( 0, 1, 0 ) : new Vector3( 0, 1, 0 );
  Vector3.Z_UNIT = assert ? new Immutable( 0, 0, 1 ) : new Vector3( 0, 0, 1 );

  return Vector3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * 4-dimensional Matrix
 *
 * TODO: consider adding affine flag if it will help performance (a la Matrix3)
 * TODO: get rotation angles
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Matrix4',['require','DOT/dot','DOT/Vector3','DOT/Vector4'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  require( 'DOT/Vector3' );
  require( 'DOT/Vector4' );

  var Float32Array = window.Float32Array || Array;

  function Matrix4( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {

    // entries stored in column-major format
    this.entries = new Float32Array( 16 );

    this.rowMajor(
      v00 !== undefined ? v00 : 1, v01 !== undefined ? v01 : 0, v02 !== undefined ? v02 : 0, v03 !== undefined ? v03 : 0,
      v10 !== undefined ? v10 : 0, v11 !== undefined ? v11 : 1, v12 !== undefined ? v12 : 0, v13 !== undefined ? v13 : 0,
      v20 !== undefined ? v20 : 0, v21 !== undefined ? v21 : 0, v22 !== undefined ? v22 : 1, v23 !== undefined ? v23 : 0,
      v30 !== undefined ? v30 : 0, v31 !== undefined ? v31 : 0, v32 !== undefined ? v32 : 0, v33 !== undefined ? v33 : 1,
      type );
  }

  dot.register( 'Matrix4', Matrix4 );

  Matrix4.Types = {
    OTHER: 0, // default
    IDENTITY: 1,
    TRANSLATION_3D: 2,
    SCALING: 3,
    AFFINE: 4

    // TODO: possibly add rotations
  };

  var Types = Matrix4.Types;

  Matrix4.identity = function() {
    return new Matrix4(
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1,
      Types.IDENTITY );
  };

  Matrix4.translation = function( x, y, z ) {
    return new Matrix4(
      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1,
      Types.TRANSLATION_3D );
  };

  Matrix4.translationFromVector = function( v ) { return Matrix4.translation( v.x, v.y, v.z ); };

  Matrix4.scaling = function( x, y, z ) {
    // allow using one parameter to scale everything
    y = y === undefined ? x : y;
    z = z === undefined ? x : z;

    return new Matrix4(
      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1,
      Types.SCALING );
  };

  // axis is a normalized Vector3, angle in radians.
  Matrix4.rotationAxisAngle = function( axis, angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var C = 1 - c;

    return new Matrix4(
      axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s, 0,
      axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s, 0,
      axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };

  // TODO: add in rotation from quaternion, and from quat + translation

  Matrix4.rotationX = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4(
      1, 0, 0, 0,
      0, c, -s, 0,
      0, s, c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };

  Matrix4.rotationY = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4(
      c, 0, s, 0,
      0, 1, 0, 0,
      -s, 0, c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };

  Matrix4.rotationZ = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );

    return new Matrix4(
      c, -s, 0, 0,
      s, c, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };

  // aspect === width / height
  Matrix4.gluPerspective = function( fovYRadians, aspect, zNear, zFar ) {
    var cotangent = Math.cos( fovYRadians ) / Math.sin( fovYRadians );

    return new Matrix4(
      cotangent / aspect, 0, 0, 0,
      0, cotangent, 0, 0,
      0, 0, ( zFar + zNear ) / ( zNear - zFar ), ( 2 * zFar * zNear ) / ( zNear - zFar ),
      0, 0, -1, 0 );
  };

  Matrix4.prototype = {
    constructor: Matrix4,

    rowMajor: function( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {
      this.entries[ 0 ] = v00;
      this.entries[ 1 ] = v10;
      this.entries[ 2 ] = v20;
      this.entries[ 3 ] = v30;
      this.entries[ 4 ] = v01;
      this.entries[ 5 ] = v11;
      this.entries[ 6 ] = v21;
      this.entries[ 7 ] = v31;
      this.entries[ 8 ] = v02;
      this.entries[ 9 ] = v12;
      this.entries[ 10 ] = v22;
      this.entries[ 11 ] = v32;
      this.entries[ 12 ] = v03;
      this.entries[ 13 ] = v13;
      this.entries[ 14 ] = v23;
      this.entries[ 15 ] = v33;

      // TODO: consider performance of the affine check here
      this.type = type === undefined ? ( ( v30 === 0 && v31 === 0 && v32 === 0 && v33 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
      return this;
    },

    columnMajor: function( v00, v10, v20, v30, v01, v11, v21, v31, v02, v12, v22, v32, v03, v13, v23, v33, type ) {
      return this.rowMajor( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type );
    },

    set: function( matrix ) {
      return this.rowMajor(
        matrix.m00(), matrix.m01(), matrix.m02(), matrix.m03(),
        matrix.m10(), matrix.m11(), matrix.m12(), matrix.m13(),
        matrix.m20(), matrix.m21(), matrix.m22(), matrix.m23(),
        matrix.m30(), matrix.m31(), matrix.m32(), matrix.m33(),
        matrix.type );
    },

    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler
    m00: function() { return this.entries[ 0 ]; },
    m01: function() { return this.entries[ 4 ]; },
    m02: function() { return this.entries[ 8 ]; },
    m03: function() { return this.entries[ 12 ]; },
    m10: function() { return this.entries[ 1 ]; },
    m11: function() { return this.entries[ 5 ]; },
    m12: function() { return this.entries[ 9 ]; },
    m13: function() { return this.entries[ 13 ]; },
    m20: function() { return this.entries[ 2 ]; },
    m21: function() { return this.entries[ 6 ]; },
    m22: function() { return this.entries[ 10 ]; },
    m23: function() { return this.entries[ 14 ]; },
    m30: function() { return this.entries[ 3 ]; },
    m31: function() { return this.entries[ 7 ]; },
    m32: function() { return this.entries[ 11 ]; },
    m33: function() { return this.entries[ 15 ]; },

    isFinite: function() {
      return isFinite( this.m00() ) &&
             isFinite( this.m01() ) &&
             isFinite( this.m02() ) &&
             isFinite( this.m03() ) &&
             isFinite( this.m10() ) &&
             isFinite( this.m11() ) &&
             isFinite( this.m12() ) &&
             isFinite( this.m13() ) &&
             isFinite( this.m20() ) &&
             isFinite( this.m21() ) &&
             isFinite( this.m22() ) &&
             isFinite( this.m23() ) &&
             isFinite( this.m30() ) &&
             isFinite( this.m31() ) &&
             isFinite( this.m32() ) &&
             isFinite( this.m33() );
    },

    // the 3D translation, assuming multiplication with a homogeneous vector
    getTranslation: function() {
      return new dot.Vector3( this.m03(), this.m13(), this.m23() );
    },
    get translation() { return this.getTranslation(); },

    // returns a vector that is equivalent to ( T(1,0,0).magnitude(), T(0,1,0).magnitude(), T(0,0,1).magnitude() )
    // where T is a relative transform
    getScaleVector: function() {
      var m0003 = this.m00() + this.m03();
      var m1013 = this.m10() + this.m13();
      var m2023 = this.m20() + this.m23();
      var m3033 = this.m30() + this.m33();
      var m0103 = this.m01() + this.m03();
      var m1113 = this.m11() + this.m13();
      var m2123 = this.m21() + this.m23();
      var m3133 = this.m31() + this.m33();
      var m0203 = this.m02() + this.m03();
      var m1213 = this.m12() + this.m13();
      var m2223 = this.m22() + this.m23();
      var m3233 = this.m32() + this.m33();
      return new dot.Vector3(
        Math.sqrt( m0003 * m0003 + m1013 * m1013 + m2023 * m2023 + m3033 * m3033 ),
        Math.sqrt( m0103 * m0103 + m1113 * m1113 + m2123 * m2123 + m3133 * m3133 ),
        Math.sqrt( m0203 * m0203 + m1213 * m1213 + m2223 * m2223 + m3233 * m3233 ) );
    },
    get scaleVector() { return this.getScaleVector(); },

    getCSSTransform: function() {
      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility

      // We need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
      // See https://github.com/phetsims/dot/issues/36

      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!
      // NOTE: the toFixed calls are inlined for performance reasons
      return 'matrix3d(' +
             this.entries[ 0 ].toFixed( 20 ) + ',' +
             this.entries[ 1 ].toFixed( 20 ) + ',' +
             this.entries[ 2 ].toFixed( 20 ) + ',' +
             this.entries[ 3 ].toFixed( 20 ) + ',' +
             this.entries[ 4 ].toFixed( 20 ) + ',' +
             this.entries[ 5 ].toFixed( 20 ) + ',' +
             this.entries[ 6 ].toFixed( 20 ) + ',' +
             this.entries[ 7 ].toFixed( 20 ) + ',' +
             this.entries[ 8 ].toFixed( 20 ) + ',' +
             this.entries[ 9 ].toFixed( 20 ) + ',' +
             this.entries[ 10 ].toFixed( 20 ) + ',' +
             this.entries[ 11 ].toFixed( 20 ) + ',' +
             this.entries[ 12 ].toFixed( 20 ) + ',' +
             this.entries[ 13 ].toFixed( 20 ) + ',' +
             this.entries[ 14 ].toFixed( 20 ) + ',' +
             this.entries[ 15 ].toFixed( 20 ) + ')';
    },
    get cssTransform() { return this.getCSSTransform(); },

    // exact equality
    equals: function( m ) {
      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() && this.m03() === m.m03() &&
             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() && this.m13() === m.m13() &&
             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22() && this.m23() === m.m23() &&
             this.m30() === m.m30() && this.m31() === m.m31() && this.m32() === m.m32() && this.m33() === m.m33();
    },

    // equality within a margin of error
    equalsEpsilon: function( m, epsilon ) {
      return Math.abs( this.m00() - m.m00() ) < epsilon &&
             Math.abs( this.m01() - m.m01() ) < epsilon &&
             Math.abs( this.m02() - m.m02() ) < epsilon &&
             Math.abs( this.m03() - m.m03() ) < epsilon &&
             Math.abs( this.m10() - m.m10() ) < epsilon &&
             Math.abs( this.m11() - m.m11() ) < epsilon &&
             Math.abs( this.m12() - m.m12() ) < epsilon &&
             Math.abs( this.m13() - m.m13() ) < epsilon &&
             Math.abs( this.m20() - m.m20() ) < epsilon &&
             Math.abs( this.m21() - m.m21() ) < epsilon &&
             Math.abs( this.m22() - m.m22() ) < epsilon &&
             Math.abs( this.m23() - m.m23() ) < epsilon &&
             Math.abs( this.m30() - m.m30() ) < epsilon &&
             Math.abs( this.m31() - m.m31() ) < epsilon &&
             Math.abs( this.m32() - m.m32() ) < epsilon &&
             Math.abs( this.m33() - m.m33() ) < epsilon;
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations (returning a new matrix)
     *----------------------------------------------------------------------------*/

    copy: function() {
      return new Matrix4(
        this.m00(), this.m01(), this.m02(), this.m03(),
        this.m10(), this.m11(), this.m12(), this.m13(),
        this.m20(), this.m21(), this.m22(), this.m23(),
        this.m30(), this.m31(), this.m32(), this.m33(),
        this.type
      );
    },

    plus: function( m ) {
      return new Matrix4(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(), this.m03() + m.m03(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(), this.m13() + m.m13(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22(), this.m23() + m.m23(),
        this.m30() + m.m30(), this.m31() + m.m31(), this.m32() + m.m32(), this.m33() + m.m33()
      );
    },

    minus: function( m ) {
      return new Matrix4(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(), this.m03() - m.m03(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(), this.m13() - m.m13(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22(), this.m23() - m.m23(),
        this.m30() - m.m30(), this.m31() - m.m31(), this.m32() - m.m32(), this.m33() - m.m33()
      );
    },

    transposed: function() {
      return new Matrix4(
        this.m00(), this.m10(), this.m20(), this.m30(),
        this.m01(), this.m11(), this.m21(), this.m31(),
        this.m02(), this.m12(), this.m22(), this.m32(),
        this.m03(), this.m13(), this.m23(), this.m33() );
    },

    negated: function() {
      return new Matrix4(
        -this.m00(), -this.m01(), -this.m02(), -this.m03(),
        -this.m10(), -this.m11(), -this.m12(), -this.m13(),
        -this.m20(), -this.m21(), -this.m22(), -this.m23(),
        -this.m30(), -this.m31(), -this.m32(), -this.m33() );
    },

    inverted: function() {
      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_3D:
          return new Matrix4(
            1, 0, 0, -this.m03(),
            0, 1, 0, -this.m13(),
            0, 0, 1, -this.m23(),
            0, 0, 0, 1, Types.TRANSLATION_3D );
        case Types.SCALING:
          return new Matrix4(
            1 / this.m00(), 0, 0, 0,
            0, 1 / this.m11(), 0, 0,
            0, 0, 1 / this.m22(), 0,
            0, 0, 0, 1 / this.m33(), Types.SCALING );
        case Types.AFFINE:
        case Types.OTHER:
          var det = this.getDeterminant();
          if ( det !== 0 ) {
            return new Matrix4(
              ( -this.m31() * this.m22() * this.m13() + this.m21() * this.m32() * this.m13() + this.m31() * this.m12() * this.m23() - this.m11() * this.m32() * this.m23() - this.m21() * this.m12() * this.m33() + this.m11() * this.m22() * this.m33() ) / det,
              ( this.m31() * this.m22() * this.m03() - this.m21() * this.m32() * this.m03() - this.m31() * this.m02() * this.m23() + this.m01() * this.m32() * this.m23() + this.m21() * this.m02() * this.m33() - this.m01() * this.m22() * this.m33() ) / det,
              ( -this.m31() * this.m12() * this.m03() + this.m11() * this.m32() * this.m03() + this.m31() * this.m02() * this.m13() - this.m01() * this.m32() * this.m13() - this.m11() * this.m02() * this.m33() + this.m01() * this.m12() * this.m33() ) / det,
              ( this.m21() * this.m12() * this.m03() - this.m11() * this.m22() * this.m03() - this.m21() * this.m02() * this.m13() + this.m01() * this.m22() * this.m13() + this.m11() * this.m02() * this.m23() - this.m01() * this.m12() * this.m23() ) / det,
              ( this.m30() * this.m22() * this.m13() - this.m20() * this.m32() * this.m13() - this.m30() * this.m12() * this.m23() + this.m10() * this.m32() * this.m23() + this.m20() * this.m12() * this.m33() - this.m10() * this.m22() * this.m33() ) / det,
              ( -this.m30() * this.m22() * this.m03() + this.m20() * this.m32() * this.m03() + this.m30() * this.m02() * this.m23() - this.m00() * this.m32() * this.m23() - this.m20() * this.m02() * this.m33() + this.m00() * this.m22() * this.m33() ) / det,
              ( this.m30() * this.m12() * this.m03() - this.m10() * this.m32() * this.m03() - this.m30() * this.m02() * this.m13() + this.m00() * this.m32() * this.m13() + this.m10() * this.m02() * this.m33() - this.m00() * this.m12() * this.m33() ) / det,
              ( -this.m20() * this.m12() * this.m03() + this.m10() * this.m22() * this.m03() + this.m20() * this.m02() * this.m13() - this.m00() * this.m22() * this.m13() - this.m10() * this.m02() * this.m23() + this.m00() * this.m12() * this.m23() ) / det,
              ( -this.m30() * this.m21() * this.m13() + this.m20() * this.m31() * this.m13() + this.m30() * this.m11() * this.m23() - this.m10() * this.m31() * this.m23() - this.m20() * this.m11() * this.m33() + this.m10() * this.m21() * this.m33() ) / det,
              ( this.m30() * this.m21() * this.m03() - this.m20() * this.m31() * this.m03() - this.m30() * this.m01() * this.m23() + this.m00() * this.m31() * this.m23() + this.m20() * this.m01() * this.m33() - this.m00() * this.m21() * this.m33() ) / det,
              ( -this.m30() * this.m11() * this.m03() + this.m10() * this.m31() * this.m03() + this.m30() * this.m01() * this.m13() - this.m00() * this.m31() * this.m13() - this.m10() * this.m01() * this.m33() + this.m00() * this.m11() * this.m33() ) / det,
              ( this.m20() * this.m11() * this.m03() - this.m10() * this.m21() * this.m03() - this.m20() * this.m01() * this.m13() + this.m00() * this.m21() * this.m13() + this.m10() * this.m01() * this.m23() - this.m00() * this.m11() * this.m23() ) / det,
              ( this.m30() * this.m21() * this.m12() - this.m20() * this.m31() * this.m12() - this.m30() * this.m11() * this.m22() + this.m10() * this.m31() * this.m22() + this.m20() * this.m11() * this.m32() - this.m10() * this.m21() * this.m32() ) / det,
              ( -this.m30() * this.m21() * this.m02() + this.m20() * this.m31() * this.m02() + this.m30() * this.m01() * this.m22() - this.m00() * this.m31() * this.m22() - this.m20() * this.m01() * this.m32() + this.m00() * this.m21() * this.m32() ) / det,
              ( this.m30() * this.m11() * this.m02() - this.m10() * this.m31() * this.m02() - this.m30() * this.m01() * this.m12() + this.m00() * this.m31() * this.m12() + this.m10() * this.m01() * this.m32() - this.m00() * this.m11() * this.m32() ) / det,
              ( -this.m20() * this.m11() * this.m02() + this.m10() * this.m21() * this.m02() + this.m20() * this.m01() * this.m12() - this.m00() * this.m21() * this.m12() - this.m10() * this.m01() * this.m22() + this.m00() * this.m11() * this.m22() ) / det
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },

    timesMatrix: function( m ) {
      // I * M === M * I === I (the identity)
      if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
        return this.type === Types.IDENTITY ? m : this;
      }

      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_3D ) {
          // faster combination of translations
          return new Matrix4(
            1, 0, 0, this.m03() + m.m02(),
            0, 1, 0, this.m13() + m.m12(),
            0, 0, 1, this.m23() + m.m23(),
            0, 0, 0, 1, Types.TRANSLATION_3D );
        }
        else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return new Matrix4(
            this.m00() * m.m00(), 0, 0, 0,
            0, this.m11() * m.m11(), 0, 0,
            0, 0, this.m22() * m.m22(), 0,
            0, 0, 0, 1, Types.SCALING );
        }
      }

      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine

        // affine case
        return new Matrix4(
          this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
          this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
          this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03(),
          this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
          this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
          this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13(),
          this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
          this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
          this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22(),
          this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23(),
          0, 0, 0, 1, Types.AFFINE );
      }

      // general case
      return new Matrix4(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20() + this.m03() * m.m30(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21() + this.m03() * m.m31(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22() + this.m03() * m.m32(),
        this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03() * m.m33(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20() + this.m13() * m.m30(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21() + this.m13() * m.m31(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22() + this.m13() * m.m32(),
        this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13() * m.m33(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20() + this.m23() * m.m30(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21() + this.m23() * m.m31(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() + this.m23() * m.m32(),
        this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23() * m.m33(),
        this.m30() * m.m00() + this.m31() * m.m10() + this.m32() * m.m20() + this.m33() * m.m30(),
        this.m30() * m.m01() + this.m31() * m.m11() + this.m32() * m.m21() + this.m33() * m.m31(),
        this.m30() * m.m02() + this.m31() * m.m12() + this.m32() * m.m22() + this.m33() * m.m32(),
        this.m30() * m.m03() + this.m31() * m.m13() + this.m32() * m.m23() + this.m33() * m.m33() );
    },

    timesVector4: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z + this.m03() * v.w;
      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z + this.m13() * v.w;
      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z + this.m23() * v.w;
      var w = this.m30() * v.x + this.m31() * v.y + this.m32() * v.z + this.m33() * v.w;
      return new dot.Vector4( x, y, z, w );
    },

    timesVector3: function( v ) {
      return this.timesVector4( v.toVector4() ).toVector3();
    },

    timesTransposeVector4: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z + this.m30() * v.w;
      var y = this.m01() * v.x + this.m11() * v.y + this.m21() * v.z + this.m31() * v.w;
      var z = this.m02() * v.x + this.m12() * v.y + this.m22() * v.z + this.m32() * v.w;
      var w = this.m03() * v.x + this.m13() * v.y + this.m23() * v.z + this.m33() * v.w;
      return new dot.Vector4( x, y, z, w );
    },

    timesTransposeVector3: function( v ) {
      return this.timesTransposeVector4( v.toVector4() ).toVector3();
    },

    timesRelativeVector3: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z;
      var y = this.m01() * v.y + this.m11() * v.y + this.m21() * v.z;
      var z = this.m02() * v.z + this.m12() * v.y + this.m22() * v.z;
      return new dot.Vector3( x, y, z );
    },

    getDeterminant: function() {
      return this.m03() * this.m12() * this.m21() * this.m30() -
             this.m02() * this.m13() * this.m21() * this.m30() -
             this.m03() * this.m11() * this.m22() * this.m30() +
             this.m01() * this.m13() * this.m22() * this.m30() +
             this.m02() * this.m11() * this.m23() * this.m30() -
             this.m01() * this.m12() * this.m23() * this.m30() -
             this.m03() * this.m12() * this.m20() * this.m31() +
             this.m02() * this.m13() * this.m20() * this.m31() +
             this.m03() * this.m10() * this.m22() * this.m31() -
             this.m00() * this.m13() * this.m22() * this.m31() -
             this.m02() * this.m10() * this.m23() * this.m31() +
             this.m00() * this.m12() * this.m23() * this.m31() +
             this.m03() * this.m11() * this.m20() * this.m32() -
             this.m01() * this.m13() * this.m20() * this.m32() -
             this.m03() * this.m10() * this.m21() * this.m32() +
             this.m00() * this.m13() * this.m21() * this.m32() +
             this.m01() * this.m10() * this.m23() * this.m32() -
             this.m00() * this.m11() * this.m23() * this.m32() -
             this.m02() * this.m11() * this.m20() * this.m33() +
             this.m01() * this.m12() * this.m20() * this.m33() +
             this.m02() * this.m10() * this.m21() * this.m33() -
             this.m00() * this.m12() * this.m21() * this.m33() -
             this.m01() * this.m10() * this.m22() * this.m33() +
             this.m00() * this.m11() * this.m22() * this.m33();
    },
    get determinant() { return this.getDeterminant(); },

    toString: function() {
      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + ' ' + this.m03() + '\n' +
             this.m10() + ' ' + this.m11() + ' ' + this.m12() + ' ' + this.m13() + '\n' +
             this.m20() + ' ' + this.m21() + ' ' + this.m22() + ' ' + this.m23() + '\n' +
             this.m30() + ' ' + this.m31() + ' ' + this.m32() + ' ' + this.m33();
    },

    makeImmutable: function() {
      this.rowMajor = function() {
        throw new Error( 'Cannot modify immutable matrix' );
      };
    }
  };

  // create an immutable
  Matrix4.IDENTITY = new Matrix4();
  Matrix4.IDENTITY.makeImmutable();

  return Matrix4;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * 3-dimensional Matrix
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Matrix3',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2','DOT/Vector3','DOT/Matrix4'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var Poolable = require( 'PHET_CORE/Poolable' );

  var FastArray = dot.FastArray;

  require( 'DOT/Vector2' );
  require( 'DOT/Vector3' );
  require( 'DOT/Matrix4' );

  var identityFastArray = new FastArray( 9 );
  identityFastArray[ 0 ] = 1;
  identityFastArray[ 4 ] = 1;
  identityFastArray[ 8 ] = 1;

  var createIdentityArray = FastArray === Array ?
                            function() {
                              return [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
                            } :
                            function() {
                              return new FastArray( identityFastArray );
                            };

  // Create an identity matrix
  function Matrix3( argumentsShouldNotExist ) {

    //Make sure no clients are expecting to create a matrix with non-identity values
    assert && assert( !argumentsShouldNotExist, 'Matrix3 constructor should not be called with any arguments.  Use Matrix3.createFromPool()/Matrix3.identity()/etc.' );

    // entries stored in column-major format
    this.entries = createIdentityArray();

    phetAllocation && phetAllocation( 'Matrix3' );
    this.type = Types.IDENTITY;
  }

  dot.register( 'Matrix3', Matrix3 );

  Matrix3.Types = {
    // NOTE: if an inverted matrix of a type is not that type, change inverted()!
    // NOTE: if two matrices with identical types are multiplied, the result should have the same type. if not, changed timesMatrix()!
    // NOTE: on adding a type, exhaustively check all type usage
    OTHER: 0, // default
    IDENTITY: 1,
    TRANSLATION_2D: 2,
    SCALING: 3,
    AFFINE: 4

    // TODO: possibly add rotations
  };

  var Types = Matrix3.Types;

  Matrix3.identity = function() { return Matrix3.dirtyFromPool().setToIdentity(); };
  Matrix3.translation = function( x, y ) { return Matrix3.dirtyFromPool().setToTranslation( x, y ); };
  Matrix3.translationFromVector = function( v ) { return Matrix3.translation( v.x, v.y ); };
  Matrix3.scaling = function( x, y ) { return Matrix3.dirtyFromPool().setToScale( x, y ); };
  Matrix3.scale = Matrix3.scaling;
  Matrix3.affine = function( m00, m10, m01, m11, m02, m12 ) { return Matrix3.dirtyFromPool().setToAffine( m00, m01, m02, m10, m11, m12 ); };
  Matrix3.rowMajor = function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) { return Matrix3.dirtyFromPool().rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ); };

  // axis is a normalized Vector3, angle in radians.
  Matrix3.rotationAxisAngle = function( axis, angle ) { return Matrix3.dirtyFromPool().setToRotationAxisAngle( axis, angle ); };

  Matrix3.rotationX = function( angle ) { return Matrix3.dirtyFromPool().setToRotationX( angle ); };
  Matrix3.rotationY = function( angle ) { return Matrix3.dirtyFromPool().setToRotationY( angle ); };
  Matrix3.rotationZ = function( angle ) { return Matrix3.dirtyFromPool().setToRotationZ( angle ); };

  // standard 2d rotation
  Matrix3.rotation2 = Matrix3.rotationZ;

  Matrix3.rotationAround = function( angle, x, y ) {
    return Matrix3.translation( x, y ).timesMatrix( Matrix3.rotation2( angle ) ).timesMatrix( Matrix3.translation( -x, -y ) );
  };

  Matrix3.rotationAroundPoint = function( angle, point ) {
    return Matrix3.rotationAround( angle, point.x, point.y );
  };

  Matrix3.fromSVGMatrix = function( svgMatrix ) { return Matrix3.dirtyFromPool().setToSVGMatrix( svgMatrix ); };

  // a rotation matrix that rotates A to B, by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors
  Matrix3.rotateAToB = function( a, b ) { return Matrix3.dirtyFromPool().setRotationAToB( a, b ); };

  Matrix3.prototype = {
    constructor: Matrix3,

    /*---------------------------------------------------------------------------*
     * "Properties"
     *----------------------------------------------------------------------------*/

    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler
    m00: function() { return this.entries[ 0 ]; },
    m01: function() { return this.entries[ 3 ]; },
    m02: function() { return this.entries[ 6 ]; },
    m10: function() { return this.entries[ 1 ]; },
    m11: function() { return this.entries[ 4 ]; },
    m12: function() { return this.entries[ 7 ]; },
    m20: function() { return this.entries[ 2 ]; },
    m21: function() { return this.entries[ 5 ]; },
    m22: function() { return this.entries[ 8 ]; },

    isIdentity: function() {
      return this.type === Types.IDENTITY || this.equals( Matrix3.IDENTITY );
    },

    // returning false means "inconclusive, may be identity or not"
    isFastIdentity: function() {
      return this.type === Types.IDENTITY;
    },

    isAffine: function() {
      return this.type === Types.AFFINE || ( this.m20() === 0 && this.m21() === 0 && this.m22() === 1 );
    },

    // if it's an affine matrix where the components of transforms are independent
    // i.e. constructed from arbitrary component scaling and translation.
    isAligned: function() {
      // non-diagonal non-translation entries should all be zero.
      return this.isAffine() && this.m01() === 0 && this.m10() === 0;
    },

    // if it's an affine matrix where the components of transforms are independent, but may be switched (unlike isAligned)
    // i.e. the 2x2 rotational sub-matrix is of one of the two forms:
    // A 0  or  0  A
    // 0 B      B  0
    // This means that moving a transformed point by (x,0) or (0,y) will result in a motion along one of the axes.
    isAxisAligned: function() {
      return this.isAffine() && ( ( this.m01() === 0 && this.m10() === 0 ) || ( this.m00() === 0 && this.m11() === 0 ) );
    },

    isFinite: function() {
      return isFinite( this.m00() ) &&
             isFinite( this.m01() ) &&
             isFinite( this.m02() ) &&
             isFinite( this.m10() ) &&
             isFinite( this.m11() ) &&
             isFinite( this.m12() ) &&
             isFinite( this.m20() ) &&
             isFinite( this.m21() ) &&
             isFinite( this.m22() );
    },

    getDeterminant: function() {
      return this.m00() * this.m11() * this.m22() + this.m01() * this.m12() * this.m20() + this.m02() * this.m10() * this.m21() - this.m02() * this.m11() * this.m20() - this.m01() * this.m10() * this.m22() - this.m00() * this.m12() * this.m21();
    },
    get determinant() { return this.getDeterminant(); },

    // the 2D translation, assuming multiplication with a homogeneous vector
    getTranslation: function() {
      return new dot.Vector2( this.m02(), this.m12() );
    },
    get translation() { return this.getTranslation(); },

    // returns a vector that is equivalent to ( T(1,0).magnitude(), T(0,1).magnitude() ) where T is a relative transform
    getScaleVector: function() {
      return new dot.Vector2(
        Math.sqrt( this.m00() * this.m00() + this.m10() * this.m10() ),
        Math.sqrt( this.m01() * this.m01() + this.m11() * this.m11() ) );
    },
    get scaleVector() { return this.getScaleVector(); },

    // angle in radians for the 2d rotation from this matrix, between pi, -pi
    getRotation: function() {
      return Math.atan2( this.m10(), this.m00() );
    },
    get rotation() { return this.getRotation(); },

    toMatrix4: function() {
      return new dot.Matrix4(
        this.m00(), this.m01(), this.m02(), 0,
        this.m10(), this.m11(), this.m12(), 0,
        this.m20(), this.m21(), this.m22(), 0,
        0, 0, 0, 1 );
    },

    toAffineMatrix4: function() {
      return new dot.Matrix4(
        this.m00(), this.m01(), 0, this.m02(),
        this.m10(), this.m11(), 0, this.m12(),
        0, 0, 1, 0,
        0, 0, 0, 1 );
    },

    toString: function() {
      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + '\n' +
             this.m10() + ' ' + this.m11() + ' ' + this.m12() + '\n' +
             this.m20() + ' ' + this.m21() + ' ' + this.m22();
    },

    toSVGMatrix: function() {
      var result = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ).createSVGMatrix();

      // top two rows
      result.a = this.m00();
      result.b = this.m10();
      result.c = this.m01();
      result.d = this.m11();
      result.e = this.m02();
      result.f = this.m12();

      return result;
    },

    getCSSTransform: function() {
      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility

      // We need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
      // See https://github.com/phetsims/dot/issues/36

      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!
      // NOTE: the toFixed calls are inlined for performance reasons
      return 'matrix(' + this.entries[ 0 ].toFixed( 20 ) + ',' + this.entries[ 1 ].toFixed( 20 ) + ',' + this.entries[ 3 ].toFixed( 20 ) + ',' + this.entries[ 4 ].toFixed( 20 ) + ',' + this.entries[ 6 ].toFixed( 20 ) + ',' + this.entries[ 7 ].toFixed( 20 ) + ')';
    },
    get cssTransform() { return this.getCSSTransform(); },

    getSVGTransform: function() {
      // SVG transform presentation attribute. See http://www.w3.org/TR/SVG/coords.html#TransformAttribute

      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that
      function svgNumber( number ) {
        // Largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed
        // See https://github.com/phetsims/dot/issues/36
        return number.toFixed( 20 );
      }

      switch( this.type ) {
        case Types.IDENTITY:
          return '';
        case Types.TRANSLATION_2D:
          return 'translate(' + svgNumber( this.entries[ 6 ] ) + ',' + svgNumber( this.entries[ 7 ] ) + ')';
        case Types.SCALING:
          return 'scale(' + svgNumber( this.entries[ 0 ] ) + ( this.entries[ 0 ] === this.entries[ 4 ] ? '' : ',' + svgNumber( this.entries[ 4 ] ) ) + ')';
        default:
          return 'matrix(' + svgNumber( this.entries[ 0 ] ) + ',' + svgNumber( this.entries[ 1 ] ) + ',' + svgNumber( this.entries[ 3 ] ) + ',' + svgNumber( this.entries[ 4 ] ) + ',' + svgNumber( this.entries[ 6 ] ) + ',' + svgNumber( this.entries[ 7 ] ) + ')';
      }
    },
    get svgTransform() { return this.getSVGTransform(); },

    // returns a parameter object suitable for use with jQuery's .css()
    getCSSTransformStyles: function() {
      var transformCSS = this.getCSSTransform();

      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/
      return {
        // force iOS hardware acceleration
        '-webkit-perspective': 1000,
        '-webkit-backface-visibility': 'hidden',

        '-webkit-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
        '-moz-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
        '-ms-transform': transformCSS,
        '-o-transform': transformCSS,
        'transform': transformCSS,
        'transform-origin': 'top left', // at the origin of the component. consider 0px 0px instead. Critical, since otherwise this defaults to 50% 50%!!! see https://developer.mozilla.org/en-US/docs/CSS/transform-origin
        '-ms-transform-origin': 'top left' // TODO: do we need other platform-specific transform-origin styles?
      };
    },
    get cssTransformStyles() { return this.getCSSTransformStyles(); },

    // exact equality
    equals: function( m ) {
      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() &&
             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() &&
             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22();
    },

    // equality within a margin of error
    equalsEpsilon: function( m, epsilon ) {
      return Math.abs( this.m00() - m.m00() ) < epsilon && Math.abs( this.m01() - m.m01() ) < epsilon && Math.abs( this.m02() - m.m02() ) < epsilon &&
             Math.abs( this.m10() - m.m10() ) < epsilon && Math.abs( this.m11() - m.m11() ) < epsilon && Math.abs( this.m12() - m.m12() ) < epsilon &&
             Math.abs( this.m20() - m.m20() ) < epsilon && Math.abs( this.m21() - m.m21() ) < epsilon && Math.abs( this.m22() - m.m22() ) < epsilon;
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations (returns a new matrix)
     *----------------------------------------------------------------------------*/

    copy: function() {
      return Matrix3.createFromPool(
        this.m00(), this.m01(), this.m02(),
        this.m10(), this.m11(), this.m12(),
        this.m20(), this.m21(), this.m22(),
        this.type
      );
    },

    plus: function( m ) {
      return Matrix3.createFromPool(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
      );
    },

    minus: function( m ) {
      return Matrix3.createFromPool(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
      );
    },

    transposed: function() {
      return Matrix3.createFromPool(
        this.m00(), this.m10(), this.m20(),
        this.m01(), this.m11(), this.m21(),
        this.m02(), this.m12(), this.m22(), ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
      );
    },

    negated: function() {
      return Matrix3.createFromPool(
        -this.m00(), -this.m01(), -this.m02(),
        -this.m10(), -this.m11(), -this.m12(),
        -this.m20(), -this.m21(), -this.m22()
      );
    },

    inverted: function() {
      var det;

      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_2D:
          return Matrix3.createFromPool(
            1, 0, -this.m02(),
            0, 1, -this.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        case Types.SCALING:
          return Matrix3.createFromPool(
            1 / this.m00(), 0, 0,
            0, 1 / this.m11(), 0,
            0, 0, 1 / this.m22(), Types.SCALING );
        case Types.AFFINE:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return Matrix3.createFromPool(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              0, 0, 1, Types.AFFINE
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        case Types.OTHER:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return Matrix3.createFromPool(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
              Types.OTHER
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },

    timesMatrix: function( m ) {
      // I * M === M * I === M (the identity)
      if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
        return this.type === Types.IDENTITY ? m : this;
      }

      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_2D ) {
          // faster combination of translations
          return Matrix3.createFromPool(
            1, 0, this.m02() + m.m02(),
            0, 1, this.m12() + m.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        }
        else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return Matrix3.createFromPool(
            this.m00() * m.m00(), 0, 0,
            0, this.m11() * m.m11(), 0,
            0, 0, 1, Types.SCALING );
        }
      }

      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine

        // affine case
        return Matrix3.createFromPool(
          this.m00() * m.m00() + this.m01() * m.m10(),
          this.m00() * m.m01() + this.m01() * m.m11(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
          this.m10() * m.m00() + this.m11() * m.m10(),
          this.m10() * m.m01() + this.m11() * m.m11(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
          0, 0, 1, Types.AFFINE );
      }

      // general case
      return Matrix3.createFromPool(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
    },

    /*---------------------------------------------------------------------------*
     * Immutable operations (returns new form of a parameter)
     *----------------------------------------------------------------------------*/

    timesVector2: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02();
      var y = this.m10() * v.x + this.m11() * v.y + this.m12();
      return new dot.Vector2( x, y );
    },

    timesVector3: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;
      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;
      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;
      return new dot.Vector3( x, y, z );
    },

    timesTransposeVector2: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y;
      var y = this.m01() * v.x + this.m11() * v.y;
      return new dot.Vector2( x, y );
    },

    // TODO: this operation seems to not work for transformDelta2, should be vetted
    timesRelativeVector2: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y;
      var y = this.m10() * v.y + this.m11() * v.y;
      return new dot.Vector2( x, y );
    },

    /*---------------------------------------------------------------------------*
     * Mutable operations (changes this matrix)
     *----------------------------------------------------------------------------*/

    // every mutable method goes through rowMajor
    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
      this.entries[ 0 ] = v00;
      this.entries[ 1 ] = v10;
      this.entries[ 2 ] = v20;
      this.entries[ 3 ] = v01;
      this.entries[ 4 ] = v11;
      this.entries[ 5 ] = v21;
      this.entries[ 6 ] = v02;
      this.entries[ 7 ] = v12;
      this.entries[ 8 ] = v22;

      // TODO: consider performance of the affine check here
      this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
      return this;
    },

    set: function( matrix ) {
      return this.rowMajor(
        matrix.m00(), matrix.m01(), matrix.m02(),
        matrix.m10(), matrix.m11(), matrix.m12(),
        matrix.m20(), matrix.m21(), matrix.m22(),
        matrix.type );
    },

    setArray: function( array ) {
      return this.rowMajor(
        array[ 0 ], array[ 3 ], array[ 6 ],
        array[ 1 ], array[ 4 ], array[ 7 ],
        array[ 2 ], array[ 5 ], array[ 8 ] );
    },

    // component setters
    set00: function( value ) {
      this.entries[ 0 ] = value;
      return this;
    },
    set01: function( value ) {
      this.entries[ 3 ] = value;
      return this;
    },
    set02: function( value ) {
      this.entries[ 6 ] = value;
      return this;
    },
    set10: function( value ) {
      this.entries[ 1 ] = value;
      return this;
    },
    set11: function( value ) {
      this.entries[ 4 ] = value;
      return this;
    },
    set12: function( value ) {
      this.entries[ 7 ] = value;
      return this;
    },
    set20: function( value ) {
      this.entries[ 2 ] = value;
      return this;
    },
    set21: function( value ) {
      this.entries[ 5 ] = value;
      return this;
    },
    set22: function( value ) {
      this.entries[ 8 ] = value;
      return this;
    },

    makeImmutable: function() {
      this.rowMajor = function() {
        throw new Error( 'Cannot modify immutable matrix' );
      };
      return this;
    },

    columnMajor: function( v00, v10, v20, v01, v11, v21, v02, v12, v22, type ) {
      return this.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
    },

    add: function( m ) {
      return this.rowMajor(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
      );
    },

    subtract: function( m ) {
      return this.rowMajor(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
      );
    },

    transpose: function() {
      return this.rowMajor(
        this.m00(), this.m10(), this.m20(),
        this.m01(), this.m11(), this.m21(),
        this.m02(), this.m12(), this.m22(),
        ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
      );
    },

    negate: function() {
      return this.rowMajor(
        -this.m00(), -this.m01(), -this.m02(),
        -this.m10(), -this.m11(), -this.m12(),
        -this.m20(), -this.m21(), -this.m22()
      );
    },

    invert: function() {
      var det;

      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_2D:
          return this.rowMajor(
            1, 0, -this.m02(),
            0, 1, -this.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        case Types.SCALING:
          return this.rowMajor(
            1 / this.m00(), 0, 0,
            0, 1 / this.m11(), 0,
            0, 0, 1 / this.m22(), Types.SCALING );
        case Types.AFFINE:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return this.rowMajor(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              0, 0, 1, Types.AFFINE
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        case Types.OTHER:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return this.rowMajor(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
              Types.OTHER
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },

    multiplyMatrix: function( m ) {
      // M * I === M (the identity)
      if ( m.type === Types.IDENTITY ) {
        // no change needed
        return this;
      }

      // I * M === M (the identity)
      if ( this.type === Types.IDENTITY ) {
        // copy the other matrix to us
        return this.set( m );
      }

      if ( this.type === m.type ) {
        // currently two matrices of the same type will result in the same result type
        if ( this.type === Types.TRANSLATION_2D ) {
          // faster combination of translations
          return this.rowMajor(
            1, 0, this.m02() + m.m02(),
            0, 1, this.m12() + m.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        }
        else if ( this.type === Types.SCALING ) {
          // faster combination of scaling
          return this.rowMajor(
            this.m00() * m.m00(), 0, 0,
            0, this.m11() * m.m11(), 0,
            0, 0, 1, Types.SCALING );
        }
      }

      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        // currently two matrices that are anything but "other" are technically affine, and the result will be affine

        // affine case
        return this.rowMajor(
          this.m00() * m.m00() + this.m01() * m.m10(),
          this.m00() * m.m01() + this.m01() * m.m11(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
          this.m10() * m.m00() + this.m11() * m.m10(),
          this.m10() * m.m01() + this.m11() * m.m11(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
          0, 0, 1, Types.AFFINE );
      }

      // general case
      return this.rowMajor(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
    },

    prependTranslation: function( x, y ) {
      this.set02( this.m02() + x );
      this.set12( this.m12() + y );

      if ( this.type === Types.IDENTITY || this.type === Types.TRANSLATION_2D ) {
        this.type = Types.TRANSLATION_2D;
      }
      else if ( this.type === Types.OTHER ) {
        this.type = Types.OTHER;
      }
      else {
        this.type = Types.AFFINE;
      }
      return this; // for chaining
    },

    setToIdentity: function() {
      return this.rowMajor(
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
        Types.IDENTITY );
    },

    setToTranslation: function( x, y ) {
      return this.rowMajor(
        1, 0, x,
        0, 1, y,
        0, 0, 1,
        Types.TRANSLATION_2D );
    },

    setToScale: function( x, y ) {
      // allow using one parameter to scale everything
      y = y === undefined ? x : y;

      return this.rowMajor(
        x, 0, 0,
        0, y, 0,
        0, 0, 1,
        Types.SCALING );
    },

    // row major
    setToAffine: function( m00, m01, m02, m10, m11, m12 ) {
      return this.rowMajor( m00, m01, m02, m10, m11, m12, 0, 0, 1, Types.AFFINE );
    },

    // axis is a normalized Vector3, angle in radians.
    setToRotationAxisAngle: function( axis, angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );
      var C = 1 - c;

      return this.rowMajor(
        axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s,
        axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s,
        axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c,
        Types.OTHER );
    },

    setToRotationX: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor(
        1, 0, 0,
        0, c, -s,
        0, s, c,
        Types.OTHER );
    },

    setToRotationY: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor(
        c, 0, s,
        0, 1, 0,
        -s, 0, c,
        Types.OTHER );
    },

    setToRotationZ: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );

      return this.rowMajor(
        c, -s, 0,
        s, c, 0,
        0, 0, 1,
        Types.AFFINE );
    },

    setToSVGMatrix: function( svgMatrix ) {
      return this.rowMajor(
        svgMatrix.a, svgMatrix.c, svgMatrix.e,
        svgMatrix.b, svgMatrix.d, svgMatrix.f,
        0, 0, 1,
        Types.AFFINE );
    },

    // a rotation matrix that rotates A to B (Vector3 instances), by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors
    setRotationAToB: function( a, b ) {
      // see http://graphics.cs.brown.edu/~jfh/papers/Moller-EBA-1999/paper.pdf for information on this implementation
      var start = a;
      var end = b;

      var epsilon = 0.0001;

      var e;
      var h;
      var f;

      var v = start.cross( end );
      e = start.dot( end );
      f = ( e < 0 ) ? -e : e;

      // if "from" and "to" vectors are nearly parallel
      if ( f > 1.0 - epsilon ) {
        var c1;
        var c2;
        var c3;

        var x = new dot.Vector3(
          ( start.x > 0.0 ) ? start.x : -start.x,
          ( start.y > 0.0 ) ? start.y : -start.y,
          ( start.z > 0.0 ) ? start.z : -start.z
        );

        if ( x.x < x.y ) {
          if ( x.x < x.z ) {
            x = dot.Vector3.X_UNIT;
          }
          else {
            x = dot.Vector3.Z_UNIT;
          }
        }
        else {
          if ( x.y < x.z ) {
            x = dot.Vector3.Y_UNIT;
          }
          else {
            x = dot.Vector3.Z_UNIT;
          }
        }

        var u = x.minus( start );
        v = x.minus( end );

        c1 = 2.0 / u.dot( u );
        c2 = 2.0 / v.dot( v );
        c3 = c1 * c2 * u.dot( v );

        return this.rowMajor(
          -c1 * u.x * u.x - c2 * v.x * v.x + c3 * v.x * u.x + 1,
          -c1 * u.x * u.y - c2 * v.x * v.y + c3 * v.x * u.y,
          -c1 * u.x * u.z - c2 * v.x * v.z + c3 * v.x * u.z,
          -c1 * u.y * u.x - c2 * v.y * v.x + c3 * v.y * u.x,
          -c1 * u.y * u.y - c2 * v.y * v.y + c3 * v.y * u.y + 1,
          -c1 * u.y * u.z - c2 * v.y * v.z + c3 * v.y * u.z,
          -c1 * u.z * u.x - c2 * v.z * v.x + c3 * v.z * u.x,
          -c1 * u.z * u.y - c2 * v.z * v.y + c3 * v.z * u.y,
          -c1 * u.z * u.z - c2 * v.z * v.z + c3 * v.z * u.z + 1
        );
      }
      else {
        // the most common case, unless "start"="end", or "start"=-"end"
        var hvx;
        var hvz;
        var hvxy;
        var hvxz;
        var hvyz;
        h = 1.0 / ( 1.0 + e );
        hvx = h * v.x;
        hvz = h * v.z;
        hvxy = hvx * v.y;
        hvxz = hvx * v.z;
        hvyz = hvz * v.y;

        return this.rowMajor(
          e + hvx * v.x, hvxy - v.z, hvxz + v.y,
          hvxy + v.z, e + h * v.y * v.y, hvyz - v.x,
          hvxz - v.y, hvyz + v.x, e + hvz * v.z
        );
      }
    },

    setTo32Bit: function() {
      if ( window.Float32Array ) {
        this.entries = new window.Float32Array( this.entries );
      }
      return this;
    },

    setTo64Bit: function() {
      if ( window.Float64Array ) {
        this.entries = new window.Float64Array( this.entries );
      }
      return this;
    },

    /*---------------------------------------------------------------------------*
     * Mutable operations (changes the parameter)
     *----------------------------------------------------------------------------*/

    multiplyVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m01() * v.y + this.m02(),
        this.m10() * v.x + this.m11() * v.y + this.m12() );
    },

    multiplyVector3: function( v ) {
      return v.setXYZ(
        this.m00() * v.x + this.m01() * v.y + this.m02() * v.z,
        this.m10() * v.x + this.m11() * v.y + this.m12() * v.z,
        this.m20() * v.x + this.m21() * v.y + this.m22() * v.z );
    },

    multiplyTransposeVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m10() * v.y,
        this.m01() * v.x + this.m11() * v.y );
    },

    multiplyRelativeVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m01() * v.y,
        this.m10() * v.y + this.m11() * v.y );
    },

    // sets the transform of a Canvas 2D rendering context to the affine part of this matrix
    canvasSetTransform: function( context ) {
      context.setTransform(
        // inlined array entries
        this.entries[ 0 ],
        this.entries[ 1 ],
        this.entries[ 3 ],
        this.entries[ 4 ],
        this.entries[ 6 ],
        this.entries[ 7 ]
      );
    },

    // appends the affine part of this matrix to the Canvas 2D rendering context
    canvasAppendTransform: function( context ) {
      if ( this.type !== Types.IDENTITY ) {
        context.transform(
          // inlined array entries
          this.entries[ 0 ],
          this.entries[ 1 ],
          this.entries[ 3 ],
          this.entries[ 4 ],
          this.entries[ 6 ],
          this.entries[ 7 ]
        );
      }
    }
  };

  Poolable.mixin( Matrix3, {

    //The default factory creates an identity matrix
    defaultFactory: function() { return new Matrix3(); },

    constructorDuplicateFactory: function( pool ) {
      return function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
        var instance = pool.length ? pool.pop() : new Matrix3();
        return instance.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
      };
    }
  } );

  // create an immutable
  Matrix3.IDENTITY = Matrix3.identity();
  Matrix3.IDENTITY.makeImmutable();

  Matrix3.X_REFLECTION = Matrix3.createFromPool(
    -1, 0, 0,
    0, 1, 0,
    0, 0, 1,
    Types.AFFINE );
  Matrix3.X_REFLECTION.makeImmutable();

  Matrix3.Y_REFLECTION = Matrix3.createFromPool(
    1, 0, 0,
    0, -1, 0,
    0, 0, 1,
    Types.AFFINE );
  Matrix3.Y_REFLECTION.makeImmutable();

  //Shortcut for translation times a matrix (without allocating a translation matrix), see scenery#119
  Matrix3.translationTimesMatrix = function( x, y, m ) {
    var type;
    if ( m.type === Types.IDENTITY || m.type === Types.TRANSLATION_2D ) {
      return Matrix3.createFromPool(
        1, 0, m.m02() + x,
        0, 1, m.m12() + y,
        0, 0, 1,
        Types.TRANSLATION_2D );
    }
    else if ( m.type === Types.OTHER ) {
      type = Types.OTHER;
    }
    else {
      type = Types.AFFINE;
    }
    return Matrix3.createFromPool(
      m.m00(), m.m01(), m.m02() + x,
      m.m10(), m.m11(), m.m12() + y,
      m.m20(), m.m21(), m.m22(),
      type );
  };

  Matrix3.printer = {
    print: function( matrix ) {
      console.log( matrix.toString() );
    }
  };

  return Matrix3;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * 2-dimensional ray consisting of an origin point and a unit direction vector.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Ray2',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  /**
   * Constructs a2D ray using the supplied origin position and unit length direction vector
   * 
   * @param {Vector2} position - the ray's point of origin
   * @param {Vector2} direction - the ray's unit direction vector
   * @constructor
   */
  function Ray2( position, direction ) {
    
    this.position = position; // @public (read-only)
    this.direction = direction; // @public (read-only)

    assert && assert( Math.abs( direction.magnitude() - 1 ) < 0.01 , 'the direction must be a unit vector');

    phetAllocation && phetAllocation( 'Ray2' );
  }

  dot.register( 'Ray2', Ray2 );

  Ray2.prototype = {
    constructor: Ray2,

    /**
     * Returns a new Ray that has it origin shifted to a position given by an amount distance*this.direction.
     * @public
     * @param {number} distance
     * @returns {Ray2}
     */
    shifted: function( distance ) {
      return new Ray2( this.pointAtDistance( distance ), this.direction );
    },
    
    /**
     * Returns a position that is a distance 'distance' along the ray.
     * @public
     * @param {number} distance
     * @returns {Vector2}
     */
    pointAtDistance: function( distance ) {
      return this.position.plus( this.direction.timesScalar( distance ) );
    },

    /**
     * Returns the attributes of this ray into a string
     * @public
     * @returns {string}
     */
    toString: function() {
      return this.position.toString() + ' => ' + this.direction.toString();
    }
  };

  return Ray2;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Forward and inverse transforms with 3x3 matrices. Methods starting with 'transform' will apply the transform from our
 * primary matrix, while methods starting with 'inverse' will apply the transform from the inverse of our matrix.
 *
 * Generally, this means transform.inverseThing( transform.transformThing( thing ) ).equals( thing ).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Transform3',['require','PHET_CORE/inherit','AXON/Events','DOT/dot','DOT/Matrix3','DOT/Vector2','DOT/Ray2'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var dot = require( 'DOT/dot' );

  require( 'DOT/Matrix3' );
  require( 'DOT/Vector2' );
  require( 'DOT/Ray2' );

  var scratchMatrix = new dot.Matrix3();

  function checkMatrix( matrix ) {
    return ( matrix instanceof dot.Matrix3 ) && matrix.isFinite();
  }

  /**
   * Creates a transform based around an initial matrix.
   * @constructor
   * @public
   *
   * @param {Matrix3} matrix
   */
  function Transform3( matrix ) {
    Events.call( this );

    // @private {Matrix3} - The primary matrix used for the transform
    this.matrix = dot.Matrix3.IDENTITY.copy();

    // @private {Matrix3} - The inverse of the primary matrix, computed lazily
    this.inverse = dot.Matrix3.IDENTITY.copy();

    // @private {Matrix3} - The transpose of the primary matrix, computed lazily
    this.matrixTransposed = dot.Matrix3.IDENTITY.copy();

    // @private {Matrix3} - The inverse of the transposed primary matrix, computed lazily
    this.inverseTransposed = dot.Matrix3.IDENTITY.copy();


    // @private {boolean} - Whether this.inverse has been computed based on the latest primary matrix
    this.inverseValid = true;

    // @private {boolean} - Whether this.matrixTransposed has been computed based on the latest primary matrix
    this.transposeValid = true;

    // @private {boolean} - Whether this.inverseTransposed has been computed based on the latest primary matrix
    this.inverseTransposeValid = true;

    if ( matrix ) {
      this.setMatrix( matrix );
    }

    phetAllocation && phetAllocation( 'Transform3' );
  }

  dot.register( 'Transform3', Transform3 );

  inherit( Events, Transform3, {
    /*---------------------------------------------------------------------------*
     * mutators
     *---------------------------------------------------------------------------*/

    /**
     * Sets the value of the primary matrix directly from a Matrix3. Does not change the Matrix3 instance of this
     * Transform3.
     * @public
     *
     * @param {Matrix3} matrix
     */
    setMatrix: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      // copy the matrix over to our matrix
      this.matrix.set( matrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * This should be called after our internal matrix is changed. It marks the other dependent matrices as invalid,
     * and sends out notifications of the change.
     * @private
     */
    invalidate: function() {
      // sanity check
      assert && assert( this.matrix.isFinite() );

      // dependent matrices now invalid
      this.inverseValid = false;
      this.transposeValid = false;
      this.inverseTransposeValid = false;

      this.trigger0( 'change' );
    },

    /**
     * Modifies the primary matrix such that: this.matrix = matrix * this.matrix.
     * @public
     *
     * @param {Matrix3} matrix
     */
    prepend: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      // In the absence of a prepend-multiply function in Matrix3, copy over to a scratch matrix instead
      // TODO: implement a prepend-multiply directly in Matrix3 for a performance increase
      scratchMatrix.set( this.matrix );
      this.matrix.set( matrix );
      this.matrix.multiplyMatrix( scratchMatrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * Optimized prepended translation such that: this.matrix = translation( x, y ) * this.matrix.
     * @public
     *
     * @param {number} x -  x-coordinate
     * @param {number} y -  y-coordinate
     */
    prependTranslation: function( x, y ) {
      // See scenery#119 for more details on the need.

      assert && assert( typeof x === 'number' && typeof y === 'number' && isFinite( x ) && isFinite( y ),
        'Attempted to prepend non-finite or non-number (x,y) to the transform' );

      this.matrix.prependTranslation( x, y );

      // set flags and notify
      this.invalidate();
    },

    /**
     * Modifies the primary matrix such that: this.matrix = this.matrix * matrix
     * @public
     *
     * @param {Matrix3} matrix
     */
    append: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );

      this.matrix.multiplyMatrix( matrix );

      // set flags and notify
      this.invalidate();
    },

    /**
     * Like prepend(), but prepends the other transform's matrix.
     * @public
     *
     * @param {Transform3} transform
     */
    prependTransform: function( transform ) {
      this.prepend( transform.matrix );
    },

    /**
     * Like append(), but appends the other transform's matrix.
     * @public
     *
     * @param {Transform3} transform
     */
    appendTransform: function( transform ) {
      this.append( transform.matrix );
    },

    /**
     * Sets the transform of a Canvas context to be equivalent to this transform.
     * @public
     *
     * @param {CanvasRenderingContext2D} context
     */
    applyToCanvasContext: function( context ) {
      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m02(), this.matrix.m12() );
    },

    /*---------------------------------------------------------------------------*
     * getters
     *---------------------------------------------------------------------------*/

    /**
     * Creates a copy of this transform.
     * @public
     *
     * @returns {Transform3}
     */
    copy: function() {
      var transform = new Transform3( this.matrix );

      transform.inverse = this.inverse;
      transform.matrixTransposed = this.matrixTransposed;
      transform.inverseTransposed = this.inverseTransposed;

      transform.inverseValid = this.inverseValid;
      transform.transposeValid = this.transposeValid;
      transform.inverseTransposeValid = this.inverseTransposeValid;
    },

    /**
     * Returns the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix3}
     */
    getMatrix: function() {
      return this.matrix;
    },

    /**
     * Returns the inverse of the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix3}
     */
    getInverse: function() {
      if ( !this.inverseValid ) {
        this.inverseValid = true;

        this.inverse.set( this.matrix );
        this.inverse.invert();
      }
      return this.inverse;
    },

    /**
     * Returns the transpose of the primary matrix of this transform.
     * @public
     *
     * @returns {Matrix3}
     */
    getMatrixTransposed: function() {
      if ( !this.transposeValid ) {
        this.transposeValid = true;

        this.matrixTransposed.set( this.matrix );
        this.matrixTransposed.transpose();
      }
      return this.matrixTransposed;
    },

    /**
     * Returns the inverse of the transpose of matrix of this transform.
     * @public
     *
     * @returns {Matrix3}
     */
    getInverseTransposed: function() {
      if ( !this.inverseTransposeValid ) {
        this.inverseTransposeValid = true;

        this.inverseTransposed.set( this.getInverse() ); // triggers inverse to be valid
        this.inverseTransposed.transpose();
      }
      return this.inverseTransposed;
    },

    /**
     * Returns whether our primary matrix is known to be an identity matrix. If false is returned, it doesn't necessarily
     * mean our matrix isn't an identity matrix, just that it is unlikely in normal usage.
     * @public
     *
     * @returns {boolean}
     */
    isIdentity: function() {
      return this.matrix.type === dot.Matrix3.Types.IDENTITY;
    },

    /**
     * Returns whether any components of our primary matrix are either infinite or NaN.
     * @public
     *
     * @returns {boolean}
     */
    isFinite: function() {
      return this.matrix.isFinite();
    },

    /*---------------------------------------------------------------------------*
     * forward transforms (for Vector2 or scalar)
     *---------------------------------------------------------------------------*/

    /**
     * Transforms a 2-dimensional vector like it is a point with a position (translation is applied).
     * @public
     *
     * For an affine matrix $M$, the result is the homogeneous multiplication $M\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    transformPosition2: function( v ) {
      return this.matrix.timesVector2( v );
    },

    /**
     * Transforms a 2-dimensional vector like position is irrelevant (translation is not applied).
     * @public
     *
     * For an affine matrix $\begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix}$,
     * the result is $\begin{bmatrix} a & b & 0 \\ d & e & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    transformDelta2: function( v ) {
      var m = this.getMatrix();
      // m . v - m . Vector2.ZERO
      return new dot.Vector2( m.m00() * v.x + m.m01() * v.y, m.m10() * v.x + m.m11() * v.y );
    },

    /**
     * Transforms a 2-dimensional vector like it is a normal to a curve (so that the curve is transformed, and the new
     * normal to the curve at the transformed point is returned).
     * @public
     *
     * For an affine matrix $\begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix}$,
     * the result is $\begin{bmatrix} a & e & 0 \\ d & b & 0 \\ 0 & 0 & 1 \end{bmatrix}^{-1} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     * This is essentially the transposed inverse with translation removed.
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    transformNormal2: function( v ) {
      return this.getInverse().timesTransposeVector2( v ).normalize();
    },

    /**
     * Returns the resulting x-coordinate of the transformation of all vectors with the initial input x-coordinate. If
     * this is not well-defined (the x value depends on y), an assertion is thrown (and y is assumed to be 0).
     * @public
     *
     * @param {number} x
     * @returns {number}
     */
    transformX: function( x ) {
      var m = this.getMatrix();
      assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );
      return m.m00() * x + m.m02();
    },

    /**
     * Returns the resulting y-coordinate of the transformation of all vectors with the initial input y-coordinate. If
     * this is not well-defined (the y value depends on x), an assertion is thrown (and x is assumed to be 0).
     * @public
     *
     * @param {number} y
     * @returns {number}
     */
    transformY: function( y ) {
      var m = this.getMatrix();
      assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y + m.m12();
    },

    /**
     * Returns the x-coordinate difference for two transformed vectors, which add the x-coordinate difference of the input
     * x (and same y values) beforehand.
     * @public
     *
     * @param {number} x
     * @returns {number}
     */
    transformDeltaX: function( x ) {
      var m = this.getMatrix();
      // same as this.transformDelta2( new dot.Vector2( x, 0 ) ).x;
      return m.m00() * x;
    },

    /**
     * Returns the y-coordinate difference for two transformed vectors, which add the y-coordinate difference of the input
     * y (and same x values) beforehand.
     * @public
     *
     * @param {number} y
     * @returns {number}
     */
    transformDeltaY: function( y ) {
      var m = this.getMatrix();
      // same as this.transformDelta2( new dot.Vector2( 0, y ) ).y;
      return m.m11() * y;
    },

    /**
     * Returns bounds (axis-aligned) that contains the transformed bounds rectangle.
     * @public
     *
     * NOTE: transform.inverseBounds2( transform.transformBounds2( bounds ) ) may be larger than the original box,
     * if it includes a rotation that isn't a multiple of $\pi/2$. This is because the returned bounds may expand in
     * area to cover ALL of the corners of the transformed bounding box.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    transformBounds2: function( bounds ) {
      return bounds.transformed( this.matrix );
    },

    /**
     * Returns a transformed kite.Shape.
     * @public
     *
     * @param {Shape} shape
     * @returns {Shape}
     */
    transformShape: function( shape ) {
      return shape.transformed( this.matrix );
    },

    /**
     * Returns a transformed ray.
     * @public
     *
     * @param {Ray2} ray
     * @returns {Ray2}
     */
    transformRay2: function( ray ) {
      return new dot.Ray2( this.transformPosition2( ray.position ), this.transformDelta2( ray.direction ).normalized() );
    },

    /*---------------------------------------------------------------------------*
     * inverse transforms (for Vector2 or scalar)
     *---------------------------------------------------------------------------*/

    /**
     * Transforms a 2-dimensional vector by the inverse of our transform like it is a point with a position (translation is applied).
     * @public
     *
     * For an affine matrix $M$, the result is the homogeneous multiplication $M^{-1}\begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     *
     * This is the inverse of transformPosition2().
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    inversePosition2: function( v ) {
      return this.getInverse().timesVector2( v );
    },

    /**
     * Transforms a 2-dimensional vector by the inverse of our transform like position is irrelevant (translation is not applied).
     * @public
     *
     * For an affine matrix $\begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix}$,
     * the result is $\begin{bmatrix} a & b & 0 \\ d & e & 0 \\ 0 & 0 & 1 \end{bmatrix}^{-1} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     *
     * This is the inverse of transformDelta2().
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    inverseDelta2: function( v ) {
      var m = this.getInverse();
      // m . v - m . Vector2.ZERO
      return new dot.Vector2( m.m00() * v.x + m.m01() * v.y, m.m10() * v.x + m.m11() * v.y );
    },

    /**
     * Transforms a 2-dimensional vector by the inverse of our transform like it is a normal to a curve (so that the
     * curve is transformed, and the new normal to the curve at the transformed point is returned).
     * @public
     *
     * For an affine matrix $\begin{bmatrix} a & b & c \\ d & e & f \\ 0 & 0 & 1 \end{bmatrix}$,
     * the result is $\begin{bmatrix} a & e & 0 \\ d & b & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$.
     * This is essentially the transposed transform with translation removed.
     *
     * This is the inverse of transformNormal2().
     *
     * @param {Vector2} v
     * @returns {Vector2}
     */
    inverseNormal2: function( v ) {
      return this.matrix.timesTransposeVector2( v ).normalize();
    },

    /**
     * Returns the resulting x-coordinate of the inverse transformation of all vectors with the initial input x-coordinate. If
     * this is not well-defined (the x value depends on y), an assertion is thrown (and y is assumed to be 0).
     * @public
     *
     * This is the inverse of transformX().
     *
     * @param {number} x
     * @returns {number}
     */
    inverseX: function( x ) {
      var m = this.getInverse();
      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
      return m.m00() * x + m.m02();
    },

    /**
     * Returns the resulting y-coordinate of the inverse transformation of all vectors with the initial input y-coordinate. If
     * this is not well-defined (the y value depends on x), an assertion is thrown (and x is assumed to be 0).
     * @public
     *
     * This is the inverse of transformY().
     *
     * @param {number} y
     * @returns {number}
     */
    inverseY: function( y ) {
      var m = this.getInverse();
      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y + m.m12();
    },

    /**
     * Returns the x-coordinate difference for two inverse-transformed vectors, which add the x-coordinate difference of the input
     * x (and same y values) beforehand.
     * @public
     *
     * This is the inverse of transformDeltaX().
     *
     * @param {number} x
     * @returns {number}
     */
    inverseDeltaX: function( x ) {
      var m = this.getInverse();
      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
      // same as this.inverseDelta2( new dot.Vector2( x, 0 ) ).x;
      return m.m00() * x;
    },

    /**
     * Returns the y-coordinate difference for two inverse-transformed vectors, which add the y-coordinate difference of the input
     * y (and same x values) beforehand.
     * @public
     *
     * This is the inverse of transformDeltaY().
     *
     * @param {number} y
     * @returns {number}
     */
    inverseDeltaY: function( y ) {
      var m = this.getInverse();
      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
      // same as this.inverseDelta2( new dot.Vector2( 0, y ) ).y;
      return m.m11() * y;
    },

    /**
     * Returns bounds (axis-aligned) that contains the inverse-transformed bounds rectangle.
     * @public
     *
     * NOTE: transform.inverseBounds2( transform.transformBounds2( bounds ) ) may be larger than the original box,
     * if it includes a rotation that isn't a multiple of $\pi/2$. This is because the returned bounds may expand in
     * area to cover ALL of the corners of the transformed bounding box.
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    inverseBounds2: function( bounds ) {
      return bounds.transformed( this.getInverse() );
    },

    /**
     * Returns an inverse-transformed kite.Shape.
     * @public
     *
     * This is the inverse of transformShape()
     *
     * @param {Shape} shape
     * @returns {Shape}
     */
    inverseShape: function( shape ) {
      return shape.transformed( this.getInverse() );
    },

    /**
     * Returns an inverse-transformed ray.
     * @public
     *
     * This is the inverse of transformRay2()
     *
     * @param {Ray2} ray
     * @returns {Ray2}
     */
    inverseRay2: function( ray ) {
      return new dot.Ray2( this.inversePosition2( ray.position ), this.inverseDelta2( ray.direction ).normalized() );
    }
  } );

  return Transform3;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * A segment represents a specific curve with a start and end.
 *
 * Each segment is treated parametrically, where t=0 is the start of the segment, and t=1 is the end. Values of t
 * between those represent points along the segment.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Segment',['require','KITE/kite','PHET_CORE/inherit','AXON/Events','DOT/Util','DOT/Bounds2'],function( require ) {
  'use strict';

  var kite = require( 'KITE/kite' );

  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var DotUtil = require( 'DOT/Util' ); // eslint-disable-line require-statement-match
  var Bounds2 = require( 'DOT/Bounds2' );

  /**
   * @constructor
   *
   * Each segment should implement the following API.
   *
   * properties (backed by ES5 getters, created usually lazily):
   *
   *   start {Vector2}
   *     The start point of the segment, parametrically at t=0.
   *
   *   end {Vector2}
   *     The end point of the segment, parametrically at t=1.
   *
   *   startTangent {Vector2}
   *     The normalized tangent vector to the segment at its start point, pointing in the direction of motion
   *     (form start to end).
   *
   *   endTangent {Vector2}
   *     The normalized tangent vector to the segment at its end point, pointing in the direction of motion
   *     (form start to end).
   *
   *   bounds {Bounds2}
   *     The bounding box for the segment.
   *
   * methods:
   *
   *   positionAt( t: {number} ) : {Vector2}
   *     Returns the position parametrically, with 0 <= t <= 1. NOTE that this function doesn't keep a constant
   *     magnitude tangent.
   *
   *   tangentAt( t: {number} ) : {Vector2}
   *     Returns the non-normalized tangent (dx/dt, dy/dt) of this segment at the parametric value of t, with
   *     0 <= t <= 1.
   *
   *   curvatureAt( t: {number} ) : {number}
   *     Returns the signed curvature (positive for visual clockwise - mathematical counterclockwise)
   *
   *   subdivided( t: {number} ) : {Array.<Segment>}
   *     Returns an array with up to 2 sub-segments, split at the parametric t value. The segments together should make
   *     the same shape as the original segment.
   *
   *   getSVGPathFragment()     - returns a string containing the SVG path. assumes that the start point is already
   *                              provided, so anything that calls this needs to put the M calls first
   *   strokeLeft( lineWidth )  - returns an array of segments that will draw an offset curve on the logical left side
   *   strokeRight( lineWidth ) - returns an array of segments that will draw an offset curve on the logical right side
   *   windingIntersection      - returns the winding number for intersection with a ray
   *   getInteriorExtremaTs     - returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on
   *                              these will result in monotonic segments
   *   intersection( ray )      - returns a list of intersections between the segment and the ray. Intersections will be
   *                              of the given format:
   *                              {
   *                                distance: {number} - Distance from the ray's origin to the intersection
   *                                point: {Vector2} - The location of the intersection
   *                                normal: {Vector2} - The normal (unit vector perpendicular to the segment at the
   *                                                    location) at the intersection, such that the dot product between
   *                                                    the normal and ray direction is <= 0
   *                                wind: {number} - The winding number for the intersection. Either 1 or -1, depending
   *                                                 on the direction the segment goes relative to the ray (to the left
   *                                                 or right). Used for computing Shape intersection via the non-zero
   *                                                 fill rule.
   *                              }
   *   getBounds() : {Bounds2} - Returns a {Bounds2} representing the bounding box for the segment.
   *   getNondegenerateSegments() : {Array.<Segment>} - Returns a list of non-degenerate segments that are equivalent to
   *                                                    this segment. Generally gets rid (or simplifies) invalid or
   *                                                    repeated segments.
   *   writeToContext( context ) - draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point
   *   transformed( matrix )     - returns a new segment that represents this segment after transformation by the matrix
   */
  function Segment() {
    Events.call( this );
  }

  kite.register( 'Segment', Segment );

  /**
   * Returns itself
   * @param {Vector2} x
   * @returns {Vector2}
   */
  var identityFunction = function identityFunction( x ) { return x; };

  inherit( Events, Segment, {
    /**
     * Will return true if the start/end tangents are purely vertical or horizontal. If all of the segments of a shape
     * have this property, then the only line joins will be a multiple of pi/2 (90 degrees), and so all of the types of
     * line joins will have the same bounds. This means that the stroked bounds will just be a pure dilation of the
     * regular bounds, by lineWidth / 2.
     * @public
     *
     * @returns {boolean}
     */
    areStrokedBoundsDilated: function() {
      var epsilon = 0.0000001;

      // If the derivative at the start/end are pointing in a cardinal direction (north/south/east/west), then the
      // endpoints won't trigger non-dilated bounds, and the interior of the curve will not contribute.
      return Math.abs( this.startTangent.x * this.startTangent.y ) < epsilon && Math.abs( this.endTangent.x * this.endTangent.y ) < epsilon;
    },

    /**
     *  // TODO: override everywhere so this isn't necessary (it's not particularly efficient!)
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    getBoundsWithTransform: function( matrix ) {
      var transformedSegment = this.transformed( matrix );
      return transformedSegment.getBounds();
    },

    /**
     *
     * @param {Array.<number>} tList - list of sorted t values from 0 <= t <= 1
     * @returns {Array}
     */
    subdivisions: function( tList ) {
      // this could be solved by recursion, but we don't plan on the JS engine doing tail-call optimization
      var right = this; // eslint-disable-line consistent-this
      var result = [];
      for ( var i = 0; i < tList.length; i++ ) {
        // assume binary subdivision
        var t = tList[ i ];
        var arr = right.subdivided( t );
        assert && assert( arr.length === 2 );
        result.push( arr[ 0 ] );
        right = arr[ 1 ];

        // scale up the remaining t values
        for ( var j = i + 1; j < tList.length; j++ ) {
          tList[ j ] = DotUtil.linear( t, 1, 0, 1, tList[ j ] );
        }
      }
      result.push( right );
      return result;
    },

    // return an array of segments from breaking this segment into monotone pieces
    subdividedIntoMonotone: function() {
      return this.subdivisions( this.getInteriorExtremaTs() );
    },

    /**
     *
     * @param {Object} [options] -           with the following options provided:
     *  - minLevels:                       how many levels to force subdivisions
     *  - maxLevels:                       prevent subdivision past this level
     *  - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve
     *  - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments
     *  - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
     *  - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
     *                                     instead of using our brute-force logic
     * @param {number} [minLevels] -   how many levels to force subdivisions
     * @param {number} [maxLevels] -   prevent subdivision past this level
     * @param {Array.<Segment>} [segments]
     * @param {Vector2} [start]
     * @param {Vector2} [end]
     * @returns {Array.<Line>}
     */
    toPiecewiseLinearSegments: function( options, minLevels, maxLevels, segments, start, end ) {
      // for the first call, initialize min/max levels from our options
      minLevels = minLevels === undefined ? options.minLevels : minLevels;
      maxLevels = maxLevels === undefined ? options.maxLevels : maxLevels;
      segments = segments || [];
      var pointMap = options.pointMap || identityFunction;

      // points mapped by the (possibly-nonlinear) pointMap.
      start = start || pointMap( this.start );
      end = end || pointMap( this.end );
      var middle = pointMap( this.positionAt( 0.5 ) );

      assert && assert( minLevels <= maxLevels );
      assert && assert( options.distanceEpsilon === null || typeof options.distanceEpsilon === 'number' );
      assert && assert( options.curveEpsilon === null || typeof options.curveEpsilon === 'number' );
      assert && assert( !pointMap || typeof pointMap === 'function' );

      // i.e. we will have finished = maxLevels === 0 || ( minLevels <= 0 && epsilonConstraints ), just didn't want to one-line it
      var finished = maxLevels === 0; // bail out once we reach our maximum number of subdivision levels
      if ( !finished && minLevels <= 0 ) { // force subdivision if minLevels hasn't been reached
        // flatness criterion: A=start, B=end, C=midpoint, d0=distance from AB, d1=||B-A||, subdivide if d0/d1 > sqrt(epsilon)
        finished = ( options.curveEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) / start.distanceSquared( end ) < options.curveEpsilon ) ) &&
                   // deviation criterion
                   ( options.distanceEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) < options.distanceEpsilon ) );
      }

      if ( finished ) {
        segments.push( new kite.Line( start, end ) );
      }
      else {
        var subdividedSegments = this.subdivided( 0.5 );
        subdividedSegments[ 0 ].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, start, middle );
        subdividedSegments[ 1 ].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, middle, end );
      }
      return segments;
    }
  } );

  /**
   * Adds getter/setter function pairs and ES5 pairs, e.g. addInvalidatingGetterSetter( Arc, 'radius' ) would add:
   * - segment.getRadius()
   * - segment.setRadius( value )
   * - segment.radius // getter and setter
   *
   * It assumes the following is the internal name: '_' + name
   *
   * @param {Function} type - Should be the constructor of the type. We will modify its prototype
   * @param {string} name - Name of the attribute
   */
  Segment.addInvalidatingGetterSetter = function( type, name ) {
    var internalName = '_' + name;
    var capitalizedName = name.charAt( 0 ).toUpperCase() + name.slice( 1 );
    var getterName = 'get' + capitalizedName;
    var setterName = 'set' + capitalizedName;

    // e.g. getRadius()
    type.prototype[ getterName ] = function() {
      return this[ internalName ];
    };

    // e.g. setRadius( value )
    type.prototype[ setterName ] = function( value ) {
      if ( this[ internalName ] !== value ) {
        this[ internalName ] = value;
        this.invalidate();
      }
      return this; // allow chaining
    };

    Object.defineProperty( type.prototype, name, {
      set: type.prototype[ setterName ],
      get: type.prototype[ getterName ]
    } );
  };

  /**
   * list of { segment: ..., t: ..., closestPoint: ..., distanceSquared: ... } (since there can be duplicates), threshold is used for subdivision,
   * where it will exit if all of the segments are shorter than the threshold
   *  TODO: solve segments to determine this analytically!
   * @param {Array.<Segment>} segments
   * @param {Vector2} point
   * @param {number} threshold
   * @returns {Array.<Object>}
   */
  Segment.closestToPoint = function( segments, point, threshold ) {
    var thresholdSquared = threshold * threshold;
    var items = [];
    var bestList = [];
    var bestDistanceSquared = Number.POSITIVE_INFINITY;
    var thresholdOk = false;

    _.each( segments, function( segment ) {
      // if we have an explicit computation for this segment, use it
      if ( segment.explicitClosestToPoint ) {
        var infos = segment.explicitClosestToPoint( point );
        _.each( infos, function( info ) {
          if ( info.distanceSquared < bestDistanceSquared ) {
            bestList = [ info ];
            bestDistanceSquared = info.distanceSquared;
          }
          else if ( info.distanceSquared === bestDistanceSquared ) {
            bestList.push( info );
          }
        } );
      }
      else {
        // otherwise, we will split based on monotonicity, so we can subdivide
        // separate, so we can map the subdivided segments
        var ts = [ 0 ].concat( segment.getInteriorExtremaTs() ).concat( [ 1 ] );
        for ( var i = 0; i < ts.length - 1; i++ ) {
          var ta = ts[ i ];
          var tb = ts[ i + 1 ];
          var pa = segment.positionAt( ta );
          var pb = segment.positionAt( tb );
          var bounds = Bounds2.point( pa ).addPoint( pb );
          var minDistanceSquared = bounds.minimumDistanceToPointSquared( point );
          if ( minDistanceSquared <= bestDistanceSquared ) {
            var maxDistanceSquared = bounds.maximumDistanceToPointSquared( point );
            if ( maxDistanceSquared < bestDistanceSquared ) {
              bestDistanceSquared = maxDistanceSquared;
              bestList = []; // clear it
            }
            items.push( {
              ta: ta,
              tb: tb,
              pa: pa,
              pb: pb,
              segment: segment,
              bounds: bounds,
              min: minDistanceSquared,
              max: maxDistanceSquared
            } );
          }
        }
      }
    } );

    while ( items.length && !thresholdOk ) {
      var curItems = items;
      items = [];

      // whether all of the segments processed are shorter than the threshold
      thresholdOk = true;

      _.each( curItems, function( item ) {
        if ( item.minDistanceSquared > bestDistanceSquared ) {
          return; // drop this item
        }
        if ( thresholdOk && item.pa.distanceSquared( item.pb ) > thresholdSquared ) {
          thresholdOk = false;
        }
        var tmid = ( item.ta + item.tb ) / 2;
        var pmid = item.segment.positionAt( tmid );
        var boundsA = Bounds2.point( item.pa ).addPoint( pmid );
        var boundsB = Bounds2.point( item.pb ).addPoint( pmid );
        var minA = boundsA.minimumDistanceToPointSquared( point );
        var minB = boundsB.minimumDistanceToPointSquared( point );
        if ( minA <= bestDistanceSquared ) {
          var maxA = boundsA.maximumDistanceToPointSquared( point );
          if ( maxA < bestDistanceSquared ) {
            bestDistanceSquared = maxA;
            bestList = []; // clear it
          }
          items.push( {
            ta: item.ta,
            tb: tmid,
            pa: item.pa,
            pb: pmid,
            segment: item.segment,
            bounds: boundsA,
            min: minA,
            max: maxA
          } );
        }
        if ( minB <= bestDistanceSquared ) {
          var maxB = boundsB.maximumDistanceToPointSquared( point );
          if ( maxB < bestDistanceSquared ) {
            bestDistanceSquared = maxB;
            bestList = []; // clear it
          }
          items.push( {
            ta: tmid,
            tb: item.tb,
            pa: pmid,
            pb: item.pb,
            segment: item.segment,
            bounds: boundsB,
            min: minB,
            max: maxB
          } );
        }
      } );
    }

    // if there are any closest regions, they are within the threshold, so we will add them all
    _.each( items, function( item ) {
      var t = ( item.ta + item.tb ) / 2;
      var closestPoint = item.segment.positionAt( t );
      bestList.push( {
        segment: item.segment,
        t: t,
        closestPoint: closestPoint,
        distanceSquared: point.distanceSquared( closestPoint )
      } );
    } );

    return bestList;
  };

  /**
   * Given the cubic-premultiplied values for two cubic bezier curves, determines (if available) a specified (a,b) pair
   * such that p( t ) === q( a * t + b ).
   * @public
   *
   * Given a 1-dimensional cubic bezier determined by the control points p0, p1, p2 and p3, compute:
   *
   * [ p0s ]    [  1   0   0   0 ]   [ p0 ]
   * [ p1s ] == [ -3   3   0   0 ] * [ p1 ]
   * [ p2s ] == [  3  -6   3   0 ] * [ p2 ]
   * [ p3s ]    [ -1   3  -3   1 ]   [ p3 ]
   *
   * see Cubic.getOverlaps for more information.
   *
   * @param {number} p0s
   * @param {number} p1s
   * @param {number} p2s
   * @param {number} p3s
   * @param {number} q0s
   * @param {number} q1s
   * @param {number} q2s
   * @param {number} q3s
   * @returns {null|true|{a:number,b:number}} - null if no solution, true if every a,b pair is a solution, otherwise
   *                                            the single solution
   */
  Segment.polynomialGetOverlapCubic = function( p0s, p1s, p2s, p3s, q0s, q1s, q2s, q3s ) {
    if ( q3s === 0 ) {
      return Segment.polynomialGetOverlapQuadratic( p0s, p1s, p2s, q0s, q1s, q2s );
    }

    var a = Math.pow( p3s / q3s, 1 / 3 );
    if ( a === 0 ) {
      return null; // If there would be solutions, then q3s would have been non-zero
    }
    var b = ( p2s - a * a * q2s ) / ( 3 * a * a * q3s );
    return {
      a: a,
      b: b
    };
  };

  /**
   * Given the quadratic-premultiplied values for two quadratic bezier curves, determines (if available) a specified (a,b) pair
   * such that p( t ) === q( a * t + b ).
   * @public
   *
   * Given a 1-dimensional quadratic bezier determined by the control points p0, p1, p2, compute:
   *
   * [ p0s ]    [  1   0   0 ]   [ p0 ]
   * [ p1s ] == [ -2   2   0 ] * [ p1 ]
   * [ p2s ]    [  2  -2   3 ] * [ p2 ]
   *
   * see Quadratic.getOverlaps for more information.
   *
   * @param {number} p0s
   * @param {number} p1s
   * @param {number} p2s
   * @param {number} q0s
   * @param {number} q1s
   * @param {number} q2s
   * @returns {null|true|{a:number,b:number}} - null if no solution, true if every a,b pair is a solution, otherwise
   *                                            the single solution
   */
  Segment.polynomialGetOverlapQuadratic = function( p0s, p1s, p2s, q0s, q1s, q2s ) {
    if ( q2s === 0 ) {
      return Segment.polynomialGetOverlapLinear( p0s, p1s, q0s, q1s );
    }

    var discr = p2s / q2s;
    if ( discr < 0 ) {
      return null; // not possible to have a solution with an imaginary a
    }

    var a = Math.sqrt( p2s / q2s );
    if ( a === 0 ) {
      return null; // If there would be solutions, then q2s would have been non-zero
    }

    var b = ( p1s - a * q1s ) / ( 2 * a * q2s );
    return {
      a: a,
      b: b
    };
  };

  /**
   * Given the linear-premultiplied values for two lines, determines (if available) a specified (a,b) pair
   * such that p( t ) === q( a * t + b ).
   * @public
   *
   * Given a line determined by the control points p0, p1, compute:
   *
   * [ p0s ] == [  1   0 ] * [ p0 ]
   * [ p1s ] == [ -1   1 ] * [ p1 ]
   *
   * see Quadratic/Cubic.getOverlaps for more information.
   *
   * @param {number} p0s
   * @param {number} p1s
   * @param {number} q0s
   * @param {number} q1s
   * @returns {null|true|{a:number,b:number}} - null if no solution, true if every a,b pair is a solution, otherwise
   *                                            the single solution
   */
  Segment.polynomialGetOverlapLinear = function( p0s, p1s, q0s, q1s ) {
    if ( q1s === 0 ) {
      if ( p0s === q0s ) {
        return true;
      }
      else {
        return null;
      }
    }

    var a = p1s / q1s;
    if ( a === 0 ) {
      return null;
    }

    var b = ( p0s - q0s ) / q1s;
    return {
      a: a,
      b: b
    };
  };

  Segment.clipOverlap = function( overlap ) {

  };

  return Segment;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Arc segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Arc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var DotUtil = require( 'DOT/Util' ); // eslint-disable-line require-statement-match

  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );

  /**
   * Creates a circular arc (or circle if the startAngle/endAngle difference is ~2pi).
   * @constructor
   *
   * See http://www.w3.org/TR/2dcontext/#dom-context-2d-arc for detailed information on the parameters.
   *
   * @param {Vector2} center - Center of the arc (every point on the arc is equally far from the center)
   * @param {number} radius - How far from the center the arc will be
   * @param {number} startAngle - Angle (radians) of the start of the arc
   * @param {number} endAngle - Angle (radians) of the end of the arc
   * @param {boolean} anticlockwise - Decides which direction the arc takes around the center
   */
  function Arc( center, radius, startAngle, endAngle, anticlockwise ) {
    Segment.call( this );

    this._center = center; // @private {Vector2}
    this._radius = radius; // @private {number}
    this._startAngle = startAngle; // @private {number}
    this._endAngle = endAngle; // @private {number}
    this._anticlockwise = anticlockwise; // @private {boolean}

    this.invalidate();
  }

  kite.register( 'Arc', Arc );

  inherit( Segment, Arc, {

    /**
     * Returns the position parametrically, with 0 <= t <= 1.
     * @public
     *
     * NOTE: positionAt( 0 ) will return the start of the segment, and positionAt( 1 ) will return the end of the
     * segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );

      return this.positionAtAngle( this.angleAt( t ) );
    },

    /**
     * Returns the non-normalized tangent (dx/dt, dy/dt) of this segment at the parametric value of t, with 0 <= t <= 1.
     * @public
     *
     * NOTE: tangentAt( 0 ) will return the tangent at the start of the segment, and tangentAt( 1 ) will return the
     * tangent at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );

      return this.tangentAtAngle( this.angleAt( t ) );
    },

    /**
     * Returns the signed curvature of the segment at the parametric value t, where 0 <= t <= 1.
     * @public
     *
     * The curvature will be positive for visual clockwise / mathematical counterclockwise curves, negative for opposite
     * curvature, and 0 for no curvature.
     *
     * NOTE: curvatureAt( 0 ) will return the curvature at the start of the segment, and curvatureAt( 1 ) will return
     * the curvature at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {number}
     */
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );

      // Since it is an arc of as circle, the curvature is independent of t
      return ( this._anticlockwise ? -1 : 1 ) / this._radius;
    },

    /**
     * Returns an array with up to 2 sub-segments, split at the parametric t value. Together (in order) they should make
     * up the same shape as the current segment.
     * @public
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Array.<Segment>}
     */
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );

      // If t is 0 or 1, we only need to return 1 segment
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }

      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles
      var angle0 = this.angleAt( 0 );
      var angleT = this.angleAt( t );
      var angle1 = this.angleAt( 1 );
      return [
        new kite.Arc( this._center, this._radius, angle0, angleT, this._anticlockwise ),
        new kite.Arc( this._center, this._radius, angleT, angle1, this._anticlockwise )
      ];
    },

    /**
     * Clears cached information, should be called when any of the 'constructor arguments' are mutated.
     * @public
     */
    invalidate: function() {
      // Lazily-computed derived information
      this._start = null; // {Vector2|null}
      this._end = null; // {Vector2|null}
      this._startTangent = null; // {Vector2|null}
      this._endTangent = null; // {Vector2|null}
      this._actualEndAngle = null; // {number|null} - End angle in relation to our start angle (can get remapped)
      this._isFullPerimeter = null; // {boolean|null} - Whether it's a full circle (and not just an arc)
      this._angleDifference = null; // {number|null}
      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}

      // Remap negative radius to a positive radius
      if ( this._radius < 0 ) {
        // support this case since we might actually need to handle it inside of strokes?
        this._radius = -this._radius;
        this._startAngle += Math.PI;
        this._endAngle += Math.PI;
      }

      // Constraints that should always be satisfied
      assert && assert( !( ( !this.anticlockwise && this._endAngle - this._startAngle <= -Math.PI * 2 ) ||
                           ( this.anticlockwise && this._startAngle - this._endAngle <= -Math.PI * 2 ) ),
        'Not handling arcs with start/end angles that show differences in-between browser handling' );
      assert && assert( !( ( !this.anticlockwise && this._endAngle - this._startAngle > Math.PI * 2 ) ||
                           ( this.anticlockwise && this._startAngle - this._endAngle > Math.PI * 2 ) ),
        'Not handling arcs with start/end angles that show differences in-between browser handling' );

      this.trigger0( 'invalidated' );
    },

    /**
     * Gets the start position of this arc.
     * @public
     *
     * @returns {Vector2}
     */
    getStart: function() {
      if ( this._start === null ) {
        this._start = this.positionAtAngle( this._startAngle );
      }
      return this._start;
    },
    get start() { return this.getStart(); },

    /**
     * Gets the end position of this arc.
     * @public
     *
     * @returns {Vector2}
     */
    getEnd: function() {
      if ( this._end === null ) {
        this._end = this.positionAtAngle( this._endAngle );
      }
      return this._end;
    },
    get end() { return this.getEnd(); },

    /**
     * Gets the unit vector tangent to this arc at the start point.
     * @public
     *
     * @returns {Vector2}
     */
    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAtAngle( this._startAngle );
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },

    /**
     * Gets the unit vector tangent to the arc at the end point.
     * @public
     *
     * @returns {Vector2}
     */
    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAtAngle( this._endAngle );
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },

    /**
     * Gets the end angle in radians.
     *
     * @public
     * @returns {number}
     */
    getActualEndAngle: function() {
      if ( this._actualEndAngle === null ) {
        // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle
        if ( this._anticlockwise ) {
          // angle is 'decreasing'
          // -2pi <= end - start < 2pi
          if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle - 2 * Math.PI;
          }
          else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
        else {
          // angle is 'increasing'
          // -2pi < end - start <= 2pi
          if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle + Math.PI * 2;
          }
          else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
      }
      return this._actualEndAngle;
    },
    get actualEndAngle() { return this.getActualEndAngle(); },

    /**
     * Returns a boolean value that indicates if the arc wraps up by more than two Pi.
     * @public
     *
     * @returns {boolean}
     */
    getIsFullPerimeter: function() {
      if ( this._isFullPerimeter === null ) {
        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
      }
      return this._isFullPerimeter;
    },
    get isFullPerimeter() { return this.getIsFullPerimeter(); },

    /**
     * Returns an angle difference that represents how "much" of the circle our arc covers.
     * The answer is always greater or equal to zero
     * The answer can exceed two Pi
     * @public
     *
     * @returns {number}
     */
    getAngleDifference: function() {
      if ( this._angleDifference === null ) {
        // compute an angle difference that represents how "much" of the circle our arc covers
        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
        if ( this._angleDifference < 0 ) {
          this._angleDifference += Math.PI * 2;
        }
        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
      }
      return this._angleDifference;
    },
    get angleDifference() { return this.getAngleDifference(); },

    /**
     * Returns the bounds of this segment.
     * @public
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      if ( this._bounds === null ) {
        // acceleration for intersection
        this._bounds = Bounds2.NOTHING.copy().withPoint( this.getStart() )
          .withPoint( this.getEnd() );

        // if the angles are different, check extrema points
        if ( this._startAngle !== this._endAngle ) {
          // check all of the extrema points
          this.includeBoundsAtAngle( 0 );
          this.includeBoundsAtAngle( Math.PI / 2 );
          this.includeBoundsAtAngle( Math.PI );
          this.includeBoundsAtAngle( 3 * Math.PI / 2 );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    /**
     * Returns a list of non-degenerate segments that are equivalent to this segment. Generally gets rid (or simplifies)
     * invalid or repeated segments.
     * @public
     *
     * @returns {Array.<Segment>}
     */
    getNondegenerateSegments: function() {
      if ( this._radius <= 0 || this._startAngle === this._endAngle ) {
        return [];
      }
      else {
        return [ this ]; // basically, Arcs aren't really degenerate that easily
      }
    },

    /**
     * Attempts to expand the private _bounds bounding box to include a point at a specific angle, making sure that
     * angle is actually included in the arc. This will presumably be called at angles that are at critical points,
     * where the arc should have maximum/minimum x/y values.
     * @private
     *
     * @param {number} angle
     */
    includeBoundsAtAngle: function( angle ) {
      if ( this.containsAngle( angle ) ) {
        // the boundary point is in the arc
        this._bounds = this._bounds.withPoint( this._center.plus( Vector2.createPolar( this._radius, angle ) ) );
      }
    },

    /**
     * Maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.
     * @public
     *
     * @param {number} angle
     * @returns {number}
     */
    mapAngle: function( angle ) {
      // consider an assert that we contain that angle?
      return ( this._startAngle > this.getActualEndAngle() ) ?
             DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
             DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
    },

    /**
     * Returns the parametrized value t for a given angle. The value t should range from 0 to 1 (inclusive).
     * @public
     *
     * @param {number} angle
     * @returns {number}
     */
    tAtAngle: function( angle ) {
      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
    },

    /**
     * Returns the angle for the parametrized t value. The t value should range from 0 to 1 (inclusive).
     * @public
     * @param {number} t
     * @returns {number}
     */
    angleAt: function( t ) {
      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
    },

    /**
     * Returns the position of this arc at angle.
     * @public
     *
     * @param {number} angle
     * @returns {Vector2}
     */
    positionAtAngle: function( angle ) {
      return this._center.plus( Vector2.createPolar( this._radius, angle ) );
    },

    /**
     * Returns the normalized tangent of this arc.
     * The tangent points outward (inward) of this arc for clockwise (anticlockwise) direction.
     * @public
     *
     * @param {number} angle
     * @returns {Vector2}
     */
    tangentAtAngle: function( angle ) {
      var normal = Vector2.createPolar( 1, angle );

      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
    },

    /**
     * Returns whether the given angle is contained by the arc (whether a ray from the arc's origin going in that angle
     * will intersect the arc).
     * @public
     *
     * @param {number} angle
     * @returns {boolean}
     */
    containsAngle: function( angle ) {
      // transform the angle into the appropriate coordinate form
      // TODO: check anticlockwise version!
      var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;

      // get the angle between 0 and 2pi
      var positiveMinAngle = DotUtil.moduloBetweenDown( normalizedAngle, 0, Math.PI * 2 );

      return positiveMinAngle <= this.angleDifference;
    },

    /**
     * Returns a string containing the SVG path. assumes that the start point is already provided,
     * so anything that calls this needs to put the M calls first
     * @public
     *
     * @returns {string}
     */
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info
        // rx ry x-axis-rotation large-arc-flag sweep-flag x y

        var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
        var sweepFlag = this._anticlockwise ? '0' : '1';
        var largeArcFlag;
        if ( this.angleDifference < Math.PI * 2 - epsilon ) {
          largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';
          this._svgPathFragment = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' + largeArcFlag +
                                  ' ' + sweepFlag + ' ' + kite.svgNumber( this.end.x ) + ' ' + kite.svgNumber( this.end.y );
        }
        else {
          // circle (or almost-circle) case needs to be handled differently
          // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs

          // get the angle that is between and opposite of both of the points
          var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
          var splitPoint = this._center.plus( Vector2.createPolar( this._radius, splitOppositeAngle ) );

          largeArcFlag = '0'; // since we split it in 2, it's always the small arc

          var firstArc = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' +
                         largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( splitPoint.x ) + ' ' + kite.svgNumber( splitPoint.y );
          var secondArc = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' +
                          largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( this.end.x ) + ' ' + kite.svgNumber( this.end.y );

          this._svgPathFragment = firstArc + ' ' + secondArc;
        }
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },

    /**
     * Returns an array of arcs that will draw an offset on the logical left side
     * @public
     *
     * @param {number} lineWidth
     * @returns {Array.<Arc>}
     */
    strokeLeft: function( lineWidth ) {
      return [ new kite.Arc( this._center, this._radius + ( this._anticlockwise ? 1 : -1 ) * lineWidth / 2, this._startAngle, this._endAngle, this._anticlockwise ) ];
    },

    /**
     * Returns an array of arcs that will draw an offset curve on the logical right side
     * @public
     *
     * @param {number} lineWidth
     * @returns {Array.<Arc>}
     */
    strokeRight: function( lineWidth ) {
      return [ new kite.Arc( this._center, this._radius + ( this._anticlockwise ? -1 : 1 ) * lineWidth / 2, this._endAngle, this._startAngle, !this._anticlockwise ) ];
    },

    /**
     * Returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on these will result in monotonic segments
     * Does not include t=0 and t=1
     * @public
     *
     * @returns {Array.<number>}
     */
    getInteriorExtremaTs: function() {
      var self = this;
      var result = [];
      _.each( [ 0, Math.PI / 2, Math.PI, 3 * Math.PI / 2 ], function( angle ) {
        if ( self.containsAngle( angle ) ) {
          var t = self.tAtAngle( angle );
          var epsilon = 0.0000000001; // TODO: general kite epsilon?
          if ( t > epsilon && t < 1 - epsilon ) {
            result.push( t );
          }
        }
      } );
      return result.sort(); // modifies original, which is OK
    },

    /**
     * Hit-tests this segment with the ray. An array of all intersections of the ray with this segment will be returned.
     * For details, see the documentation in Segment.js
     * @public
     *
     * @param {Ray2} ray
     * @returns {Array.<Intersection>} - See Segment.js for details
     */
    intersection: function( ray ) {
      var result = []; // hits in order

      // left here, if in the future we want to better-handle boundary points
      var epsilon = 0;

      // Run a general circle-intersection routine, then we can test the angles later.
      // Solves for the two solutions t such that ray.position + ray.direction * t is on the circle.
      // Then we check whether the angle at each possible hit point is in our arc.
      var centerToRay = ray.position.minus( this._center );
      var tmp = ray.direction.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var discriminant = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this._radius * this._radius );
      if ( discriminant < epsilon ) {
        // ray misses circle entirely
        return result;
      }
      var base = ray.direction.dot( this._center ) - ray.direction.dot( ray.position );
      var sqt = Math.sqrt( discriminant ) / 2;
      var ta = base - sqt;
      var tb = base + sqt;

      if ( tb < epsilon ) {
        // circle is behind ray
        return result;
      }

      var pointB = ray.pointAtDistance( tb );
      var normalB = pointB.minus( this._center ).normalized();

      if ( ta < epsilon ) {
        // we are inside the circle, so only one intersection is possible
        if ( this.containsAngle( normalB.angle() ) ) {
          result.push( {
            distance: tb,
            point: pointB,
            normal: normalB.negated(), // normal is towards the ray
            wind: this._anticlockwise ? -1 : 1 // since we are inside, wind this way
          } );
        }
      }
      else {
        // two possible hits (outside circle)
        var pointA = ray.pointAtDistance( ta );
        var normalA = pointA.minus( this._center ).normalized();

        if ( this.containsAngle( normalA.angle() ) ) {
          result.push( {
            distance: ta,
            point: pointA,
            normal: normalA,
            wind: this._anticlockwise ? 1 : -1 // hit from outside
          } );
        }
        if ( this.containsAngle( normalB.angle() ) ) {
          result.push( {
            distance: tb,
            point: pointB,
            normal: normalB.negated(),
            wind: this._anticlockwise ? -1 : 1 // this is the far hit, which winds the opposite way
          } );
        }
      }

      return result;
    },

    /**
     * Returns the resultant winding number of this ray intersecting this arc.
     * @public
     *
     * @param {Ray2} ray
     * @returns {number}
     */
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },

    /**
     * Draws this arc to the 2D Canvas context, assuming the context's current location is already at the start point
     * @public
     *
     * @param {CanvasRenderingContext2D} context
     */
    writeToContext: function( context ) {
      context.arc( this._center.x, this._center.y, this._radius, this._startAngle, this._endAngle, this._anticlockwise );
    },

    /**
     * Returns a new copy of this arc, transformed by the given matrix.
     * @public
     *
     * TODO: test various transform types, especially rotations, scaling, shears, etc.
     *
     * @param {Matrix3} matrix
     * @returns {Arc|EllipticalArc}
     */
    transformed: function( matrix ) {
      // so we can handle reflections in the transform, we do the general case handling for start/end angles
      var startAngle = matrix.timesVector2( Vector2.createPolar( 1, this._startAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();
      var endAngle = matrix.timesVector2( Vector2.createPolar( 1, this._endAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();

      // reverse the 'clockwiseness' if our transform includes a reflection
      var anticlockwise = matrix.getDeterminant() >= 0 ? this._anticlockwise : !this._anticlockwise;

      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
      }

      var scaleVector = matrix.getScaleVector();
      if ( scaleVector.x !== scaleVector.y ) {
        var radiusX = scaleVector.x * this._radius;
        var radiusY = scaleVector.y * this._radius;
        return new kite.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, 0, startAngle, endAngle, anticlockwise );
      }
      else {
        var radius = scaleVector.x * this._radius;
        return new kite.Arc( matrix.timesVector2( this._center ), radius, startAngle, endAngle, anticlockwise );
      }
    }
  } );

  /**
   * Add getters and setters
   */
  Segment.addInvalidatingGetterSetter( Arc, 'center' );
  Segment.addInvalidatingGetterSetter( Arc, 'radius' );
  Segment.addInvalidatingGetterSetter( Arc, 'startAngle' );
  Segment.addInvalidatingGetterSetter( Arc, 'endAngle' );
  Segment.addInvalidatingGetterSetter( Arc, 'anticlockwise' );

  return Arc;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Describes a section of continuous overlap (multiple overlapping points) between two segments.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/util/Overlap',['require','PHET_CORE/inherit','KITE/kite'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var kite = require( 'KITE/kite' );

  /**
   * @public
   * @constructor
   *
   * Creates an overlap based on two segments with their t-values (parametric value) within the range of [0,1]
   * (inclusive). The t value from the first curve can be mapped to an equivalent t value from the second curve such
   * that first( t ) === second( a * t + b ).
   *
   * Endpoint values for the actual overlap will be computed, such that
   * - first( t0 ) === second( qt0 )
   * - first( t1 ) === second( qt1 )
   * - All of those t values are in the range [0,1]
   */
  function Overlap( a, b ) {
    assert && assert( typeof a === 'number' && isFinite( a ) && a !== 0,
      'a should be a finite non-zero number' );
    assert && assert( typeof b === 'number' && isFinite( b ),
      'b should be a finite number' );

    // @public {number}
    this.a = a;
    this.b = b;

    var t0 = 0;
    var t1 = 1;
    var qt0 = this.apply( t0 );
    var qt1 = this.apply( t1 );

    if ( qt0 > 1 ) {
      qt0 = 1;
      t0 = this.applyInverse( qt0 );
    }
    if ( qt0 < 0 ) {
      qt0 = 0;
      t0 = this.applyInverse( qt0 );
    }
    if ( qt1 > 1 ) {
      qt1 = 1;
      t1 = this.applyInverse( qt1 );
    }
    if ( qt1 < 0 ) {
      qt1 = 0;
      t1 = this.applyInverse( qt1 );
    }

    // @public {number} - Initial and ending t-values for the first curve (t0,t1) and second curve (qt0,qt1).
    this.t0 = t0;
    this.t1 = t1;
    if ( a > 0 ) {
      this.qt0 = qt0;
      this.qt1 = qt1;
    }
    else {
      this.qt0 = qt1;
      this.qt1 = qt0;
    }

    assert && assert( this.t0 >= 0 && this.t0 <= 1, 't0 out of range: ' + this.t0 );
    assert && assert( this.t1 >= 0 && this.t1 <= 1, 't1 out of range: ' + this.t1 );
    assert && assert( this.qt0 >= 0 && this.qt0 <= 1, 'qt0 out of range: ' + this.qt0 );
    assert && assert( this.qt1 >= 0 && this.qt1 <= 1, 'qt1 out of range: ' + this.qt1 );
  }

  kite.register( 'Overlap', Overlap );

  inherit( Object, Overlap, {
    /**
     * Maps a t value from the first curve to the second curve (assuming it is within the overlap range).
     * @public
     *
     * @param {number} t
     * @returns {number}
     */
    apply: function( t ) {
      return this.a * t + this.b;
    },

    /**
     * Maps a t value from the second curve to the first curve (assuming it is within the overlap range).
     * @public
     *
     * @param {number} t
     * @returns {number}
     */
    applyInverse: function( t ) {
      return ( t - this.b ) / this.a;
    }
  } );

  return kite.Overlap;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Quadratic Bezier segment
 *
 * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Quadratic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Matrix3','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/util/Overlap'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Util = require( 'DOT/Util' );
  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  var Overlap = require( 'KITE/util/Overlap' );

  // constants
  var solveQuadraticRootsReal = Util.solveQuadraticRootsReal;
  var arePointsCollinear = Util.arePointsCollinear;

  /**
   *
   * @param {Vector2} start
   * @param {Vector2} control
   * @param {Vector2} end
   * @constructor
   */
  function Quadratic( start, control, end ) {
    Segment.call( this );

    this._start = start;
    this._control = control;
    this._end = end;

    this.invalidate();
  }

  kite.register( 'Quadratic', Quadratic );

  inherit( Segment, Quadratic, {

    degree: 2, // degree of the polynomial (quadratic)

    /**
     * Returns the position parametrically, with 0 <= t <= 1.
     * @public
     *
     * NOTE: positionAt( 0 ) will return the start of the segment, and positionAt( 1 ) will return the end of the
     * segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );

      var mt = 1 - t;
      // described from t=[0,1] as: (1-t)^2 start + 2(1-t)t control + t^2 end
      // TODO: allocation reduction
      return this._start.times( mt * mt ).plus( this._control.times( 2 * mt * t ) ).plus( this._end.times( t * t ) );
    },

    /**
     * Returns the non-normalized tangent (dx/dt, dy/dt) of this segment at the parametric value of t, with 0 <= t <= 1.
     * @public
     *
     * NOTE: tangentAt( 0 ) will return the tangent at the start of the segment, and tangentAt( 1 ) will return the
     * tangent at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );

      // For a quadratic curve, the derivavtive is given by : 2(1-t)( control - start ) + 2t( end - control )
      // TODO: allocation reduction
      return this._control.minus( this._start ).times( 2 * ( 1 - t ) ).plus( this._end.minus( this._control ).times( 2 * t ) );
    },

    /**
     * Returns the signed curvature of the segment at the parametric value t, where 0 <= t <= 1.
     * @public
     *
     * The curvature will be positive for visual clockwise / mathematical counterclockwise curves, negative for opposite
     * curvature, and 0 for no curvature.
     *
     * NOTE: curvatureAt( 0 ) will return the curvature at the start of the segment, and curvatureAt( 1 ) will return
     * the curvature at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {number}
     */
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );

      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31
      // TODO: remove code duplication with Cubic
      var epsilon = 0.0000001;
      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
        var isZero = t < 0.5;
        var p0 = isZero ? this._start : this._end;
        var p1 = this._control;
        var p2 = isZero ? this._end : this._start;
        var d10 = p1.minus( p0 );
        var a = d10.magnitude();
        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
      }
      else {
        return this.subdivided( t, true )[ 0 ].curvatureAt( 1 );
      }
    },

    /**
     * Returns an array with up to 2 sub-segments, split at the parametric t value. Together (in order) they should make
     * up the same shape as the current segment.
     * @public
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Array.<Segment>}
     */
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );

      // If t is 0 or 1, we only need to return 1 segment
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }

      // de Casteljau method
      var leftMid = this._start.blend( this._control, t );
      var rightMid = this._control.blend( this._end, t );
      var mid = leftMid.blend( rightMid, t );
      return [
        new kite.Quadratic( this._start, leftMid, mid ),
        new kite.Quadratic( mid, rightMid, this._end )
      ];
    },

    /**
     * @public - Clears cached information, should be called when any of the 'constructor arguments' are mutated.
     */
    invalidate: function() {
      // Lazily-computed derived information
      this._startTangent = null; // {Vector2|null}
      this._endTangent = null; // {Vector2|null}
      this._tCriticalX = null; // {number|null} T where x-derivative is 0 (replaced with NaN if not in range)
      this._tCriticalY = null; // {number|null} T where y-derivative is 0 (replaced with NaN if not in range)

      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}

      this.trigger0( 'invalidated' );
    },

    /**
     * Returns the tangent vector (normalized) to the segment at the start, pointing in the direction of motion (from start to end)
     * @returns {Vector2}
     */
    getStartTangent: function() {
      if ( this._startTangent === null ) {
        var controlIsStart = this._start.equals( this._control );
        // TODO: allocation reduction
        this._startTangent = controlIsStart ?
                             this._end.minus( this._start ).normalized() :
                             this._control.minus( this._start ).normalized();
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },

    /**
     * Returns the tangent vector (normalized) to the segment at the end, pointing in the direction of motion (from start to end)
     * @returns {Vector2}
     */
    getEndTangent: function() {
      if ( this._endTangent === null ) {
        var controlIsEnd = this._end.equals( this._control );
        // TODO: allocation reduction
        this._endTangent = controlIsEnd ?
                           this._end.minus( this._start ).normalized() :
                           this._end.minus( this._control ).normalized();
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },

    /**
     *
     * @returns {number}
     */
    getTCriticalX: function() {
      // compute x where the derivative is 0 (used for bounds and other things)
      if ( this._tCriticalX === null ) {
        this._tCriticalX = Quadratic.extremaT( this._start.x, this._control.x, this._end.x );
      }
      return this._tCriticalX;
    },
    get tCriticalX() { return this.getTCriticalX(); },


    /**
     *
     * @returns {number}
     */
    getTCriticalY: function() {
      // compute y where the derivative is 0 (used for bounds and other things)
      if ( this._tCriticalY === null ) {
        this._tCriticalY = Quadratic.extremaT( this._start.y, this._control.y, this._end.y );
      }
      return this._tCriticalY;
    },
    get tCriticalY() { return this.getTCriticalY(); },

    /**
     * Returns a list of non-degenerate segments that are equivalent to this segment. Generally gets rid (or simplifies)
     * invalid or repeated segments.
     * @public
     *
     * @returns {Array.<Segment>}
     */
    getNondegenerateSegments: function() {
      var start = this._start;
      var control = this._control;
      var end = this._end;

      var startIsEnd = start.equals( end );
      var startIsControl = start.equals( control );
      var endIsControl = start.equals( control );

      if ( startIsEnd && startIsControl ) {
        // all same points
        return [];
      }
      else if ( startIsEnd ) {
        // this is a special collinear case, we basically line out to the farthest point and back
        var halfPoint = this.positionAt( 0.5 );
        return [
          new kite.Line( start, halfPoint ),
          new kite.Line( halfPoint, end )
        ];
      }
      else if ( arePointsCollinear( start, control, end ) ) {
        // if they are collinear, we can reduce to start->control and control->end, or if control is between, just one line segment
        // also, start !== end (handled earlier)
        if ( startIsControl || endIsControl ) {
          // just a line segment!
          return [ new kite.Line( start, end ) ]; // no extra nondegenerate check since start !== end
        }
        // now control point must be unique. we check to see if our rendered path will be outside of the start->end line segment
        var delta = end.minus( start );
        var p1d = control.minus( start ).dot( delta.normalized ) / delta.magnitude();
        var t = Quadratic.extremaT( 0, p1d, 1 );
        if ( !isNaN( t ) && t > 0 && t < 1 ) {
          // we have a local max inside the range, indicating that our extrema point is outside of start->end
          // we'll line to and from it
          var pt = this.positionAt( t );
          return _.flatten( [
            new kite.Line( start, pt ).getNondegenerateSegments(),
            new kite.Line( pt, end ).getNondegenerateSegments()
          ] );
        }
        else {
          // just provide a line segment, our rendered path doesn't go outside of this
          return [ new kite.Line( start, end ) ]; // no extra nondegenerate check since start !== end
        }
      }
      else {
        return [ this ];
      }
    },

    /**
     * Returns the bounds of this segment.
     * @public
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      // calculate our temporary guaranteed lower bounds based on the end points
      if ( this._bounds === null ) {
        this._bounds = new Bounds2( Math.min( this._start.x, this._end.x ), Math.min( this._start.y, this._end.y ), Math.max( this._start.x, this._end.x ), Math.max( this._start.y, this._end.y ) );

        // compute x and y where the derivative is 0, so we can include this in the bounds
        var tCriticalX = this.getTCriticalX();
        var tCriticalY = this.getTCriticalY();

        if ( !isNaN( tCriticalX ) && tCriticalX > 0 && tCriticalX < 1 ) {
          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalX ) );
        }
        if ( !isNaN( tCriticalY ) && tCriticalY > 0 && tCriticalY < 1 ) {
          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalY ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    // see http://www.visgraf.impa.br/sibgrapi96/trabs/pdf/a14.pdf
    // and http://math.stackexchange.com/questions/12186/arc-length-of-bezier-curves for curvature / arc length

    /**
     * Returns an array of quadratic that are offset to this quadratic by a distance r
     * @param {number} r - distance
     * @param {boolean} reverse
     * @returns {Array.<Quadratic>}
     */
    offsetTo: function( r, reverse ) {
      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html
      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      var curves = [ this ];

      // subdivide this curve
      var depth = 5; // generates 2^depth curves
      for ( var i = 0; i < depth; i++ ) {
        curves = _.flatten( _.map( curves, function( curve ) {
          return curve.subdivided( 0.5, true );
        } ) );
      }

      var offsetCurves = _.map( curves, function( curve ) { return curve.approximateOffset( r ); } );

      if ( reverse ) {
        offsetCurves.reverse();
        offsetCurves = _.map( offsetCurves, function( curve ) { return curve.reversed( true ); } );
      }

      return offsetCurves;
    },

    /**
     * elevation of this quadratic Bezier curve to a cubic Bezier curve
     * @returns {Cubic}
     */
    degreeElevated: function() {
      // TODO: allocation reduction
      return new kite.Cubic(
        this._start,
        this._start.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
        this._end.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
        this._end
      );
    },

    /**
     * Returns a quadratic where the end and starting point have been reversed
     * @returns {Quadratic}
     */
    reversed: function() {
      return new kite.Quadratic( this._end, this._control, this._start );
    },

    /**
     *
     * @param {number} r - distance
     * @returns {Quadratic}
     */
    approximateOffset: function( r ) {
      return new kite.Quadratic(
        this._start.plus( ( this._start.equals( this._control ) ? this._end.minus( this._start ) : this._control.minus( this._start ) ).perpendicular().normalized().times( r ) ),
        this._control.plus( this._end.minus( this._start ).perpendicular().normalized().times( r ) ),
        this._end.plus( ( this._end.equals( this._control ) ? this._end.minus( this._start ) : this._end.minus( this._control ) ).perpendicular().normalized().times( r ) )
      );
    },

    /**
     * Returns a string containing the SVG path. assumes that the start point is already provided, so anything that calls this needs to put the M calls first
     * @returns {string}
     */
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        this._svgPathFragment = 'Q ' + kite.svgNumber( this._control.x ) + ' ' + kite.svgNumber( this._control.y ) + ' ' +
                                kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },

    /**
     * Returns an array of lines that will draw an offset curve on the logical left side
     * @param {number} lineWidth
     * @returns {Array.<Quadratic>}
     */
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },

    /**
     * Returns an array of lines that will draw an offset curve on the logical right side
     * @param {number} lineWidth
     * @returns {Array.<Quadratic>}
     */
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },

    /**
     *
     * @returns {Array.<number>}
     */
    getInteriorExtremaTs: function() {
      // TODO: we assume here we are reduce, so that a criticalX doesn't equal a criticalY?
      var result = [];
      var epsilon = 0.0000000001; // TODO: general kite epsilon?

      var criticalX = this.getTCriticalX();
      var criticalY = this.getTCriticalY();

      if ( !isNaN( criticalX ) && criticalX > epsilon && criticalX < 1 - epsilon ) {
        result.push( this.tCriticalX );
      }
      if ( !isNaN( criticalY ) && criticalY > epsilon && criticalY < 1 - epsilon ) {
        result.push( this.tCriticalY );
      }
      return result.sort();
    },

    /**
     * Hit-tests this segment with the ray. An array of all intersections of the ray with this segment will be returned.
     * For details, see the documentation in Segment.js
     * @public
     *
     * @param {Ray2} ray
     * @returns {Array.<Intersection>} - See Segment.js for details
     */
    intersection: function( ray ) {
      var self = this;
      var result = [];

      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
      var inverseMatrix = Matrix3.rotation2( -ray.direction.angle() ).timesMatrix( Matrix3.translation( -ray.position.x, -ray.position.y ) );

      var p0 = inverseMatrix.timesVector2( this._start );
      var p1 = inverseMatrix.timesVector2( this._control );
      var p2 = inverseMatrix.timesVector2( this._end );

      //(1-t)^2 start + 2(1-t)t control + t^2 end
      var a = p0.y - 2 * p1.y + p2.y;
      var b = -2 * p0.y + 2 * p1.y;
      var c = p0.y;

      var ts = solveQuadraticRootsReal( a, b, c );

      _.each( ts, function( t ) {
        if ( t >= 0 && t <= 1 ) {
          var hitPoint = self.positionAt( t );
          var unitTangent = self.tangentAt( t ).normalized();
          var perp = unitTangent.perpendicular();
          var toHit = hitPoint.minus( ray.position );

          // make sure it's not behind the ray
          if ( toHit.dot( ray.direction ) > 0 ) {
            result.push( {
              distance: toHit.magnitude(),
              point: hitPoint,
              normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
              wind: ray.direction.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
            } );
          }
        }
      } );
      return result;
    },

    /**
     * Returns the winding number for intersection with a ray
     * @param {Ray2} ray
     * @returns {number}
     */
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },

    /**
     * Draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point
     * @param {CanvasRenderingContext2D} context
     */
    writeToContext: function( context ) {
      context.quadraticCurveTo( this._control.x, this._control.y, this._end.x, this._end.y );
    },

    /**
     * Returns a new quadratic that represents this quadratic after transformation by the matrix
     * @param {Matrix3} matrix
     * @returns {Quadratic}
     */
    transformed: function( matrix ) {
      return new kite.Quadratic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control ), matrix.timesVector2( this._end ) );
    },

    /**
     * given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b
     * @param {number} a
     * @param {number} b
     * @returns {Quadratic}
     */
    reparameterized: function( a, b ) {
      // to the polynomial pt^2 + qt + r:
      var p = this._start.plus( this._end.plus( this._control.timesScalar( -2 ) ) );
      var q = this._control.minus( this._start ).timesScalar( 2 );
      var r = this._start;

      // to the polynomial alpha*x^2 + beta*x + gamma:
      var alpha = p.timesScalar( a * a );
      var beta = p.timesScalar( a * b ).timesScalar( 2 ).plus( q.timesScalar( a ) );
      var gamma = p.timesScalar( b * b ).plus( q.timesScalar( b ) ).plus( r );

      // back to the form start,control,end
      return new kite.Quadratic( gamma, beta.timesScalar( 0.5 ).plus( gamma ), alpha.plus( beta ).plus( gamma ) );
    }
  } );

  /**
   * Add getters and setters
   */
  Segment.addInvalidatingGetterSetter( Quadratic, 'start' );
  Segment.addInvalidatingGetterSetter( Quadratic, 'control' );
  Segment.addInvalidatingGetterSetter( Quadratic, 'end' );

  // one-dimensional solution to extrema
  Quadratic.extremaT = function( start, control, end ) {
    // compute t where the derivative is 0 (used for bounds and other things)
    var divisorX = 2 * ( end - 2 * control + start );
    if ( divisorX !== 0 ) {
      return -2 * ( control - start ) / divisorX;
    }
    else {
      return NaN;
    }
  };

  /**
   * Determine whether two Quadratics overlap over a continuous section, and if so finds the a,b pair such that
   * p( t ) === q( a * t + b ).
   * @public
   *
   * NOTE: for this particular function, we assume we're not degenerate. Things may work if we can be degree-reduced
   * to a quadratic, but generally that shouldn't be done.
   *
   * @param {Quadratic} quadratic1
   * @param {Quadratic} quadratic2
   * @returns {null|{a:number,b:number}} - The solution, if there is one (and only one)
   */
  Quadratic.getOverlaps = function( quadratic1, quadratic2 ) {
    assert && assert( quadratic1 instanceof Quadratic, 'first Quadratic is not an instance of Quadratic' );
    assert && assert( quadratic2 instanceof Quadratic, 'second Quadratic is not an instance of Quadratic' );

    /*
     * NOTE: For implementation details in this function, please see Cubic.getOverlaps. It goes over all of the
     * same implementation details, but instead our bezier matrix is a 3x3:
     *
     * [  1  0  0 ]
     * [ -2  2  0 ]
     * [  1 -2  1 ]
     *
     * And we use the upper-left section of (at+b) adjustment matrix relevant for the quadratic.
     */

    var noOverlap = [];

    // Efficiently compute the multiplication of the bezier matrix:
    var p0x = quadratic1._start.x;
    var p1x = -2 * quadratic1._start.x + 2 * quadratic1._control.x;
    var p2x = quadratic1._start.x - 2 * quadratic1._control.x + quadratic1._end.x;
    var p0y = quadratic1._start.y;
    var p1y = -2 * quadratic1._start.y + 2 * quadratic1._control.y;
    var p2y = quadratic1._start.y - 2 * quadratic1._control.y + quadratic1._end.y;
    var q0x = quadratic2._start.x;
    var q1x = -2 * quadratic2._start.x + 2 * quadratic2._control.x;
    var q2x = quadratic2._start.x - 2 * quadratic2._control.x + quadratic2._end.x;
    var q0y = quadratic2._start.y;
    var q1y = -2 * quadratic2._start.y + 2 * quadratic2._control.y;
    var q2y = quadratic2._start.y - 2 * quadratic2._control.y + quadratic2._end.y;

    // Determine the candidate overlap
    var xOverlap = Segment.polynomialGetOverlapQuadratic( p0x, p1x, p2x, q0x, q1x, q2x );
    var yOverlap = Segment.polynomialGetOverlapQuadratic( p0y, p1y, p2y, q0y, q1y, q2y );
    var overlap = ( xOverlap === null || xOverlap === true ) ? yOverlap : xOverlap;
    if ( overlap === null || overlap === true ) {
      return noOverlap; // No way to pin down an overlap
    }

    // Grab an approximate value to use as epsilon (that is scale-independent)
    var approxEpsilon = ( Math.abs( p0x ) + Math.abs( p1x ) + Math.abs( p2x ) +
                          Math.abs( p0y ) + Math.abs( p1y ) + Math.abs( p2y ) +
                          Math.abs( q0x ) + Math.abs( q1x ) + Math.abs( q2x ) +
                          Math.abs( q0y ) + Math.abs( q1y ) + Math.abs( q2y ) ) * 1e-6;

    var a = overlap.a;
    var b = overlap.b;

    var aa = a * a;
    var bb = b * b;
    var ab2 = 2 * a * b;

    // Check that the formula is satisfied (3 equations per x and y each)
    if ( Math.abs( q0x + b * q1x + bb * q2x - p0x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1x + ab2 * q2x - p1x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aa * q2x - p2x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( q0y + b * q1y + bb * q2y - p0y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1y + ab2 * q2y - p1y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aa * q2y - p2y ) > approxEpsilon ) { return noOverlap; }

    var qt0 = b;
    var qt1 = a + b;

    // TODO: do we want an epsilon in here to be permissive?
    if ( ( qt0 > 1 && qt1 > 1 ) || ( qt0 < 0 && qt1 < 0 ) ) {
      return noOverlap;
    }

    return [ new Overlap( a, b ) ];
  };

  return Quadratic;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Cubic Bezier segment.
 *
 * See http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf for info
 *
 * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Cubic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/util/Overlap','KITE/segments/Quadratic'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Util = require( 'DOT/Util' );

  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  var Overlap = require( 'KITE/util/Overlap' );
  require( 'KITE/segments/Quadratic' );


  var solveQuadraticRootsReal = Util.solveQuadraticRootsReal; // function that returns an array of number
  var solveCubicRootsReal = Util.solveCubicRootsReal; // function that returns an array of number
  var arePointsCollinear = Util.arePointsCollinear; // function that returns a boolean

  // convenience variables use to reduce the number of vector allocations
  var scratchVector1 = new Vector2();
  var scratchVector2 = new Vector2();
  var scratchVector3 = new Vector2();

  // Used in multiple filters
  function isBetween0And1( t ) {
    return t >= 0 && t <= 1;
  }

  /**
   * Creates a cubic bezier curve
   * @constructor
   *
   * @param {Vector2} start - Start point of the cubic bezier
   * @param {Vector2} control1 - First control point
   * @param {Vector2} control2 - Second control point
   * @param {Vector2} end - End point of the cubic bezier
   */
  function Cubic( start, control1, control2, end ) {
    Segment.call( this );

    this._start = start; //  @private {Vector2}
    this._control1 = control1; // @private {Vector2}
    this._control2 = control2; // @private {Vector2}
    this._end = end; // @private {Vector2}

    this.invalidate();
  }

  kite.register( 'Cubic', Cubic );

  inherit( Segment, Cubic, {

    degree: 3, // degree of this polynomial (cubic)

    /**
     * Returns the position parametrically, with 0 <= t <= 1.
     * @public
     *
     * NOTE: positionAt( 0 ) will return the start of the segment, and positionAt( 1 ) will return the end of the
     * segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );

      // Equivalent position: (1 - t)^3*start + 3*(1 - t)^2*t*control1 + 3*(1 - t) t^2*control2 + t^3*end
      var mt = 1 - t;
      return this._start.times( mt * mt * mt ).plus( this._control1.times( 3 * mt * mt * t ) ).plus( this._control2.times( 3 * mt * t * t ) ).plus( this._end.times( t * t * t ) );
    },

    /**
     * Returns the non-normalized tangent (dx/dt, dy/dt) of this segment at the parametric value of t, with 0 <= t <= 1.
     * @public
     *
     * NOTE: tangentAt( 0 ) will return the tangent at the start of the segment, and tangentAt( 1 ) will return the
     * tangent at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );

      // derivative: -3 p0 (1 - t)^2 + 3 p1 (1 - t)^2 - 6 p1 (1 - t) t + 6 p2 (1 - t) t - 3 p2 t^2 + 3 p3 t^2
      var mt = 1 - t;
      var result = new Vector2();
      return result.set( this._start ).multiplyScalar( -3 * mt * mt )
        .add( scratchVector1.set( this._control1 ).multiplyScalar( 3 * mt * mt - 6 * mt * t ) )
        .add( scratchVector1.set( this._control2 ).multiplyScalar( 6 * mt * t - 3 * t * t ) )
        .add( scratchVector1.set( this._end ).multiplyScalar( 3 * t * t ) );
    },

    /**
     * Returns the signed curvature of the segment at the parametric value t, where 0 <= t <= 1.
     * @public
     *
     * The curvature will be positive for visual clockwise / mathematical counterclockwise curves, negative for opposite
     * curvature, and 0 for no curvature.
     *
     * NOTE: curvatureAt( 0 ) will return the curvature at the start of the segment, and curvatureAt( 1 ) will return
     * the curvature at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {number}
     */
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );

      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31
      // TODO: remove code duplication with Quadratic
      var epsilon = 0.0000001;
      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
        var isZero = t < 0.5;
        var p0 = isZero ? this._start : this._end;
        var p1 = isZero ? this._control1 : this._control2;
        var p2 = isZero ? this._control2 : this._control1;
        var d10 = p1.minus( p0 );
        var a = d10.magnitude();
        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
      }
      else {
        return this.subdivided( t )[ 0 ].curvatureAt( 1 );
      }
    },

    /**
     * Returns an array with up to 2 sub-segments, split at the parametric t value. Together (in order) they should make
     * up the same shape as the current segment.
     * @public
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Array.<Segment>}
     */
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );

      // If t is 0 or 1, we only need to return 1 segment
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }

      // de Casteljau method
      // TODO: add a 'bisect' or 'between' method for vectors?
      var left = this._start.blend( this._control1, t );
      var right = this._control2.blend( this._end, t );
      var middle = this._control1.blend( this._control2, t );
      var leftMid = left.blend( middle, t );
      var rightMid = middle.blend( right, t );
      var mid = leftMid.blend( rightMid, t );
      return [
        new kite.Cubic( this._start, left, leftMid, mid ),
        new kite.Cubic( mid, rightMid, right, this._end )
      ];
    },

    /**
     * Clears cached information, should be called when any of the 'constructor arguments' are mutated.
     * @public
     */
    invalidate: function() {
      // Lazily-computed derived information
      this._startTangent = null; // {Vector2|null}
      this._endTangent = null; // {Vector2|null}
      this._r = null; // {number|null}
      this._s = null; // {number|null}

      // Cusp-specific information
      this._tCusp = null; // {number|null} - T value for a potential cusp
      this._tDeterminant = null; // {number|null}
      this._tInflection1 = null; // {number|null} - NaN if not applicable
      this._tInflection2 = null; // {number|null} - NaN if not applicable
      this._quadratics = null; // {Array.<Quadratic>|null}

      // T-values where X and Y (respectively) reach an extrema (not necessarily including 0 and 1)
      this._xExtremaT = null; // {Array.<number>|null}
      this._yExtremaT = null; // {Array.<number>|null}

      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}

      this.trigger0( 'invalidated' );
    },

    /**
     * Gets the start position of this cubic polynomial.
     * @public
     *
     * @returns {Vector2}
     */
    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAt( 0 ).normalized();
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },

    /**
     * Gets the end position of this cubic polynomial.
     * @public
     *
     * @returns {Vector2}
     */
    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAt( 1 ).normalized();
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },

    /**
     * TODO: documentation
     * @public
     *
     * @returns {Vector2}
     */
    getR: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      if ( this._r === null ) {
        this._r = this._control1.minus( this._start ).normalized();
      }
      return this._r;
    },
    get r() { return this.getR(); },

    /**
     * TODO: documentation
     * @public
     *
     * @returns {Vector2}
     */
    getS: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      if ( this._s === null ) {
        this._s = this.getR().perpendicular();
      }
      return this._s;
    },
    get s() { return this.getS(); },

    /**
     * Returns the parametric t value for the possible cusp location. A cusp may or may not exist at that point.
     * @public
     *
     * @returns {number}
     */
    getTCusp: function() {
      if ( this._tCusp === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tCusp !== null );
      return this._tCusp;
    },
    get tCusp() { return this.getTCusp(); },

    /**
     * Returns the determinant value for the cusp, which indicates the presence (or lack of presence) of a cusp.
     * @public
     *
     * @returns {number}
     */
    getTDeterminant: function() {
      if ( this._tDeterminant === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tDeterminant !== null );
      return this._tDeterminant;
    },
    get tDeterminant() { return this.getTDeterminant(); },

    /**
     * Returns the parametric t value for the potential location of the first possible inflection point.
     * @public
     *
     * @returns {number}
     */
    getTInflection1: function() {
      if ( this._tInflection1 === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tInflection1 !== null );
      return this._tInflection1;
    },
    get tInflection1() { return this.getTInflection1(); },

    /**
     * Returns the parametric t value for the potential location of the second possible inflection point.
     * @public
     *
     * @returns {number}
     */
    getTInflection2: function() {
      if ( this._tInflection2 === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tInflection2 !== null );
      return this._tInflection2;
    },
    get tInflection2() { return this.getTInflection2(); },

    /**
     * If there is a cusp, this cubic will consist of one or two quadratic segments, typically "start => cusp" and
     * "cusp => end".
     * @public
     *
     * @returns {Array.<Quadratic>|null}
     */
    getQuadratics: function() {
      if ( this._quadratics === null ) {
        this.computeCuspSegments();
      }
      assert && assert( this._quadratics !== null );
      return this._quadratics;
    },

    /**
     * Returns a list of parametric t values where x-extrema exist, i.e. where dx/dt==0. These are candidate locations
     * on the cubic for "maximum X" and "minimum X", and are needed for bounds computations.
     * @public
     *
     * @returns {Array.<number>}
     */
    getXExtremaT: function() {
      if ( this._xExtremaT === null ) {
        this._xExtremaT = Cubic.extremaT( this._start.x, this._control1.x, this._control2.x, this._end.x );
      }
      return this._xExtremaT;
    },
    get xExtremaT() { return this.getXExtremaT(); },

    /**
     * Returns a list of parametric t values where y-extrema exist, i.e. where dy/dt==0. These are candidate locations
     * on the cubic for "maximum Y" and "minimum Y", and are needed for bounds computations.
     * @public
     *
     * @returns {Array.<number>}
     */
    getYExtremaT: function() {
      if ( this._yExtremaT === null ) {
        this._yExtremaT = Cubic.extremaT( this._start.y, this._control1.y, this._control2.y, this._end.y );
      }
      return this._yExtremaT;
    },
    get yExtremaT() { return this.getYExtremaT(); },

    /**
     * Returns the bounds of this segment.
     * @public
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING;
        this._bounds = this._bounds.withPoint( this._start );
        this._bounds = this._bounds.withPoint( this._end );

        var self = this;
        _.each( this.getXExtremaT(), function( t ) {
          if ( t >= 0 && t <= 1 ) {
            self._bounds = self._bounds.withPoint( self.positionAt( t ) );
          }
        } );
        _.each( this.getYExtremaT(), function( t ) {
          if ( t >= 0 && t <= 1 ) {
            self._bounds = self._bounds.withPoint( self.positionAt( t ) );
          }
        } );

        if ( this.hasCusp() ) {
          this._bounds = this._bounds.withPoint( this.positionAt( this.getTCusp() ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    /**
     * Computes all cusp-related information, including whether there is a cusp, any inflection points, etc.
     * @private
     */
    computeCuspInfo: function() {
      // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf
      // TODO: allocation reduction
      var a = this._start.times( -1 ).plus( this._control1.times( 3 ) ).plus( this._control2.times( -3 ) ).plus( this._end );
      var b = this._start.times( 3 ).plus( this._control1.times( -6 ) ).plus( this._control2.times( 3 ) );
      var c = this._start.times( -3 ).plus( this._control1.times( 3 ) );

      var aPerp = a.perpendicular(); // {Vector2}
      var bPerp = b.perpendicular(); // {Vector2}
      var aPerpDotB = aPerp.dot( b ); // {number}

      this._tCusp = -0.5 * ( aPerp.dot( c ) / aPerpDotB ); // {number}
      this._tDeterminant = this._tCusp * this._tCusp - ( 1 / 3 ) * ( bPerp.dot( c ) / aPerpDotB ); // {number}
      if ( this._tDeterminant >= 0 ) {
        var sqrtDet = Math.sqrt( this._tDeterminant );
        this._tInflection1 = this._tCusp - sqrtDet;
        this._tInflection2 = this._tCusp + sqrtDet;
      }
      else {
        // there are no real roots to the quadratic polynomial.
        this._tInflection1 = NaN;
        this._tInflection2 = NaN;
      }
    },

    /**
     * If there is a cusp, this computes the 2 quadratic Bezier curves that this Cubic can be converted into.
     * @private
     */
    computeCuspSegments: function() {
      if ( this.hasCusp() ) {
        // if there is a cusp, we'll split at the cusp into two quadratic bezier curves.
        // see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8088&rep=rep1&type=pdf (Singularities of rational Bezier curves - J Monterde, 2001)
        this._quadratics = [];
        var tCusp = this.getTCusp();
        if ( tCusp === 0 ) {
          this._quadratics.push( new kite.Quadratic( this.start, this.control2, this.end, false ) );
        }
        else if ( tCusp === 1 ) {
          this._quadratics.push( new kite.Quadratic( this.start, this.control1, this.end, false ) );
        }
        else {
          var subdividedAtCusp = this.subdivided( tCusp );
          this._quadratics.push( new kite.Quadratic( subdividedAtCusp[ 0 ].start, subdividedAtCusp[ 0 ].control1, subdividedAtCusp[ 0 ].end, false ) );
          this._quadratics.push( new kite.Quadratic( subdividedAtCusp[ 1 ].start, subdividedAtCusp[ 1 ].control2, subdividedAtCusp[ 1 ].end, false ) );
        }
      }
      else {
        this._quadratics = null;
      }
    },

    /**
     * Returns a list of non-degenerate segments that are equivalent to this segment. Generally gets rid (or simplifies)
     * invalid or repeated segments.
     * @public
     *
     * @returns {Array.<Segment>}
     */
    getNondegenerateSegments: function() {
      var self = this;

      var start = this._start;
      var control1 = this._control1;
      var control2 = this._control2;
      var end = this._end;

      var reduced = this.degreeReduced( 1e-9 );

      if ( start.equals( end ) && start.equals( control1 ) && start.equals( control2 ) ) {
        // degenerate point
        return [];
      }
      else if ( this.hasCusp() ) {
        return _.flatten( this.getQuadratics().map( function( quadratic ) {
          return quadratic.getNondegenerateSegments();
        } ) );
      }
      else if ( reduced ) {
        // if we can reduce to a quadratic Bezier, always do this (and make sure it is non-degenerate)
        return reduced.getNondegenerateSegments();
      }
      else if ( arePointsCollinear( start, control1, end ) && arePointsCollinear( start, control2, end ) ) {
        var extremaPoints = this.getXExtremaT().concat( this.getYExtremaT() ).sort().map( function( t ) {
          return self.positionAt( t );
        } );

        var segments = [];
        var lastPoint = start;
        if ( extremaPoints.length ) {
          segments.push( new kite.Line( start, extremaPoints[ 0 ] ) );
          lastPoint = extremaPoints[ 0 ];
        }
        for ( var i = 1; i < extremaPoints.length; i++ ) {
          segments.push( new kite.Line( extremaPoints[ i - 1 ], extremaPoints[ i ] ) );
          lastPoint = extremaPoints[ i ];
        }
        segments.push( new kite.Line( lastPoint, end ) );

        return _.flatten( segments.map( function( segment ) { return segment.getNondegenerateSegments(); } ), true );
      }
      else {
        return [ this ];
      }
    },

    /**
     * Returns whether this cubic has a cusp.
     * @public
     *
     * @returns {boolean}
     */
    hasCusp: function() {
      var tCusp = this.getTCusp();

      var epsilon = 1e-7; // TODO: make this available to change?
      return tCusp >= 0 && tCusp <= 1 && this.tangentAt( tCusp ).magnitude() < epsilon;
    },

    /**
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    toRS: function( point ) {
      var firstVector = point.minus( this._start );
      return new Vector2( firstVector.dot( this.getR() ), firstVector.dot( this.getS() ) );
    },

    /**
     *
     * @param {number} r
     * @param {boolean} reverse
     * @returns {Array.<Line>}
     */
    offsetTo: function( r, reverse ) {
      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html
      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf

      // how many segments to create (possibly make this more adaptive?)
      var quantity = 32;

      var points = [];
      var result = [];
      for ( var i = 0; i < quantity; i++ ) {
        var t = i / ( quantity - 1 );
        if ( reverse ) {
          t = 1 - t;
        }

        points.push( this.positionAt( t ).plus( this.tangentAt( t ).perpendicular().normalized().times( r ) ) );
        if ( i > 0 ) {
          result.push( new kite.Line( points[ i - 1 ], points[ i ] ) );
        }
      }

      return result;
    },

    /**
     * Returns a string containing the SVG path. assumes that the start point is already provided, so anything that calls this needs to put
     * the M calls first
     * @returns {string}
     */
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        this._svgPathFragment = 'C ' + kite.svgNumber( this._control1.x ) + ' ' + kite.svgNumber( this._control1.y ) + ' ' +
                                kite.svgNumber( this._control2.x ) + ' ' + kite.svgNumber( this._control2.y ) + ' ' +
                                kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },

    /**
     * Returns an array of lines that will draw an offset curve on the logical left side
     * @param {number} lineWidth
     * @returns {Array.<Line>}
     */
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },

    /**
     * Returns an array of lines that will draw an offset curve on the logical right side
     * @param {number} lineWidth
     * @returns {Array.<Line>}
     */
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },

    /**
     * Returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on these will result in monotonic segments
     * The list does not include t=0 and t=1
     * @returns {Array.<number>}
     */
    getInteriorExtremaTs: function() {
      var ts = this.getXExtremaT().concat( this.getYExtremaT() );
      var result = [];
      _.each( ts, function( t ) {
        var epsilon = 0.0000000001; // TODO: general kite epsilon?
        if ( t > epsilon && t < 1 - epsilon ) {
          // don't add duplicate t values
          if ( _.every( result, function( otherT ) { return Math.abs( t - otherT ) > epsilon; } ) ) {
            result.push( t );
          }
        }
      } );
      return result.sort();
    },


    /**
     * Hit-tests this segment with the ray. An array of all intersections of the ray with this segment will be returned.
     * For details, see the documentation in Segment.js
     * @public
     *
     * @param {Ray2} ray
     * @returns {Array.<Intersection>} - See Segment.js for details
     */
    intersection: function( ray ) {
      var self = this;
      var result = [];

      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
      var inverseMatrix = Matrix3.rotation2( -ray.direction.angle() ).timesMatrix( Matrix3.translation( -ray.position.x, -ray.position.y ) );

      var p0 = inverseMatrix.timesVector2( this._start );
      var p1 = inverseMatrix.timesVector2( this._control1 );
      var p2 = inverseMatrix.timesVector2( this._control2 );
      var p3 = inverseMatrix.timesVector2( this._end );

      // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3
      var a = -p0.y + 3 * p1.y - 3 * p2.y + p3.y;
      var b = 3 * p0.y - 6 * p1.y + 3 * p2.y;
      var c = -3 * p0.y + 3 * p1.y;
      var d = p0.y;

      var ts = solveCubicRootsReal( a, b, c, d );

      _.each( ts, function( t ) {
        if ( t >= 0 && t <= 1 ) {
          var hitPoint = self.positionAt( t );
          var unitTangent = self.tangentAt( t ).normalized();
          var perp = unitTangent.perpendicular();
          var toHit = hitPoint.minus( ray.position );

          // make sure it's not behind the ray
          if ( toHit.dot( ray.direction ) > 0 ) {
            result.push( {
              distance: toHit.magnitude(),
              point: hitPoint,
              normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
              wind: ray.direction.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
            } );
          }
        }
      } );
      return result;
    },

    /**
     * Returns the winding number for intersection with a ray
     * @param {Ray2} ray
     * @returns {number}
     */
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },

    /**
     * Draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point
     * @param {CanvasRenderingContext2D} context
     */
    writeToContext: function( context ) {
      context.bezierCurveTo( this._control1.x, this._control1.y, this._control2.x, this._control2.y, this._end.x, this._end.y );
    },

    /**
     * Returns a new cubic that represents this cubic after transformation by the matrix
     * @param {Matrix3} matrix
     * @returns {Cubic}
     */
    transformed: function( matrix ) {
      return new kite.Cubic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control1 ), matrix.timesVector2( this._control2 ), matrix.timesVector2( this._end ) );
    },


    /**
     * Returns a degree-reduced quadratic Bezier if possible, otherwise it returns null
     * @param {number} epsilon
     * @returns {Quadratic|null}
     */
    degreeReduced: function( epsilon ) {
      epsilon = epsilon || 0; // if not provided, use an exact version
      var controlA = scratchVector1.set( this._control1 ).multiplyScalar( 3 ).subtract( this._start ).divideScalar( 2 );
      var controlB = scratchVector2.set( this._control2 ).multiplyScalar( 3 ).subtract( this._end ).divideScalar( 2 );
      var difference = scratchVector3.set( controlA ).subtract( controlB );
      if ( difference.magnitude() <= epsilon ) {
        return new kite.Quadratic(
          this._start,
          controlA.average( controlB ), // average the control points for stability. they should be almost identical
          this._end
        );
      }
      else {
        // the two options for control points are too far away, this curve isn't easily reducible.
        return null;
      }
    }

    // returns the resultant winding number of this ray intersecting this segment.
    // windingIntersection: function( ray ) {
    //   // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections
    //   var inverseMatrix = Matrix3.rotation2( -ray.direction.angle() );
    //   assert && assert( inverseMatrix.timesVector2( ray.direction ).x > 0.99 ); // verify that we transform the unit vector to the x-unit

    //   var y0 = inverseMatrix.timesVector2( this._start ).y;
    //   var y1 = inverseMatrix.timesVector2( this._control1 ).y;
    //   var y2 = inverseMatrix.timesVector2( this._control2 ).y;
    //   var y3 = inverseMatrix.timesVector2( this._end ).y;

    //   // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3
    //   var a = -y0 + 3 * y1 - 3 * y2 + y3;
    //   var b = 3 * y0 - 6 * y1 + 3 * y2;
    //   var c = -3 * y0 + 3 * y1;
    //   var d = y0;

    //   // solve cubic roots
    //   var ts = solveCubicRootsReal( a, b, c, d );

    //   var result = 0;

    //   // for each hit
    //   _.each( ts, function( t ) {
    //     if ( t >= 0 && t <= 1 ) {
    //       result += ray.direction.perpendicular().dot( this.tangentAt( t ) ) < 0 ? 1 : -1;
    //     }
    //   } );

    //   return result;
    // }
  } );

  /**
   * Add getters and setters
   */
  Segment.addInvalidatingGetterSetter( Cubic, 'start' );
  Segment.addInvalidatingGetterSetter( Cubic, 'control1' );
  Segment.addInvalidatingGetterSetter( Cubic, 'control2' );
  Segment.addInvalidatingGetterSetter( Cubic, 'end' );


  /**
   * finds what t values the cubic extrema are at (if any). This is just the 1-dimensional case, used for multiple purposes
   * @param {number} v0
   * @param {number} v1
   * @param {number} v2
   * @param {number} v3
   * @returns {number}
   */
  Cubic.extremaT = function( v0, v1, v2, v3 ) {
    if ( v0 === v1 && v0 === v2 && v0 === v3 ) {
      return [];
    }

    // coefficients of derivative
    var a = -3 * v0 + 9 * v1 - 9 * v2 + 3 * v3;
    var b = 6 * v0 - 12 * v1 + 6 * v2;
    var c = -3 * v0 + 3 * v1;

    return _.filter( solveQuadraticRootsReal( a, b, c ), isBetween0And1 );
  };

  /**
   * Determine whether two Cubics overlap over a continuous section, and if so finds the a,b pair such that
   * p( t ) === q( a * t + b ).
   * @public
   *
   * NOTE: for this particular function, we assume we're not degenerate. Things may work if we can be degree-reduced
   * to a quadratic, but generally that shouldn't be done.
   *
   * @param {Cubic} cubic1
   * @param {Cubic} cubic2
   * @returns {null|{a:number,b:number}} - The solution, if there is one (and only one)
   */
  Cubic.getOverlaps = function( cubic1, cubic2 ) {
    assert && assert( cubic1 instanceof Cubic, 'first Cubic is not an instance of Cubic' );
    assert && assert( cubic2 instanceof Cubic, 'second Cubic is not an instance of Cubic' );

    /*
     * For a 1-dimensional cubic bezier, we have the formula:
     *
     *                            [  0  0  0  0 ]   [ p0 ]
     * p( t ) = [ 1 t t^2 t^3 ] * [ -3  3  0  0 ] * [ p1 ]
     *                            [  3 -6  3  0 ]   [ p2 ]
     *                            [ -1  3 -3  1 ]   [ p3 ]
     *
     * where p0,p1,p2,p3 are the control values (start,control1,control2,end). We want to see if a linear-mapped cubic:
     *
     *                                              [ 1 b b^2  b^3  ]   [  0  0  0  0 ]   [ q0 ]
     * p( t ) =? q( a * t + b ) = [ 1 t t^2 t^3 ] * [ 0 a 2ab 3ab^2 ] * [ -3  3  0  0 ] * [ q1 ]
     *                                              [ 0 0 a^2 3a^2b ]   [  3 -6  3  0 ]   [ q2 ]
     *                                              [ 0 0  0   a^3  ]   [ -1  3 -3  1 ]   [ q3 ]
     *
     * (is it equal to the second cubic if we can find a linear way to map its input t-value?)
     *
     * For simplicity and efficiency, we'll precompute the multiplication of the bezier matrix:
     * [ p0s ]    [  1   0   0   0 ]   [ p0 ]
     * [ p1s ] == [ -3   3   0   0 ] * [ p1 ]
     * [ p2s ]    [  3  -6   3   0 ]   [ p2 ]
     * [ p3s ]    [ -1   3  -3   1 ]   [ p3 ]
     *
     * Leaving our computation to solve for a,b such that:
     *
     * [ p0s ]    [ 1 b b^2  b^3  ]   [ q0s ]
     * [ p1s ] == [ 0 a 2ab 3ab^2 ] * [ q1s ]
     * [ p2s ]    [ 0 0 a^2 3a^2b ]   [ q2s ]
     * [ p3s ]    [ 0 0  0   a^3  ]   [ q3s ]
     *
     * The subproblem of computing possible a,b pairs will be left to Segment.polynomialGetOverlapCubic and its
     * reductions (if p3s/q3s are zero, they aren't fully cubic beziers and can be degree reduced, which is handled).
     *
     * Then, given an a,b pair, we need to ensure the above formula is satisfied (approximately, due to floating-point
     * arithmetic).
     */

    var noOverlap = [];

    // Efficiently compute the multiplication of the bezier matrix:
    var p0x = cubic1._start.x;
    var p1x = -3 * cubic1._start.x + 3 * cubic1._control1.x;
    var p2x = 3 * cubic1._start.x - 6 * cubic1._control1.x + 3 * cubic1._control2.x;
    var p3x = -1 * cubic1._start.x + 3 * cubic1._control1.x - 3 * cubic1._control2.x + cubic1._end.x;
    var p0y = cubic1._start.y;
    var p1y = -3 * cubic1._start.y + 3 * cubic1._control1.y;
    var p2y = 3 * cubic1._start.y - 6 * cubic1._control1.y + 3 * cubic1._control2.y;
    var p3y = -1 * cubic1._start.y + 3 * cubic1._control1.y - 3 * cubic1._control2.y + cubic1._end.y;
    var q0x = cubic2._start.x;
    var q1x = -3 * cubic2._start.x + 3 * cubic2._control1.x;
    var q2x = 3 * cubic2._start.x - 6 * cubic2._control1.x + 3 * cubic2._control2.x;
    var q3x = -1 * cubic2._start.x + 3 * cubic2._control1.x - 3 * cubic2._control2.x + cubic2._end.x;
    var q0y = cubic2._start.y;
    var q1y = -3 * cubic2._start.y + 3 * cubic2._control1.y;
    var q2y = 3 * cubic2._start.y - 6 * cubic2._control1.y + 3 * cubic2._control2.y;
    var q3y = -1 * cubic2._start.y + 3 * cubic2._control1.y - 3 * cubic2._control2.y + cubic2._end.y;

    // Determine the candidate overlap
    var xOverlap = Segment.polynomialGetOverlapCubic( p0x, p1x, p2x, p3x, q0x, q1x, q2x, q3x );
    var yOverlap = Segment.polynomialGetOverlapCubic( p0y, p1y, p2y, p3y, q0y, q1y, q2y, q3y );
    var overlap = ( xOverlap === null || xOverlap === true ) ? yOverlap : xOverlap;
    if ( overlap === null || overlap === true ) {
      return noOverlap; // No way to pin down an overlap
    }

    // Grab an approximate value to use as epsilon (that is scale-independent)
    var approxEpsilon = ( Math.abs( p0x ) + Math.abs( p1x ) + Math.abs( p2x ) + Math.abs( p3x ) +
                          Math.abs( p0y ) + Math.abs( p1y ) + Math.abs( p2y ) + Math.abs( p3y ) +
                          Math.abs( q0x ) + Math.abs( q1x ) + Math.abs( q2x ) + Math.abs( q3x ) +
                          Math.abs( q0y ) + Math.abs( q1y ) + Math.abs( q2y ) + Math.abs( q3y ) ) * 1e-6;

    var a = overlap.a;
    var b = overlap.b;

    // Premultiply a few values
    var aa = a * a;
    var aaa = a * a * a;
    var bb = b * b;
    var bbb = b * b * b;
    var ab2 = 2 * a * b;
    var abb3 = 3 * a * bb;
    var aab3 = 3 * aa * b;

    // Check that the formula is satisfied (4 equations per x and y each)
    if ( Math.abs( q0x + b * q1x + bb * q2x + bbb * q3x - p0x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1x + ab2 * q2x + abb3 * q3x - p1x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aa * q2x + aab3 * q3x - p2x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aaa * q3x - p3x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( q0y + b * q1y + bb * q2y + bbb * q3y - p0y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1y + ab2 * q2y + abb3 * q3y - p1y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aa * q2y + aab3 * q3y - p2y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aaa * q3y - p3y ) > approxEpsilon ) { return noOverlap; }

    var qt0 = b;
    var qt1 = a + b;

    // TODO: do we want an epsilon in here to be permissive?
    if ( ( qt0 > 1 && qt1 > 1 ) || ( qt0 < 0 && qt1 < 0 ) ) {
      return noOverlap;
    }

    return [ new Overlap( a, b ) ];
  };

  return Cubic;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Elliptical arc segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/EllipticalArc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Matrix3','DOT/Transform3','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var Util = require( 'DOT/Util' );
  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );

  // constants
  var toDegrees = Util.toDegrees;

  // TODO: notes at http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
  // Canvas notes were at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-ellipse
  // context.ellipse was removed from the Canvas spec

  /**
   *
   * @param {Vector2} center
   * @param {number} radiusX
   * @param {number} radiusY
   * @param {number} rotation
   * @param {number} startAngle
   * @param {number} endAngle
   * @param {boolean} anticlockwise
   * @constructor
   */
  function EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
    Segment.call( this );

    this._center = center;
    this._radiusX = radiusX;
    this._radiusY = radiusY;
    this._rotation = rotation;
    this._startAngle = startAngle;
    this._endAngle = endAngle;
    this._anticlockwise = anticlockwise;

    this.invalidate();
  }

  kite.register( 'EllipticalArc', EllipticalArc );

  inherit( Segment, EllipticalArc, {

    /**
     * Returns the position parametrically, with 0 <= t <= 1.
     * @public
     *
     * NOTE: positionAt( 0 ) will return the start of the segment, and positionAt( 1 ) will return the end of the
     * segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );

      return this.positionAtAngle( this.angleAt( t ) );
    },

    /**
     * Returns the non-normalized tangent (dx/dt, dy/dt) of this segment at the parametric value of t, with 0 <= t <= 1.
     * @public
     *
     * NOTE: tangentAt( 0 ) will return the tangent at the start of the segment, and tangentAt( 1 ) will return the
     * tangent at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );

      return this.tangentAtAngle( this.angleAt( t ) );
    },

    /**
     * Returns the signed curvature of the segment at the parametric value t, where 0 <= t <= 1.
     * @public
     *
     * The curvature will be positive for visual clockwise / mathematical counterclockwise curves, negative for opposite
     * curvature, and 0 for no curvature.
     *
     * NOTE: curvatureAt( 0 ) will return the curvature at the start of the segment, and curvatureAt( 1 ) will return
     * the curvature at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {number}
     */
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );

      // see http://mathworld.wolfram.com/Ellipse.html (59)
      var angle = this.angleAt( t );
      var aq = this._radiusX * Math.sin( angle );
      var bq = this._radiusY * Math.cos( angle );
      var denominator = Math.pow( bq * bq + aq * aq, 3 / 2 );
      return ( this._anticlockwise ? -1 : 1 ) * this._radiusX * this._radiusY / denominator;
    },

    /**
     * Returns an array with up to 2 sub-segments, split at the parametric t value. Together (in order) they should make
     * up the same shape as the current segment.
     * @public
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Array.<Segment>}
     */
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );

      // If t is 0 or 1, we only need to return 1 segment
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }

      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles
      var angle0 = this.angleAt( 0 );
      var angleT = this.angleAt( t );
      var angle1 = this.angleAt( 1 );
      return [
        new kite.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angle0, angleT, this._anticlockwise ),
        new kite.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angleT, angle1, this._anticlockwise )
      ];
    },

    /**
     * Clears cached information, should be called when any of the 'constructor arguments' are mutated.
     * @public
     */
    invalidate: function() {
      // Lazily-computed derived information
      this._unitTransform = null; // {Transform3|null} - Mapping between our ellipse and a unit circle
      this._start = null; // {Vector2|null}
      this._end = null; // {Vector2|null}
      this._startTangent = null; // {Vector2|null}
      this._endTangent = null; // {Vector2|null}
      this._actualEndAngle = null; // {number|null} - End angle in relation to our start angle (can get remapped)
      this._isFullPerimeter = null; // {boolean|null} - Whether it's a full ellipse (and not just an arc)
      this._angleDifference = null; // {number|null}
      this._unitArcSegment = null; // {Arc|null} - Corresponding circular arc for our unit transform.
      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}

      // remapping of negative radii
      if ( this._radiusX < 0 ) {
        // support this case since we might actually need to handle it inside of strokes?
        this._radiusX = -this._radiusX;
        this._startAngle = Math.PI - this._startAngle;
        this._endAngle = Math.PI - this._endAngle;
        this._anticlockwise = !this._anticlockwise;
      }
      if ( this._radiusY < 0 ) {
        // support this case since we might actually need to handle it inside of strokes?
        this._radiusY = -this._radiusY;
        this._startAngle = -this._startAngle;
        this._endAngle = -this._endAngle;
        this._anticlockwise = !this._anticlockwise;
      }
      if ( this._radiusX < this._radiusY ) {
        // swap radiusX and radiusY internally for consistent Canvas / SVG output
        this._rotation += Math.PI / 2;
        this._startAngle -= Math.PI / 2;
        this._endAngle -= Math.PI / 2;

        // swap radiusX and radiusY
        var tmpR = this._radiusX;
        this._radiusX = this._radiusY;
        this._radiusY = tmpR;
      }

      if ( this._radiusX < this._radiusY ) {
        // TODO: check this
        throw new Error( 'Not verified to work if radiusX < radiusY' );
      }

      // constraints shared with Arc
      assert && assert( !( ( !this._anticlockwise && this._endAngle - this._startAngle <= -Math.PI * 2 ) ||
                           ( this._anticlockwise && this._startAngle - this._endAngle <= -Math.PI * 2 ) ),
        'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
      assert && assert( !( ( !this._anticlockwise && this._endAngle - this._startAngle > Math.PI * 2 ) ||
                           ( this._anticlockwise && this._startAngle - this._endAngle > Math.PI * 2 ) ),
        'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );

      this.trigger0( 'invalidated' );
    },

    /**
     * // TODO
     * @returns {Transform3}
     */
    getUnitTransform: function() {
      if ( this._unitTransform === null ) {
        this._unitTransform = EllipticalArc.computeUnitTransform( this._center, this._radiusX, this._radiusY, this._rotation );
      }
      return this._unitTransform;
    },
    get unitTransform() { return this.getUnitTransform(); },

    /**
     * Gets the start point of this ellipticalArc
     * @returns {Vector2}
     */
    getStart: function() {
      if ( this._start === null ) {
        this._start = this.positionAtAngle( this._startAngle );
      }
      return this._start;
    },
    get start() { return this.getStart(); },

    /**
     * Gets the end point of this ellipticalArc
     * @returns {Vector2}
     */
    getEnd: function() {
      if ( this._end === null ) {
        this._end = this.positionAtAngle( this._endAngle );
      }
      return this._end;
    },
    get end() { return this.getEnd(); },

    /**
     * Gets the tangent vector (normalized) to this ellipticalArc at the start, pointing in the direction of motion (from start to end)
     * @returns {Vector2}
     */
    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAtAngle( this._startAngle );
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },

    /**
     * Gets the tangent vector (normalized) to this ellipticalArc at the end point, pointing in the direction of motion (from start to end)
     * @returns {Vector2}
     */
    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAtAngle( this._endAngle );
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },

    /**
     * Gets the end angle in radians
     * @returns {number}
     */
    getActualEndAngle: function() {
      if ( this._actualEndAngle === null ) {
        // compute an actual end angle so that we can smoothly go from this._startAngle to this._actualEndAngle
        if ( this._anticlockwise ) {
          // angle is 'decreasing'
          // -2pi <= end - start < 2pi
          if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle - 2 * Math.PI;
          }
          else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
        else {
          // angle is 'increasing'
          // -2pi < end - start <= 2pi
          if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle + Math.PI * 2;
          }
          else {
            // equal
            this._actualEndAngle = this._startAngle;
          }
        }
      }
      return this._actualEndAngle;
    },
    get actualEndAngle() { return this.getActualEndAngle(); },

    /**
     * Returns a boolean value that indicates if the arc wraps up by more than two Pi
     * @returns {boolean}
     */
    getIsFullPerimeter: function() {
      if ( this._isFullPerimeter === null ) {
        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
      }
      return this._isFullPerimeter;
    },
    get isFullPerimeter() { return this.getIsFullPerimeter(); },

    /**
     * Returns an angle difference that represents how "much" of the circle our arc covers
     * The answer is always greater or equal to zero
     * The answer can exceed two Pi
     * @returns {number}
     */
    getAngleDifference: function() {
      if ( this._angleDifference === null ) {
        // compute an angle difference that represents how "much" of the circle our arc covers
        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
        if ( this._angleDifference < 0 ) {
          this._angleDifference += Math.PI * 2;
        }
        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
      }
      return this._angleDifference;
    },
    get angleDifference() { return this.getAngleDifference(); },

    /**
     * a unit arg segment that we can map to our ellipse. useful for hit testing and such.
     * @returns {Arc}
     */
    getUnitArcSegment: function() {
      if ( this._unitArcSegment === null ) {
        this._unitArcSegment = new kite.Arc( Vector2.ZERO, 1, this._startAngle, this._endAngle, this._anticlockwise );
      }
      return this._unitArcSegment;
    },
    get unitArcSegment() { return this.getUnitArcSegment(); },

    /**
     * Returns the bounds of this segment.
     * @public
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING.withPoint( this.getStart() )
          .withPoint( this.getEnd() );

        // if the angles are different, check extrema points
        if ( this._startAngle !== this._endAngle ) {
          // solve the mapping from the unit circle, find locations where a coordinate of the gradient is zero.
          // we find one extrema point for both x and y, since the other two are just rotated by pi from them.
          var xAngle = Math.atan( -( this._radiusY / this._radiusX ) * Math.tan( this._rotation ) );
          var yAngle = Math.atan( ( this._radiusY / this._radiusX ) / Math.tan( this._rotation ) );

          // check all of the extrema points
          this.possibleExtremaAngles = [
            xAngle,
            xAngle + Math.PI,
            yAngle,
            yAngle + Math.PI
          ];

          _.each( this.possibleExtremaAngles, this.includeBoundsAtAngle.bind( this ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    /**
     * Returns a list of non-degenerate segments that are equivalent to this segment. Generally gets rid (or simplifies)
     * invalid or repeated segments.
     * @public
     *
     * @returns {Array.<Segment>}
     */
    getNondegenerateSegments: function() {
      if ( this._radiusX <= 0 || this._radiusY <= 0 || this._startAngle === this._endAngle ) {
        return [];
      }
      else if ( this._radiusX === this._radiusY ) {
        // reduce to an Arc
        var startAngle = this._startAngle - this._rotation;
        var endAngle = this._endAngle - this._rotation;

        // preserve full circles
        if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
          endAngle = this._anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
        }
        return [ new kite.Arc( this._center, this._radiusX, startAngle, endAngle, this._anticlockwise ) ];
      }
      else {
        return [ this ];
      }
    },
    /**
     *
     * @param {number} angle
     */
    includeBoundsAtAngle: function( angle ) {
      if ( this.unitArcSegment.containsAngle( angle ) ) {
        // the boundary point is in the arc
        this._bounds = this._bounds.withPoint( this.positionAtAngle( angle ) );
      }
    },

    /**
     * maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.
     * @param {number} angle
     * @returns {number}
     */
    mapAngle: function( angle ) {
      // consider an assert that we contain that angle?
      return ( this._startAngle > this.getActualEndAngle() ) ?
             Util.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
             Util.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
    },

    /**
     * Returns the parametrized value t for a given angle. The value t should range from 0 to 1 (inclusive)
     * @param {number} angle
     * @returns {number}
     */
    tAtAngle: function( angle ) {
      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
    },
    /**
     * Returns the angle for the parametrized t value. The t value should range from 0 to 1 (inclusive)
     * @param {number} t
     * @returns {number}
     */
    angleAt: function( t ) {
      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
    },

    /**
     * Returns the position of this arc at angle.
     * @param {number} angle
     * @returns {Vector2}
     */
    positionAtAngle: function( angle ) {
      return this.getUnitTransform().transformPosition2( Vector2.createPolar( 1, angle ) );
    },

    /**
     * Returns the normalized tangent of this arc.
     * The tangent points outward (inward) of this arc for clockwise (anticlockwise) direction.
     * @param {number} angle
     * @returns {Vector2}
     */
    tangentAtAngle: function( angle ) {
      var normal = this.getUnitTransform().transformNormal2( Vector2.createPolar( 1, angle ) );

      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
    },

    /**
     * Returns an array of straight lines that will draw an offset on the logical left (right) side for reverse false (true)
     * It discretizes the elliptical arc in 32 segments and returns an offset curve as a list of lineTos
     * @param {number} r - distance
     * @param {boolean} reverse
     * @returns {Array.<Line>}
     */
    offsetTo: function( r, reverse ) {
      // how many segments to create (possibly make this more adaptive?)
      var quantity = 32;

      var points = [];
      var result = [];
      for ( var i = 0; i < quantity; i++ ) {
        var ratio = i / ( quantity - 1 );
        if ( reverse ) {
          ratio = 1 - ratio;
        }
        var angle = this.angleAt( ratio );

        points.push( this.positionAtAngle( angle ).plus( this.tangentAtAngle( angle ).perpendicular().normalized().times( r ) ) );
        if ( i > 0 ) {
          result.push( new kite.Line( points[ i - 1 ], points[ i ] ) );
        }
      }

      return result;
    },

    /**
     * Returns a string containing the SVG path. assumes that the start point is already provided,
     * so anything that calls this needs to put the M calls first
     * @returns {string}
     */
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info
        // rx ry x-axis-rotation large-arc-flag sweep-flag x y
        var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
        var sweepFlag = this._anticlockwise ? '0' : '1';
        var largeArcFlag;
        var degreesRotation = toDegrees( this._rotation ); // bleh, degrees?
        if ( this.getAngleDifference() < Math.PI * 2 - epsilon ) {
          largeArcFlag = this.getAngleDifference() < Math.PI ? '0' : '1';
          this._svgPathFragment = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' + degreesRotation +
                                  ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( this.getEnd().x ) + ' ' + kite.svgNumber( this.getEnd().y );
        }
        else {
          // ellipse (or almost-ellipse) case needs to be handled differently
          // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs

          // get the angle that is between and opposite of both of the points
          var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
          var splitPoint = this.positionAtAngle( splitOppositeAngle );

          largeArcFlag = '0'; // since we split it in 2, it's always the small arc

          var firstArc = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' +
                         degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' +
                         kite.svgNumber( splitPoint.x ) + ' ' + kite.svgNumber( splitPoint.y );
          var secondArc = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' +
                          degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' +
                          kite.svgNumber( this.getEnd().x ) + ' ' + kite.svgNumber( this.getEnd().y );

          this._svgPathFragment = firstArc + ' ' + secondArc;
        }
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },
    /**
     * Returns an array of straight lines  that will draw an offset on the logical left side
     * @param {number} lineWidth
     * @returns {Array.<Line>}
     */
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },

    /**
     * Returns an array of straight lines that will draw an offset curve on the logical right side
     * @param {number} lineWidth
     * @returns {Array.<Line>}
     */
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },

    /**
     * Returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on these will result in monotonic segments
     * Does not include t=0 and t=1
     * @returns {Array.<number>}
     */
    getInteriorExtremaTs: function() {
      var self = this;
      var result = [];
      _.each( this.possibleExtremaAngles, function( angle ) {
        if ( self.unitArcSegment.containsAngle( angle ) ) {
          var t = self.tAtAngle( angle );
          var epsilon = 0.0000000001; // TODO: general kite epsilon?
          if ( t > epsilon && t < 1 - epsilon ) {
            result.push( t );
          }
        }
      } );
      return result.sort(); // modifies original, which is OK
    },

    /**
     * Hit-tests this segment with the ray. An array of all intersections of the ray with this segment will be returned.
     * For details, see the documentation in Segment.js
     * @public
     *
     * @param {Ray2} ray
     * @returns {Array.<Intersection>} - See Segment.js for details
     */
    intersection: function( ray ) {
      // be lazy. transform it into the space of a non-elliptical arc.
      var unitTransform = this.getUnitTransform();
      var rayInUnitCircleSpace = unitTransform.inverseRay2( ray );
      var hits = this.getUnitArcSegment().intersection( rayInUnitCircleSpace );

      return _.map( hits, function( hit ) {
        var transformedPoint = unitTransform.transformPosition2( hit.point );
        return {
          distance: ray.position.distance( transformedPoint ),
          point: transformedPoint,
          normal: unitTransform.inverseNormal2( hit.normal ),
          wind: hit.wind
        };
      } );
    },

    /**
     * Returns the resultant winding number of this ray intersecting this arc.
     * @param {Ray2} ray
     * @returns {number}
     */
    windingIntersection: function( ray ) {
      // be lazy. transform it into the space of a non-elliptical arc.
      var rayInUnitCircleSpace = this.getUnitTransform().inverseRay2( ray );
      return this.getUnitArcSegment().windingIntersection( rayInUnitCircleSpace );
    },

    /**
     * Draws this arc to the 2D Canvas context, assuming the context's current location is already at the start point
     * @param {CanvasRenderingContext2D} context
     */
    writeToContext: function( context ) {
      if ( context.ellipse ) {
        context.ellipse( this._center.x, this._center.y, this._radiusX, this._radiusY, this._rotation, this._startAngle, this._endAngle, this._anticlockwise );
      }
      else {
        // fake the ellipse call by using transforms
        this.getUnitTransform().getMatrix().canvasAppendTransform( context );
        context.arc( 0, 0, 1, this._startAngle, this._endAngle, this._anticlockwise );
        this.getUnitTransform().getInverse().canvasAppendTransform( context );
      }
    },

    /**
     * Returns this elliptical arc transformed by a matrix
     * An immutable method
     * @param {Matrix3} matrix
     * @returns {EllipticalArc}
     */
    transformed: function( matrix ) {
      var transformedSemiMajorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusX, this._rotation ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
      var transformedSemiMinorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusY, this._rotation + Math.PI / 2 ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
      var rotation = transformedSemiMajorAxis.angle();
      var radiusX = transformedSemiMajorAxis.magnitude();
      var radiusY = transformedSemiMinorAxis.magnitude();

      var reflected = matrix.getDeterminant() < 0;

      // reverse the 'clockwiseness' if our transform includes a reflection
      // TODO: check reflections. swapping angle signs should fix clockwiseness
      var anticlockwise = reflected ? !this._anticlockwise : this._anticlockwise;
      var startAngle = reflected ? -this._startAngle : this._startAngle;
      var endAngle = reflected ? -this._endAngle : this._endAngle;

      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
      }

      return new kite.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
    }
  } );

  /**
   * Add getters and setters
   */
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'center' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'radiusX' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'radiusY' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'rotation' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'startAngle' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'endAngle' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'anticlockwise' );

  // adapted from http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
  // transforms the unit circle onto our ellipse
  /**
   *
   * @param {Vector2} center
   * @param {number} radiusX
   * @param {number} radiusY
   * @param {number} rotation
   * @returns {Transform3}
   */
  EllipticalArc.computeUnitTransform = function( center, radiusX, radiusY, rotation ) {
    return new Transform3( Matrix3.translation( center.x, center.y ) // TODO: convert to Matrix3.translation( this._center) when available
      .timesMatrix( Matrix3.rotation2( rotation ) )
      .timesMatrix( Matrix3.scaling( radiusX, radiusY ) ) );
  };

  return EllipticalArc;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Linear segment
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/segments/Line',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/util/Overlap'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Util = require( 'DOT/Util' );

  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  var Overlap = require( 'KITE/util/Overlap' );

  var scratchVector2 = new Vector2();

  /**
   *
   * @param {Vector2} start
   * @param {Vector2} end
   * @constructor
   */
  function Line( start, end ) {
    Segment.call( this );

    this._start = start; // @private {Vector2}
    this._end = end; // @private  {Vector2}

    this.invalidate();
  }

  kite.register( 'Line', Line );

  inherit( Segment, Line, {

    /**
     * Returns the position parametrically, with 0 <= t <= 1.
     * @public
     *
     * NOTE: positionAt( 0 ) will return the start of the segment, and positionAt( 1 ) will return the end of the
     * segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );

      return this._start.plus( this._end.minus( this._start ).times( t ) );
    },

    /**
     * Returns the non-normalized tangent (dx/dt, dy/dt) of this segment at the parametric value of t, with 0 <= t <= 1.
     * @public
     *
     * NOTE: tangentAt( 0 ) will return the tangent at the start of the segment, and tangentAt( 1 ) will return the
     * tangent at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Vector2}
     */
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );

      // tangent always the same, just use the start tangent
      return this.getStartTangent();
    },

    /**
     * Returns the signed curvature of the segment at the parametric value t, where 0 <= t <= 1.
     * @public
     *
     * The curvature will be positive for visual clockwise / mathematical counterclockwise curves, negative for opposite
     * curvature, and 0 for no curvature.
     *
     * NOTE: curvatureAt( 0 ) will return the curvature at the start of the segment, and curvatureAt( 1 ) will return
     * the curvature at the end of the segment.
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {number}
     */
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );

      return 0; // no curvature on a straight line segment
    },

    /**
     * Returns an array with up to 2 sub-segments, split at the parametric t value. Together (in order) they should make
     * up the same shape as the current segment.
     * @public
     *
     * This method is part of the Segment API. See Segment.js's constructor for more API documentation.
     *
     * @param {number} t
     * @returns {Array.<Segment>}
     */
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );

      // If t is 0 or 1, we only need to return 1 segment
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }

      var pt = this.positionAt( t );
      return [
        new kite.Line( this._start, pt ),
        new kite.Line( pt, this._end )
      ];
    },

    /**
     * Clears cached information, should be called when any of the 'constructor arguments' are mutated.
     * @public
     */
    invalidate: function() {
      // Lazily-computed derived information
      this._tangent = null; // {Vector2|null}
      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}

      this.trigger0( 'invalidated' );
    },

    /**
     * Returns a normalized unit vector that is tangent to this line (at the starting point)
     * the unit vectors points toward the end points.
     * @returns {Vector2}
     */
    getStartTangent: function() {
      if ( this._tangent === null ) {
        // TODO: allocation reduction
        this._tangent = this._end.minus( this._start ).normalized();
      }
      return this._tangent;
    },
    get startTangent() { return this.getStartTangent(); },

    /**
     * Returns the normalized unit vector that is tangent to this line
     * same as getStartTangent, since this is a straight line
     * @returns {Vector2}
     */
    getEndTangent: function() {
      return this.getStartTangent();
    },
    get endTangent() { return this.getEndTangent(); },

    /**
     * Returns the bounds of this segment.
     * @public
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      // TODO: allocation reduction
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING.copy().addPoint( this._start ).addPoint( this._end );
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    /**
     * Returns the bounding box for this transformed Line
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    getBoundsWithTransform: function( matrix ) {
      // uses mutable calls
      var bounds = Bounds2.NOTHING.copy();
      bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._start ) ) );
      bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._end ) ) );
      return bounds;
    },

    /**
     * Returns a list of non-degenerate segments that are equivalent to this segment. Generally gets rid (or simplifies)
     * invalid or repeated segments.
     * @public
     *
     * @returns {Array.<Segment>}
     */
    getNondegenerateSegments: function() {
      // if it is degenerate (0-length), just ignore it
      if ( this._start.equals( this._end ) ) {
        return [];
      }
      else {
        return [ this ];
      }
    },

    /**
     * Returns a string containing the SVG path. assumes that the start point is already provided,
     * so anything that calls this needs to put the M calls first
     * @returns {string}
     */
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        this._svgPathFragment = 'L ' + kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },

    /**
     * Returns an array of Line that will draw an offset curve on the logical left side
     * @param {number} lineWidth
     * @returns {Array.<Line>}
     */
    strokeLeft: function( lineWidth ) {
      var offset = this.getEndTangent().perpendicular().negated().times( lineWidth / 2 );
      return [ new kite.Line( this._start.plus( offset ), this._end.plus( offset ) ) ];
    },
    /**
     * Returns an array of Line that will draw an offset curve on the logical right side
     * @param {number} lineWidth
     * @returns {Array.<Line>}
     */
    strokeRight: function( lineWidth ) {
      var offset = this.getStartTangent().perpendicular().times( lineWidth / 2 );
      return [ new kite.Line( this._end.plus( offset ), this._start.plus( offset ) ) ];
    },

    /**
     * In general, this method returns a list of t values where dx/dt or dy/dt is 0 where 0 < t < 1. subdividing on these will result in monotonic segments
     * Since lines are already monotone, it returns an empty array
     * @returns {Array}
     */
    getInteriorExtremaTs: function() { return []; },

    /**
     * Hit-tests this segment with the ray. An array of all intersections of the ray with this segment will be returned.
     * For details, see the documentation in Segment.js
     * @public
     *
     * @param {Ray2} ray
     * @returns {Array.<Intersection>} - See Segment.js for details
     */
    intersection: function( ray ) {
      // We solve for the parametric line-line intersection, and then ensure the parameters are within both
      // the line segment and forwards from the ray.

      var result = [];

      var start = this._start;
      var end = this._end;

      var diff = end.minus( start );

      if ( diff.magnitudeSquared() === 0 ) {
        return result;
      }

      var denom = ray.direction.y * diff.x - ray.direction.x * diff.y;

      // If denominator is 0, the lines are parallel or coincident
      if ( denom === 0 ) {
        return result;
      }

      // linear parameter where start (0) to end (1)
      var t = ( ray.direction.x * ( start.y - ray.position.y ) - ray.direction.y * ( start.x - ray.position.x ) ) / denom;

      // check that the intersection point is between the line segment's endpoints
      if ( t < 0 || t >= 1 ) {
        return result;
      }

      // linear parameter where ray.position (0) to ray.position+ray.direction (1)
      var s = ( diff.x * ( start.y - ray.position.y ) - diff.y * ( start.x - ray.position.x ) ) / denom;

      // bail if it is behind our ray
      if ( s < 0.00000001 ) {
        return result;
      }

      // return the proper winding direction depending on what way our line intersection is "pointed"
      var perp = diff.perpendicular();
      result.push( {
        distance: s,
        point: start.plus( diff.times( t ) ),
        normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
        wind: ray.direction.perpendicular().dot( diff ) < 0 ? 1 : -1,
        segment: this
      } );
      return result;
    },

    /**
     * Returns the resultant winding number of a ray intersecting this line.
     * @param {Ray2} ray
     * @returns {number}
     */
    windingIntersection: function( ray ) {
      var hits = this.intersection( ray );
      if ( hits.length ) {
        return hits[ 0 ].wind;
      }
      else {
        return 0;
      }
    },

    /**
     * Draws this line to the 2D Canvas context, assuming the context's current location is already at the start point
     * @param {CanvasRenderingContext2D} context
     */
    writeToContext: function( context ) {
      context.lineTo( this._end.x, this._end.y );
    },

    /**
     * Returns a new Line that represents this line after transformation by the matrix
     * @param {Matrix3} matrix
     * @returns {Line}
     */
    transformed: function( matrix ) {
      return new kite.Line( matrix.timesVector2( this._start ), matrix.timesVector2( this._end ) );
    },

    /**
     * Returns an object that gives information about the closest point (on a line segment) to the point argument
     * @param {Vector2} point
     * @returns {Array.<Object>}
     */
    explicitClosestToPoint: function( point ) {
      var diff = this._end.minus( this._start );
      var t = point.minus( this._start ).dot( diff ) / diff.magnitudeSquared();
      t = Util.clamp( t, 0, 1 );
      var closestPoint = this.positionAt( t );
      return [
        {
          segment: this,
          t: t,
          closestPoint: closestPoint,
          distanceSquared: point.distanceSquared( closestPoint )
        }
      ];
    },

    /**
     * Given the current curve parameterized by t, will return a curve parameterized by x where t = a * x + b
     * @param {number} a
     * @param {number} b
     * @returns {Line}
     */
    reparameterized: function( a, b ) {
      return new kite.Line( this.positionAt( b ), this.positionAt( a + b ) );
    },

    /**
     * Convert a line in the $(theta,r)$ plane of the form $(\theta_1,r_1)$ to $(\theta_2,r_2)$ and
     * converts to the the cartesian coordinate system
     * E.g. a polar line (0,1) to (2 Pi,1) would be mapped to a circle of radius 1
     * @param {Object} options
     * @returns {Array.<Line>|Array.<Arc>|Array.<Segment>}
     */
    polarToCartesian: function( options ) {
      // x represent an angle whereas y represent a radius
      if ( this._start.x === this._end.x ) {
        // angle is the same, we are still a line segment!
        return [ new kite.Line( Vector2.createPolar( this._start.y, this._start.x ), Vector2.createPolar( this._end.y, this._end.x ) ) ];
      }
      else if ( this._start.y === this._end.y ) {
        // we have a constant radius, so we are a circular arc
        return [ new kite.Arc( Vector2.ZERO, this._start.y, this._start.x, this._end.x, this._start.x > this._end.x ) ];
      }
      else {
        return this.toPiecewiseLinearSegments( options );
      }
    }
  } );

  /**
   * Add getters and setters
   */
  Segment.addInvalidatingGetterSetter( Line, 'start' );
  Segment.addInvalidatingGetterSetter( Line, 'end' );

  /**
   * Determine whether two lines overlap over a continuous section, and if so finds the a,b pair such that
   * p( t ) === q( a * t + b ).
   * @public
   *
   * @param {Line} line1
   * @param {Line} line2
   * @returns {null|{a:number,b:number}} - The solution, if there is one (and only one)
   */
  Line.getOverlaps = function( line1, line2 ) {
    assert && assert( line1 instanceof Line, 'first Line is not an instance of Line' );
    assert && assert( line2 instanceof Line, 'second Line is not an instance of Line' );

    /*
     * NOTE: For implementation details in this function, please see Cubic.getOverlaps. It goes over all of the
     * same implementation details, but instead our bezier matrix is a 2x2:
     *
     * [  1  0 ]
     * [ -1  1 ]
     *
     * And we use the upper-left section of (at+b) adjustment matrix relevant for the line.
     */

    var noOverlap = [];

    // Efficiently compute the multiplication of the bezier matrix:
    var p0x = line1._start.x;
    var p1x = -1 * line1._start.x + line1._end.x;
    var p0y = line1._start.y;
    var p1y = -1 * line1._start.y + line1._end.y;
    var q0x = line2._start.x;
    var q1x = -1 * line2._start.x + line2._end.x;
    var q0y = line2._start.y;
    var q1y = -1 * line2._start.y + line2._end.y;

    // Determine the candidate overlap
    var xOverlap = Segment.polynomialGetOverlapLinear( p0x, p1x, q0x, q1x );
    var yOverlap = Segment.polynomialGetOverlapLinear( p0y, p1y, q0y, q1y );
    var overlap = ( xOverlap === null || xOverlap === true ) ? yOverlap : xOverlap;
    if ( overlap === null || overlap === true ) {
      return noOverlap; // No way to pin down an overlap
    }

    // Grab an approximate value to use as epsilon (that is scale-independent)
    var approxEpsilon = ( Math.abs( p0x ) + Math.abs( p1x ) +
                          Math.abs( p0y ) + Math.abs( p1y ) +
                          Math.abs( q0x ) + Math.abs( q1x ) +
                          Math.abs( q0y ) + Math.abs( q1y ) ) * 1e-6;

    var a = overlap.a;
    var b = overlap.b;

    // Check that the formula is satisfied (2 equations per x and y each)
    if ( Math.abs( q0x + b * q1x - p0x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1x - p1x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( q0y + b * q1y - p0y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1y - p1y ) > approxEpsilon ) { return noOverlap; }

    var qt0 = b;
    var qt1 = a + b;

    // TODO: do we want an epsilon in here to be permissive?
    if ( ( qt0 > 1 && qt1 > 1 ) || ( qt0 < 0 && qt1 < 0 ) ) {
      return noOverlap;
    }

    return [ new Overlap( a, b ) ];
  };

  return Line;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Styles needed to determine a stroked line shape.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/util/LineStyles',['require','KITE/kite','DOT/Util','PHET_CORE/inherit','KITE/segments/Arc','KITE/segments/Line'],function( require ) {
  'use strict';

  var kite = require( 'KITE/kite' );
  var Util = require( 'DOT/Util' );
  var inherit = require( 'PHET_CORE/inherit' );

  var Arc = require( 'KITE/segments/Arc' );
  var Line = require( 'KITE/segments/Line' );

  // constants
  var lineLineIntersection = Util.lineLineIntersection;

  var DEFAULT_OPTIONS = {
    lineWidth: 1,
    lineCap: 'butt',
    lineJoin: 'miter',
    lineDashOffset: 0,
    miterLimit: 10
  };

  /**
   *
   * @param {Object} [args]
   * @constructor
   */
  function LineStyles( args ) {
    if ( args === undefined ) {
      args = {};
    }
    this.lineWidth = args.lineWidth !== undefined ? args.lineWidth : DEFAULT_OPTIONS.lineWidth;
    this.lineCap = args.lineCap !== undefined ? args.lineCap : DEFAULT_OPTIONS.lineCap; // butt, round, square
    this.lineJoin = args.lineJoin !== undefined ? args.lineJoin : DEFAULT_OPTIONS.lineJoin; // miter, round, bevel
    this.lineDash = args.lineDash ? args.lineDash : []; // [] is default, otherwise an array of numbers
    this.lineDashOffset = args.lineDashOffset !== undefined ? args.lineDashOffset : DEFAULT_OPTIONS.lineDashOffset; // 0 default, any number
    this.miterLimit = args.miterLimit !== undefined ? args.miterLimit : DEFAULT_OPTIONS.miterLimit; // see https://svgwg.org/svg2-draft/painting.html for miterLimit computations

    assert && assert( Array.isArray( this.lineDash ) );
  }

  kite.register( 'LineStyles', LineStyles );

  inherit( Object, LineStyles, {

    /**
     * Determines of this lineStyles is equal to the other LineStyles
     * @param {Object} other - arguments of LineStyles
     * @returns {boolean}
     */
    equals: function( other ) {
      var typical = this.lineWidth === other.lineWidth &&
                    this.lineCap === other.lineCap &&
                    this.lineJoin === other.lineJoin &&
                    this.miterLimit === other.miterLimit &&
                    this.lineDashOffset === other.lineDashOffset;
      if ( !typical ) {
        return false;
      }

      if ( this.lineDash.length === other.lineDash.length ) {
        for ( var i = 0; i < this.lineDash.length; i++ ) {
          if ( this.lineDash[ i ] !== other.lineDash[ i ] ) {
            return false;
          }
        }
      }
      else {
        // line dashes must be different
        return false;
      }

      return true;
    },

    /**
     * Creates an array of Segments that make up a line join, to the left side.
     *
     * Joins two segments together on the logical "left" side, at 'center' (where they meet), and un-normalized tangent
     * vectors in the direction of the stroking. To join on the "right" side, switch the tangent order and negate them.
     *
     * @param {Vector2} center
     * @param {Vector2} fromTangent
     * @param {Vector2} toTangent
     * @returns {Array.<Line>|null}
     */
    leftJoin: function( center, fromTangent, toTangent ) {
      fromTangent = fromTangent.normalized();
      toTangent = toTangent.normalized();

      // where our join path starts and ends
      var fromPoint = center.plus( fromTangent.perpendicular().negated().times( this.lineWidth / 2 ) );
      var toPoint = center.plus( toTangent.perpendicular().negated().times( this.lineWidth / 2 ) );

      var bevel = ( fromPoint.equals( toPoint ) ? [] : [ new Line( fromPoint, toPoint ) ] );

      // only insert a join on the non-acute-angle side
      if ( fromTangent.perpendicular().dot( toTangent ) > 0 ) {
        switch( this.lineJoin ) {
          case 'round':
            var fromAngle = fromTangent.angle() + Math.PI / 2;
            var toAngle = toTangent.angle() + Math.PI / 2;
            return [ new Arc( center, this.lineWidth / 2, fromAngle, toAngle, true ) ];
          case 'miter':
            var theta = fromTangent.angleBetween( toTangent.negated() );
            if ( 1 / Math.sin( theta / 2 ) <= this.miterLimit && theta < Math.PI - 0.00001 ) {
              // draw the miter
              var miterPoint = lineLineIntersection( fromPoint, fromPoint.plus( fromTangent ), toPoint, toPoint.plus( toTangent ) );
              return [
                new Line( fromPoint, miterPoint ),
                new Line( miterPoint, toPoint )
              ];
            }
            else {
              // angle too steep, use bevel instead. same as below, but copied for linter
              return bevel;
            }
          case 'bevel':
            return bevel;
          default:
            throw new Error( 'invalid lineJoin: ' + this.lineJoin );
        }
      }
      else {
        // no join necessary here since we have the acute angle. just simple lineTo for now so that the next segment starts from the right place
        // TODO: can we prevent self-intersection here?
        return bevel;
      }
    },

    /**
     * Creates an array of Segments that make up a line join, to the right side.
     *
     * Joins two segments together on the logical "right" side, at 'center' (where they meet), and normalized tangent
     * vectors in the direction of the stroking. To join on the "left" side, switch the tangent order and negate them.
     * @param {Vector2} center
     * @param {Vector2} fromTangent
     * @param {Vector2} toTangent
     * @returns {Array.<Line>|null}
     */
    rightJoin: function( center, fromTangent, toTangent ) {
      return this.leftJoin( center, toTangent.negated(), fromTangent.negated() );
    },

    /**
     * Creates an array of Segments that make up a line cap from the endpoint 'center' in the direction of the tangent
     *
     * @param {Vector2} center
     * @param {Vector2} tangent
     * @returns {Array.<Arc>|Array.<Line>}
     */
    cap: function( center, tangent ) {
      tangent = tangent.normalized();

      var fromPoint = center.plus( tangent.perpendicular().times( -this.lineWidth / 2 ) );
      var toPoint = center.plus( tangent.perpendicular().times( this.lineWidth / 2 ) );

      switch( this.lineCap ) {
        case 'butt':
          return [ new Line( fromPoint, toPoint ) ];
        case 'round':
          var tangentAngle = tangent.angle();
          return [ new Arc( center, this.lineWidth / 2, tangentAngle + Math.PI / 2, tangentAngle - Math.PI / 2, true ) ];
        case 'square':
          var toLeft = tangent.perpendicular().negated().times( this.lineWidth / 2 );
          var toRight = tangent.perpendicular().times( this.lineWidth / 2 );
          var toFront = tangent.times( this.lineWidth / 2 );

          var left = center.plus( toLeft ).plus( toFront );
          var right = center.plus( toRight ).plus( toFront );
          return [
            new Line( fromPoint, left ),
            new Line( left, right ),
            new Line( right, toPoint )
          ];
        default:
          throw new Error( 'invalid lineCap: ' + this.lineCap );
      }
    }
  } );

  LineStyles.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

  return kite.LineStyles;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A Canvas-style stateful (mutable) subpath, which tracks segments in addition to the points.
 *
 * See http://www.w3.org/TR/2dcontext/#concept-path
 * for the path / subpath Canvas concept.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/util/Subpath',['require','DOT/Bounds2','PHET_CORE/inherit','AXON/Events','KITE/kite','KITE/segments/Line','KITE/segments/Arc','KITE/util/LineStyles'],function( require ) {
  'use strict';

  var Bounds2 = require( 'DOT/Bounds2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );

  var kite = require( 'KITE/kite' );

  var Line = require( 'KITE/segments/Line' );
  var Arc = require( 'KITE/segments/Arc' );
  var LineStyles = require( 'KITE/util/LineStyles' );

  /**
   * all arguments optional (they are for the copy() method)
   * @param {Array.<Segment>} [segments]
   * @param {Array.<Vector2>} [points]
   * @param {boolean} [closed]
   * @constructor
   */
  function Subpath( segments, points, closed ) {
    Events.call( this );

    var self = this;

    this.segments = [];

    // recombine points if necessary, based off of start points of segments + the end point of the last segment
    this.points = points || ( ( segments && segments.length ) ? _.map( segments, function( segment ) { return segment.start; } ).concat( segments[ segments.length - 1 ].end ) : [] );
    this.closed = !!closed;

    // cached stroked shape (so hit testing can be done quickly on stroked shapes)
    this._strokedSubpaths = null;
    this._strokedSubpathsComputed = false;
    this._strokedStyles = null;

    this._bounds = null; // {Bounds2 | null} - If non-null, the bounds of the subpath

    this._invalidateListener = this.invalidate.bind( this );
    this._invalidatingPoints = false; // So we can invalidate all of the points without firing invalidation tons of times

    // Add all segments directly (hooks up invalidation listeners properly)
    if ( segments ) {
      for ( var i = 0; i < segments.length; i++ ) {
        _.each( segments[ i ].getNondegenerateSegments(), function( segment ) {
          self.addSegmentDirectly( segment );
        } );
      }
    }
  }

  kite.register( 'Subpath', Subpath );

  inherit( Events, Subpath, {

    /**
     * Returns the bounds of this subpath. It is the bounding-box union of the bounds of each segment contained.
     * @public
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      if ( this._bounds === null ) {
        var bounds = Bounds2.NOTHING.copy();
        _.each( this.segments, function( segment ) {
          bounds.includeBounds( segment.getBounds() );
        } );
        this._bounds = bounds;
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    /**
     * Returns an immutable copy of this subpath
     * @returns {Subpath}
     */
    copy: function() {
      return new Subpath( this.segments.slice( 0 ), this.points.slice( 0 ), this.closed );
    },

    invalidatePoints: function() {
      this._invalidatingPoints = true;

      var numSegments = this.segments.length;
      for ( var i = 0; i < numSegments; i++ ) {
        this.segments[ i ].invalidate();
      }

      this._invalidatingPoints = false;
      this.invalidate();
    },

    invalidate: function() {
      if ( !this._invalidatingPoints ) {
        this._bounds = null;
        this._strokedSubpathsComputed = false;
        this.trigger0( 'invalidated' );
      }
    },

    /**
     * Adds a point to this subpath
     * @param {Vector2} point
     * @returns {Subpath}
     */
    addPoint: function( point ) {
      this.points.push( point );

      return this; // allow chaining
    },

    /**
     * @private - REALLY! Make sure we invalidate() after this is called
     * @param {Segment} segment
     * @returns {Subpath}
     */
    addSegmentDirectly: function( segment ) {
      assert && assert( segment.start.isFinite(), 'Segment start is infinite' );
      assert && assert( segment.end.isFinite(), 'Segment end is infinite' );
      assert && assert( segment.startTangent.isFinite(), 'Segment startTangent is infinite' );
      assert && assert( segment.endTangent.isFinite(), 'Segment endTangent is infinite' );
      assert && assert( segment.bounds.isEmpty() || segment.bounds.isFinite(), 'Segment bounds is infinite and non-empty' );
      this.segments.push( segment );

      // Hook up an invalidation listener, so if this segment is invalidated, it will invalidate our subpath!
      // NOTE: if we add removal of segments, we'll need to remove these listeners, or we'll leak!
      segment.onStatic( 'invalidated', this._invalidateListener );

      return this; // allow chaining
    },

    /**
     * Adds a segment to this subpath
     * @param {Segment} segment
     * @returns {Subpath}
     */
    addSegment: function( segment ) {
      var nondegenerateSegments = segment.getNondegenerateSegments();
      var numNondegenerateSegments = nondegenerateSegments.length;
      for ( var i = 0; i < numNondegenerateSegments; i++ ) {
        this.addSegmentDirectly( segment );
      }
      this.invalidate(); // need to invalidate after addSegmentDirectly

      return this; // allow chaining
    },

    /**
     * Adds a line segment from the start to end (if non-zero length) and marks the subpath as closed.
     * NOTE: normally you just want to mark the subpath as closed, and not generate the closing segment this way?
     */
    addClosingSegment: function() {
      if ( this.hasClosingSegment() ) {
        var closingSegment = this.getClosingSegment();
        this.addSegmentDirectly( closingSegment );
        this.invalidate(); // need to invalidate after addSegmentDirectly
        this.addPoint( this.getFirstPoint() );
        this.closed = true;
      }
    },

    // TODO: consider always adding a closing segment into our segments list for easier processing!! see addClosingSegment()
    /**
     * Sets this subpath to be a closed path
     */
    close: function() {
      this.closed = true;
    },

    /**
     * Returns the numbers of points in this subpath
     * @returns {number}
     */
    getLength: function() {
      return this.points.length;
    },

    /**
     * Returns the first point of this subpath
     * @returns {Vector2}
     */
    getFirstPoint: function() {
      return _.first( this.points );
    },

    /**
     * Returns the last point of this subpath
     * @returns {Vector2}
     */
    getLastPoint: function() {
      return _.last( this.points );
    },

    /**
     * Returns the first segment of this subpath
     * @returns {Segment}
     */
    getFirstSegment: function() {
      return _.first( this.segments );
    },

    /**
     * Returns the last segment of this subpath
     * @returns {Segment}
     */
    getLastSegment: function() {
      return _.last( this.segments );
    },

    /**
     * Determines if this subpath is drawable, i.e. if it contains asny segments
     * @returns {boolean}
     */
    isDrawable: function() {
      return this.segments.length > 0;
    },

    /**
     * Determines if this subpath is a closed path, i.e. if the flag is set to closed
     * @returns {boolean}
     */
    isClosed: function() {
      return this.closed;
    },

    /**
     * Determines if this subpath is a closed path, i.e. if it has a closed segment
     * @returns {boolean}
     */
    hasClosingSegment: function() {
      return !this.getFirstPoint().equalsEpsilon( this.getLastPoint(), 0.000000001 );
    },

    /**
     * Returns a line that would closed this subpath
     * @returns {Line}
     */
    getClosingSegment: function() {
      assert && assert( this.hasClosingSegment(), 'Implicit closing segment unnecessary on a fully closed path' );
      return new Line( this.getLastPoint(), this.getFirstPoint() );
    },

    /**
     * Draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point
     * @param {CanvasRenderingContext2D} context
     */
    writeToContext: function( context ) {
      if ( this.isDrawable() ) {
        var startPoint = this.getFirstSegment().start;
        context.moveTo( startPoint.x, startPoint.y ); // the segments assume the current context position is at their start

        var len = this.segments.length;
        for ( var i = 0; i < len; i++ ) {
          this.segments[ i ].writeToContext( context );
        }

        if ( this.closed ) {
          context.closePath();
        }
      }
    },

    /**
     * @param {Object} [options] -           with the following options provided:
     *  - minLevels:                       how many levels to force subdivisions
     *  - maxLevels:                       prevent subdivision past this level
     *  - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve
     *  - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments
     *  - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
     *  - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
     *                                     instead of using our brute-force logic
     * @returns {Subpath}
     */
    toPiecewiseLinear: function( options ) {
      assert && assert( !options.pointMap, 'For use with pointMap, please use nonlinearTransformed' );
      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
        return segment.toPiecewiseLinearSegments( options );
      } ) ), null, this.closed );
    },

    /**
     *
     * @param {Matrix3} matrix
     * @returns {Subpath}
     */
    transformed: function( matrix ) {
      return new Subpath(
        _.map( this.segments, function( segment ) { return segment.transformed( matrix ); } ),
        _.map( this.points, function( point ) { return matrix.timesVector2( point ); } ),
        this.closed
      );
    },

    /**
     *
     * @param {Object} [options] -           with the following options provided:
     *  - minLevels:                       how many levels to force subdivisions
     *  - maxLevels:                       prevent subdivision past this level
     *  - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve
     *  - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments
     *  - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
     *  - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
     *                                     instead of using our brute-force logic
     * @returns {Subpath}
     */
    nonlinearTransformed: function( options ) {
      // specify an actual closing segment, so it can be mapped properly by any non-linear transforms
      // TODO: always create and add the closing segments when the subpath is closed!!!
      if ( this.closed && this.hasClosingSegment() ) {
        this.addClosingSegment();
      }

      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
        // check for this segment's support for the specific transform or discretization being applied
        if ( options.methodName && segment[ options.methodName ] ) {
          return segment[ options.methodName ]( options );
        }
        else {
          return segment.toPiecewiseLinearSegments( options );
        }
      } ) ), null, this.closed );
    },

    /**
     * Returns the bounds of this subpath when transform by a matrix
     * An immutable method
     * @param {Matrix3} matrix
     * @returns {bounds}
     */
    getBoundsWithTransform: function( matrix ) {
      var bounds = Bounds2.NOTHING.copy();
      var numSegments = this.segments.length;
      for ( var i = 0; i < numSegments; i++ ) {
        bounds.includeBounds( this.segments[ i ].getBoundsWithTransform( matrix ) );
      }
      return bounds;
    },

    /**
     * Returns a subpath that is offset from this subpath by a distance
     * {experimental} returns a subpath
     * @param {number} distance
     * @returns {Subpath}
     */
    offset: function( distance ) {
      if ( !this.isDrawable() ) {
        return new Subpath( [], null, this.closed );
      }
      if ( distance === 0 ) {
        return new Subpath( this.segments.slice(), null, this.closed );
      }

      var i;

      var regularSegments = this.segments.slice();
      if ( this.closed && this.hasClosingSegment() ) {
        regularSegments.push( this.getClosingSegment() );
      }
      var offsets = [];

      for ( i = 0; i < regularSegments.length; i++ ) {
        offsets.push( regularSegments[ i ].strokeLeft( 2 * distance ) );
      }

      var segments = [];
      for ( i = 0; i < regularSegments.length; i++ ) {
        if ( this.closed || i > 0 ) {
          var previousI = ( i > 0 ? i : regularSegments.length ) - 1;
          var center = regularSegments[ i ].start;
          var fromTangent = regularSegments[ previousI ].endTangent;
          var toTangent = regularSegments[ i ].startTangent;

          var startAngle = fromTangent.perpendicular().negated().times( distance ).angle();
          var endAngle = toTangent.perpendicular().negated().times( distance ).angle();
          var anticlockwise = fromTangent.perpendicular().dot( toTangent ) > 0;
          segments.push( new Arc( center, Math.abs( distance ), startAngle, endAngle, anticlockwise ) );
        }
        segments = segments.concat( offsets[ i ] );
      }

      return new Subpath( segments, null, this.closed );
    },

    /**
     * Returns an array of subpaths (one if open, two if closed) that represent a stroked copy of this subpath.
     * @param {LineStyles} lineStyles
     * @returns {Array.<Subpath>}
     */
    stroked: function( lineStyles ) {
      // non-drawable subpaths convert to empty subpaths
      if ( !this.isDrawable() ) {
        return [];
      }

      if ( lineStyles === undefined ) {
        lineStyles = new LineStyles();
      }

      // return a cached version if possible
      if ( this._strokedSubpathsComputed && this._strokedStyles.equals( lineStyles ) ) {
        return this._strokedSubpaths;
      }

      var lineWidth = lineStyles.lineWidth;

      var i;
      var leftSegments = [];
      var rightSegments = [];
      var firstSegment = this.getFirstSegment();
      var lastSegment = this.getLastSegment();

      function appendLeftSegments( segments ) {
        leftSegments = leftSegments.concat( segments );
      }

      function appendRightSegments( segments ) {
        rightSegments = rightSegments.concat( segments );
      }

      // we don't need to insert an implicit closing segment if the start and end points are the same
      var alreadyClosed = lastSegment.end.equals( firstSegment.start );
      // if there is an implicit closing segment
      var closingSegment = alreadyClosed ? null : new Line( this.segments[ this.segments.length - 1 ].end, this.segments[ 0 ].start );

      // stroke the logical "left" side of our path
      for ( i = 0; i < this.segments.length; i++ ) {
        if ( i > 0 ) {
          appendLeftSegments( lineStyles.leftJoin( this.segments[ i ].start, this.segments[ i - 1 ].endTangent, this.segments[ i ].startTangent ) );
        }
        appendLeftSegments( this.segments[ i ].strokeLeft( lineWidth ) );
      }

      // stroke the logical "right" side of our path
      for ( i = this.segments.length - 1; i >= 0; i-- ) {
        if ( i < this.segments.length - 1 ) {
          appendRightSegments( lineStyles.rightJoin( this.segments[ i ].end, this.segments[ i ].endTangent, this.segments[ i + 1 ].startTangent ) );
        }
        appendRightSegments( this.segments[ i ].strokeRight( lineWidth ) );
      }

      var subpaths;
      if ( this.closed ) {
        if ( alreadyClosed ) {
          // add the joins between the start and end
          appendLeftSegments( lineStyles.leftJoin( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );
          appendRightSegments( lineStyles.rightJoin( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );
        }
        else {
          // logical "left" stroke on the implicit closing segment
          appendLeftSegments( lineStyles.leftJoin( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );
          appendLeftSegments( closingSegment.strokeLeft( lineWidth ) );
          appendLeftSegments( lineStyles.leftJoin( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );

          // logical "right" stroke on the implicit closing segment
          appendRightSegments( lineStyles.rightJoin( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );
          appendRightSegments( closingSegment.strokeRight( lineWidth ) );
          appendRightSegments( lineStyles.rightJoin( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );
        }
        subpaths = [
          new Subpath( leftSegments, null, true ),
          new Subpath( rightSegments, null, true )
        ];
      }
      else {
        subpaths = [
          new Subpath( leftSegments.concat( lineStyles.cap( lastSegment.end, lastSegment.endTangent ) )
            .concat( rightSegments )
            .concat( lineStyles.cap( firstSegment.start, firstSegment.startTangent.negated() ) ),
            null, true )
        ];
      }

      this._strokedSubpaths = subpaths;
      this._strokedSubpathsComputed = true;
      this._strokedStyles = new LineStyles( lineStyles ); // shallow copy, since we consider linestyles to be mutable

      return subpaths;
    }
  } );

  return kite.Subpath;
} );

/*
 * NOTE: Generated from svgPath.pegjs using PEG.js, with added kite namespace and require.js compatibility.
 * See svgPath.pegjs for more documentation, or run 'grunt generate-svgPath-parser' to regenerate.
 */

define( 'KITE/parser/svgPath',['require','KITE/kite'],function( require ) {
  var kite = require( 'KITE/kite' );

  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */

  function quote( s ) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
    return '"' + s
                 .replace( /\\/g, '\\\\' )  // backslash
                 .replace( /"/g, '\\"' )    // closing quote character
                 .replace( /\x08/g, '\\b' ) // backspace
                 .replace( /\t/g, '\\t' )   // horizontal tab
                 .replace( /\n/g, '\\n' )   // line feed
                 .replace( /\f/g, '\\f' )   // form feed
                 .replace( /\r/g, '\\r' )   // carriage return
                 .replace( /[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape )
           + '"';
  }

  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function( input, startRule ) {
      var parseFunctions = {
        "svgPath": parse_svgPath,
        "movetoDrawtoCommandGroups": parse_movetoDrawtoCommandGroups,
        "movetoDrawtoCommandGroup": parse_movetoDrawtoCommandGroup,
        "drawtoCommands": parse_drawtoCommands,
        "drawtoCommand": parse_drawtoCommand,
        "moveto": parse_moveto,
        "movetoArgumentSequence": parse_movetoArgumentSequence,
        "closepath": parse_closepath,
        "lineto": parse_lineto,
        "linetoArgumentSequence": parse_linetoArgumentSequence,
        "horizontalLineto": parse_horizontalLineto,
        "horizontalLinetoArgumentSequence": parse_horizontalLinetoArgumentSequence,
        "verticalLineto": parse_verticalLineto,
        "verticalLinetoArgumentSequence": parse_verticalLinetoArgumentSequence,
        "curveto": parse_curveto,
        "curvetoArgumentSequence": parse_curvetoArgumentSequence,
        "curvetoArgument": parse_curvetoArgument,
        "smoothCurveto": parse_smoothCurveto,
        "smoothCurvetoArgumentSequence": parse_smoothCurvetoArgumentSequence,
        "smoothCurvetoArgument": parse_smoothCurvetoArgument,
        "quadraticBezierCurveto": parse_quadraticBezierCurveto,
        "quadraticBezierCurvetoArgumentSequence": parse_quadraticBezierCurvetoArgumentSequence,
        "quadraticBezierCurvetoArgument": parse_quadraticBezierCurvetoArgument,
        "smoothQuadraticBezierCurveto": parse_smoothQuadraticBezierCurveto,
        "smoothQuadraticBezierCurvetoArgumentSequence": parse_smoothQuadraticBezierCurvetoArgumentSequence,
        "ellipticalArc": parse_ellipticalArc,
        "ellipticalArcArgumentSequence": parse_ellipticalArcArgumentSequence,
        "ellipticalArcArgument": parse_ellipticalArcArgument,
        "coordinatePair": parse_coordinatePair,
        "nonnegativeNumber": parse_nonnegativeNumber,
        "number": parse_number,
        "flag": parse_flag,
        "commaWsp": parse_commaWsp,
        "comma": parse_comma,
        "floatingPointConstant": parse_floatingPointConstant,
        "fractionalConstant": parse_fractionalConstant,
        "exponent": parse_exponent,
        "sign": parse_sign,
        "digitSequence": parse_digitSequence,
        "digit": parse_digit,
        "wsp": parse_wsp
      };

      if ( startRule !== undefined ) {
        if ( parseFunctions[ startRule ] === undefined ) {
          throw new Error( "Invalid rule name: " + quote( startRule ) + "." );
        }
      }
      else {
        startRule = "svgPath";
      }

      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];

      function padLeft( input, padding, length ) {
        var result = input;

        var padLength = length - input.length;
        for ( var i = 0; i < padLength; i++ ) {
          result = padding + result;
        }

        return result;
      }

      function escape( ch ) {
        var charCode = ch.charCodeAt( 0 );
        var escapeChar;
        var length;

        if ( charCode <= 0xFF ) {
          escapeChar = 'x';
          length = 2;
        }
        else {
          escapeChar = 'u';
          length = 4;
        }

        return '\\' + escapeChar + padLeft( charCode.toString( 16 ).toUpperCase(), '0', length );
      }

      function matchFailed( failure ) {
        if ( pos < rightmostFailuresPos ) {
          return;
        }

        if ( pos > rightmostFailuresPos ) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }

        rightmostFailuresExpected.push( failure );
      }

      function parse_svgPath() {
        var result0, result1, result2, result3;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_wsp();
        while ( result1 !== null ) {
          result0.push( result1 );
          result1 = parse_wsp();
        }
        if ( result0 !== null ) {
          result1 = parse_movetoDrawtoCommandGroups();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = [];
            result3 = parse_wsp();
            while ( result3 !== null ) {
              result2.push( result3 );
              result3 = parse_wsp();
            }
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, path ) { return path ? path : []; })( pos0, result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_movetoDrawtoCommandGroups() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_movetoDrawtoCommandGroup();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_movetoDrawtoCommandGroups();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a.concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_movetoDrawtoCommandGroup();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return a; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_movetoDrawtoCommandGroup() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_moveto();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_drawtoCommands();
            result2 = result2 !== null ? result2 : "";
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, m, c ) { return c.length ? m.concat( c ) : m; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_drawtoCommands() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_drawtoCommand();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_drawtoCommands();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, cmd, cmds ) { return cmd.concat( cmds ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_drawtoCommand();
          if ( result0 !== null ) {
            result0 = (function( offset, cmd ) { return cmd; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_drawtoCommand() {
        var result0;

        result0 = parse_closepath();
        if ( result0 === null ) {
          result0 = parse_lineto();
          if ( result0 === null ) {
            result0 = parse_horizontalLineto();
            if ( result0 === null ) {
              result0 = parse_verticalLineto();
              if ( result0 === null ) {
                result0 = parse_curveto();
                if ( result0 === null ) {
                  result0 = parse_smoothCurveto();
                  if ( result0 === null ) {
                    result0 = parse_quadraticBezierCurveto();
                    if ( result0 === null ) {
                      result0 = parse_smoothQuadraticBezierCurveto();
                      if ( result0 === null ) {
                        result0 = parse_ellipticalArc();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }

      function parse_moveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 77 ) {
          result0 = "M";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"M\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_movetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) { return createMoveTo( args, false ); })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 109 ) {
            result0 = "m";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"m\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_movetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) { return createMoveTo( args, true ); })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_movetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, pair, list ) { return [ pair ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, pair ) { return [ pair ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_closepath() {
        var result0;
        var pos0;

        pos0 = pos;
        if ( input.charCodeAt( pos ) === 90 ) {
          result0 = "Z";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"Z\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 122 ) {
            result0 = "z";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"z\"" );
            }
          }
        }
        if ( result0 !== null ) {
          result0 = (function( offset, command ) { return { cmd: 'close' }; })( pos0, result0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_lineto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 76 ) {
          result0 = "L";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"L\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'lineTo',
                args: [ arg.x, arg.y ]
              };
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 108 ) {
            result0 = "l";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"l\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_linetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'lineToRelative',
                  args: [ arg.x, arg.y ]
                };
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_linetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_horizontalLineto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 72 ) {
          result0 = "H";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"H\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_horizontalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'horizontalLineTo',
                args: [ arg ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 104 ) {
            result0 = "h";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"h\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_horizontalLinetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'horizontalLineToRelative',
                  args: [ arg ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_horizontalLinetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_horizontalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_number();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_verticalLineto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 86 ) {
          result0 = "V";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"V\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_verticalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'verticalLineTo',
                args: [ arg ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 118 ) {
            result0 = "v";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"v\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_verticalLinetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'verticalLineToRelative',
                  args: [ arg ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_verticalLinetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_verticalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_number();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_curveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 67 ) {
          result0 = "C";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"C\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_curvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'cubicCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 99 ) {
            result0 = "c";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"c\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_curvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'cubicCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_curvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_curvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_curvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_curvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_curvetoArgument() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result3 = parse_commaWsp();
              result3 = result3 !== null ? result3 : "";
              if ( result3 !== null ) {
                result4 = parse_coordinatePair();
                if ( result4 !== null ) {
                  result0 = [ result0, result1, result2, result3, result4 ];
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b, c ) { return [ a.x, a.y, b.x, b.y, c.x, c.y ]; })( pos0, result0[ 0 ], result0[ 2 ], result0[ 4 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_smoothCurveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 83 ) {
          result0 = "S";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"S\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_smoothCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'smoothCubicCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 115 ) {
            result0 = "s";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"s\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_smoothCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'smoothCubicCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_smoothCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_smoothCurvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_smoothCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_smoothCurvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_smoothCurvetoArgument() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_quadraticBezierCurveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 81 ) {
          result0 = "Q";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"Q\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_quadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'quadraticCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 113 ) {
            result0 = "q";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"q\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_quadraticBezierCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'quadraticCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_quadraticBezierCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_quadraticBezierCurvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_quadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_quadraticBezierCurvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_quadraticBezierCurvetoArgument() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_smoothQuadraticBezierCurveto() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 84 ) {
          result0 = "T";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"T\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'smoothQuadraticCurveTo',
                args: [ arg.x, arg.y ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 116 ) {
            result0 = "t";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"t\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'smoothQuadraticCurveToRelative',
                  args: [ arg.x, arg.y ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_smoothQuadraticBezierCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_ellipticalArc() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 65 ) {
          result0 = "A";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"A\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_ellipticalArcArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              arg[ 2 ] *= Math.PI / 180;
              return { cmd: 'ellipticalArcTo', args: arg }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 97 ) {
            result0 = "a";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"a\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_ellipticalArcArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                arg[ 2 ] *= Math.PI / 180;
                return { cmd: 'ellipticalArcToRelative', args: arg }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_ellipticalArcArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_ellipticalArcArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_ellipticalArcArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_ellipticalArcArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_ellipticalArcArgument() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_nonnegativeNumber();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_nonnegativeNumber();
            if ( result2 !== null ) {
              result3 = parse_commaWsp();
              result3 = result3 !== null ? result3 : "";
              if ( result3 !== null ) {
                result4 = parse_number();
                if ( result4 !== null ) {
                  result5 = parse_commaWsp();
                  if ( result5 !== null ) {
                    result6 = parse_flag();
                    if ( result6 !== null ) {
                      result7 = parse_commaWsp();
                      result7 = result7 !== null ? result7 : "";
                      if ( result7 !== null ) {
                        result8 = parse_flag();
                        if ( result8 !== null ) {
                          result9 = parse_commaWsp();
                          result9 = result9 !== null ? result9 : "";
                          if ( result9 !== null ) {
                            result10 = parse_coordinatePair();
                            if ( result10 !== null ) {
                              result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10 ];
                            }
                            else {
                              result0 = null;
                              pos = pos1;
                            }
                          }
                          else {
                            result0 = null;
                            pos = pos1;
                          }
                        }
                        else {
                          result0 = null;
                          pos = pos1;
                        }
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, rx, ry, rot, largeArc, sweep, to ) { return [ rx, ry, rot, largeArc, sweep, to.x, to.y ] })( pos0, result0[ 0 ], result0[ 2 ], result0[ 4 ], result0[ 6 ], result0[ 8 ], result0[ 10 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_coordinatePair() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_number();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return { x: a, y: b }; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_nonnegativeNumber() {
        var result0;
        var pos0;

        pos0 = pos;
        result0 = parse_floatingPointConstant();
        if ( result0 !== null ) {
          result0 = (function( offset, number ) { return parseFloat( number ); })( pos0, result0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            result0 = (function( offset, number ) { return parseInt( number, 10 ); })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_number() {
        var result0, result1;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_sign();
        result0 = result0 !== null ? result0 : "";
        if ( result0 !== null ) {
          result1 = parse_floatingPointConstant();
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, sign, number ) { return parseFloat( sign + number ); })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_sign();
          result0 = result0 !== null ? result0 : "";
          if ( result0 !== null ) {
            result1 = parse_digitSequence();
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, sign, number ) { return parseInt( sign + number, 10 ); })( pos0, result0[ 0 ], result0[ 1 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_flag() {
        var result0;
        var pos0;

        pos0 = pos;
        if ( input.charCodeAt( pos ) === 48 ) {
          result0 = "0";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"0\"" );
          }
        }
        if ( result0 !== null ) {
          result0 = (function( offset ) { return false; })( pos0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          if ( input.charCodeAt( pos ) === 49 ) {
            result0 = "1";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"1\"" );
            }
          }
          if ( result0 !== null ) {
            result0 = (function( offset ) { return true; })( pos0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_commaWsp() {
        var result0, result1, result2, result3;
        var pos0;

        pos0 = pos;
        result1 = parse_wsp();
        if ( result1 !== null ) {
          result0 = [];
          while ( result1 !== null ) {
            result0.push( result1 );
            result1 = parse_wsp();
          }
        }
        else {
          result0 = null;
        }
        if ( result0 !== null ) {
          result1 = parse_comma();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = [];
            result3 = parse_wsp();
            while ( result3 !== null ) {
              result2.push( result3 );
              result3 = parse_wsp();
            }
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos0;
            }
          }
          else {
            result0 = null;
            pos = pos0;
          }
        }
        else {
          result0 = null;
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_comma();
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos0;
            }
          }
          else {
            result0 = null;
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_comma() {
        var result0;

        if ( input.charCodeAt( pos ) === 44 ) {
          result0 = ",";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\",\"" );
          }
        }
        return result0;
      }

      function parse_floatingPointConstant() {
        var result0, result1;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_fractionalConstant();
        if ( result0 !== null ) {
          result1 = parse_exponent();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            result1 = parse_exponent();
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_fractionalConstant() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_digitSequence();
        result0 = result0 !== null ? result0 : "";
        if ( result0 !== null ) {
          if ( input.charCodeAt( pos ) === 46 ) {
            result1 = ".";
            pos++;
          }
          else {
            result1 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\".\"" );
            }
          }
          if ( result1 !== null ) {
            result2 = parse_digitSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + '.' + b; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            if ( input.charCodeAt( pos ) === 46 ) {
              result1 = ".";
              pos++;
            }
            else {
              result1 = null;
              if ( reportFailures === 0 ) {
                matchFailed( "\".\"" );
              }
            }
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return a })( pos0, result0[ 0 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }

      function parse_exponent() {
        var result0, result1, result2;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 101 ) {
          result0 = "e";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"e\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 69 ) {
            result0 = "E";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"E\"" );
            }
          }
        }
        if ( result0 !== null ) {
          result1 = parse_sign();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_digitSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b, c ) { return a + b + c; })( pos0, result0[ 0 ], result0[ 1 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }

      function parse_sign() {
        var result0;

        if ( input.charCodeAt( pos ) === 43 ) {
          result0 = "+";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"+\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 45 ) {
            result0 = "-";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"-\"" );
            }
          }
        }
        return result0;
      }

      function parse_digitSequence() {
        var result0, result1;
        var pos0, pos1;

        pos0 = pos;
        pos1 = pos;
        result0 = parse_digit();
        if ( result0 !== null ) {
          result1 = parse_digitSequence();
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          result0 = parse_digit();
        }
        return result0;
      }

      function parse_digit() {
        var result0;

        if ( /^[0-9]/.test( input.charAt( pos ) ) ) {
          result0 = input.charAt( pos );
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "[0-9]" );
          }
        }
        return result0;
      }

      function parse_wsp() {
        var result0;

        if ( input.charCodeAt( pos ) === 32 ) {
          result0 = " ";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\" \"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 9 ) {
            result0 = "\t";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"\\t\"" );
            }
          }
          if ( result0 === null ) {
            if ( input.charCodeAt( pos ) === 13 ) {
              result0 = "\r";
              pos++;
            }
            else {
              result0 = null;
              if ( reportFailures === 0 ) {
                matchFailed( "\"\\r\"" );
              }
            }
            if ( result0 === null ) {
              if ( input.charCodeAt( pos ) === 10 ) {
                result0 = "\n";
                pos++;
              }
              else {
                result0 = null;
                if ( reportFailures === 0 ) {
                  matchFailed( "\"\\n\"" );
                }
              }
            }
          }
        }
        return result0;
      }


      function cleanupExpected( expected ) {
        expected.sort();

        var lastExpected = null;
        var cleanExpected = [];
        for ( var i = 0; i < expected.length; i++ ) {
          if ( expected[ i ] !== lastExpected ) {
            cleanExpected.push( expected[ i ] );
            lastExpected = expected[ i ];
          }
        }
        return cleanExpected;
      }

      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */

        var line = 1;
        var column = 1;
        var seenCR = false;

        for ( var i = 0; i < Math.max( pos, rightmostFailuresPos ); i++ ) {
          var ch = input.charAt( i );
          if ( ch === "\n" ) {
            if ( !seenCR ) { line++; }
            column = 1;
            seenCR = false;
          }
          else if ( ch === "\r" || ch === "\u2028" || ch === "\u2029" ) {
            line++;
            column = 1;
            seenCR = true;
          }
          else {
            column++;
            seenCR = false;
          }
        }

        return { line: line, column: column };
      }


      function createMoveTo( args, isRelative ) {
        var result = [ {
          cmd: isRelative ? 'moveToRelative' : 'moveTo',
          args: [ args[ 0 ].x, args[ 0 ].y ]
        } ];

        // any other coordinate pairs are implicit lineTos
        if ( args.length > 1 ) {
          for ( var i = 1; i < args.length; i++ ) {
            result.push( {
              cmd: isRelative ? 'lineToRelative' : 'lineTo',
              args: [ args[ i ].x, args[ i ].y ]
            } );
          }
        }
        return result;
      }


      var result = parseFunctions[ startRule ]();

      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if ( result === null || pos !== input.length ) {
        var offset = Math.max( pos, rightmostFailuresPos );
        var found = offset < input.length ? input.charAt( offset ) : null;
        var errorPosition = computeErrorPosition();

        throw new this.SyntaxError(
          cleanupExpected( rightmostFailuresExpected ),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }

      return result;
    },

    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };

  /* Thrown when a parser encounters a syntax error. */

  result.SyntaxError = function( expected, found, offset, line, column ) {
    function buildMessage( expected, found ) {
      var expectedHumanized, foundHumanized;

      switch( expected.length ) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[ 0 ];
          break;
        default:
          expectedHumanized = expected.slice( 0, expected.length - 1 ).join( ", " )
                              + " or "
                              + expected[ expected.length - 1 ];
      }

      foundHumanized = found ? quote( found ) : "end of input";

      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }

    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage( expected, found );
    this.offset = offset;
    this.line = line;
    this.column = column;
  };

  result.SyntaxError.prototype = Error.prototype;

  kite.register( 'svgPath', result );
  return kite.svgPath;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Shape handling
 *
 * Shapes are internally made up of Subpaths, which contain a series of segments, and are optionally closed.
 * Familiarity with how Canvas handles subpaths is helpful for understanding this code.
 *
 * Canvas spec: http://www.w3.org/TR/2dcontext/
 * SVG spec: http://www.w3.org/TR/SVG/expanded-toc.html
 *           http://www.w3.org/TR/SVG/paths.html#PathData (for paths)
 * Notes for elliptical arcs: http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes
 * Notes for painting strokes: https://svgwg.org/svg2-draft/painting.html
 *
 * TODO: add nonzero / evenodd support when browsers support it
 * TODO: docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'KITE/Shape',['require','KITE/segments/Arc','DOT/Bounds2','KITE/segments/Cubic','AXON/Events','KITE/segments/EllipticalArc','KITE/kite','PHET_CORE/inherit','KITE/segments/Line','KITE/segments/Quadratic','DOT/Ray2','KITE/util/Subpath','KITE/parser/svgPath','DOT/Vector2'],function( require ) {
  'use strict';

  var Arc = require( 'KITE/segments/Arc' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Cubic = require( 'KITE/segments/Cubic' );
  var Events = require( 'AXON/Events' );
  var EllipticalArc = require( 'KITE/segments/EllipticalArc' );
  var kite = require( 'KITE/kite' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'KITE/segments/Line' );
  var Quadratic = require( 'KITE/segments/Quadratic' );
  var Ray2 = require( 'DOT/Ray2' );
  var Subpath = require( 'KITE/util/Subpath' );
  var svgPath = require( 'KITE/parser/svgPath' );
  var Vector2 = require( 'DOT/Vector2' );

  /**
   * Convenience function that returns a Vector2
   * used throughout this file as an abbreviation for a displacement, a position or a point.
   * @private
   * @param {number} x
   * @param {number} y
   * @returns {Vector2}
   */
  function v( x, y ) { return new Vector2( x, y ); }

  /**
   * The tension parameter controls how smoothly the curve turns through its control points. For a Catmull-Rom curve,
   * the tension is zero. The tension should range from -1 to 1.
   * @private
   * @param {Vector2} beforeVector
   * @param {Vector2} currentVector
   * @param {Vector2} afterVector
   * @param {number} tension - the tension should range from -1 to 1.
   * @returns {Vector2}
   */
  function weightedSplineVector( beforeVector, currentVector, afterVector, tension ) {
    return afterVector.copy()
      .subtract( beforeVector )
      .multiplyScalar( ( 1 - tension ) / 6 )
      .add( currentVector );
  }

  // a normalized vector for non-zero winding checks
  // var weirdDir = v( Math.PI, 22 / 7 );

  /**
   * All arguments optional, they are for the copy() method. if used, ensure that 'bounds' is consistent with 'subpaths'
   *
   * @param {Array.<Subpath>} [subpaths]
   * @param {Bounds2} [bounds]
   * @constructor
   */
  function Shape( subpaths, bounds ) {
    var self = this;

    Events.call( this );

    // @public Lower-level piecewise mathematical description using segments, also individually immutable
    this.subpaths = [];

    // If non-null, computed bounds for all pieces added so far. Lazily computed with getBounds/bounds ES5 getter
    this._bounds = bounds ? bounds.copy() : null; // {Bounds2 | null}

    this.resetControlPoints();

    this._invalidateListener = this.invalidate.bind( this );
    this._invalidatingPoints = false; // So we can invalidate all of the points without firing invalidation tons of times

    // @private {boolean} - When set by makeImmutable(), it indicates this Shape won't be changed from now on, and
    //                      attempts to change it may result in errors.
    this._immutable = false;

    // Add in subpaths from the constructor (if applicable)
    if ( typeof subpaths === 'object' ) {
      // assume it's an array
      for ( var i = 0; i < subpaths.length; i++ ) {
        this.addSubpath( subpaths[ i ] );
      }
    }

    if ( subpaths && typeof subpaths !== 'object' ) {
      assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' );
      // parse the SVG path
      _.each( svgPath.parse( subpaths ), function( item ) {
        assert && assert( Shape.prototype[ item.cmd ] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );
        self[ item.cmd ].apply( self, item.args );
      } );
    }

    // defines _bounds if not already defined (among other things)
    this.invalidate();

    phetAllocation && phetAllocation( 'Shape' );
  }

  kite.register( 'Shape', Shape );

  inherit( Events, Shape, {

    /**
     * Resets the control points
     * for tracking the last quadratic/cubic control point for smooth* functions
     * see https://github.com/phetsims/kite/issues/38
     * @private
     */
    resetControlPoints: function() {
      this.lastQuadraticControlPoint = null;
      this.lastCubicControlPoint = null;
    },

    /**
     * Sets the quadratic control point
     * @private
     * @param {Vector2} point
     */
    setQuadraticControlPoint: function( point ) {
      this.lastQuadraticControlPoint = point;
      this.lastCubicControlPoint = null;
    },

    /**
     * Sets the cubic control point
     * @private
     * @param {Vector2} point
     */
    setCubicControlPoint: function( point ) {
      this.lastQuadraticControlPoint = null;
      this.lastCubicControlPoint = point;
    },

    /**
     * Adds a new subpath if there have already been draw calls made. Will prevent any line or connection from the last
     * draw call to future draw calls.
     * @private
     * @returns {Shape}
     * //TODO delete?, this function is not used within kite
     */
    subpath: function() {
      if ( this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }

      return this; // for chaining
    },

    /**
     * Moves to a point given by the coordinates x and y
     * @public
     * @param {number} x
     * @param {number} y
     * @returns {Shape}
     */
    moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },

    /**
     * Moves a relative displacement (x,y) from last point
     * @public
     * @param {number} x
     * @param {number} y
     * @returns {Shape}
     */
    moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },

    /**
     * Moves a relative displacement (point) from last point
     * @public
     * @param {Vector2} point - a displacement
     * @returns {Shape}
     */
    moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },

    /**
     * Adds to this shape a subpath that moves (no joint) it to a point
     * @public
     * @param {Vector2} point
     * @returns {Shape}
     */
    moveToPoint: function( point ) {
      this.addSubpath( new Subpath().addPoint( point ) );
      this.resetControlPoints();

     return this;  // for chaining
    },

    /**
     * Adds to this shape a straight line from last point to the coordinate (x,y)
     * @public
     * @param {number} x
     * @param {number} y
     * @returns {Shape}
     */
    lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },

    /**
     * Adds to this shape a straight line displaced by a relative amount x, and y  from last point
     * @public
     * @param {number} x - horizontal displacement
     * @param {number} y - vertical displacement
     * @returns {Shape}
     */
    lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },

    /**
     * Adds to this shape a straight line displaced by a relative displacement (point)
     * @public
     * @param {Vector2} point - a displacement
     * @returns {Shape}
     */
    lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },

    /**
     * Adds to this shape a straight line from this lastPoint to point
     * @public
     * @param {Vector2} point
     * @returns {Shape}
     */
    lineToPoint: function( point ) {
      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-lineto
      if ( this.hasSubpaths() ) {
        var start = this.getLastSubpath().getLastPoint();
        var end = point;
        var line = new Line( start, end );
        this.getLastSubpath().addPoint( end );
        this.addSegmentAndBounds( line );
      }
      else {
        this.ensure( point );
      }
      this.resetControlPoints();

     return this;  // for chaining
    },

    /**
     * Adds a horizontal line (x represents the x-coordinate of the end point)
     * @public
     * @param {number} x -
     * @returns {Shape}
     */
    horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },

    /**
     * Adds a horizontal line (x represent a horizontal displacement)
     * @public
     * @param {number} x
     * @returns {Shape}
     */
    horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },

    /**
     * Adds a vertical line (y represents the y-coordinate of the end point)
     * @public
     * @param {number} y
     * @returns {Shape}
     */
    verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },

    /**
     * Adds a vertical line (y represents a vertical displacement)
     * @public
     * @param {number} y
     * @returns {Shape}
     */
    verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },

    /**
     * Adds a quadratic curve to this shape
     * The curve is guaranteed to pass through the coordinate (x,y) but does not
     * pass through the control point
     * @public
     * @param {number} cpx - control point horizontal coordinate
     * @param {number} cpy - control point vertical coordinate
     * @param {number} x
     * @param {number} y
     * @returns {Shape}
     */
    quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },

    /**
     * Adds a quadratic curve to this shape. The control and final points are specified as displacment from the last point in this shape
     * @public
     * @param {number} cpx - control point horizontal coordinate
     * @param {number} cpy - control point vertical coordinate
     * @param {number} x - final x position of the quadratic curve
     * @param {number} y - final y position of the quadratic curve
     * @returns {Shape}
     */
    quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },

    /**
     * Adds a quadratic curve to this shape. The control and final points are specified as displacement from the last point in this shape
     * @public
     * @param {Vector2} controlPoint
     * @param {Vector2} point - the quadratic curve passes through this point
     * @returns {Shape}
     */
    quadraticCurveToPointRelative: function( controlPoint, point ) {
      var relativePoint = this.getRelativePoint();
      return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );
    },
    // TODO: consider a rename to put 'smooth' farther back?

    /**
     * Adds a quadratic curve to this shape. The quadratic curves passes through the x and y coordinate.
     * The shape should join smoothly with the previous subpaths
     * @public
     * @param {number} x - final x position of the quadratic curve
     * @param {number} y - final y position of the quadratic curve
     * @returns {Shape}
     */
    smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },

    /**
     * Adds a quadratic curve to this shape. The quadratic curves passes through the x and y coordinate.
     * The shape should join smoothly with the previous subpaths
     * @public
     * @param {number} x - final x position of the quadratic curve
     * @param {number} y - final y position of the quadratic curve
     * @returns {Shape}
     */
    smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },

    /**
     * Adds a quadratic curve to this shape.
     * @public
     * @param {Vector2} controlPoint
     * @param {Vector2} point - the quadratic curve passes through this point
     * @returns {Shape}
     */
    quadraticCurveToPoint: function( controlPoint, point ) {
      var self = this;

      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-quadraticcurveto
      this.ensure( controlPoint );
      var start = this.getLastSubpath().getLastPoint();
      var quadratic = new Quadratic( start, controlPoint, point );
      this.getLastSubpath().addPoint( point );
      var nondegenerateSegments = quadratic.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        // TODO: optimization
        self.addSegmentAndBounds( segment );
      } );
      this.setQuadraticControlPoint( controlPoint );

     return this;  // for chaining
    },

    /**
     * @public
     * @param {number} cp1x - control point 1,  horizontal coordinate
     * @param {number} cp1y - control point 1,  vertical coordinate
     * @param {number} cp2x - control point 2,  horizontal coordinate
     * @param {number} cp2y - control point 2,  vertical coordinate
     * @param {number} x - final x position of the cubic curve
     * @param {number} y - final y position of the cubic curve
     * @returns {Shape}
     */
    cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },

    /**
     * @public
     * @param {number} cp1x - control point 1,  horizontal displacement
     * @param {number} cp1y - control point 1,  vertical displacement
     * @param {number} cp2x - control point 2,  horizontal displacement
     * @param {number} cp2y - control point 2,  vertical displacement
     * @param {number} x - final horizontal displacement
     * @param {number} y - final vertical displacment
     * @returns {Shape}
     */
    cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },

    /**
     * @public
     * @param {Vector2} control1 - control displacement  1
     * @param {Vector2} control2 - control displacement 2
     * @param {Vector2} point - final displacement
     * @returns {Shape}
     */
    cubicCurveToPointRelative: function( control1, control2, point ) {
      var relativePoint = this.getRelativePoint();
      return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );
    },

    /**
     * @public
     * @param {number} cp2x - control point 2,  horizontal coordinate
     * @param {number} cp2y - control point 2,  vertical coordinate
     * @param {number} x
     * @param {number} y
     * @returns {Shape}
     */
    smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },

    /**
     * @public
     * @param {number} cp2x - control point 2,  horizontal coordinate
     * @param {number} cp2y - control point 2,  vertical coordinate
     * @param {number} x
     * @param {number} y
     * @returns {Shape}
     */
    smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },

    /**
     * @public
     * @param {Vector2} control1
     * @param {Vector2} control2
     * @param {Vector2} point
     * @returns {Shape}
     */
    cubicCurveToPoint: function( control1, control2, point ) {
      var self = this;
      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-quadraticcurveto
      this.ensure( control1 );
      var start = this.getLastSubpath().getLastPoint();
      var cubic = new Cubic( start, control1, control2, point );

      var nondegenerateSegments = cubic.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        self.addSegmentAndBounds( segment );
      } );
      this.getLastSubpath().addPoint( point );

      this.setCubicControlPoint( control2 );

     return this;  // for chaining
    },

    /**
     * @public
     * @param {number} centerX - horizontal coordinate of the center of the arc
     * @param {number} centerY - Center of the arc
     * @param {number} radius - How far from the center the arc will be
     * @param {number} startAngle - Angle (radians) of the start of the arc
     * @param {number} endAngle - Angle (radians) of the end of the arc
     * @param {boolean} [anticlockwise] - Decides which direction the arc takes around the center
     * @returns {Shape}
     **/
    arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },

    /**
     * @public
     * @param {Vector2} center - Center of the arc (every point on the arc is equally far from the center)
     * @param {number} radius - How far from the center the arc will be
     * @param {number} startAngle - Angle (radians) of the start of the arc
     * @param {number} endAngle - Angle (radians) of the end of the arc
     * @param {boolean} [anticlockwise] - Decides which direction the arc takes around the center
     * @returns {Shape}
     **/
    arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {
      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-arc

      var arc = new Arc( center, radius, startAngle, endAngle, anticlockwise );

      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas
      var startPoint = arc.getStart();
      var endPoint = arc.getEnd();

      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them
      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
        this.addSegmentAndBounds( new Line( this.getLastSubpath().getLastPoint(), startPoint ) );
      }

      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }

      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)
      this.getLastSubpath().addPoint( startPoint );
      this.getLastSubpath().addPoint( endPoint );

      this.addSegmentAndBounds( arc );
      this.resetControlPoints();

     return this;  // for chaining
    },

    /**
     * Creates an elliptical arc
     * @public
     * @param {number} centerX - horizontal coordinate of the center of the arc
     * @param {number} centerY -  vertical coordinate of the center of the arc
     * @param {number} radiusX - semi axis
     * @param {number} radiusY - semi axis
     * @param {number} rotation - rotation of the elliptical arc with respect to the
     * @param {number} startAngle
     * @param {number} endAngle
     * @param {boolean} [anticlockwise]
     * @returns {Shape}
     */
    ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
      return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
    },

    /**
     * Creates an elliptic arc
     * @public
     * @param {Vector2} center
     * @param {number} radiusX
     * @param {number} radiusY
     * @param {number} rotation - rotation of the arc with respect to the positive x axis.
     * @param {number} startAngle -
     * @param {number} endAngle
     * @param {boolean} [anticlockwise]
     * @returns {Shape}
     */
    ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
      // see http://www.w3.org/TR/2dcontext/#dom-context-2d-arc

      var ellipticalArc = new EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );

      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas
      var startPoint = ellipticalArc.start;
      var endPoint = ellipticalArc.end;

      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them
      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
        this.addSegmentAndBounds( new Line( this.getLastSubpath().getLastPoint(), startPoint ) );
      }

      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }

      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)
      this.getLastSubpath().addPoint( startPoint );
      this.getLastSubpath().addPoint( endPoint );

      this.addSegmentAndBounds( ellipticalArc );
      this.resetControlPoints();

     return this;  // for chaining
    },

    /**
     * Adds a subpath that joins the last point of this shape to the first point to form a closed shape
     * @public
     * @returns {Shape}
     */
    close: function() {
      if ( this.hasSubpaths() ) {
        var previousPath = this.getLastSubpath();
        var nextPath = new Subpath();

        previousPath.close();
        this.addSubpath( nextPath );
        nextPath.addPoint( previousPath.getFirstPoint() );
      }
      this.resetControlPoints();
     return this;  // for chaining
    },

    /**
     * Makes this Shape immutable, so that attempts to further change the Shape will fail. This allows clients to avoid
     * adding change listeners to this Shape.
     * @public
     *
     * @returns {Shape} - Self, for chaining
     */
    makeImmutable: function() {
      this._immutable = true;

      this.notifyInvalidationListeners();

      return this; // for chaining
    },

    /**
     * Returns whether this Shape is immutable (see makeImmutable for details).
     * @public
     *
     * @returns {boolean}
     */
    isImmutable: function() {
      return this._immutable;
    },

    /**
     * Matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html
     * @public
     *
     * WARNING: rotation (for now) is in DEGREES. This will probably change in the future.
     *
     * @param {number} radiusX - Semi-major axis size
     * @param {number} radiusY - Semi-minor axis size
     * @param {number} rotation - Rotation of the ellipse (its semi-major axis)
     * @param {boolean} largeArc - Whether the arc will go the longest route around the ellipse.
     * @param {boolean} sweep - Whether the arc made goes from start to end "clockwise" (opposite of anticlockwise flag)
     * @param {number} x - End point X location
     * @param {number} y - End point Y location
     * @returns {Shape} - this Shape for chaining
     */
    ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
      var relativePoint = this.getRelativePoint();
      return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );
    },

    /**
     * Matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html
     * @public
     *
     * WARNING: rotation (for now) is in DEGREES. This will probably change in the future.
     *
     * @param {number} radiusX - Semi-major axis size
     * @param {number} radiusY - Semi-minor axis size
     * @param {number} rotation - Rotation of the ellipse (its semi-major axis)
     * @param {boolean} largeArc - Whether the arc will go the longest route around the ellipse.
     * @param {boolean} sweep - Whether the arc made goes from start to end "clockwise" (opposite of anticlockwise flag)
     * @param {number} x - End point X location
     * @param {number} y - End point Y location
     * @returns {Shape} - this Shape for chaining
     */
    ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
      // See "F.6.5 Conversion from endpoint to center parameterization"
      // in https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes

      var self = this;

      var endPoint = new Vector2( x, y );
      this.ensure( endPoint );

      var startPoint = this.getLastSubpath().getLastPoint();
      this.getLastSubpath().addPoint( endPoint );

      // Absolute value applied to radii (per SVG spec)
      if ( radiusX < 0 ) { radiusX *= -1.0; }
      if ( radiusY < 0 ) { radiusY *= -1.0; }

      var rxs = radiusX * radiusX;
      var rys = radiusY * radiusY;
      var prime = startPoint.minus( endPoint ).dividedScalar( 2 ).rotated( -rotation );
      var pxs = prime.x * prime.x;
      var pys = prime.y * prime.y;
      var centerPrime = new Vector2( radiusX * prime.y / radiusY, -radiusY * prime.x / radiusX );

      // If the radii are not large enough to accomodate the start/end point, apply F.6.6 correction
      var size = pxs / rxs + pys / rys;
      if ( size > 1 ) {
        radiusX *= Math.sqrt( size );
        radiusY *= Math.sqrt( size );

        // redo some computations from above
        rxs = radiusX * radiusX;
        rys = radiusY * radiusY;
        centerPrime = new Vector2( radiusX * prime.y / radiusY, -radiusY * prime.x / radiusX );
      }

      // Naming matches https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes for
      // F.6.5 Conversion from endpoint to center parameterization

      centerPrime.multiplyScalar( Math.sqrt( Math.max( 0, ( rxs * rys - rxs * pys - rys * pxs ) / ( rxs * pys + rys * pxs ) ) ) );
      if ( largeArc === sweep ) {
        // From spec: where the + sign is chosen if fA ≠ fS, and the − sign is chosen if fA = fS.
        centerPrime.multiplyScalar( -1 );
      }
      var center = startPoint.blend( endPoint, 0.5 ).plus( centerPrime.rotated( rotation ) );
      function signedAngle( u, v ) {
        // From spec: where the ± sign appearing here is the sign of ux vy − uy vx.
        return ( ( u.x * v.y - u.y * v.x ) > 0 ? 1 : -1 ) * u.angleBetween( v );
      }
      var victor = new Vector2( ( prime.x - centerPrime.x ) / radiusX, ( prime.y - centerPrime.y ) / radiusY );
      var ross = new Vector2( ( -prime.x - centerPrime.x ) / radiusX, ( -prime.y - centerPrime.y ) / radiusY );
      var startAngle = signedAngle( Vector2.X_UNIT, victor );
      var deltaAngle = signedAngle( victor, ross ) % ( Math.PI * 2 );

      // From spec:
      // > In other words, if fS = 0 and the right side of (F.6.5.6) is greater than 0, then subtract 360°, whereas if
      // > fS = 1 and the right side of (F.6.5.6) is less than 0, then add 360°. In all other cases leave it as is.
      if ( !sweep && deltaAngle > 0 ) {
        deltaAngle -= Math.PI * 2;
      }
      if ( sweep && deltaAngle < 0 ) {
        deltaAngle += Math.PI * 2;
      }

      // Standard handling of degenerate segments (particularly, converting elliptical arcs to circular arcs)
      var ellipticalArc = new EllipticalArc( center, radiusX, radiusY, rotation, startAngle, startAngle + deltaAngle, !sweep );
      var nondegenerateSegments = ellipticalArc.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        self.addSegmentAndBounds( segment );
      } );

      return this;
    },

     /**
     * Draws a circle using the arc() call with the following parameters:
     * circle( center, radius ) // center is a Vector2
     * circle( centerX, centerY, radius )
     * @param {Vector2|number} centerX
     * @param {number} centerY
     * @param {number} [radius]
     * @returns {Shape} - this shape for chaining
     */
    circle: function( centerX, centerY, radius ) {
      if ( typeof centerX === 'object' ) {
        // circle( center, radius )
        var center = centerX;
        radius = centerY;
        return this.arcPoint( center, radius, 0, Math.PI * 2, false ).close();
      }
      else {
        // circle( centerX, centerY, radius )
        return this.arcPoint( v( centerX, centerY ), radius, 0, Math.PI * 2, false ).close();
      }
    },

    /**
     * Draws an ellipse using the ellipticalArc() call with the following parameters:
     * ellipse( center, radiusX, radiusY, rotation ) // center is a Vector2
     * ellipse( centerX, centerY, radiusX, radiusY, rotation )
     *
     * The rotation is about the centerX, centerY.
     * @public
     * @param {number|Vector2} centerX
     * @param {number} [centerY]
     * @param {number} radiusX
     * @param {number} radiusY
     * @param {number} rotation
     * @returns {Shape}
     */
    ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {
      // TODO: separate into ellipse() and ellipsePoint()?
      // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling
      if ( typeof centerX === 'object' ) {
        // ellipse( center, radiusX, radiusY, rotation )
        var center = centerX;
        rotation = radiusY;
        radiusY = radiusX;
        radiusX = centerY;
        return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false ).close();
      }
      else {
        // ellipse( centerX, centerY, radiusX, radiusY, rotation )
        return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false ).close();
      }
    },

    /**
     * Creates a rectangle shape
     * @public
     * @param {number} x - left position
     * @param {number} y - bottom position (in non inverted cartesian system)
     * @param {number} width
     * @param {number} height
     * @returns {Shape}
     */
    rect: function( x, y, width, height ) {
      var subpath = new Subpath();
      this.addSubpath( subpath );
      subpath.addPoint( v( x, y ) );
      subpath.addPoint( v( x + width, y ) );
      subpath.addPoint( v( x + width, y + height ) );
      subpath.addPoint( v( x, y + height ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 0 ], subpath.points[ 1 ] ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 1 ], subpath.points[ 2 ] ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 2 ], subpath.points[ 3 ] ) );
      subpath.close();
      this.addSubpath( new Subpath() );
      this.getLastSubpath().addPoint( v( x, y ) );
      assert && assert( !isNaN( this.bounds.getX() ) );
      this.resetControlPoints();

      return this;
    },

    /**
     * Creates a round rectangle. All arguments are number.
     * @public
     * @param {number} x
     * @param {number} y
     * @param {number} width - width of the rectangle
     * @param {number} height - height of the rectangle
     * @param {number} arcw - arc width
     * @param {number} arch - arc height
     * @returns {Shape}
     */
    roundRect: function( x, y, width, height, arcw, arch ) {
      var lowX = x + arcw;
      var highX = x + width - arcw;
      var lowY = y + arch;
      var highY = y + height - arch;
      // if ( true ) {
      if ( arcw === arch ) {
        // we can use circular arcs, which have well defined stroked offsets
        this
          .arc( highX, lowY, arcw, -Math.PI / 2, 0, false )
          .arc( highX, highY, arcw, 0, Math.PI / 2, false )
          .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )
          .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )
          .close();
      }
      else {
        // we have to resort to elliptical arcs
        this
          .ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )
          .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )
          .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )
          .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )
          .close();
      }
      return this;
    },

    /**
     * Creates a polygon from an array of vertices.
     * @public
     * @param {Array.<Vector2>} vertices
     * @returns {Shape}
     */
    polygon: function( vertices ) {
      var length = vertices.length;
      if ( length > 0 ) {
        this.moveToPoint( vertices[ 0 ] );
        for ( var i = 1; i < length; i++ ) {
          this.lineToPoint( vertices[ i ] );
        }
      }
      return this.close();
    },

    /**
     * This is a convenience function that allows to generate Cardinal splines
     * from a position array. Cardinal spline differs from Bezier curves in that all
     * defined points on a Cardinal spline are on the path itself.
     *
     * It includes a tension parameter to allow the client to specify how tightly
     * the path interpolates between points. One can think of the tension as the tension in
     * a rubber band around pegs. however unlike a rubber band the tension can be negative.
     * the tension ranges from -1 to 1
     *
     * @public
     * @param {Array.<Vector2>} positions
     * @param {Object} [options] - see documentation below
     * @returns {Shape}
     */
    cardinalSpline: function( positions, options ) {
      options = _.extend( {
        // the tension parameter controls how smoothly the curve turns through its
        // control points. For a Catmull-Rom curve the tension is zero.
        // the tension should range from  -1 to 1
        tension: 0,

        // is the resulting shape forming a closed line?
        isClosedLineSegments: false
      }, options );

      assert && assert( options.tension < 1 && options.tension > -1, ' the tension goes from -1 to 1 ' );

      var pointNumber = positions.length; // number of points in the array

      // if the line is open, there is one less segments than point vectors
      var segmentNumber = ( options.isClosedLineSegments ) ? pointNumber : pointNumber - 1;

      for ( var i = 0; i < segmentNumber; i++ ) {
        var cardinalPoints; // {Array.<Vector2>} cardinal points Array
        if ( i === 0 && !options.isClosedLineSegments ) {
          cardinalPoints = [
            positions[ 0 ],
            positions[ 0 ],
            positions[ 1 ],
            positions[ 2 ] ];
        }
        else if ( (i === segmentNumber - 1) && !options.isClosedLineSegments ) {
          cardinalPoints = [
            positions[ i - 1 ],
            positions[ i ],
            positions[ i + 1 ],
            positions[ i + 1 ] ];
        }
        else {
          cardinalPoints = [
            positions[ ( i - 1 + pointNumber ) % pointNumber ],
            positions[ i % pointNumber ],
            positions[ ( i + 1 ) % pointNumber ],
            positions[ ( i + 2 ) % pointNumber ] ];
        }

        // Cardinal Spline to Cubic Bezier conversion matrix
        //    0                 1             0            0
        //  (-1+tension)/6      1      (1-tension)/6       0
        //    0            (1-tension)/6      1       (-1+tension)/6
        //    0                 0             1           0

        // {Array.<Vector2>} bezier points Array
        var bezierPoints = [
          cardinalPoints[ 1 ],
          weightedSplineVector( cardinalPoints[ 0 ], cardinalPoints[ 1 ], cardinalPoints[ 2 ], options.tension ),
          weightedSplineVector( cardinalPoints[ 3 ], cardinalPoints[ 2 ], cardinalPoints[ 1 ], options.tension ),
          cardinalPoints[ 2 ]
        ];

        // special operations on the first point
        if ( i === 0 ) {
          this.ensure( bezierPoints[ 0 ] );
          this.getLastSubpath().addPoint( bezierPoints[ 0 ] );
        }

        this.cubicCurveToPoint( bezierPoints[ 1 ], bezierPoints[ 2 ], bezierPoints[ 3 ] );
      }

      return this;
    },

    /**
     * Returns a copy of this shape
     * @public
     * @returns {Shape}
     */
    copy: function() {
      // copy each individual subpath, so future modifications to either Shape doesn't affect the other one
      return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );
    },

    /**
     * Writes out this shape's path to a canvas 2d context. does NOT include the beginPath()!
     * @param {CanvasRenderingContext2D} context
     */
    writeToContext: function( context ) {
      var len = this.subpaths.length;
      for ( var i = 0; i < len; i++ ) {
        this.subpaths[ i ].writeToContext( context );
      }
    },

    /**
     * Returns something like "M150 0 L75 200 L225 200 Z" for a triangle
     * @returns {string}
     */
    getSVGPath: function() {
      var string = '';
      var len = this.subpaths.length;
      for ( var i = 0; i < len; i++ ) {
        var subpath = this.subpaths[ i ];
        if ( subpath.isDrawable() ) {
          // since the commands after this are relative to the previous 'point', we need to specify a move to the initial point
          var startPoint = subpath.segments[ 0 ].start;

          string += 'M ' + kite.svgNumber( startPoint.x ) + ' ' + kite.svgNumber( startPoint.y ) + ' ';

          for ( var k = 0; k < subpath.segments.length; k++ ) {
            string += subpath.segments[ k ].getSVGPathFragment() + ' ';
          }

          if ( subpath.isClosed() ) {
            string += 'Z ';
          }
        }
      }
      return string;
    },

    /**
     * Returns a new Shape that is transformed by the associated matrix
     * @param {Matrix3} matrix
     * @returns {Shape}
     */
    transformed: function( matrix ) {
      // TODO: allocation reduction
      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );
      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
      return new Shape( subpaths, bounds );
    },

    /**
     * Provided options (see Segment.nonlinearTransformed)
     * - minLevels:                       how many levels to force subdivisions
     * - maxLevels:                       prevent subdivision past this level
     * - distanceEpsilon (optional null): controls level of subdivision by attempting to ensure a maximum (squared) deviation from the curve. smaller => more subdivision
     * - curveEpsilon (optional null):    controls level of subdivision by attempting to ensure a maximum curvature change between segments. smaller => more subdivision
     * -   OR includeCurvature:           {boolean}, whether to include a default curveEpsilon (usually off by default)
     * - pointMap (optional):             function( Vector2 ) : Vector2, represents a (usually non-linear) transformation applied
     * - methodName (optional):           if the method name is found on the segment, it is called with the expected signature function( options ) : Array[Segment]
     *                                    instead of using our brute-force logic. Supports optimizations for custom non-linear transforms (like polar coordinates)
     */
    nonlinearTransformed: function( options ) {
      // defaults
      options = _.extend( {
        minLevels: 0,
        maxLevels: 7,
        distanceEpsilon: 0.16, // NOTE: this will change when the Shape is scaled, since this is a threshold for the square of a distance value
        curveEpsilon: ( options && options.includeCurvature ) ? 0.002 : null
      }, options );

      // TODO: allocation reduction
      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.nonlinearTransformed( options ); } );
      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
      return new Shape( subpaths, bounds );
    },

    /**
     * Maps points by treating their x coordinate as polar angle, and y coordinate as polar magnitude.
     * See http://en.wikipedia.org/wiki/Polar_coordinate_system
     *
     * Please see Shape.nonlinearTransformed for more documentation on adaptive discretization options (minLevels, maxLevels, distanceEpsilon, curveEpsilon)
     *
     * Example: A line from (0,10) to (pi,10) will be transformed to a circular arc from (10,0) to (-10,0) passing through (0,10).
     */
    polarToCartesian: function( options ) {
      return this.nonlinearTransformed( _.extend( {
        pointMap: function( p ) {
          return Vector2.createPolar( p.y, p.x );
          // return new Vector2( p.y * Math.cos( p.x ), p.y * Math.sin( p.x ) );
        },
        methodName: 'polarToCartesian' // this will be called on Segments if it exists to do more optimized conversion (see Line)
      }, options ) );
    },

    /**
     * Converts each segment into lines, using an adaptive (midpoint distance subdivision) method.
     *
     * NOTE: uses nonlinearTransformed method internally, but since we don't provide a pointMap or methodName, it won't create anything but line segments.
     * See nonlinearTransformed for documentation of options
     */
    toPiecewiseLinear: function( options ) {
      assert && assert( !options.pointMap, 'No pointMap for toPiecewiseLinear allowed, since it could create non-linear segments' );
      assert && assert( !options.methodName, 'No methodName for toPiecewiseLinear allowed, since it could create non-linear segments' );
      return this.nonlinearTransformed( options );
    },

    /**
     * Is this point contained in this shape
     * @param {Vector2} point
     * @returns {boolean}
     */
    containsPoint: function( point ) {
      // we pick a ray, and determine the winding number over that ray. if the number of segments crossing it CCW == number of segments crossing it CW, then the point is contained in the shape
      var ray = new Ray2( point, Vector2.X_UNIT );

      return this.windingIntersection( ray ) !== 0;
    },

    /**
     * Hit-tests this shape with the ray. An array of all intersections of the ray with this shape will be returned.
     * For details, see the documentation in Segment.js
     * @public
     *
     * @param {Ray2} ray
     * @returns {Array.<Intersection>} - See Segment.js for details. For this function, intersections will be returned
     *                                   sorted by the distance from the ray's location.
     */
    intersection: function( ray ) {
      var hits = [];
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];

        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            var segment = subpath.segments[ k ];
            hits = hits.concat( segment.intersection( ray ) );
          }

          if ( subpath.hasClosingSegment() ) {
            hits = hits.concat( subpath.getClosingSegment().intersection( ray ) );
          }
        }
      }
      return _.sortBy( hits, function( hit ) { return hit.distance; } );
    },

    /**
     * Returns whether the provided line segment would have some part on top or touching the interior (filled area) of
     * this shape.
     * @public
     *
     * This differs somewhat from an intersection of the line segment with the Shape's path, as we will return true
     * ("intersection") if the line segment is entirely contained in the interior of the Shape's path.
     *
     * @param {Vector2} startPoint - One end of the line segment
     * @param {Vector2} endPoint - The other end of the line segment
     * @returns {boolean}
     */
    interiorIntersectsLineSegment: function( startPoint, endPoint ) {
      // First check if our midpoint is in the Shape (as either our midpoint is in the Shape, OR the line segment will
      // intersect the Shape's boundary path).
      var midpoint = startPoint.blend( endPoint, 0.5 );
      if ( this.containsPoint( midpoint ) ) {
        return true;
      }

      // TODO: if an issue, we can reduce this allocation to a scratch variable local in the Shape.js scope.
      var delta = endPoint.minus( startPoint );
      var length = delta.magnitude();

      if ( length === 0 ) {
        return false;
      }

      delta.normalize(); // so we can use it as a unit vector, expected by the Ray

      // Grab all intersections (that are from startPoint towards the direction of endPoint)
      var hits = this.intersection( new Ray2( startPoint, delta ) );

      // See if we have any intersections along our infinite ray whose distance from the startPoint is less than or
      // equal to our line segment's length.
      for ( var i = 0; i < hits.length; i++ ) {
        if ( hits[ i ].distance <= length ) {
          return true;
        }
      }

      // Did not hit the boundary, and wasn't fully contained.
      return false;
    },

    /**
     * Returns the winding number for intersection with a ray
     * @param {Ray2} ray
     * @returns {number}
     */
    windingIntersection: function( ray ) {
      var wind = 0;

      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];

        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            wind += subpath.segments[ k ].windingIntersection( ray );
          }

          // handle the implicit closing line segment
          if ( subpath.hasClosingSegment() ) {
            wind += subpath.getClosingSegment().windingIntersection( ray );
          }
        }
      }

      return wind;
    },

    /**
     * Whether the path of the Shape intersects (or is contained in) the provided bounding box.
     * Computed by checking intersections with all four edges of the bounding box, or whether the Shape is totally
     * contained within the bounding box.
     *
     * @param {Bounds2} bounds
     * @returns {boolean}
     */
    intersectsBounds: function( bounds ) {
      // If the bounding box completely surrounds our shape, it intersects the bounds
      if ( this.bounds.intersection( bounds ).equals( this.bounds ) ) {
        return true;
      }

      // rays for hit testing along the bounding box edges
      var minHorizontalRay = new Ray2( new Vector2( bounds.minX, bounds.minY ), new Vector2( 1, 0 ) );
      var minVerticalRay = new Ray2( new Vector2( bounds.minX, bounds.minY ), new Vector2( 0, 1 ) );
      var maxHorizontalRay = new Ray2( new Vector2( bounds.maxX, bounds.maxY ), new Vector2( -1, 0 ) );
      var maxVerticalRay = new Ray2( new Vector2( bounds.maxX, bounds.maxY ), new Vector2( 0, -1 ) );

      var hitPoint;
      var i;
      // TODO: could optimize to intersect differently so we bail sooner
      var horizontalRayIntersections = this.intersection( minHorizontalRay ).concat( this.intersection( maxHorizontalRay ) );
      for ( i = 0; i < horizontalRayIntersections.length; i++ ) {
        hitPoint = horizontalRayIntersections[ i ].point;
        if ( hitPoint.x >= bounds.minX && hitPoint.x <= bounds.maxX ) {
          return true;
        }
      }

      var verticalRayIntersections = this.intersection( minVerticalRay ).concat( this.intersection( maxVerticalRay ) );
      for ( i = 0; i < verticalRayIntersections.length; i++ ) {
        hitPoint = verticalRayIntersections[ i ].point;
        if ( hitPoint.y >= bounds.minY && hitPoint.y <= bounds.maxY ) {
          return true;
        }
      }

      // not contained, and no intersections with the sides of the bounding box
      return false;
    },

    // TODO: rename stroked( lineStyles )
    /**
     * Returns a new Shape that is an outline of the stroked path of this current Shape. currently not intended to be nested (doesn't do intersection computations yet)
     * @param {LineStyles} lineStyles
     * @returns {Shape}
     */
    getStrokedShape: function( lineStyles ) {
      var subpaths = [];
      var bounds = Bounds2.NOTHING.copy();
      var subLen = this.subpaths.length;
      for ( var i = 0; i < subLen; i++ ) {
        var subpath = this.subpaths[ i ];
        var strokedSubpath = subpath.stroked( lineStyles );
        subpaths = subpaths.concat( strokedSubpath );
      }
      subLen = subpaths.length;
      for ( i = 0; i < subLen; i++ ) {
        bounds.includeBounds( subpaths[ i ].bounds );
      }
      return new Shape( subpaths, bounds );
    },

    /**
     *
     * {experimental!}
     * @param {number} distance
     * @returns {Shape}
     */
    getOffsetShape: function( distance ) {
      // TODO: abstract away this type of behavior
      var subpaths = [];
      var bounds = Bounds2.NOTHING.copy();
      var subLen = this.subpaths.length;
      for ( var i = 0; i < subLen; i++ ) {
        subpaths.push( this.subpaths[ i ].offset( distance ) );
      }
      subLen = subpaths.length;
      for ( i = 0; i < subLen; i++ ) {
        bounds.includeBounds( subpaths[ i ].bounds );
      }
      return new Shape( subpaths, bounds );
    },

    /**
     * Returns the bounds of this shape. It is the bounding-box union of the bounds of each subpath contained.
     * @public
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      if ( this._bounds === null ) {
        var bounds = Bounds2.NOTHING.copy();
        _.each( this.subpaths, function( subpath ) {
          bounds.includeBounds( subpath.getBounds() );
        } );
        this._bounds = bounds;
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    /**
     * Returns the bounds for a stroked version of this shape. The input lineStyles are used to determine the size and
     * style of the stroke, and then the bounds of the stroked shape are returned.
     * @public
     *
     * @param {LineStyles} lineStyles
     * @returns {Bounds2}
     */
    getStrokedBounds: function( lineStyles ) {
      // Check if all of our segments end vertically or horizontally AND our drawable subpaths are all closed. If so,
      // we can apply a bounds dilation.
      var areStrokedBoundsDilated = true;
      for ( var i = 0; i < this.subpaths.length; i++ ) {
        var subpath = this.subpaths[ i ];

        // If a subpath with any segments is NOT closed, line-caps will apply. We can't make the simplification in this
        // case.
        if ( subpath.isDrawable() && !subpath.isClosed() ) {
          areStrokedBoundsDilated = false;
          break;
        }
        for ( var j = 0; j < subpath.segments.length; j++ ) {
          var segment = subpath.segments[ j ];
          if ( !segment.areStrokedBoundsDilated() ) {
            areStrokedBoundsDilated = false;
            break;
          }
        }
      }

      if ( areStrokedBoundsDilated ) {
        return this.bounds.dilated( lineStyles.lineWidth / 2 );
      }
      else {
        return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );
      }
    },

    /**
     *
     * @param {Matrix3} matrix
     * @param {LineStyles} [lineStyles]
     * @returns {Bounds2}
     */
    getBoundsWithTransform: function( matrix, lineStyles ) {
      // if we don't need to handle rotation/shear, don't use the extra effort!
      if ( matrix.isAxisAligned() ) {
        return this.getStrokedBounds( lineStyles );
      }

      var bounds = Bounds2.NOTHING.copy();

      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];
        bounds.includeBounds( subpath.getBoundsWithTransform( matrix ) );
      }

      if ( lineStyles ) {
        bounds.includeBounds( this.getStrokedShape( lineStyles ).getBoundsWithTransform( matrix ) );
      }

      return bounds;
    },

    /**
     * Return an approximate value of the area inside of this Shape (where containsPoint is true) using Monte-Carlo.
     * @public
     *
     * @param {number} numSamples - How many times to randomly check for inclusion of points.
     * @returns {number}
     */
    getApproximateArea: function( numSamples ) {
      var x = this.bounds.minX;
      var y = this.bounds.minY;
      var width = this.bounds.width;
      var height = this.bounds.height;

      var rectangleArea = width * height;
      var count = 0;
      var point = new Vector2();
      for ( var i = 0; i < numSamples; i++ ) {
        point.x = x + Math.random() * width;
        point.y = y + Math.random() * height;
        if ( this.containsPoint( point ) ) {
          count++;
        }
      }
      return rectangleArea * count / numSamples;
    },

    /**
     * Return the approximate location of the centroid of the Shape (the average of all points where containsPoint is true)
     * using Monte-Carlo methods.
     * @public
     *
     * @param {number} numSamples - How many times to randomly check for inclusion of points.
     * @returns {number}
     */
    getApproximateCentroid: function( numSamples ) {
      var x = this.bounds.minX;
      var y = this.bounds.minY;
      var width = this.bounds.width;
      var height = this.bounds.height;

      var count = 0;
      var sum = new Vector2();
      var point = new Vector2();
      for ( var i = 0; i < numSamples; i++ ) {
        point.x = x + Math.random() * width;
        point.y = y + Math.random() * height;
        if ( this.containsPoint( point ) ) {
          sum.add( point );
          count++;
        }
      }
      return sum.dividedScalar( count );
    },

    /**
     * Should be called after mutating the x/y of Vector2 points that were passed in to various Shape calls, so that
     * derived information computed (bounds, etc.) will be correct, and any clients (e.g. Scenery Paths) will be
     * notified of the updates.
     */
    invalidatePoints: function() {
      this._invalidatingPoints = true;

      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        this.subpaths[ i ].invalidatePoints();
      }

      this._invalidatingPoints = false;
      this.invalidate();
    },

    /**
     *
     * @returns {string}
     */
    toString: function() {
      // TODO: consider a more verbose but safer way?
      return 'new kite.Shape( \'' + this.getSVGPath() + '\' )';
    },

    /*---------------------------------------------------------------------------*
     * Internal subpath computations
     *----------------------------------------------------------------------------*/

    /**
     * @private
     */
    invalidate: function() {
      assert && assert( !this._immutable, 'Attempt to modify an immutable Shape' );

      if ( !this._invalidatingPoints ) {
        this._bounds = null;

        this.notifyInvalidationListeners();
      }
    },

    /**
     * Called when a part of the Shape has changed, or if metadata on the Shape has changed (e.g. it became immutable).
     * @private
     */
    notifyInvalidationListeners: function() {
      this.trigger0( 'invalidated' );
    },

    /**
     * @private
     */
    addSegmentAndBounds: function( segment ) {
      this.getLastSubpath().addSegment( segment );
      this.invalidate();
    },

    /**
     * @private
     * @param {Vector2} point
     */
    ensure: function( point ) {
      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
        this.getLastSubpath().addPoint( point );
      }
    },

    /**
     * Adds a subpath
     * @private
     * @param {Subpath} subpath
     */
    addSubpath: function( subpath ) {
      this.subpaths.push( subpath );

      // listen to when the subpath is invalidated (will cause bounds recomputation here)
      subpath.onStatic( 'invalidated', this._invalidateListener );

      this.invalidate();

      return this; // allow chaining
    },

    /**
     * Determines if there are any subpaths
     * @private
     * @returns {boolean}
     */
    hasSubpaths: function() {
      return this.subpaths.length > 0;
    },

    /**
     * Gets the last subpath
     * @private
     * @returns {Subpath}
     */
    getLastSubpath: function() {
      return _.last( this.subpaths );
    },

    /**
     * Gets the last point in the last subpath, or null if it doesn't exist
     * @private
     * @returns {Subpath|null}
     */
    getLastPoint: function() {
      return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;
    },

    /**
     * Gets the last drawable segment in the last subpath, or null if it doesn't exist
     * @private
     * @returns {Segment|null}
     */
    getLastSegment: function() {
      if ( !this.hasSubpaths() ) { return null; }

      var subpath = this.getLastSubpath();
      if ( !subpath.isDrawable() ) { return null; }

      return subpath.getLastSegment();
    },

    /**
     * Returns the control point to be used to create a smooth quadratic segments
     * @private
     * @returns {Vector2}
     */
    getSmoothQuadraticControlPoint: function() {
      var lastPoint = this.getLastPoint();

      if ( this.lastQuadraticControlPoint ) {
        return lastPoint.plus( lastPoint.minus( this.lastQuadraticControlPoint ) );
      }
      else {
        return lastPoint;
      }
    },

    /**
     * Returns the control point to be used to create a smooth cubic segment
     * @private
     * @returns {Vector2}
     */
    getSmoothCubicControlPoint: function() {
      var lastPoint = this.getLastPoint();

      if ( this.lastCubicControlPoint ) {
        return lastPoint.plus( lastPoint.minus( this.lastCubicControlPoint ) );
      }
      else {
        return lastPoint;
      }
    },

    /**
     * Returns the last point in the last subpath, or the Vector ZERO if it doesn't exist
     * @private
     * @returns {Vector2}
     */
    getRelativePoint: function() {
      var lastPoint = this.getLastPoint();
      return lastPoint ? lastPoint : Vector2.ZERO;
    }
  } );

  /*---------------------------------------------------------------------------*
   * Shape shortcuts
   *----------------------------------------------------------------------------*/

  /**
   * Creates a rectangle
   * @public
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @returns {Shape}
   */
  Shape.rectangle = function( x, y, width, height ) {
    return new Shape().rect( x, y, width, height );
  };
  Shape.rect = Shape.rectangle;

  /**
   * Creates a round rectangle {Shape}, with {number} arguments. Uses circular or elliptical arcs if given.
   * @public
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} arcw
   * @param {number} arch
   * @returns {Shape}
   */
  Shape.roundRect = function( x, y, width, height, arcw, arch ) {
    return new Shape().roundRect( x, y, width, height, arcw, arch );
  };
  Shape.roundRectangle = Shape.roundRect;

  /**
   * Creates a rounded rectangle, where each corner can have a different radius. The radii default to 0, and may be set
   * using topLeft, topRight, bottomLeft and bottomRight in the options.
   * @public

   * E.g.:
   *
   * var cornerRadius = 20;
   * var rect = Shape.roundedRectangleWithRadii( 0, 0, 200, 100, {
   *   topLeft: cornerRadius,
   *   topRight: cornerRadius
   * } );
   *
   * @param {number} x - Left edge location
   * @param {number} y - Top edge location
   * @param {number} width - Width of rectangle
   * @param {number} height - Height of rectangle
   * @param {Object} [cornerRadii] - Optional object with potential radii for each corner.
   * @returns {Shape}
   */
  Shape.roundedRectangleWithRadii = function( x, y, width, height, cornerRadii ) {
    // defaults to 0 (not using _.extends, since we reference each multiple times)
    var topLeftRadius = cornerRadii && cornerRadii.topLeft || 0;
    var topRightRadius = cornerRadii && cornerRadii.topRight || 0;
    var bottomLeftRadius = cornerRadii && cornerRadii.bottomLeft || 0;
    var bottomRightRadius = cornerRadii && cornerRadii.bottomRight || 0;

    // type and constraint assertions
    assert && assert( typeof x === 'number' && isFinite( x ), 'Non-finite x' );
    assert && assert( typeof y === 'number' && isFinite( y ), 'Non-finite y' );
    assert && assert( typeof width === 'number' && width >= 0 && isFinite( width ), 'Negative or non-finite width' );
    assert && assert( typeof height === 'number' && height >= 0 && isFinite( height ), 'Negative or non-finite height' );
    assert && assert( typeof topLeftRadius === 'number' && topLeftRadius >= 0 && isFinite( topLeftRadius ),
      'Invalid topLeft' );
    assert && assert( typeof topRightRadius === 'number' && topRightRadius >= 0 && isFinite( topRightRadius ),
      'Invalid topRight' );
    assert && assert( typeof bottomLeftRadius === 'number' && bottomLeftRadius >= 0 && isFinite( bottomLeftRadius ),
      'Invalid bottomLeft' );
    assert && assert( typeof bottomRightRadius === 'number' && bottomRightRadius >= 0 && isFinite( bottomRightRadius ),
      'Invalid bottomRight' );

    // verify there is no overlap between corners
    assert && assert( topLeftRadius + topRightRadius <= width, 'Corner overlap on top edge' );
    assert && assert( bottomLeftRadius + bottomRightRadius <= width, 'Corner overlap on bottom edge' );
    assert && assert( topLeftRadius + bottomLeftRadius <= height, 'Corner overlap on left edge' );
    assert && assert( topRightRadius + bottomRightRadius <= height, 'Corner overlap on right edge' );

    var shape = new kite.Shape();
    var right = x + width;
    var bottom = y + height;

    // To draw the rounded rectangle, we use the implicit "line from last segment to next segment" and the close() for
    // all of the straight line edges between arcs, or lineTo the corner.

    if ( bottomRightRadius > 0 ) {
      shape.arc( right - bottomRightRadius, bottom - bottomRightRadius, bottomRightRadius, 0, Math.PI / 2, false );
    }
    else {
      shape.moveTo( right, bottom );
    }

    if ( bottomLeftRadius > 0 ) {
      shape.arc( x + bottomLeftRadius, bottom - bottomLeftRadius, bottomLeftRadius, Math.PI / 2, Math.PI, false );
    }
    else {
      shape.lineTo( x, bottom );
    }

    if ( topLeftRadius > 0 ) {
      shape.arc( x + topLeftRadius, y + topLeftRadius, topLeftRadius, Math.PI, 3 * Math.PI / 2, false );
    }
    else {
      shape.lineTo( x, y );
    }

    if ( topRightRadius > 0 ) {
      shape.arc( right - topRightRadius, y + topRightRadius, topRightRadius, 3 * Math.PI / 2, 2 * Math.PI, false );
    }
    else {
      shape.lineTo( right, y );
    }

    shape.close();

    return shape;
  };

  /**
   * Creates a closed polygon from an array of vertices by connecting them by a series of lines.
   * The lines are joining the adjacent vertices in the array.
   * @public
   * @param {Array.<Vector2>} vertices
   * @returns {Shape}
   */
  Shape.polygon = function( vertices ) {
    return new Shape().polygon( vertices );
  };

  /**
   * Creates a rectangular shape from bounds
   * @public
   * @param {Bounds2} bounds
   * @returns {Shape}
   */
  Shape.bounds = function( bounds ) {
    return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );
  };

  /**
   * Creates a line segment, using either (x1,y1,x2,y2) or ({x1,y1},{x2,y2}) arguments
   * @public
   * @param {number|Vector2} a
   * @param {number|Vector2} b
   * @param {number} [c]
   * @param {number} [d]
   * @returns {Shape}
   */
  Shape.lineSegment = function( a, b, c, d ) {
    // TODO: add type assertions?
    if ( typeof a === 'number' ) {
      return new Shape().moveTo( a, b ).lineTo( c, d );
    }
    else {
      // then a and b must be {Vector2}
      return new Shape().moveToPoint( a ).lineToPoint( b );
    }
  };

  /**
   * Returns a regular polygon of radius and number of sides
   * The regular polygon is oriented such that the first vertex lies on the positive x-axis.
   * @public
   * @param {number} sides - an integer
   * @param {number} radius
   * @returns {Shape}
   */
  Shape.regularPolygon = function( sides, radius ) {
    var shape = new Shape();
    _.each( _.range( sides ), function( k ) {
      var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );
      ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );
    } );
    return shape.close();
  };

  /**
   * Creates a circle
   * supports both circle( centerX, centerY, radius ), circle( center, radius ), and circle( radius ) with the center default to 0,0
   * @public
   * @param {Vector2|number} centerX
   * @param {number} [centerY]
   * @param {number} [radius]
   * @returns {Shape}
   */
  Shape.circle = function( centerX, centerY, radius ) {
    if ( centerY === undefined ) {
      // circle( radius ), center = 0,0
      return new Shape().circle( 0, 0, centerX );
    }
    return new Shape().circle( centerX, centerY, radius );
  };

  /**
   * Supports ellipse( centerX, centerY, radiusX, radiusY, rotation ), ellipse( center, radiusX, radiusY, rotation ), and ellipse( radiusX, radiusY, rotation )
   * with the center default to 0,0 and rotation of 0.  The rotation is about the centerX, centerY.
   * @public
   * @param {number|Vector2} centerX
   * @param {number} [centerY]
   * @param {number|Vector2} radiusX
   * @param {number} [radiusY]
   * @param {number} rotation
   * @returns {Shape}
   */
  Shape.ellipse = function( centerX, centerY, radiusX, radiusY, rotation ) {
    // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling
    if ( radiusY === undefined ) {
      // ellipse( radiusX, radiusY ), center = 0,0
      return new Shape().ellipse( 0, 0, centerX, centerY, radiusX );
    }
    return new Shape().ellipse( centerX, centerY, radiusX, radiusY, rotation );
  };

  /**
   * Supports both arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) and arc( center, radius, startAngle, endAngle, anticlockwise )
   * @public
   * @param {Vector2|number} centerX
   * @param {number} [centerY]
   * @param {number} radius - How far from the center the arc will be
   * @param {number} startAngle - Angle (radians) of the start of the arc
   * @param {number} endAngle - Angle (radians) of the end of the arc
   * @param {boolean} [anticlockwise] - Decides which direction the arc takes around the center
   * @returns {Shape}
   */
  Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {
    return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );
  };

  return Shape;
} );

// Copyright 2013-2016, University of Colorado Boulder


/**
 * An enumeration of different back-end technologies used for rendering. It also essentially represents the API that
 * nodes need to implement to be used with this specified back-end.
 *
 * We use a bitmask to represent renderers currently, in a way that can be logically-ANDed in order to obtain
 * information about "what renderer can support all of these Nodes?"
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Renderer',['require','SCENERY/scenery'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  // now it's a namespace
  var Renderer = {};
  scenery.register( 'Renderer', Renderer );

  //OHTWO TODO: rename to take advantage of lack of deprecated names? (remove bitmask prefix)

  /*---------------------------------------------------------------------------*
   * Renderer bitmask flags
   *---------------------------------------------------------------------------*/

  Renderer.numActiveRenderers = 4;
  Renderer.bitsPerRenderer = 5;
  Renderer.bitmaskRendererArea = 0x00000FF;
  Renderer.bitmaskCurrentRendererArea = 0x000000F;
  Renderer.bitmaskLacksOffset = 0x10000;
  Renderer.bitmaskLacksShift = 16; // number of bits between the main renderer bitmask and the "lacks" variety
  Renderer.bitmaskNodeDefault = Renderer.bitmaskRendererArea;

  Renderer.bitmaskCanvas = 0x0000001;
  Renderer.bitmaskSVG = 0x0000002;
  Renderer.bitmaskDOM = 0x0000004;
  Renderer.bitmaskWebGL = 0x0000008;
  // 10, 20, 40, 80 reserved for future renderers NOTE: update bitmaskCurrentRendererArea/numActiveRenderers if they are added/removed

  // summary bits (for RendererSummary):
  Renderer.bitmaskSingleCanvas = 0x100;
  Renderer.bitmaskSingleSVG = 0x200;
  // reserved gap 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000 for future renderer-specific single information
  Renderer.bitmaskNotPainted = 0x1000;
  Renderer.bitmaskBoundsValid = 0x2000;
  Renderer.bitmaskNotAccessible = 0x4000;
  // summary bits for whether a renderer could be potentially used to display a Node.
  Renderer.bitmaskLacksCanvas = Renderer.bitmaskCanvas << Renderer.bitmaskLacksShift; // 0x10000
  Renderer.bitmaskLacksSVG = Renderer.bitmaskSVG << Renderer.bitmaskLacksShift; // 0x20000
  Renderer.bitmaskLacksDOM = Renderer.bitmaskDOM << Renderer.bitmaskLacksShift; // 0x40000
  Renderer.bitmaskLacksWebGL = Renderer.bitmaskWebGL << Renderer.bitmaskLacksShift; // 0x80000
  // reserved gap 0x10000, 0x20000, 0x40000, 0x80000 for future renderers

  Renderer.isCanvas = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskCanvas ) !== 0;
  };
  Renderer.isSVG = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskSVG ) !== 0;
  };
  Renderer.isDOM = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskDOM ) !== 0;
  };
  Renderer.isWebGL = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskWebGL ) !== 0;
  };

  var rendererMap = {
    canvas: Renderer.bitmaskCanvas,
    svg: Renderer.bitmaskSVG,
    dom: Renderer.bitmaskDOM,
    webgl: Renderer.bitmaskWebGL
  };
  Renderer.fromName = function( name ) {
    return rendererMap[ name ];
  };

  // returns the part of the bitmask that should contain only Canvas/SVG/DOM/WebGL flags
  //OHTWO TODO: use this instead of direct access to bitmaskRendererArea
  Renderer.stripBitmask = function( bitmask ) {
    return bitmask & Renderer.bitmaskRendererArea;
  };

  Renderer.createOrderBitmask = function( firstRenderer, secondRenderer, thirdRenderer, fourthRenderer ) {
    firstRenderer = firstRenderer || 0;
    secondRenderer = secondRenderer || 0;
    thirdRenderer = thirdRenderer || 0;
    fourthRenderer = fourthRenderer || 0;

    // uses 20 bits now with 4 renderers
    return firstRenderer |
           ( secondRenderer << 5 ) |
           ( thirdRenderer << 10 ) |
           ( fourthRenderer << 15 );
  };
  // bitmaskOrderN with n=0 is bitmaskOrderFirst, n=1 is bitmaskOrderSecond, etc.
  Renderer.bitmaskOrder = function( bitmask, n ) {
    // Normally the condition here shouldn't be needed, but Safari seemed to cause a logic error when this function
    // gets inlined elsewhere if n=0. See https://github.com/phetsims/scenery/issues/481 and
    // https://github.com/phetsims/bending-light/issues/259.
    if ( n > 0 ) {
      bitmask = bitmask >> ( 5 * n );
    }
    return bitmask & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderFirst = function( bitmask ) {
    return bitmask & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderSecond = function( bitmask ) {
    return ( bitmask >> 5 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderThird = function( bitmask ) {
    return ( bitmask >> 10 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderFourth = function( bitmask ) {
    return ( bitmask >> 15 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.pushOrderBitmask = function( bitmask, renderer ) {
    assert && assert( typeof bitmask === 'number' );
    assert && assert( typeof renderer === 'number' );
    var rendererToInsert = renderer;
    var totalBits = Renderer.bitsPerRenderer * Renderer.numActiveRenderers;
    for ( var i = 0; i <= totalBits; i += Renderer.bitsPerRenderer ) {
      var currentRenderer = ( bitmask >> i ) & Renderer.bitmaskCurrentRendererArea;
      if ( currentRenderer === rendererToInsert ) {
        return bitmask;
      }
      else if ( currentRenderer === 0 ) {
        // place the renderer and exit
        bitmask = bitmask | ( rendererToInsert << i );
        return bitmask;
      }
      else {
        // clear out that slot
        bitmask = ( bitmask & ~( Renderer.bitmaskCurrentRendererArea << i ) );

        // place in the renderer to insert
        bitmask = bitmask | ( rendererToInsert << i );

        rendererToInsert = currentRenderer;
      }

      // don't walk over and re-place our initial renderer
      if ( rendererToInsert === renderer ) {
        return bitmask;
      }
    }

    throw new Error( 'pushOrderBitmask overflow' );
  };

  Renderer.createSelfDrawable = function( instance, node, selfRenderer, fittable ) {
    var drawable;

    if ( Renderer.isCanvas( selfRenderer ) ) {
      drawable = node.createCanvasDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isSVG( selfRenderer ) ) {
      drawable = node.createSVGDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isDOM( selfRenderer ) ) {
      drawable = node.createDOMDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isWebGL( selfRenderer ) ) {
      drawable = node.createWebGLDrawable( selfRenderer, instance );
    }
    else {
      throw new Error( 'Unrecognized renderer: ' + selfRenderer );
    }

    // Check to make sure that all of the drawables have the required mark-dirty methods available.
    if ( assert ) {
      _.each( node.drawableMarkFlags, function( flag ) {
        var methodName = 'markDirty' + flag[ 0 ].toUpperCase() + flag.slice( 1 );
        assert( typeof drawable[ methodName ] === 'function', 'Did not find ' + methodName );
      } );
    }

    // Initialize its fittable flag
    drawable.setFittable( fittable );

    return drawable;
  };

  /*---------------------------------------------------------------------------*
   * WebGL Renderer type enumeration
   *----------------------------------------------------------------------------*/
  Renderer.webglCustom = 0x1;
  Renderer.webglTexturedTriangles = 0x2;
  Renderer.webglVertexColorPolygons = 0x3;

  return Renderer;
} );

// Copyright 2013-2016, University of Colorado Boulder


/**
 * Contains information about what renderers (and a few other flags) are supported for an entire subtree.
 *
 * We effectively do this by tracking bitmask changes from scenery.js (used for rendering properties in general). In particular, we count
 * how many zeros in the bitmask we have in key places.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/RendererSummary',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Renderer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );

  var summaryBits = [
    // renderer bits ("Is renderer X supported by the entire sub-tree?")
    Renderer.bitmaskCanvas,
    Renderer.bitmaskSVG,
    Renderer.bitmaskDOM,
    Renderer.bitmaskWebGL,

    // summary bits (added to the renderer bitmask to handle special flags for the summary)
    Renderer.bitmaskSingleCanvas,
    Renderer.bitmaskSingleSVG,
    Renderer.bitmaskNotPainted,
    Renderer.bitmaskBoundsValid,
    Renderer.bitmaskNotAccessible,

    // inverse renderer bits ("Do all painted nodes NOT support renderer X in this sub-tree?")
    Renderer.bitmaskLacksCanvas,
    Renderer.bitmaskLacksSVG,
    Renderer.bitmaskLacksDOM,
    Renderer.bitmaskLacksWebGL
  ];
  var numSummaryBits = summaryBits.length;

  // A bitmask with all of the bits set that we record
  var bitmaskAll = 0;
  for ( var l = 0; l < numSummaryBits; l++ ) {
    bitmaskAll |= summaryBits[ l ];
  }

  function RendererSummary( node ) {
    // NOTE: assumes that we are created in the Node constructor
    assert && assert( node._rendererBitmask === Renderer.bitmaskNodeDefault, 'Node must have a default bitmask when creating a RendererSummary' );
    assert && assert( node._children.length === 0, 'Node cannot have children when creating a RendererSummary' );

    this.node = node;

    // Maps stringified bitmask bit (e.g. "1" for Canvas, since Renderer.bitmaskCanvas is 0x01) to
    // a count of how many children (or self) have that property (e.g. can't renderer all of their contents with Canvas)
    this._counts = {};
    for ( var i = 0; i < numSummaryBits; i++ ) {
      this._counts[ summaryBits[ i ] ] = 0; // set everything to 0 at first
    }

    // @public
    this.bitmask = bitmaskAll;

    this.selfBitmask = RendererSummary.summaryBitmaskForNodeSelf( node );

    this.summaryChange( this.bitmask, this.selfBitmask );

    // required listeners to update our summary based on painted/non-painted information
    var listener = this.selfChange.bind( this );
    this.node.onStatic( 'opacity', listener );
    this.node.onStatic( 'hint', listener ); // should fire on things like node.renderer being changed
    this.node.onStatic( 'clip', listener );
    this.node.onStatic( 'selfBoundsValid', listener ); // e.g. Text, may change based on boundsMethod
    this.node.onStatic( 'accessibleContent', listener );
  }

  scenery.register( 'RendererSummary', RendererSummary );

  inherit( Object, RendererSummary, {
    /*
     * @public
     * Use a bitmask of all 1s to represent 'does not exist' since we count zeros
     */
    summaryChange: function( oldBitmask, newBitmask ) {
      assert && this.audit();

      var changeBitmask = oldBitmask ^ newBitmask; // bit set only if it changed

      var ancestorOldMask = 0;
      var ancestorNewMask = 0;
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];

        // If the bit for the renderer has changed
        if ( bit & changeBitmask ) {

          // If it is now set (wasn't before), gained support for the renderer
          if ( bit & newBitmask ) {
            this._counts[ bit ]--; // reduce count, since we count the number of 0s (unsupported)
            if ( this._counts[ bit ] === 0 ) {
              ancestorNewMask |= bit; // add our bit to the "new" mask we will send to ancestors
            }
          }
          // It was set before (now isn't), lost support for the renderer
          else {
            this._counts[ bit ]++; // increment the count, since we count the number of 0s (unsupported)
            if ( this._counts[ bit ] === 1 ) {
              ancestorOldMask |= bit; // add our bit to the "old" mask we will send to ancestors
            }
          }
        }
      }

      if ( ancestorOldMask || ancestorNewMask ) {
        for ( var j = 0; j < numSummaryBits; j++ ) {
          var ancestorBit = summaryBits[ j ];
          // Check for added bits
          if ( ancestorNewMask & ancestorBit ) {
            this.bitmask |= ancestorBit;
          }

          // Check for removed bits
          if ( ancestorOldMask & ancestorBit ) {
            this.bitmask ^= ancestorBit;
            assert && assert( !( this.bitmask & ancestorBit ),
              'Should be cleared, doing cheaper XOR assuming it already was set' );
          }
        }

        this.node.trigger0( 'rendererSummary' ); // please don't change children when listening to this!

        var len = this.node._parents.length;
        for ( var k = 0; k < len; k++ ) {
          this.node._parents[ k ]._rendererSummary.summaryChange( ancestorOldMask, ancestorNewMask );
        }

        assert && assert( this.bitmask === this.computeBitmask(), 'Sanity check' );
      }

      assert && this.audit();
    },

    // @public
    selfChange: function() {
      var oldBitmask = this.selfBitmask;
      var newBitmask = RendererSummary.summaryBitmaskForNodeSelf( this.node );
      if ( oldBitmask !== newBitmask ) {
        this.summaryChange( oldBitmask, newBitmask );
        this.selfBitmask = newBitmask;
      }
    },

    // @private
    computeBitmask: function() {
      var bitmask = 0;
      for ( var i = 0; i < numSummaryBits; i++ ) {
        if ( this._counts[ summaryBits[ i ] ] === 0 ) {
          bitmask |= summaryBits[ i ];
        }
      }
      return bitmask;
    },

    /**
     * @public
     * Is the renderer compatible with every single painted node under this subtree?
     * (Can this entire sub-tree be rendered with just this renderer)
     *
     * @param {number} renderer - Single bit preferred. If multiple bits set, requires ALL painted nodes are compatible
     *                            with ALL of the bits.
     */
    isSubtreeFullyCompatible: function( renderer ) {
      return !!( renderer & this.bitmask );
    },

    /**
     * @public
     * Is the renderer compatible with at least one painted node under this subtree?
     *
     * @param {number} renderer - Single bit preferred. If multiple bits set, will return if a single painted node is
     *                            compatible with at least one of the bits.
     */
    isSubtreeContainingCompatible: function( renderer ) {
      return !( ( renderer << Renderer.bitmaskLacksShift ) & this.bitmask );
    },

    isSingleCanvasSupported: function() {
      return !!( Renderer.bitmaskSingleCanvas & this.bitmask );
    },

    isSingleSVGSupported: function() {
      return !!( Renderer.bitmaskSingleSVG & this.bitmask );
    },

    isNotPainted: function() {
      return !!( Renderer.bitmaskNotPainted & this.bitmask );
    },

    isNotAccessible: function() {
      return !!( Renderer.bitmaskNotAccessible & this.bitmask );
    },

    areBoundsValid: function() {
      return !!( Renderer.bitmaskBoundsValid & this.bitmask );
    },

    /**
     * Given a bitmask representing a list of ordered preferred renderers, we check to see if all of our nodes can be
     * displayed in a single SVG block, AND that given the preferred renderers, that it will actually happen in our
     * rendering process.
     */
    isSubtreeRenderedExclusivelySVG: function( preferredRenderers ) {
      // Check if we have anything that would PREVENT us from having a single SVG block
      if ( !this.isSingleSVGSupported() ) {
        return false;
      }

      // Check for any renderer preferences that would CAUSE us to choose not to display with a single SVG block
      for ( var i = 0; i < Renderer.numActiveRenderers; i++ ) {
        // Grab the next-most preferred renderer
        var renderer = Renderer.bitmaskOrder( preferredRenderers, i );

        // If it's SVG, congrats! Everything will render in SVG (since SVG is supported, as noted above)
        if ( Renderer.bitmaskSVG & renderer ) {
          return true;
        }

        // Since it's not SVG, if there's a single painted node that supports this renderer (which is preferred over SVG),
        // then it will be rendered with this renderer, NOT SVG.
        if ( this.isSubtreeContainingCompatible( renderer ) ) {
          return false;
        }
      }

      return false; // sanity check
    },

    /**
     * Given a bitmask representing a list of ordered preferred renderers, we check to see if all of our nodes can be
     * displayed in a single Canvas block, AND that given the preferred renderers, that it will actually happen in our
     * rendering process.
     */
    isSubtreeRenderedExclusivelyCanvas: function( preferredRenderers ) {
      // Check if we have anything that would PREVENT us from having a single Canvas block
      if ( !this.isSingleCanvasSupported() ) {
        return false;
      }

      // Check for any renderer preferences that would CAUSE us to choose not to display with a single Canvas block
      for ( var i = 0; i < Renderer.numActiveRenderers; i++ ) {
        // Grab the next-most preferred renderer
        var renderer = Renderer.bitmaskOrder( preferredRenderers, i );

        // If it's Canvas, congrats! Everything will render in Canvas (since Canvas is supported, as noted above)
        if ( Renderer.bitmaskCanvas & renderer ) {
          return true;
        }

        // Since it's not Canvas, if there's a single painted node that supports this renderer (which is preferred over Canvas),
        // then it will be rendered with this renderer, NOT Canvas.
        if ( this.isSubtreeContainingCompatible( renderer ) ) {
          return false;
        }
      }

      return false; // sanity check
    },

    // for debugging purposes
    audit: function() {
      if ( assert ) {
        for ( var i = 0; i < numSummaryBits; i++ ) {
          var bit = summaryBits[ i ];
          var countIsZero = this._counts[ bit ] === 0;
          var bitmaskContainsBit = !!( this.bitmask & bit );
          assert( countIsZero === bitmaskContainsBit, 'Bits should be set if count is zero' );
        }
      }
    },

    // for debugging purposes
    toString: function() {
      var result = RendererSummary.bitmaskToString( this.bitmask );
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];
        var countForBit = this._counts[ bit ];
        if ( countForBit !== 0 ) {
          result += ' ' + RendererSummary.bitToString( bit ) + ':' + countForBit;
        }
      }
      return result;
    }
  }, {
    bitmaskAll: bitmaskAll,

    /**
     * Determines which of the summary bits can be set for a specific Node (ignoring children/ancestors).
     * For instance, for bitmaskSingleSVG, we only don't include the flag if THIS node prevents its usage
     * (even though child nodes may prevent it in the renderer summary itself).
     *
     * @param {Node} node
     */
    summaryBitmaskForNodeSelf: function( node ) {
      var bitmask = node._rendererBitmask;

      if ( node.isPainted() ) {
        bitmask |= ( ( node._rendererBitmask & Renderer.bitmaskCurrentRendererArea ) ^ Renderer.bitmaskCurrentRendererArea ) << Renderer.bitmaskLacksShift;
      }
      else {
        bitmask |= Renderer.bitmaskCurrentRendererArea << Renderer.bitmaskLacksShift;
      }

      // NOTE: If changing, see Instance.updateRenderingState
      var requiresSplit = node._hints.requireElement || node._hints.cssTransform || node._hints.layerSplit;
      var rendererHint = node._hints.renderer;

      // Whether this subtree will be able to support a single SVG element
      // NOTE: If changing, see Instance.updateRenderingState
      if ( !requiresSplit && // Can't have a single SVG element if we are split
           Renderer.isSVG( node._rendererBitmask ) && // If our node doesn't support SVG, can't do it
           ( !rendererHint || Renderer.isSVG( rendererHint ) ) ) { // Can't if a renderer hint is set to something else
        bitmask |= Renderer.bitmaskSingleSVG;
      }

      // Whether this subtree will be able to support a single Canvas element
      // NOTE: If changing, see Instance.updateRenderingState
      if ( !requiresSplit && // Can't have a single SVG element if we are split
           Renderer.isCanvas( node._rendererBitmask ) && // If our node doesn't support Canvas, can't do it
           ( !rendererHint || Renderer.isCanvas( rendererHint ) ) ) { // Can't if a renderer hint is set to something else
        bitmask |= Renderer.bitmaskSingleCanvas;
      }

      if ( !node.isPainted() ) {
        bitmask |= Renderer.bitmaskNotPainted;
      }
      if ( node.areSelfBoundsValid() ) {
        bitmask |= Renderer.bitmaskBoundsValid;
      }
      if ( !node.accessibleContent ) {
        bitmask |= Renderer.bitmaskNotAccessible;
      }

      return bitmask;
    },

    // for debugging purposes
    bitToString: function( bit ) {
      if ( bit === Renderer.bitmaskCanvas ) { return 'Canvas'; }
      if ( bit === Renderer.bitmaskSVG ) { return 'SVG'; }
      if ( bit === Renderer.bitmaskDOM ) { return 'DOM'; }
      if ( bit === Renderer.bitmaskWebGL ) { return 'WebGL'; }
      if ( bit === Renderer.bitmaskLacksCanvas ) { return '(-Canvas)'; }
      if ( bit === Renderer.bitmaskLacksSVG ) { return '(-SVG)'; }
      if ( bit === Renderer.bitmaskLacksDOM ) { return '(-DOM)'; }
      if ( bit === Renderer.bitmaskLacksWebGL ) { return '(-WebGL)'; }
      if ( bit === Renderer.bitmaskSingleCanvas ) { return 'SingleCanvas'; }
      if ( bit === Renderer.bitmaskSingleSVG ) { return 'SingleSVG'; }
      if ( bit === Renderer.bitmaskNotPainted ) { return 'NotPainted'; }
      if ( bit === Renderer.bitmaskBoundsValid ) { return 'BoundsValid'; }
      if ( bit === Renderer.bitmaskNotAccessible ) { return 'NotAccessible'; }
      return '?';
    },

    // for debugging purposes
    bitmaskToString: function( bitmask ) {
      var result = '';
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];
        if ( bitmask & bit ) {
          result += RendererSummary.bitToString( bit ) + ' ';
        }
      }
      return result;
    }
  } );

  return RendererSummary;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Sub-component of a Node that handles pickability and hit testing.
 *
 * A "listener equivalent" is either the existence of at least one input listener, or pickable:true. Nodes with
 * listener equivalents will basically try to hit-test ALL descendants that aren't invisible or pickable:false.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Picker',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Bounds2','DOT/Vector2'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );

  /**
   * @constructor
   *
   * @param {Node} node - Our node.
   */
  function Picker( node ) {
    // @private {Node} - Our node reference (does not change)
    this.node = node;

    // @private {boolean} - Whether our last-known state would have us be pruned by hit-test searches.
    //                      Should be equal to node.pickable === false || node.isVisible() === false.
    //                      Updated synchronously.
    this.selfPruned = false;

    // @private {boolean} - Whether our last-known state would have us not prune descendant subtrees for the lack of
    //                      listener equivalents (whether we have a listener equivalent).
    //                      Should be equal to node.pickable === true || node._inputListeners.length > 0.
    //                      Updated synchronously.
    this.selfInclusive = false;

    // @private {boolean} - Whether our subtree can be pruned IF no ancestor (or us) has selfInclusive as true.
    //                      Equivalent to:
    //                        node.pickable === false ||
    //                        !node.isVisible() ||
    //                        ( node.pickable !== true && subtreePickableCount === 0 )
    this.subtreePrunable = true;

    // @private {number} - Count designed to be non-zero when there is a listener equivalent in this node's subtree.
    //                     Effectively the sum of #inputListeners + (1?isPickable:true) + #childrenWithNonZeroCount.
    //                     Notably, it ignores children who are guaranteed to be pruned (selfPruned:true).
    this.subtreePickableCount = 0;

    // NOTE: We need "inclusive" and "exclusive" bounds to ideally be separate, so that they can be cached
    // independently. It's possible for one trail to have an ancestor with pickable:true (inclusive) while another
    // trail has no ancestors that make the search inclusive. This would introduce "thrashing" in the older version,
    // where it would continuously compute one or the other. Here, both versions can be stored.

    // @private {Bounds2} - Bounds to be used for pruning mouse hit tests when an ancestor has a listener equivalent.
    //                      Updated lazily, while the dirty flag is updated synchronously.
    this.mouseInclusiveBounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - Bounds to be used for pruning mouse hit tests when ancestors have NO listener equivalent.
    //                      Updated lazily, while the dirty flag is updated synchronously.
    this.mouseExclusiveBounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - Bounds to be used for pruning touch hit tests when an ancestor has a listener equivalent.
    //                      Updated lazily, while the dirty flag is updated synchronously.
    this.touchInclusiveBounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - Bounds to be used for pruning touch hit tests when ancestors have NO listener equivalent.
    //                      Updated lazily, while the dirty flag is updated synchronously.
    this.touchExclusiveBounds = Bounds2.NOTHING.copy();

    // @private {boolean} - Dirty flags, one for each Bounds.
    this.mouseInclusiveDirty = true;
    this.mouseExclusiveDirty = true;
    this.touchInclusiveDirty = true;
    this.touchExclusiveDirty = true;

    // @private {Vector2} - Used to minimize garbage created in the hit-testing process
    this.scratchVector = new Vector2();
  }

  scenery.register( 'Picker', Picker );

  inherit( Object, Picker, {

    /*
     * Return a trail to the top node (if any, otherwise null) whose self-rendered area contains the
     * point (in parent coordinates).
     * @public
     *
     * @param {Vector2} point
     * @param {boolean} useMouse - Whether mouse-specific customizations (and acceleration) applies
     * @param {boolean} useTouch - Whether touch-specific customizations (and acceleration) applies
     * @returns {Trail|null}
     */
    hitTest: function( point, useMouse, useTouch ) {
      assert && assert( point, 'trailUnderPointer requires a point' );

      sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( '-------------- ' + this.node.constructor.name + '#' + this.node.id );

      var isBaseInclusive = this.selfInclusive;

      // Validate the bounds that we will be using for hit acceleration. This should validate all bounds that could be
      // hit by recursiveHitTest.
      if ( useMouse ) {
        if ( isBaseInclusive ) {
          this.validateMouseInclusive();
        }
        else {
          this.validateMouseExclusive();
        }
      }
      else if ( useTouch ) {
        if ( isBaseInclusive ) {
          this.validateTouchInclusive();
        }
        else {
          this.validateTouchExclusive();
        }
      }
      else {
        this.node.validateBounds();
      }

      // Kick off recursive handling, with isInclusive:false
      return this.recursiveHitTest( point, useMouse, useTouch, false );
    },

    recursiveHitTest: function( point, useMouse, useTouch, isInclusive ) {
      isInclusive = isInclusive || this.selfInclusive;

      // If we are selfPruned, ignore this node and its subtree (invisible or pickable:false).
      // If the search is NOT inclusive (no listener equivalent), also ignore this subtree if subtreePrunable is true.
      if ( this.selfPruned || ( !isInclusive && this.subtreePrunable ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id +
          ' pruned ' + ( this.selfPruned ? '(self)' : '(subtree)' ) );
        return null;
      }

      // Validation should have already been done in hitTest(), we just need to grab the accelerated bounds.
      var pruningBounds;
      if ( useMouse ) {
        pruningBounds = isInclusive ? this.mouseInclusiveBounds : this.mouseExclusiveBounds;
        assert && assert( isInclusive ? !this.mouseInclusiveDirty : !this.mouseExclusiveDirty );
      }
      else if ( useTouch ) {
        pruningBounds = isInclusive ? this.touchInclusiveBounds : this.touchExclusiveBounds;
        assert && assert( isInclusive ? !this.touchInclusiveDirty : !this.touchExclusiveDirty );
      }
      else {
        pruningBounds = this.node._bounds;
        assert && assert( !this.node._boundsDirty );
      }

      // Bail quickly if our point is not inside the bounds for the subtree.
      if ( !pruningBounds.containsPoint( point ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' pruned: ' + ( useMouse ? 'mouse' : ( useTouch ? 'touch' : 'regular' ) ) );
        return null; // not in our bounds, so this point can't possibly be contained
      }

      // Transform the point in the local coordinate frame, so we can test it with the clipArea/children
      var localPoint = this.node._transform.getInverse().multiplyVector2( this.scratchVector.set( point ) );

      // If our point is outside of the local-coordinate clipping area, there should be no hit.
      if ( this.node.hasClipArea() && !this.node._clipArea.containsPoint( localPoint ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' out of clip area' );
        return null;
      }

      sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id );

      // Check children before our "self", since the children are rendered on top.
      // Manual iteration here so we can return directly, and so we can iterate backwards (last node is in front).
      for ( var i = this.node._children.length - 1; i >= 0; i-- ) {
        var child = this.node._children[ i ];

        sceneryLog && sceneryLog.hitTest && sceneryLog.push();
        var childHit = child._picker.recursiveHitTest( localPoint, useMouse, useTouch, isInclusive );
        sceneryLog && sceneryLog.hitTest && sceneryLog.pop();

        // If there was a hit, immediately add our node to the start of the Trail (will recursively build the Trail).
        if ( childHit ) {
          return childHit.addAncestor( this.node, i );
        }
      }

      // Tests for mouse and touch hit areas before testing containsPointSelf
      if ( useMouse && this.node._mouseArea ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' mouse area hit' );
        // NOTE: both Bounds2 and Shape have containsPoint! We use both here!
        return this.node._mouseArea.containsPoint( localPoint ) ? new scenery.Trail( this.node ) : null;
      }
      if ( useTouch && this.node._touchArea ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' touch area hit' );
        // NOTE: both Bounds2 and Shape have containsPoint! We use both here!
        return this.node._touchArea.containsPoint( localPoint ) ? new scenery.Trail( this.node ) : null;
      }

      // Didn't hit our children, so check ourself as a last resort. Check our selfBounds first, so we can potentially
      // avoid hit-testing the actual object (which may be more expensive).
      if ( this.node.selfBounds.containsPoint( localPoint ) ) {
        if ( this.node.containsPointSelf( localPoint ) ) {
          sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' self hit' );
          return new scenery.Trail( this.node );
        }
      }

      // No hit
      return null;
    },

    /**
     * Recursively sets dirty flags to true. If the andExclusive parameter is false, only the "inclusive" flags
     * are set to dirty.
     * @private
     *
     * @param {boolean} andExclusive
     * @param {boolean} [ignoreSelfDirty] - If true, will invalidate parents even if we were dirty.
     */
    invalidate: function( andExclusive, ignoreSelfDirty ) {
      assert && assert( typeof andExclusive === 'boolean' );

      // Track whether a 'dirty' flag was changed from false=>true (or if ignoreSelfDirty is passed).
      var wasNotDirty = !!ignoreSelfDirty || !this.mouseInclusiveDirty || !this.touchInclusiveDirty;

      this.mouseInclusiveDirty = true;
      this.touchInclusiveDirty = true;
      if ( andExclusive ) {
        wasNotDirty = wasNotDirty || !this.mouseExclusiveDirty || !this.touchExclusiveDirty;
        this.mouseExclusiveDirty = true;
        this.touchExclusiveDirty = true;
      }

      // If we are selfPruned (or if we were already fully dirty), there should be no reason to call this on our
      // parents. If we are selfPruned, we are guaranteed to not be visited in a search by our parents, so changes
      // that make this picker dirty should NOT affect our parents' pickers values.
      if ( !this.selfPruned && wasNotDirty ) {
        var parents = this.node._parents;
        for ( var i = 0; i < parents.length; i++ ) {
          parents[ i ]._picker.invalidate( andExclusive || this.selfInclusive, false );
        }
      }
    },

    /**
     * Computes the mouseInclusiveBounds for this picker (if dirty), and recursively validates it for all non-pruned
     * children.
     * @private
     *
     * NOTE: For the future, consider sharing more code with related functions. I tried this, and it made things look
     * more complicated (and probably slower), so I've kept some duplication. If a change is made to this function,
     * please check the other validate* methods to see if they also need a change.
     */
    validateMouseInclusive: function() {
      if ( !this.mouseInclusiveDirty ) {
        return;
      }

      this.mouseInclusiveBounds.set( this.node.selfBounds );

      var children = this.node._children;
      for ( var i = 0; i < children.length; i++ ) {
        var childPicker = children[ i ]._picker;

        // Since we are "inclusive", we don't care about subtreePrunable (we won't prune for that). Only check
        // if pruning is force (selfPruned).
        if ( !childPicker.selfPruned ) {
          childPicker.validateMouseInclusive();
          this.mouseInclusiveBounds.includeBounds( childPicker.mouseInclusiveBounds );
        }
      }

      // Include mouseArea (if applicable), exclude outside clipArea (if applicable), and transform to the parent
      // coordinate frame.
      this.applyAreasAndTransform( this.mouseInclusiveBounds, this.node._mouseArea );

      this.mouseInclusiveDirty = false;
    },

    /**
     * Computes the mouseExclusiveBounds for this picker (if dirty), and recursively validates the mouse-related bounds
     * for all non-pruned children.
     * @private
     *
     * Notably, if a picker is selfInclusive, we will switch to validating mouseInclusiveBounds for its subtree, as this
     * is what the hit-testing will use.
     *
     * NOTE: For the future, consider sharing more code with related functions. I tried this, and it made things look
     * more complicated (and probably slower), so I've kept some duplication. If a change is made to this function,
     * please check the other validate* methods to see if they also need a change.
     */
    validateMouseExclusive: function() {
      if ( !this.mouseExclusiveDirty ) {
        return;
      }

      this.mouseExclusiveBounds.set( this.node.selfBounds );

      var children = this.node._children;
      for ( var i = 0; i < children.length; i++ ) {
        var childPicker = children[ i ]._picker;

        // Since we are not "inclusive", we will prune the search if subtreePrunable is true.
        if ( !childPicker.subtreePrunable ) {
          // If our child is selfInclusive, we need to switch to the "inclusive" validation.
          if ( childPicker.selfInclusive ) {
            childPicker.validateMouseInclusive();
            this.mouseExclusiveBounds.includeBounds( childPicker.mouseInclusiveBounds );
          }
          // Otherwise, keep with the exclusive validation.
          else {
            childPicker.validateMouseExclusive();
            this.mouseExclusiveBounds.includeBounds( childPicker.mouseExclusiveBounds );
          }
        }
      }

      // Include mouseArea (if applicable), exclude outside clipArea (if applicable), and transform to the parent
      // coordinate frame.
      this.applyAreasAndTransform( this.mouseExclusiveBounds, this.node._mouseArea );

      this.mouseExclusiveDirty = false;
    },

    /**
     * Computes the touchInclusiveBounds for this picker (if dirty), and recursively validates it for all non-pruned
     * children.
     * @private
     *
     * NOTE: For the future, consider sharing more code with related functions. I tried this, and it made things look
     * more complicated (and probably slower), so I've kept some duplication. If a change is made to this function,
     * please check the other validate* methods to see if they also need a change.
     */
    validateTouchInclusive: function() {
      if ( !this.touchInclusiveDirty ) {
        return;
      }

      this.touchInclusiveBounds.set( this.node.selfBounds );

      var children = this.node._children;
      for ( var i = 0; i < children.length; i++ ) {
        var childPicker = children[ i ]._picker;

        // Since we are "inclusive", we don't care about subtreePrunable (we won't prune for that). Only check
        // if pruning is force (selfPruned).
        if ( !childPicker.selfPruned ) {
          childPicker.validateTouchInclusive();
          this.touchInclusiveBounds.includeBounds( childPicker.touchInclusiveBounds );
        }
      }

      // Include touchArea (if applicable), exclude outside clipArea (if applicable), and transform to the parent
      // coordinate frame.
      this.applyAreasAndTransform( this.touchInclusiveBounds, this.node._touchArea );

      this.touchInclusiveDirty = false;
    },

    /**
     * Computes the touchExclusiveBounds for this picker (if dirty), and recursively validates the touch-related bounds
     * for all non-pruned children.
     * @private
     *
     * Notably, if a picker is selfInclusive, we will switch to validating touchInclusiveBounds for its subtree, as this
     * is what the hit-testing will use.
     *
     * NOTE: For the future, consider sharing more code with related functions. I tried this, and it made things look
     * more complicated (and probably slower), so I've kept some duplication. If a change is made to this function,
     * please check the other validate* methods to see if they also need a change.
     */
    validateTouchExclusive: function() {
      if ( !this.touchExclusiveDirty ) {
        return;
      }

      this.touchExclusiveBounds.set( this.node.selfBounds );

      var children = this.node._children;
      for ( var i = 0; i < children.length; i++ ) {
        var childPicker = children[ i ]._picker;

        // Since we are not "inclusive", we will prune the search if subtreePrunable is true.
        if ( !childPicker.subtreePrunable ) {
          // If our child is selfInclusive, we need to switch to the "inclusive" validation.
          if ( childPicker.selfInclusive ) {
            childPicker.validateTouchInclusive();
            this.touchExclusiveBounds.includeBounds( childPicker.touchInclusiveBounds );
          }
          // Otherwise, keep with the exclusive validation.
          else {
            childPicker.validateTouchExclusive();
            this.touchExclusiveBounds.includeBounds( childPicker.touchExclusiveBounds );
          }
        }
      }

      // Include touchArea (if applicable), exclude outside clipArea (if applicable), and transform to the parent
      // coordinate frame.
      this.applyAreasAndTransform( this.touchExclusiveBounds, this.node._touchArea );

      this.touchExclusiveDirty = false;
    },

    /**
     * Include pointer areas (if applicable), exclude bounds outside the clip area (if applicable), and transform
     * into the parent coordinate frame. Mutates the bounds provided.
     * @private
     *
     * Meant to be called by the validation methods, as this part is the same for every validation that is done.
     *
     * @param {Bounds2} mutableBounds - The bounds to be mutated (e.g. mouseExclusiveBounds).
     * @param {Bounds2|Shape|null} pointerArea - A mouseArea/touchArea that should be included in the search.
     */
    applyAreasAndTransform: function( mutableBounds, pointerArea ) {
      // do this before the transformation to the parent coordinate frame (the mouseArea is in the local coordinate frame)
      if ( pointerArea ) {
        // we accept either Bounds2, or a Shape (in which case, we take the Shape's bounds)
        mutableBounds.includeBounds( pointerArea.isBounds ? pointerArea : pointerArea.bounds );
      }

      if ( this.node.hasClipArea() ) {
        // exclude areas outside of the clipping area's bounds (for efficiency)
        mutableBounds.constrainBounds( this.node._clipArea.bounds );
      }

      // transform it to the parent coordinate frame
      this.node.transformBoundsFromLocalToParent( mutableBounds );
    },

    /**
     * Called from Node when a child is inserted.
     * @public (scenery-internal)
     *
     * NOTE: The child may not be fully added when this is called. Don't audit, or assume that calls to the Node would
     * indicate the parent-child relationship.
     *
     * @param {Node} childNode - Our picker node's new child node.
     */
    onInsertChild: function( childNode ) {
      // If the child is selfPruned, we don't have to update any metadata.
      if ( !childNode._picker.selfPruned ) {
        var hasPickable = childNode._picker.subtreePickableCount > 0;

        // If it has a non-zero subtreePickableCount, we'll need to increment our own count by 1.
        if ( hasPickable ) {
          this.changePickableCount( 1 );
        }

        // If it has a subtreePickableCount of zero, it would be pruned by "exclusive" searches, so we only need to
        // invalidate the "inclusive" bounds.
        this.invalidate( hasPickable, true );
      }
    },

    /**
     * Called from Node when a child is removed.
     * @public (scenery-internal)
     *
     * NOTE: The child may not be fully removed when this is called. Don't audit, or assume that calls to the Node would
     * indicate the parent-child relationship.
     *
     * @param {Node} childNode - Our picker node's child that will be removed.
     */
    onRemoveChild: function( childNode ) {
      // If the child is selfPruned, we don't have to update any metadata.
      if ( !childNode._picker.selfPruned ) {
        var hasPickable = childNode._picker.subtreePickableCount > 0;

        // If it has a non-zero subtreePickableCount, we'll need to decrement our own count by 1.
        if ( hasPickable ) {
          this.changePickableCount( -1 );
        }

        // If it has a subtreePickableCount of zero, it would be pruned by "exclusive" searches, so we only need to
        // invalidate the "inclusive" bounds.
        this.invalidate( hasPickable, true );
      }
    },

    /**
     * Called from Node when an input listener is added to our node.
     * @public (scenery-internal)
     */
    onAddInputListener: function() {
      // Update flags that depend on listener count
      this.checkSelfInclusive();
      this.checkSubtreePrunable();

      // Update our pickable count, since it includes a count of how many input listeners we have.
      this.changePickableCount( 1 ); // NOTE: this should also trigger invalidation of mouse/touch bounds

      if ( assertSlow ) { this.audit(); }
    },

    /**
     * Called from Node when an input listener is removed from our node.
     * @public (scenery-internal)
     */
    onRemoveInputListener: function() {
      // Update flags that depend on listener count
      this.checkSelfInclusive();
      this.checkSubtreePrunable();

      // Update our pickable count, since it includes a count of how many input listeners we have.
      this.changePickableCount( -1 ); // NOTE: this should also trigger invalidation of mouse/touch bounds

      if ( assertSlow ) { this.audit(); }
    },

    /**
     * Called when the 'pickable' value of our Node is changed.
     * @public (scenery-internal)
     *
     * @param {boolean|null} oldPickable - Old value
     * @param {boolean|null} pickable - New value
     */
    onPickableChange: function( oldPickable, pickable ) {
      // Update flags that depend on our pickable setting.
      this.checkSelfPruned();
      this.checkSelfInclusive();
      this.checkSubtreePrunable();

      // Compute our pickable count change (pickable:true counts for 1)
      var change = ( oldPickable === true ? -1 : 0 ) + ( pickable === true ? 1 : 0 );

      if ( change ) {
        this.changePickableCount( change );
      }

      if ( assertSlow ) { this.audit(); }
    },

    /**
     * Called when the visibility of our Node is changed.
     * @public (scenery-internal)
     */
    onVisibilityChange: function() {
      // Update flags that depend on our visibility.
      this.checkSelfPruned();
      this.checkSubtreePrunable();
    },

    /**
     * Called when the mouseArea of the Node is changed.
     * @public (scenery-internal)
     */
    onMouseAreaChange: function() {
      // Bounds can depend on the mouseArea, so we'll invalidate those.
      // TODO: Consider bounds invalidation that only does the 'mouse' flags, since we don't need to invalidate touches.
      this.invalidate( true );
    },

    /**
     * Called when the mouseArea of the Node is changed.
     * @public (scenery-internal)
     */
    onTouchAreaChange: function() {
      // Bounds can depend on the touchArea, so we'll invalidate those.
      // TODO: Consider bounds invalidation that only does the 'touch' flags, since we don't need to invalidate mice.
      this.invalidate( true );
    },

    /**
     * Called when the transform of the Node is changed.
     * @public (scenery-internal)
     */
    onTransformChange: function() {
      // Can affect our bounds
      this.invalidate( true );
    },

    /**
     * Called when the transform of the Node is changed.
     * @public (scenery-internal)
     */
    onSelfBoundsDirty: function() {
      // Can affect our bounds
      this.invalidate( true );
    },

    /**
     * Called when the transform of the Node is changed.
     * @public (scenery-internal)
     */
    onClipAreaChange: function() {
      // Can affect our bounds.
      this.invalidate( true );
    },

    /**
     * Check to see if we are 'selfPruned', and update the value. If it changed, we'll need to notify our parents.
     * @private
     *
     * Note that the prunability "pickable:false" or "invisible" won't affect our computed bounds, so we don't
     * invalidate ourself.
     */
    checkSelfPruned: function() {
      var selfPruned = this.node._pickable === false || !this.node.isVisible();
      if ( this.selfPruned !== selfPruned ) {
        this.selfPruned = selfPruned;

        // Notify parents
        var parents = this.node._parents;
        for ( var i = 0; i < parents.length; i++ ) {
          var picker = parents[ i ]._picker;

          // If we have an input listener/pickable:true in our subtree, we'll need to invalidate exclusive bounds also,
          // and we'll want to update the pickable count of our parent.
          if ( this.subtreePickableCount > 0 ) {
            picker.invalidate( true, true );
            picker.changePickableCount( this.selfPruned ? -1 : 1 );
          }
          // If we have nothing in our subtree that would force a visit, we only need to invalidate the "inclusive"
          // bounds.
          else {
            picker.invalidate( false, true );
          }
        }
      }
    },

    /**
     * Check to see if we are 'selfInclusive', and update the value. If it changed, we'll need to invalidate ourself.
     * @private
     */
    checkSelfInclusive: function() {
      var selfInclusive = this.node._pickable === true || this.node._inputListeners.length > 0;
      if ( this.selfInclusive !== selfInclusive ) {
        this.selfInclusive = selfInclusive;

        // Our dirty flag handling for both inclusive and exclusive depend on this value.
        this.invalidate( true, true );
      }
    },

    /**
     * Update our 'subtreePrunable' flag.
     * @private
     */
    checkSubtreePrunable: function() {
      var subtreePrunable = this.node._pickable === false ||
                            !this.node.isVisible() ||
                            ( this.node._pickable !== true && this.subtreePickableCount === 0 );

      if ( this.subtreePrunable !== subtreePrunable ) {
        this.subtreePrunable = subtreePrunable;

        // Our dirty flag handling for both inclusive and exclusive depend on this value.
        this.invalidate( true, true );
      }
    },

    /**
     * Propagate the pickable count change down to our ancestors.
     * @private
     *
     * @param {number} n - The delta of how many pickable counts have been added/removed
     */
    changePickableCount: function( n ) {
      if ( n === 0 ) {
        return;
      }

      // Switching between 0 and 1 matters, since we then need to update the counts of our parents.
      var wasZero = this.subtreePickableCount === 0;
      this.subtreePickableCount += n;
      var isZero = this.subtreePickableCount === 0;

      // Our subtreePrunable value depends on our pickable count, make sure it gets updated.
      this.checkSubtreePrunable();

      assert && assert( this.subtreePickableCount >= 0, 'subtree pickable count should be guaranteed to be >= 0' );

      if ( !this.selfPruned && wasZero !== isZero ) {
        // Update our parents if our count changed (AND if it matters, i.e. we aren't selfPruned).
        var len = this.node._parents.length;
        for ( var i = 0; i < len; i++ ) {
          this.node._parents[ i ]._picker.changePickableCount( wasZero ? 1 : -1 );
        }
      }
    },

    /**
     * Runs a number of consistency tests when assertSlow is enabled. Verifies most conditions, and helps to catch
     * bugs earlier when they are initially triggered.
     * @public (scenery-internal)
     */
    audit: function() {
      if ( assertSlow ) {
        var self = this;

        _.each( this.node._children, function( node ) {
          node._picker.audit();
        } );

        var expectedSelfPruned = this.node.pickable === false || !this.node.isVisible();
        var expectedSelfInclusive = this.node.pickable === true || this.node._inputListeners.length > 0;
        var expectedSubtreePrunable = this.node.pickable === false ||
                                      !this.node.isVisible() ||
                                      ( this.node.pickable !== true && this.subtreePickableCount === 0 );
        var expectedSubtreePickableCount = this.node._inputListeners.length +
                                           ( this.node._pickable === true ? 1 : 0 ) +
                                           _.filter( this.node._children, function( child ) {
                                             return !child._picker.selfPruned && child._picker.subtreePickableCount > 0;
                                           } ).length;

        assertSlow( this.selfPruned === expectedSelfPruned, 'selfPruned mismatch' );
        assertSlow( this.selfInclusive === expectedSelfInclusive, 'selfInclusive mismatch' );
        assertSlow( this.subtreePrunable === expectedSubtreePrunable, 'subtreePrunable mismatch' );
        assertSlow( this.subtreePickableCount === expectedSubtreePickableCount, 'subtreePickableCount mismatch' );

        _.each( this.node._parents, function( parent ) {
          var parentPicker = parent._picker;
          var childPicker = self;

          if ( !parentPicker.mouseInclusiveDirty ) {
            assertSlow( childPicker.selfPruned || !childPicker.mouseInclusiveDirty );
          }

          if ( !parentPicker.mouseExclusiveDirty ) {
            if ( childPicker.selfInclusive ) {
              assertSlow( childPicker.selfPruned || !childPicker.mouseInclusiveDirty );
            }
            else {
              assertSlow( childPicker.selfPruned || childPicker.subtreePrunable || !childPicker.mouseExclusiveDirty );
            }
          }

          if ( !parentPicker.touchInclusiveDirty ) {
            assertSlow( childPicker.selfPruned || !childPicker.touchInclusiveDirty );
          }

          if ( !parentPicker.touchExclusiveDirty ) {
            if ( childPicker.selfInclusive ) {
              assertSlow( childPicker.selfPruned || !childPicker.touchInclusiveDirty );
            }
            else {
              assertSlow( childPicker.selfPruned || childPicker.subtreePrunable || !childPicker.touchExclusiveDirty );
            }
          }
        } );
      }
    }
  } );

  return Picker;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Utility functions for scenery that are specifically useful for Accessibility.
 * These generally pertain to DOM traversal and manipulation.
 *
 * @author Jesse Greenberg
 */

define( 'SCENERY/accessibility/AccessibilityUtil',['require','SCENERY/scenery'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );

  // constants
  var NEXT = 'NEXT';
  var PREVIOUS = 'PREVIOUS';

  // tag names with special behavior
  var BOLD_TAG = 'B';
  var STRONG_TAG = 'STRONG';
  var I_TAG = 'I';
  var EM_TAG = 'EM';
  var MARK_TAG = 'MARK';
  var SMALL_TAG = 'SMALL';
  var DEL_TAG = 'DEL';
  var INS_TAG = 'INS';
  var SUB_TAG = 'SUB';
  var SUP_TAG = 'SUP';

  // collection of tags that are used for formatting text
  var FORMATTING_TAGS = [ BOLD_TAG, STRONG_TAG, I_TAG, EM_TAG, MARK_TAG, SMALL_TAG, DEL_TAG, INS_TAG, SUB_TAG, SUP_TAG ];

  /**
   * Get all 'element' nodes off the parent element, placing them in an array for easy traversal.  Note that this
   * includes all elements, even those that are 'hidden' or purely for structure.
   *
   * @param  {HTMLElement} domElement - parent whose children will be linearized
   * @returns {HTMLElement[]}
   * @private
   */
  function getLinearDOMElements( domElement ) {

    // gets ALL descendant children for the element
    var children = domElement.getElementsByTagName( '*' );

    var linearDOM = [];
    for ( var i = 0; i < children.length; i++ ) {

      // searching for the HTML element nodes (NOT Scenery nodes)
      if ( children[ i ].nodeType === Node.ELEMENT_NODE ) {
        linearDOM[ i ] = ( children[ i ] );
      }
    }
    return linearDOM;
  }

  /**
   * Determine if an element is hidden.  An element is considered 'hidden' if it (or any of its ancestors) has the
   * 'hidden' attribute.
   * @private
   *
   * @param {HTMLElement} domElement
   * @returns {Boolean}
   */
  function isElementHidden( domElement ) {
    if ( domElement.hidden ) {
      return true;
    }
    else if ( domElement === document.body ) {
      return false;
    }
    else {
      return isElementHidden( domElement.parentElement );
    }
  }

  /**
   * Get the next or previous focusable element in the parallel DOM, relative to this Node's domElement
   * depending on the direction. Useful if you need to set focus dynamically or need to prevent default behavior
   * when focus changes. If no next or previous focusable is found, it returns the currently focused element.
   * This function should not be used directly, use getNextFocusable() or getPreviousFocusable() instead.
   * @private
   *
   * @param {string} direction - direction of traversal, one of 'NEXT' | 'PREVIOUS'
   * @param {HTMLElement} [parentElement] - optional, search will be limited to children of this element
   * @returns {HTMLElement}
   */
  function getNextPreviousFocusable( direction, parentElement ) {

    // linearize the document [or the desired parent] for traversal
    var parent = parentElement || document.body;
    var linearDOM = getLinearDOMElements( parent );

    var activeElement = document.activeElement;
    var activeIndex = linearDOM.indexOf( activeElement );
    var delta = direction === NEXT ? +1 : -1;

    // find the next focusable element in the DOM
    var nextIndex = activeIndex + delta;
    var nextFocusable;
    while ( !nextFocusable && nextIndex < linearDOM.length && nextIndex >= 0 ) {
      var nextElement = linearDOM[ nextIndex ];
      nextIndex += delta;

      // continue to next element if this one is meant to be hidden
      if ( isElementHidden( nextElement ) ) {
        continue;
      }

      // if element is for formatting, skipe over it - required since IE gives these tabindex="0" 
      if ( _.includes( FORMATTING_TAGS, nextElement.tagName ) ) {
        continue;
      }

      // if tabindex is greater than -1, the element is focusable so break
      if ( nextElement.tabIndex > -1 ) {
        nextFocusable = nextElement;
        break;
      }
    }

    // if no next focusable is found, return the active DOM element
    return nextFocusable || activeElement;
  }

  /**
   * Trims the white space from the left of the string.
   * Solution from https://stackoverflow.com/questions/1593859/left-trim-in-javascript
   * @param  {string} string
   * @return {string}
   */
  function trimLeft( string ) {

    // ^ - from the beginning of the string
    // \s - whitespace character
    // + - greedy
    return string.replace(/^\s+/,'');
  }

  var AccessibilityUtil = {

    /**
     * Get the next focusable element. This should very rarely be used.  The next focusable element can almost
     * always be focused automatically with 'Tab'.  However, if the 'Tab' key needs to be emulated this can be 
     * helpful. If no next focusable can be found, it will return the currently focused element.
     * @public
     *
     * @param{HTMLElement} [parentElement] - optional, search will be limited to elements under this element
     * @returns {HTMLElement}
     */
    getNextFocusable: function( parentElement ) {
      return getNextPreviousFocusable( NEXT, parentElement );
    },

    /**
     * Get the previous focusable element. This should very rarely be used.  The previous focusable element can almost
     * always be found automatically with default 'Shift+Tab' behavior.  However, if the 'Tab' key needs to be emulated
     * this can be helpful.  If no next focusable can be found, it will return the currently focused element.
     * @public
     *
     * @param {HTMLElement} [parentElement] - optional, search will be limited to elements under this parent
     * @returns {HTMLElement}
     */
    getPreviousFocusable: function( parentElement ) {
      return getNextPreviousFocusable( PREVIOUS, parentElement );
    },

    /**
     * If the textContent has any tags that are not formatting tags, return false. Only checking for
     * tags that are not in the whitelist FORMATTING_TAGS, if there are no tags this will still return
     * true.
     * @public
     * 
     * @param  {string} textContent
     * @returns {boolean}
     */
    usesFormattingTagsExclusive: function( textContent ) {

      var i = 0;
      var openIndices = [];
      var closeIndices = [];

      // find open/close tag pairs in the text content
      while ( i < textContent.length ) {
        var openIndex = textContent.indexOf( '<', i );
        var closeIndex = textContent.indexOf( '>', i );

        if ( openIndex > -1 ) {
          openIndices.push( openIndex );
          i = openIndex + 1;
        }
        if ( closeIndex > -1 ) {
          closeIndices.push( closeIndex );
          i = closeIndex + 1;
        }
        else {
          i++;
        }
      }

      // check the name in between the open and close brackets - if anything other than formatting tags, return false
      var onlyFormatting = true;
      var upperCaseContent = textContent.toUpperCase();
      for ( var j = 0; j < openIndices.length; j++ ) {

        // get the name and remove the closing slash
        var subString = upperCaseContent.substring( openIndices[ j ] + 1, closeIndices[ j ] );
        subString = subString.replace( '/', '' );

        // if the left of the substring contains space, it is not a valid tag so allow
        var trimmed = trimLeft( subString );
        if ( subString.length - trimmed.length > 0 ) {
          continue;
        }

        if ( !_.includes( FORMATTING_TAGS, subString ) ) {
          onlyFormatting = false;
        }
      }

      return onlyFormatting;
    }
  };

  scenery.register( 'AccessibilityUtil', AccessibilityUtil );

  return AccessibilityUtil;
} );

// Copyright 2017, University of Colorado Boulder

/**
 * A scenery-internal type for tracking what currently has focus in Display.  This is the value for
 * the static Display.focusProperty.  If a focused node is shared between two Displays, only one
 * instance will have focus.
 *
 * @author Jesse Greenberg
 */
define( 'SCENERY/accessibility/Focus',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * Constructor.
   * @param {Display} display - Display containing the focused node
   * @param {Trail} trail - Trail to the focused node
   */
  function Focus( display, trail ) {

    // @public (read-only)
    this.display = display;
    this.trail = trail;
  }

  scenery.register( 'Focus', Focus );

  return inherit( Object, Focus );
} );

// Copyright 2015-2016, University of Colorado Boulder

/**
 * An accessible peer controls the appearance of an accessible Node's instance in the parallel DOM.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Jesse Greenberg
 */

define( 'SCENERY/accessibility/AccessiblePeer',['require','PHET_CORE/inherit','PHET_CORE/Poolable','AXON/Events','SCENERY/scenery','SCENERY/accessibility/Focus'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  var Focus = require( 'SCENERY/accessibility/Focus' );
  // so RequireJS doesn't complain about circular dependency
  // var Display = require( 'SCENERY/display/Display' );

  var globalId = 1;

  /**
   * Constructor.
   *
   * @param  {AccessibleInstance} accessibleInstance
   * @param  {HTMLElement} domElement - The main DOM element used for this peer.
   * @param  {Object} options
   * @constructor
   */
  function AccessiblePeer( accessibleInstance, domElement, options ) {
    this.initializeAccessiblePeer( accessibleInstance, domElement, options );
  }

  scenery.register( 'AccessiblePeer', AccessiblePeer );

  inherit( Events, AccessiblePeer, {

    /**
     * @param {AccessibleInstance} accessibleInstance
     * @param {HTMLElement} domElement - The main DOM element used for this peer.
     * @param {Object} [options]
     * @returns {AccessiblePeer} - Returns 'this' reference, for chaining
     */
    initializeAccessiblePeer: function( accessibleInstance, domElement, options ) {
      var self = this;

      options = _.extend( {
        parentContainerElement: null, // a parent container for this peer and potential siblings
        childContainerElement: null, // an child container element where nested elements can be placed
        labelElement: null, // the element containing this node's label content 
        descriptionElement: null // the element that will contain this node's description content
      }, options );

      Events.call( this ); // TODO: is Events worth mixing in by default? Will we need to listen to events?

      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );

      // unique ID
      this.id = this.id || globalId++;

      // @public
      this.accessibleInstance = accessibleInstance;
      this.display = accessibleInstance.display;
      this.trail = accessibleInstance.trail;

      // @public, the DOM elements associated with this peer
      this.domElement = domElement;
      this.labelElement = options.labelElement;
      this.descriptionElement = options.descriptionElement;

      // @private - descendent of domElement that can be used to hold nested children
      this.childContainerElement = options.childContainerElement ? options.childContainerElement : ( this.childContainerElement || null );

      // @private - a parent element that can contain this domElement and other siblings, usually label and description content
      this.parentContainerElement = options.parentContainerElement ? options.parentContainerElement : ( this.parentContainerElement || null );
      if ( this.parentContainerElement ) {

        // The first child of the parent container element should be the peer dom element
        // if undefined, the insertBefore method will insert the peerDOMElement as the first child
        var peerDOMElement = this.domElement;
        var firstChild = this.parentContainerElement.children[ 0 ];
        this.parentContainerElement.insertBefore( peerDOMElement, firstChild );
      }

      this.disposed = false;

      // @private - listener for the focus event, to be disposed
      var focusEventListener = function( event ) {
        if ( event.target === self.domElement ) {
          scenery.Display.focus = new Focus( accessibleInstance.display, accessibleInstance.trail );
        }
      };
      this.domElement.addEventListener( 'focus', focusEventListener );

      // @private - listener for the blur event, to be disposed
      var blurEventListener = function( event ) {
        if ( event.target === self.domElement ) {
          scenery.Display.focus = null;
        }
      };
      this.domElement.addEventListener( 'blur', blurEventListener );

      // make AccessiblePeer eligible for garabage collection
      this.disposeAccessiblePeer = function() {

        // remove focus if the disposed peer currently has a focus highlight
        if ( scenery.Display.focus &&
            scenery.Display.focus.trail &&
              scenery.Display.focus.trail.equals( self.trail ) ) {

            scenery.Display.focus = null;
        }

        self.domElement.removeEventListener( 'blur', blurEventListener );
        self.domElement.removeEventListener( 'focus', focusEventListener );
      };

      return this;
    },

    /**
     * Check to see if this peer is contained in a parent container.
     *
     * @returns {boolean}
     */
    hasParentContainer: function() {
      return !!this.parentContainerElement;
    },

    /**
     * Get the parent container or the peer's dom element direclty.  Used for sorting.
     *
     * @returns {type}  description
     */
    getParentContainerElement: function() {
      return this.parentContainerElement || this.domElement;
    },

    /**
     * Get the child container or the peer's DOM element, used for sorting.
     *
     * @returns {type}  description
     */
    getChildContainerElement: function() {
      return this.childContainerElement || this.domElement;
    },

    /**
     * Get an element on this node, looked up by the association flag passed in.
     * @public (scenery-internal)
     * 
     * @param  {string} association - see AccessibilityUtil for valid associations
     * @return {HTMLElement}
     */
    getElementByAssociation: function( association ) {
      var htmlElement = null;

      if ( association === AccessiblePeer.NODE ) {
        return this.domElement;
      }
      else if ( association === AccessiblePeer.LABEL ) {
        return this.labelElement;
      }
      else if ( association === AccessiblePeer.DESCRIPTION ) {
        return this.descriptionElement;
      }
      else if ( association === AccessiblePeer.LABEL ) {
        return this.parentContainerElement;
      }
      assert && assert( htmlElement, 'no HTMLELement found by association ' + association );
      return htmlElement;
    },

    dispose: function() {
      this.disposed = true;
      this.disposeAccessiblePeer();

      // for now
      this.freeToPool && this.freeToPool();
    }
  }, {

    // @static - specifies valid associations between related AccessiblePeers in the DOM
    NODE: 'NODE', // associate with all accessible content related to this peer
    LABEL: 'LABEL', // associate with just the label content of this peer
    DESCRIPTION: 'DESCRIPTION', // associate with just the description content of this peer
    PARENT_CONTAINER: 'PARENT_CONTAINER' // associate with everything under the parent container element of this peer
  } );

  // TODO: evaluate pooling, and is it OK to pool only some peers?
  AccessiblePeer.Poolable = {
    mixin: function( selfDrawableType ) {
      // for pooling, allow <AccessiblePeerType>.createFromPool( accessibleInstance ) and accessiblePeer.freeToPool().
      // Creation will initialize the peer to an initial state.
      Poolable.mixin( selfDrawableType, {
        defaultFactory: function() {
          return new selfDrawableType();
        },
        constructorDuplicateFactory: function( pool ) {
          return function( accessibleInstance ) {
            if ( pool.length ) {
              return pool.pop().initialize( accessibleInstance );
            }
            else {
              return new selfDrawableType( accessibleInstance );
            }
          };
        }
      } );
    }
  };

  return AccessiblePeer;
} );

// Copyright 2017, University of Colorado Boulder

/**
 * A mixin for Node that implements accessibility by adding HTML content to the parallel DOM.
 *
 * The parallel DOM is an HTML structure that provides semantics for assistive technologies. For web content to be
 * accessible, assistive technologies require HTML markup, which is something that pure graphical content does not
 * include.  This mixin implements the accessible HTML content for any node in the scene graph.
 *
 * Each node can have accessible content.  The structure of the accessible content will match the structure of the scene
 * graph.
 *
 * Say we have the following scene graph:
 *
 *   A
 *  / \
 * B   C
 *    / \
 *   D   E
 *        \
 *         F
 *
 * And say that nodes A, B, C, D, and F specify accessible content for the DOM.  Scenery will render the accessible
 * content like so:
 *
 * <div id="node-A">
 *   <div id="node-B"></div>
 *   <div id="node-C">
 *     <div id="node-D"></div>
 *     <div id="node-F"></div>
 *   </div>
 * </div>
 *
 * In this example, each element is represented by a div, but any HTML element could be used. Note that in this example,
 * node E did not specify accessible content, so node F was added as a child under node C.  If node E had specified
 * accessible content, content for node F would have been added as a child under the content for node E.
 *
 * It is possible to add additional structure to the accessible content if necessary.  For instance, consider the
 * following accessible content for a button node:
 *
 * <div>
 *   <button>Button label</button>
 *   <p>This is a description for the button</p>
 * </div>
 *
 * The node is represented by the <button> DOM element, but the accessible content needs to include the parent div, and
 * a peer description paragraph.  This mixin supports this structure with the 'parentContainerElement' option.  In
 * this example, the parentContainerElement is the div, while the description is added as a child under the button
 * node's domElement.
 *
 * For additional accessibility options, please see the options listed in ACCESSIBILITY_OPTION_KEYS. For more
 * documentation on Scenery, Nodes, and the scene graph, please see http://phetsims.github.io/scenery/
 *
 * @author Jesse Greenberg (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SCENERY/accessibility/Accessibility',['require','SCENERY/scenery','PHET_CORE/extend','SCENERY/accessibility/AccessibilityUtil','SCENERY/accessibility/AccessiblePeer'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );
  var extend = require( 'PHET_CORE/extend' );
  var AccessibilityUtil = require( 'SCENERY/accessibility/AccessibilityUtil' );
  var AccessiblePeer = require( 'SCENERY/accessibility/AccessiblePeer' );

  // specific HTML tag names
  var INPUT_TAG = 'INPUT';
  var LABEL_TAG = 'LABEL';
  var BUTTON_TAG = 'BUTTON';
  var TEXTAREA_TAG = 'TEXTAREA';
  var SELECT_TAG = 'SELECT';
  var OPTGROUP_TAG = 'OPTGROUP';
  var DATALIST_TAG = 'DATALIST';
  var OUTPUT_TAG = 'OUTPUT';
  var A_TAG = 'A';

  // these elements are typically associated with forms, and support certain attributes
  var FORM_ELEMENTS = [ INPUT_TAG, BUTTON_TAG, TEXTAREA_TAG, SELECT_TAG, OPTGROUP_TAG, DATALIST_TAG, OUTPUT_TAG, A_TAG ];

  // these elements do not have a closing tag, so they won't support features like innerHTML
  var ELEMENTS_WITHOUT_CLOSING_TAG = [ INPUT_TAG ];

  // these elements require a minimum width to be visible in Safari
  var ELEMENTS_REQUIRE_WIDTH = [ INPUT_TAG, A_TAG ];

  // these events change the input value on the dom element
  var INPUT_CHANGE_EVENTS = [ 'input', 'change' ];

  // valid types of DOM events that can be added to a node
  var DOM_EVENTS = [ 'input', 'change', 'click', 'keydown', 'keyup', 'focus', 'blur' ];

  var ACCESSIBILITY_OPTION_KEYS = [
    'tagName', // Sets the tag name for the DOM element representing this node in the parallel DOM
    'inputType', // Sets the input type for the representative DOM element, only relevant if tagname is 'input'
    'inputValue', // Sets the input value for the representative DOM element, only relevant if tagname is 'input'
    'accessibleChecked', // Sets the 'checked' state for inputs of type radio and checkbox, see setAccessibleChecked()
    'parentContainerTagName', // Sets the tag name for an element that contains this node's DOM element and its peers
    'labelTagName', // Sets the tag name for the DOM element labelling this node, usually a paragraph
    'descriptionTagName', // Sets the tag name for the DOM element describing this node, usually a paragraph
    'focusHighlight', // Sets the focus highlight for the node, see setFocusHighlight()
    'focusHighlightLayerable', // Flag to determine if the focus highlight node can be layered in the scene graph, see setFocusHighlightLayerable()
    'accessibleLabel', // Set the label content for the node, see setAccessibleLabel()
    'accessibleLabelAsHTML', // Set the label content for the node as innerHTML, see setAccessibleLabelAsHTML()
    'accessibleDescription', // Set the description content for the node, see setAccessibleDescription()
    'accessibleDescriptionAsHTML', // Set the description content for the node as innerHTML, see setAccessibleDescriptionContentAsHTML()
    'accessibleHidden', // Sets wheter or not the node's DOM element is hidden in the parallel DOM
    'accessibleContentDisplayed', // sets whether or not the accessible content of the node (and its subtree) is displayed, see setAccessibleContentDisplayed()
    'focusable', // Sets whether or not the node can receive keyboard focus
    'useAriaLabel', // Sets whether or not the label will use the 'aria-label' attribute, see setUseAriaLabel()
    'ariaRole', // Sets the ARIA role for the DOM element, see setAriaRole() for documentation
    'parentContainerAriaRole', // Sets the ARIA role for the parent container DOM element, see setParentContainerAriaRole()
    'ariaDescribedByElement', // Sets a description relationship for this node's DOM element by id, see setAriaDescribedByElement()
    'ariaLabelledByElement', // Sets a label relationship with another element in the DOM by id, see setAriaLabelledByElement()
    'prependLabels'// Sets whether we want to prepend labels above the node's HTML element, see setPrependLabels()
  ];

  var Accessibility = {

    /**
     * Given the constructor for Node, mix accessibility functions into the prototype
     *
     * @param {function} type - the constructor for Node
     */
    mixin: function( type ) {
      var proto = type.prototype;

      /**
       * These properties and methods are put directly on the prototype of nodes that have Accessibility mixed in.
       */
      extend( proto, {

        /**
         * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in
         * the order they will be evaluated.  Beware that order matters for accessibility options, changing the order
         * of ACCESSIBILITY_OPTION_KEYS could break the mixin.
         * @protected
         *
         * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
         *       cases that may apply.
         */
        _mutatorKeys: ACCESSIBILITY_OPTION_KEYS.concat( proto._mutatorKeys ),

        /**
         * This should be called in the constructor to initialize the accessibility-specific parts of Node.
         * @protected
         */
        initializeAccessibility: function() {

          //REVIEW: Including the 'null' case in type documentation here would help.

          // @private {string} - the HTML tag name of the element representing this node in the DOM
          this._tagName = null;

          // @private {string} - the HTML tag name for a parent container element for this node in the DOM. This
          // parent container will contain the node's DOM element, as well as peer elements for any label or description
          // content. See setParentContainerTagName() for more documentation.
          this._parentContainerTagName = null;

          // @private {string} - the HTML tag name for the label element that will contain the label content for
          // this dom element. There are ways in which you can have a label without specifying a label tag name,
          // see setAccessibleLabel() for the list of ways.
          this._labelTagName = null;

          // @private {string} - the HTML tag name for the description element that will contain descsription content
          // for this dom element. If a description is set before a tag name is defined, a paragraph element
          // will be created for the description.
          this._descriptionTagName = null;

          // @private {string} - the type for an element with tag name of INPUT.  This should only be used
          // if the element has a tag name INPUT.
          this._inputType = null;

          // @private {string} - the value of the input, only relevant if the tag name is of type "INPUT".
          this._inputValue = null;

          // @private {boolean} - whether or not the accessible input is considered 'checked', only useful for inputs of
          // type 'radio' and 'checkbox'
          this._accessibleChecked = false;

          // @private {boolean} - determines whether or not labels should be prepended above the node's DOM element. This
          // should only be used if the element has a parentContainerElement, as the labels are sorted relative to the
          // node's DOM element under the parent container.
          this._prependLabels = null;

          // @private {array.<Object> - array of attributes that are on the node's DOM element.  Objects will have the
          // form { attribute:{string}, value:{string|number} }
          this._accessibleAttributes = [];

          // @private {string} - the label content for this node's DOM element.  There are multiple ways that a label
          // can be associated with a node's dom element, see setAccessibleLabel() for more documentation
          this._accessibleLabel = null;

          // @private {string} - whether or not the label content is innerHTML.  Internal flag that is updated
          // when the label content is set.  See setAccessibleLabelAsHTML() for more information
          this._labelIsHTML = null;

          // @private {string} - the description content for this node's DOM element.
          this._accessibleDescription = null;

          // @private {string} - whether or not the accessible description is set as innerHTML. Internal flag
          // that is set when updating description content.
          this._descriptionIsHTML = false;

          // @private {boolean} - if true, the aria label will be added as an inline attribute on the node's DOM
          // element.  This will determine how the label content is associated with the DOM element, see
          // setAccessibleLabel() for more information
          this._useAriaLabel = null;
          //REVIEW: This is marked as boolean, but initialized to null?

          // @private {string} - the ARIA role for this node's DOM element, added as an HTML attribute.  For a complete
          // list of ARIA roles, see https://www.w3.org/TR/wai-aria/roles.  Beware that many roles are not supported
          // by browsers or assistive technologies, so use vanilla HTML for accessibility semantics where possible.
          this._ariaRole = null;

          // @private {string} - the ARIA role for the parent container element, added as an HTML attribute. For a
          // complete list of ARIA roles, see https://www.w3.org/TR/wai-aria/roles. Beware that many roles are not
          // supported by browsers or assistive technologies, so use vanilla HTML for accessibility semantics where
          // possible.
          this._parentContainerAriaRole = null;

          // @private {Node} - Another node that is described by this node.  The accessible id of this node will be
          // added as the value of the "aria-describedby" accessible attribute.  The other node can be anywhere in
          // the scene graph.  The behavior for "aria-describedby" is such when the other node receives focus,
          // the accessible content under this node will be read (after any label content). Use with
          // this._ariaDescribesAssociation to limit the amount of content under this node that describes the other
          // node.
          this._ariaDescribesNode = null;

          // @private {string} - Limitation on how much of the accessible content will describe this._ariaDescribesNode.
          // The describing content can be all the content, or just the description, label, or parent container.
          // AccessiblePeer.NODE is all of the accessible content, see AccessiblePeer for the other flags.
          this._ariaDescribesAssociation = AccessiblePeer.NODE;

          // @private - Another node that is labelled by this node.  The id of this node's accessible content
          // will be added as the value of the "aria-labelledby" accessible attribute. The other node can be anywhere in
          // the scene graph.  The behavior for "aria-labelledby" is such that when the other node receives focus, the
          // accessible content under this node will be read (before any description content).
          this._ariaLabelsNode = null;

          // @private {string} - Limitation on how much of the accessible content will label this._ariaLabelsNode.
          // The describing content can be all the content, or just the description, label, or parent container.
          // AccessiblePeer.NODE is all of this node's accessible content, see AccessiblePeer for the other flags.
          this._ariaLabelsAssociation = AccessiblePeer.NODE;

          // @private {boolean} - whether or not this node's DOM element can receive focus from tab navigation.
          // Sets the tabIndex attribute on the node's DOM element.  Setting to false will not remove the node's DOM
          // from the document, but will ensure that it cannot receive focus by pressing 'tab'.  Several HTMLElements
          // (such as HTML form elements) can be focusable by default, without setting this property.
          this._focusable = null;

          // @private {Shape|Node|string.<'invisible'>} - the focus highlight that will surround this node when it
          // is focussed.  By default, the focus highlight will be a pink rectangle that surrounds the Node's local
          // bounds.
          this._focusHighlight = null;

          // @private {boolean} - A flag that allows prevents focus highlight from being displayed in the FocusOverlay.
          // If true, the focus highlight for this node will be layerable in the scene graph.  Client is responsible
          // for placement of the focus highlight in the scene graph.
          this._focusHighlightLayerable = false;

          // @private {boolean} - Whether or not the accessible content will be hidden from the browser and assistive
          // technologies.  When accessibleHidden is true, the node's DOM element will not be focusable, and it cannot
          // be found by the assistive technology virtual cursor. For more information on how assistive technologies
          // read with the virtual cursor see
          // http://www.ssbbartgroup.com/blog/how-windows-screen-readers-work-on-the-web/
          this._accessibleHidden = null;

          // @private {boolean} - Whether or not the accessible content will be hidden from the browser and assistive
          // technologies.  When accessible content is not displayed, the node will not be focusable, and it cannot
          // be found by assistive technology with the virtual cursor.  Content should almost always be hidden with 
          // setAccessibleHidden(), see that function and setAccessibleContentDisplayed() for more information.
          this._accessibleContentDisplayed = true;

          // @private {Array.<Function>} - For accessibility input handling {keyboard/click/HTML form}
          this._accessibleInputListeners = [];

          // @private {boolean} - if true, all accessible input will be halted on this Node.
          this._accessibleInputEnabled = true;
        },

        /**
         * Adds an accessible input listener. The listener's keys should be DOM event names, and the values should be
         * functions to be called when that event is fired on the dom element. No input listeners will be fired
         * if this.accessibleInputEnabled is false.
         * @public
         * 
         * @param {Object} listener
         * @returns {Object} - the actually added listener, so it can be removed via removeAccessibleInputListener
         */
        addAccessibleInputListener: function( accessibleInput ) {
          var self = this;
          var addedAccessibleInput = {};

          var keys = Object.keys( accessibleInput );
          for ( var i = 0; i < keys.length; i++ ) {
            var ev = keys[ i ];
            if ( _.includes( DOM_EVENTS, ev ) ) {

              // wrap the listener with another function so that we can update state of this Node's
              // accessible content if necessary, and prevent firing when input not enabled
              addedAccessibleInput[ ev ] = function( event ) {
                if ( self._accessibleInputEnabled ) {

                  if ( _.includes( INPUT_CHANGE_EVENTS, event.type ) ) {
                    self._inputValue = event.target.value;
                  }

                  // call the original input listener
                  accessibleInput[ event.type ]( event );
                }
              };
            }
          }

          var listenerAlreadyAdded = ( _.indexOf( this._accessibleInputListeners, addedAccessibleInput ) > 0 );
          assert && assert( !listenerAlreadyAdded, 'accessibleInput listener already added' );

          // add the listener directly to any AccessiblePeers that are representing this node
          this._accessibleInputListeners.push( addedAccessibleInput );
          this.updateAccessiblePeers( function( accessiblePeer ) {
            self.addDOMEventListeners( addedAccessibleInput, accessiblePeer.domElement );
          } );

          return addedAccessibleInput;
        },

        /**
         * Removes an input listener that was previously added with addAccessibleInputListener.
         * @public
         *
         * @param {Object} accessibleInput
         * @returns {Node} - Returns 'this' reference, for chaining
         */
        removeAccessibleInputListener: function( accessibleInput ) {

          // ensure the listener is in our list, or will be added in invalidation
          var addedIndex = _.indexOf( this._accessibleInputListeners, accessibleInput );
          assert && assert( addedIndex > -1, 'accessibleInput listener was not added' );

          this._accessibleInputListeners.splice( addedIndex, 1 );

          // remove the event listeners from any peers
          var self = this;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            self.removeDOMEventListeners( accessibleInput, accessiblePeer.domElement );
          } );

          return this;
        },

        /**
         * Returns a copy of all input listeners related to accessibility.
         * @public
         *
         * @returns {Array.<Object>}
         */
        getAccessibleInputListeners: function() {
          return this._accessibleInputListeners.slice( 0 ); // defensive copy
        },
        get accessibleInputListeners() { return this.getAccessibleInputListeners(); },

        /**
         * Prevents all accessible input listeners from being called on this Node.  Should only
         * be used internally by scenery for now.
         * @public (scenery-internal)
         *
         * REVIEW: Instead of just setting all children, we should just set one Node and then
         * traverse specific trails to see if input is enabled.
         */
        setAccessibleInputEnabled: function( accessibleInputEnabled ) {
          this._accessibleInputEnabled = accessibleInputEnabled;

          for ( var i = 0; i < this.children.length; i++ ) {
            this.children[ i ].accessibleInputEnabled = accessibleInputEnabled;
          }
        },
        set accessibleInputEnabled( accessibleInputEnabled ) { this.setAccessibleInputEnabled( accessibleInputEnabled ); },

        /**
         * Get whether or not we are preventing accessible input listeners from firing when this node receives
         * accessible input events.
         * @return {boolean}
         */
        getAccessibleInputEnabled: function() {
          return this._accessibleInputEnabled;
        },
        get accessibleInputEnabled() { return this.getAccessibleInputEnabled(); },

        /**
         * Set the tag name representing this element in the DOM. DOM element tag names are read-only, so this
         * function will create a new DOM element for the Node and reset the accessible content.
         *
         * REVIEW: Setting the tag name multiple times results in incorrect behavior with many functions, e.g.:
         *   var node = new scenery.Node();
         *   node.tagName = 'div';
         *   node.focusable = true;
         *   node.domElement.tabIndex // 0 (as expected)
         *   node.tagName = 'p';
         *   node.domElement.tabIndex // -1 (yikes!, even when node.focusable returns true)
         *
         * @param {string} tagName
         */
        setTagName: function( tagName ) {
          assert && assert( tagName === null || typeof tagName === 'string' );

          this._tagName = tagName;
          this.invalidateAccessibleContent();
        },
        set tagName( tagName ) { this.setTagName( tagName ); },

        /**
         * Get the tag name of the DOM element representing this node for accessibility.
         * @public
         *
         * REVIEW: Return type should include null, since new scenery.Node().tagName is null.
         *
         * @returns {string}
         */
        getTagName: function() {
          return this._tagName;
        },
        get tagName() { return this.getTagName(); },

        /**
         * Set the tag name for the accessible label for this Node.  DOM element tag names are read-only, so this will
         * require creating a new label element.
         *
         * REVIEW: Same problem with after-the-fact modification as tagName:
         *   var node = new scenery.Node()
         *   node.tagName = 'div';
         *   node.labelTagName = 'p'
         *   node.accessibleLabel = 'Label';
         *   node.getLabelElement() // <p>Label</p>
         *   node.labelTagName = 'div';
         *   node.getLabelElement() // <div></div> -- NO label specified, even though accessibleLabel is still set
         *
         * REVIEW: null used in unit tests, so this should be marked as accepting null
         *
         * @param {string|null} tagName
         */
        setLabelTagName: function( tagName ) {
          assert && assert( tagName === null || typeof tagName === 'string' );

          this._labelTagName = tagName;
          this.invalidateAccessibleContent();
        },
        set labelTagName( tagName ) { this.setLabelTagName( tagName ); },

        /**
         * Get the label element HTML tag name.
         * @public
         *
         * REVIEW: Return type should include null, since new scenery.Node().labelTagName is null.
         *
         * @returns {string}
         */
        getLabelTagName: function() {
          return this._labelTagName;
        },
        get labelTagName() { return this.getLabelTagName(); },

        /**
         * Set the tag name for the description. HTML element tag names are read-only, so this will require creating
         * a new HTML element, and inserting it into the DOM.
         * @public
         *
         * REVIEW: Has same issue with setting tagName and labelTagName (see those review comments)
         *
         * @param {string} tagName
         */
        setDescriptionTagName: function( tagName ) {
          assert && assert( tagName === null || typeof tagName === 'string' );

          this._descriptionTagName = tagName;
          this.invalidateAccessibleContent();
        },
        set descriptionTagName( tagName ) { this.setDescriptionTagName( tagName ); },

        /**
         * Get the HTML get name for the description element.
         * @public
         *
         * @returns {string|null}
         */
        getDescriptionTagName: function() {
          return this._descriptionTagName;
        },
        get descriptionTagName() { return this.getDescriptionTagName(); },

        /**
         * Sets the type for an input element.  Element must have the INPUT tag name. The input attribute is not
         * specified as readonly, so invalidating accessible content is not necessary.
         *
         * @param {string} inputType
         */
        setInputType: function( inputType ) {
          assert && assert( this._tagName.toUpperCase() === INPUT_TAG, 'tag name must be INPUT to support inputType' );

          this._inputType = inputType;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.type = inputType;
          } );
        },
        set inputType( inputType ) { this.setInputType( inputType ); },

        /**
         * Get the input type. Input type is only relevant if this node's DOM element has tag name "INPUT".
         * @public
         *
         * @returns {string}
         */
        getInputType: function() {
          return this._inputType;
        },
        get inputType() { return this.getInputType(); },

        /**
         * Set whether or not we want to prepend labels above the node's HTML element.  If the node does not have
         * a parent container element, one will be created. If prepending labels, the label and description elements
         * will be located above the HTML element like:
         *
         * <div id='parent-container'>
         *   <p>Label</p>
         *   <p>Description</p>
         *   <div id="node-content"></div>
         * </div>
         *
         * By default, label and description elements are placed below the node's HTML element.
         *
         * @param {boolean} prependLabels
         */
        setPrependLabels: function( prependLabels ) {
          this._prependLabels = prependLabels;

          // if there isn't a parent container element, create one so labels can be prepended
          if ( !this._parentContainerTagName ) {
            this.setParentContainerTagName( 'div' );
          }

          // TODO: can we do this without recomputing everything?
          this.invalidateAccessibleContent();
        },
        set prependLabels( prependLabels ) { this.setPrependLabels( prependLabels ); },

        /**
         * Get whether or not this node adds labels and descriptions above the representative DOM element.
         * @public
         *
         * @returns {boolean}
         */
        getPrependLabels: function() {
          return this._prependLabels;
        },
        get prependLabels() { return this.getPrependLabels(); },

        /**
         * Set the parent container tag name.  By specifying this parent container, an element will be created that
         * acts as a container for this node's DOM element and its label and description peers.  For instance, a button
         * element with a label and description will be contained like the following if the parent container tag name
         * is specified as 'section'.
         *
         * <section id='parent-container-trail-id'>
         *   <button>Press me!</button>
         *   <p>Button label</p>
         *   <p>Button description</p>
         * </section>
         *
         * @param {string} tagName
         */
        setParentContainerTagName: function( tagName ) {
          assert && assert( tagName === null || typeof tagName === 'string' );

          this._parentContainerTagName = tagName;
          this.invalidateAccessibleContent();
        },
        set parentContainerTagName( tagName ) { this.setParentContainerTagName( tagName ); },

        /**
         * Get the tag name for the parent container element.
         *
         * @returns {string}
         */
        getParentContainerTagName: function() {
          return this._parentContainerTagName;
        },
        get parentContainerTagName() { return this.getParentContainerTagName(); },

        /**
         * Set the label for the this node.  The label can be added in one of four ways:
         *   - As an inline text with the 'aria-label' attribute.
         *   - As a 'label' ellement with the 'for' attribute pointing to the
         *     node's DOM element.
         *   - As inner text on the Node's DOM element itself.
         *   - As a separate DOM element positioned as a peer or child of this
         *     node's DOM element.
         *
         * The way in which the label is added to the Node is dependent on the label tag name, whether we use the
         * aria-label attribute, and whether the node's DOM element supports inner HTML.
         *
         * @param {string} label
         */
        setAccessibleLabel: function( label ) {
          this._labelIsHTML = false;
          this.setLabelContent( label );
        },
        set accessibleLabel( label ) { this.setAccessibleLabel( label ); },

        /**
         * Get the label content for this node's DOM element.
         *
         * @returns {string}
         */
        getAccessibleLabel: function() {
          return this._accessibleLabel;
        },
        get accessibleLabel() { return this.getAccessibleLabel(); },

        /**
         * Should be used rarely and with caution, typically you should use setAccessibleLabel instead.
         * Sets the accessible label as innerHTML instead of textContent. This allows you to include
         * formatting tags in the label which are typically read with distinction by a screen reader.
         * But innerHTML is less performant because it triggers DOM restyling and insertions.
         *
         * If the content includes anything other than styling tags or has malformed HTML, we will fallback
         * to textContent. 
         * 
         * @param {string} label
         */
        setAccessibleLabelAsHTML: function( label ) {
          var formattingExclusive = AccessibilityUtil.usesFormattingTagsExclusive( label );

          // fall back to textContent if anything other than formatting tags
          this._labelIsHTML = formattingExclusive;
          this.setLabelContent( label );
        },
        set accessibleLabelAsHTML( label ) { this.setAccessibleLabelAsHTML( label ); },

        /**
         * Set the description content for this node's DOM element. A description element must exist and that element
         * must support inner HTML.  If a description element does not exist yet, we assume that a default paragraph
         * should be used.
         *
         * @param {string} textContent
         */
        setAccessibleDescription: function( textContent ) {
          this._descriptionIsHTML = false;
          this.setDescriptionContent( textContent );
        },
        set accessibleDescription( textContent ) { this.setAccessibleDescription( textContent ); },

        /**
         * Get the accessible description content that is describing this Node.
         *
         * @returns {string}
         */
        getAccessibleDescription: function() {
          return this._accessibleDescription;
        },
        get accessibleDescription() { return this.getAccessibleDescription(); },

        /**
         * Should be used rarely and with caution, typically you should use setAccessibleDescription instead.
         * Sets the accessible descriptions as innerHTML instead of textContent. This allows you to include
         * formatting tags in the descriptions which are typically read with distinction by a screen reader.
         * But innerHTML is less performant because it triggers DOM restyling and insertions.
         *
         * If the content includes anything other than styling tags or has malformed HTML, we will fallback
         * to textContent. 
         * 
         * @param {string} label
         */
        setAccessibleDescriptionAsHTML: function( textContent ) {
          var formattingExclusive = AccessibilityUtil.usesFormattingTagsExclusive( textContent );

          this._descriptionIsHTML = formattingExclusive;
          this.setDescriptionContent( textContent );
        },
        set accessibleDescriptionAsHTML( textContent ) { this.setAccessibleDescriptionAsHTML( textContent ); },

        /**
         * Set the ARIA role for this node's DOM element. According to the W3C, the ARIA role is read-only for a DOM
         * element.  So this will create a new DOM element for this Node with the desired role, and replace the old
         * element in the DOM.
         * @public
         *
         * @param {string} ariaRole - role for the element, see
         *                            https://www.w3.org/TR/html-aria/#allowed-aria-roles-states-and-properties
         *                            for a list of roles, states, and properties.
         */
        setAriaRole: function( ariaRole ) {
          this._ariaRole = ariaRole;
          this.setAccessibleAttribute( 'role', ariaRole );

          this.invalidateAccessibleContent();
        },
        set ariaRole( ariaRole ) { this.setAriaRole( ariaRole ); },

        /**
         * Get the ARIA role representing this node.
         * @public
         *
         * @returns {string}
         */
        getAriaRole: function() {
          return this._ariaRole;
        },
        get ariaRole() { return this.getAriaRole(); },

        /**
         * Set the ARIA role for this node's parent container element.  According to the W3C, the ARIA role is read-only
         * for a DOM element. This will create a new DOM element for the parent container with the desired role, and
         * replace it in the DOM.
         * @public
         *
         * @param {string} ariaRole - role for the element, see
         *                            https://www.w3.org/TR/html-aria/#allowed-aria-roles-states-and-properties
         *                            for a lsit of roles, states, and properties.
         */
        setParentContainerAriaRole: function( ariaRole ) {
          this._parentContainerAriaRole = ariaRole;
          this.invalidateAccessibleContent();
        },
        set parentContainerAriaRole( ariaRole ) { this.setParentContainerAriaRole( ariaRole ); },

        /**
         * Get the ARIA role assigned to the parent container element.
         * @public
         * @returns {string|null}
         */
        getParentContainerAriaRole: function() {
          return this._parentContainerAriaRole;
        },
        get parentcontainerAriaRole() { return this.getParentContainerAriaRole(); },

        /**
         * Sets whether or not to use the 'aria-label' attribute for labelling  the node's DOM element. By using the
         * 'aria-label' attribute, the label will be read on focus, but will can not be found with the
         * virtual cursor.
         * @public
         *
         * @param {string} useAriaLabel
         */
        setUseAriaLabel: function( useAriaLabel ) {
          this._useAriaLabel = useAriaLabel;

          var self = this;

          if ( useAriaLabel && this._labelTagName ) {
            self.setLabelTagName( null );
          }
          this.updateAccessiblePeers( function( accessiblePeer ) {
            if ( accessiblePeer.labelElement ) {

              // if we previously had a label element, remove it
              self.setLabelTagName( null );
              accessiblePeer.labelElement.parentNode && accessiblePeer.labelElement.parentNode.removeChild( accessiblePeer.labelElement );
            }
          } );

          // if a label is defined, reset the label content
          if ( this._accessibleLabel ) {
            this.setAccessibleLabel( this._accessibleLabel );
          }
        },
        set useAriaLabel( useAriaLabel ) { this.setUseAriaLabel( useAriaLabel ); },

        /**
         * Get whether or not we are using an aria-label to label this node's HTML element.
         *
         * @returns {boolean}
         */
        getUseAriaLabel: function() {
          return this._useAriaLabel;
        },
        get useAriaLabel() { return this.getUseAriaLabel(); },

        /**
         * Set the focus highlight for this node. By default, the focus highlight will be a pink rectangle that
         * surrounds the node's local bounds.  If focus highlight is set to 'invisible', the node will not have
         * any highlighting when it receives focus.
         * @public
         *
         * @param {Node|Shape|string.<'invisible'>} focusHighlight
         */
        setFocusHighlight: function( focusHighlight ) {
          this._focusHighlight = focusHighlight;

          var isFocussed = false;
          if ( this.isFocussed() ) {
            isFocussed = true;
          }
          this.invalidateAccessibleContent();

          // Reset the focus after invalidating the content.
          isFocussed && this.focus();

        },
        set focusHighlight( focusHighlight ) { this.setFocusHighlight( focusHighlight ); },

        /**
         * Get the focus highlight for this node.
         * @public
         *
         * @returns {Node|Shape|string<'invisible'>}
         */
        getFocusHighlight: function() {
          return this._focusHighlight;
        },
        get focusHighlight() { return this.getFocusHighlight(); },

        /**
         * Setting a flag to break default and allow the focus highlight to be (z) layered into the scene graph.
         * TODO: We may want to eventually handle the case of setting this flag while the node is currently focused.
         * @param {Boolean} focusHighlightLayerable
         */
        setFocusHighlightLayerable: function( focusHighlightLayerable ) {
          this._focusHighlightLayerable = focusHighlightLayerable;
          this.invalidateAccessibleContent();
        },
        set focusHighlightLayerable( focusHighlightLayerable ) { this.setFocusHighlightLayerable( focusHighlightLayerable ); },

        /**
         * Get the flag for if this node is layerable in the scene graph (or if it is always on top, like the default).
         * @public
         *
         * @returns {Boolean}
         */
        getFocusHighlightLayerable: function() {
          return this._focusHighlightLayerable;
        },
        get focusHighlightLayerable() { return this.getFocusHighlightLayerable(); },

        /**
         * Set the aria-describedby relation between this node's accessible content and the accessible
         * content of another node.  The value of the 'aria-describedby' attribute is a string id that references
         * another HTMLElement in the DOM.  Upon focus, a screen reader should read the content under the HTML element
         * referenced by the id, after any label content.  Exact behavior will depend on the user agent. This node must
         * have only one accessible instance so that value for 'aria-describedby' is unique.
         * @public
         * 
         * @param {Node} node
         * @param {string} [association] 'NODE'|'LABEL'|'DESCRIPTION'|'PARENT_CONTAINER'
         */
        setAriaDescribesNode: function( node, association ) {
          assert && assert( this.accessibleInstances.length < 2, 'Cannot describe another node if using DAG' );

          this._ariaDescribesNode = node;
          this._ariaDescribesAssociation = association || AccessiblePeer.NODE;

          if ( this.accessibleInstances.length > 0 ) {
            var peer = this.accessibleInstances[ 0 ].peer;
            var associatedElement = peer.getElementByAssociation( this._ariaDescribesAssociation );
            node.setAccessibleAttribute( 'aria-describedby', associatedElement.id );
          }
        },

        /**
         * Set the aria-labelledby relation between this node's accessible content and the accessible
         * content of another node.  The value of the 'aria-labelledby' attribute is a string id that references
         * another HTMLElement in the DOM.  Upon focus, a screen reader should read the content under the HTML element
         * referenced by the id, before any description content.  Exact behavior will depend on the user agent. This
         * node must have only one accessible instance so that value for 'aria-labelledby' is unique.
         * @public
         * 
         * @param {Node} node
         * @param {string} [association] 'NODE'|'LABEL'|'DESCRIPTION'|'PARENT_CONTAINER'
         */
        setAriaLabelsNode: function( node, association ) {
          assert && assert( this.accessibleInstances.length < 2, 'Cannot describe another node if using DAG' );

          this._ariaLabelsNode = node;
          this._ariaLabelsAssociation = association || AccessiblePeer.NODE;

          if ( this.accessibleInstances.length > 0 ) {
            var peer = this.accessibleInstances[ 0 ].peer;
            var associatedElement = peer.getElementByAssociation( this._ariaLabelsAssociation );
            node.setAccessibleAttribute( 'aria-labelledby', associatedElement.id );
          }
        },

        /**
         * Hide completely from a screen reader and the browser by setting the hidden attribute on the node's
         * representative DOM element. If this domElement and its peers have a parent container, the container
         * should be hidden so that all peers are hidden as well.  Hiding the element will remove it from the focus
         * order.
         *
         * @public
         *
         * @param {boolean} hidden
         */
        setAccessibleHidden: function( hidden ) {
          this._accessibleHidden = hidden;

          this.updateAccessiblePeers( function( accessiblePeer ) {
            if ( accessiblePeer.parentContainerElement ) {
              accessiblePeer.parentContainerElement.hidden = hidden;
            }
            else if ( accessiblePeer.domElement ) {
              accessiblePeer.domElement.hidden = hidden;
            }
          } );
        },
        set accessibleHidden( hidden ) { this.setAccessibleHidden( hidden ); },

        /**
         * Get whether or not this node's representative DOM element is hidden.
         * @public
         *
         * @returns {boolean}
         */
        getAccessibleHidden: function() {
          return this._accessibleHidden;
        },
        get accessibleHidden() { return this.getAccessibleHidden(); },

        /**
         * Sets whether or not the accessible content should be displayed in the DOM. Almost always, setAccessibleHidden
         * should be used instead of this function.  This should behave exactly like setAccessibleHidden. If removed
         * from display, content will be removed from focus order and undiscoverable with the virtual cursor. Sometimes,
         * hidden attribute is not handled the same way across screen readers, so this function can be used to
         * completely remove the content from the DOM.
         * @public
         *
         * @param {boolean} contentDisplayed
         */
        setAccessibleContentDisplayed: function( contentDisplayed ) {
          this._accessibleContentDisplayed = contentDisplayed;

          for ( var j = 0; j < this._children.length; j++ ) {
            var child = this._children[ j ];
            child.setAccessibleContentDisplayed( contentDisplayed );
          }
          this.invalidateAccessibleContent();
        },
        set accessibleContentDisplayed( contentDisplayed ) { this.setAccessibleContentDisplayed( contentDisplayed ); },

        getAccessibleContentDisplayed: function() {
          return this._accessibleContentDisplayed;
        },
        get accessibleContentDisplayed() { return this.getAccessibleContentDisplayed(); },

        /**
         * Set the value of an input element.  Element must be a form element to support the value attribute. The input
         * value is converted to string since input values are generally string for HTML.
         * @public
         *
         * @param {string} value
         */
        setInputValue: function( value ) {
          assert && assert( _.includes( FORM_ELEMENTS, this._tagName.toUpperCase() ), 'dom element must be a form element to support value' );

          value = value.toString();
          this._inputValue = value;

          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.value = value;
          } );
        },
        set inputValue( value ) { this.setInputValue( value ); },

        /**
         * Get the value of the element. Element must be a form element to support the value attribute.
         * @public
         *
         * @returns {string}
         */
        getInputValue: function() {
          return this._inputValue;
        },
        get inputValue() { return this.getInputValue(); },

        /**
         * Set whether or not the checked attribute appears on the dom elements associated with this Node's
         * accessible content.  This is only useful for inputs of type 'radio' and 'checkbox'. A 'checked' input
         * is considered selected to the browser and assistive technology.
         *
         * @public
         * @param {boolean} checked
         */
        setAccessibleChecked: function( checked ) {
          this._accessibleChecked = checked;

          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.checked = checked;
          } );
        },
        set accessibleChecked( checked ) { this.setAccessibleChecked( checked ); },

        /**
         * Get whether or not the accessible input is 'checked'.
         *
         * @public
         * @return {boolean}
         */
        getAccessibleChecked: function() {
          return this._accessibleChecked;
        },
        get accessibleChecked() { return this.getAccessibleChecked(); },

        /**
         * Get an array containing all accessible attributes that have been added to this node's DOM element.
         * @public
         *
         * @returns {string[]}
         */
        getAccessibleAttributes: function() {
          return this._accessibleAttributes.slice( 0 ); // defensive copy
        },
        get accessibleAttributes() { return this.getAccessibleAttributes(); },

        /**
         * Set a particular attribute for this node's DOM element, generally to provide extra semantic information for
         * a screen reader.
         *
         * @param {string} attribute - string naming the attribute
         * @param {string|boolean} value - the value for the attribute
         * @public
         */
        setAccessibleAttribute: function( attribute, value ) {

          // if the accessible attribute already exists in the list, remove it - no need
          // to remove from the peers, existing attributes will simply be replaced in the DOM
          for ( var i = 0; i < this._accessibleAttributes.length; i++ ) {
            if ( this._accessibleAttributes[ i ].attribute === attribute ) {
              this._accessibleAttributes.splice( i, 1 );
            }
          }

          this._accessibleAttributes.push( { attribute: attribute, value: value } );
          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.setAttribute( attribute, value );
          } );
        },

        /**
         * Remove a particular attribute, removing the associated semantic information from the DOM element.
         *
         * @param {string} attribute - name of the attribute to remove
         * @public
         */
        removeAccessibleAttribute: function( attribute ) {

          var attributeRemoved = false;
          for ( var i = 0; i < this._accessibleAttributes.length; i++ ) {
            if ( this._accessibleAttributes[ i ].attribute === attribute ) {
              this._accessibleAttributes.splice( i, 1 );
              attributeRemoved = true;
            }
          }
          assert && assert( attributeRemoved, 'Node does not have accessible attribute ' + attribute );

          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.removeAttribute( attribute );
          } );
        },

        /**
         * Remove all attributes from this node's dom element.
         * @public
         */
        removeAccessibleAttributes: function() {

          // all attributes currently on this node's DOM element
          var attributes = this.getAccessibleAttributes();

          for ( var i = 0; i < attributes.length; i++ ) {
            var attribute = attributes[ i ].attribute;
            this.removeAccessibleAttribute( attribute );
          }
        },

        /**
         * Make the DOM element explicitly focusable with a tab index. Native HTML form elements will generally be in
         * the navigation order without explicitly setting focusable.  If these need to be removed from the navigation
         * order, call setFocusable( false ).  Removing an element from the focus order does not hide the element from
         * assistive technology.
         * @public
         *
         * @param {boolean} isFocusable
         */
        setFocusable: function( isFocusable ) {
          this._focusable = isFocusable;

          this.updateAccessiblePeers( function( accessiblePeer ) {
            if ( accessiblePeer.domElement ) {
              accessiblePeer.domElement.tabIndex = isFocusable ? 0 : -1;
            }
          } );
        },
        set focusable( isFocusable ) { this.setFocusable( isFocusable ); },

        /**
         * Get whether or not the node is focusable.
         * @public
         *
         * REVIEW: Usually boolean getters would be called something like isFocusable().
         *
         * @returns {boolean}
         */
        getFocusable: function() {
          return this._focusable;
        },
        get focusable() { return this.getFocusable(); },

        /**
         * Get whether this node's dom element is currently focussed.
         * @public
         *
         * REVIEW: This function is not spelled correctly.
         * 
         * @returns {boolean}
         */
        isFocussed: function() {
          var isFocused = false;
          if ( this.accessibleInstances.length > 0 ) {
            isFocused = document.activeElement === this.accessibleInstances[ 0 ].peer.domElement;
          }

          return isFocused;
        },
        get focussed() { return this.isFocussed(); },

        /**
         * Focus this node's dom element. The element must not be hidden, and it must be focusable. If the node
         * has more than one instance, this will fail because the DOM element is not uniquely defined. If accessibility
         * is not enabled, this will be a no op. When Accessibility is more widely used, the no op can be replaced
         * with an assertion that checks for accessible content.
         * 
         * @public
         */
        focus: function() {
          if ( this.accessibleInstances.length > 0 ) {

            // when accessibility is widely used, this assertion can be added back in
            // assert && assert( this.accessibleInstances.length > 0, 'there must be accessible content for the node to receive focus' );
            assert && assert( this._focusable, 'trying to set focus on a node that is not focusable' );
            assert && assert( !this._accessibleHidden, 'trying to set focus on a node with hidden accessible content' );
            assert && assert( this.accessibleInstances.length === 1, 'focus() unsuported for Nodes using DAG, accessible conotent is not unique' );

            this.accessibleInstances[ 0 ].peer.domElement.focus();
          }
        },

        /**
         * Remove focus from this DOM element.  The focus highlight will dissapear, and the element will not receive
         * keyboard events when it doesn't have focus.
         * @public
         */
        blur: function() {
          if ( this.accessibleInstances.length > 0 ) {
            this.accessibleInstances[ 0 ].peer.domElement.blur();
          }
        },

        /**
         * Add DOM event listeners contained in the accessibleInput directly to the DOM elements on each
         * accessibleInstance.  Never use this directly, use addAccessibleInputListener()
         * @private
         *
         * @param {Object} accessibleInput
         * @param {AccessibleInstance} accessibleInstance
         */
        addDOMEventListeners: function( accessibleInput, domElement ) {
          for ( var event in accessibleInput ) {
            if ( accessibleInput.hasOwnProperty( event ) && _.includes( DOM_EVENTS, event ) ) {
              domElement.addEventListener( event, accessibleInput[ event ] );
            }
          }
        },

        /**
         * Remove a DOM event listener contained in an accesssibleInput.  Never to be used directly, see
         * removeAccessibilityInputListener().
         * @private
         *
         * @param {Object} accessibleInput
         */
        removeDOMEventListeners: function( accessibleInput, domElement ) {
          for ( var event in accessibleInput ) {
            if ( accessibleInput.hasOwnProperty( event ) && _.includes( DOM_EVENTS, event ) ) {
              domElement.removeEventListener( event, accessibleInput[ event ] );
            }
          }
        },

        /**
         * Do not use this function directly, it is private.  Updates the accessible label setting the
         * content as innerHTML or textContent based on whether or state of this._labelIsHTML flag.
         * 
         * @private
         * @param {string} label
         */
        setLabelContent: function( label ) {
          this._accessibleLabel = label;

          var self = this;
          if ( this._useAriaLabel ) {
            this.setAccessibleAttribute( 'aria-label', this._accessibleLabel );
          }
          else if ( this._labelTagName ) {
            this.updateAccessiblePeers( function( accessiblePeer ) {
              if ( accessiblePeer.labelElement ) {
                setTextContent( accessiblePeer.labelElement, self._accessibleLabel, self._labelIsHTML );

                // if the label element happens to be a 'label', associate with 'for' attribute
                if ( self._labelTagName.toUpperCase() === LABEL_TAG ) {
                  accessiblePeer.labelElement.setAttribute( 'for', accessiblePeer.domElement.id );
                }
              }
            } );
          }
          else {
            this.updateAccessiblePeers( function( accessiblePeer ) {
              if ( elementSupportsInnerHTML( accessiblePeer.domElement ) ) {
                setTextContent( accessiblePeer.domElement, label, self._labelIsHTML );
              }
            } );
          }
        },

        /**
         * Do not use this function directly, it is private. Updates the accessible description,
         * setting content as innerHTML or textContent based no the state of this._descriptionIsHTML flag.
         *
         * @private
         * @param {string} description
         */
        setDescriptionContent: function( description ) {
          this._accessibleDescription = description;

          // if there is no description element, assume that a paragraph element should be used
          if ( !this._descriptionTagName ) {
            this.setDescriptionTagName( 'p' );
          }

          var self = this;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            setTextContent( accessiblePeer.descriptionElement, description, self._descriptionIsHTML );
          } );
        },

        /**
         * Update all AccessiblePeers representing this node with the callback, which takes the AccessiblePeer 
         * as an argument.
         * @private
         * @param {function} callback
         */
        updateAccessiblePeers: function( callback ) {
          for ( var i = 0; i < this.accessibleInstances.length; i++ ) {
            this.accessibleInstances[ i ].peer && callback( this.accessibleInstances[ i ].peer );
          }
        }
      } );

      /**
       * If the text content uses formatting tags, set the content as innerHTML. Otherwise, set as textContent.
       * In general, textContent is more secure and more performant because it doesn't trigger DOM styling and
       * element insertions.
       *
       * @param {HTMLElement} domElement
       * @param {string} textContent
       * @param {boolean} isHTML - whether or not to set the content as HTML
       */
      function setTextContent( domElement, textContent, isHTML ) {
        if ( isHTML ) {
          domElement.innerHTML = textContent;
        }
        else {
          domElement.textContent = textContent;
        }
      }

      /**
       * Returns whether or not the element supports innerHTML.
       * @private
       * @param {HTMLElement} domElement
       * @returns {boolean}
       */
      function elementSupportsInnerHTML( domElement ) {
        return !_.includes( ELEMENTS_WITHOUT_CLOSING_TAG, domElement.tagName );
      }

      /**
       * Create an HTML element.  Unless this is a form element or explicitly marked as focusable, add a negative
       * tab index. IE gives all elements a tabIndex of 0 and handles tab navigation internally, so this marks
       * which elements should not be in the focus order.
       *
       * @param  {string} tagName
       * @param {boolean} focusable - should the element be explicitly added to the focus order?
       * @returns {HTMLElement}
       */
      function createElement( tagName, focusable ) {
        var domElement = document.createElement( tagName );
        var upperCaseTagName = tagName.toUpperCase();

        // give all non-focusable elements a tabindex of -1 for browser consistency
        if ( !_.includes( FORM_ELEMENTS, upperCaseTagName ) && !focusable ) {
          domElement.tabIndex = -1;
        }

        // Safari requires that certain input elements have width, otherwise it will not be keyboard accessible
        if ( _.includes( ELEMENTS_REQUIRE_WIDTH, upperCaseTagName ) ) {
          domElement.style.width = '1px';
        }

        return domElement;
      }

      /**
       * Called by invalidateAccessibleContent.  'this' will be bound by call. The contentElement will either be a
       * label or description element.  The contentElement will be sorted relative to this node's DOM element or its
       * parentContainerElement.  Its placement will also depend on whether or not this node wants to prepend labels,
       * see setPrependLabels().
       * @private
       *
       * @param {AccessiblePeer} contentElement
       * @param {HTMLElement} contentElement 
       * @param {boolean} prependLabels
       */
      function insertContentElement( accessiblePeer, contentElement, prependLabels ) {

        // if we have a parent container, add the element as a child of the container - otherwise, add as child of the
        // node's DOM element
        if ( accessiblePeer.parentContainerElement ) {
          if ( prependLabels && accessiblePeer.parentContainerElement === accessiblePeer.domElement.parentNode ) {
            accessiblePeer.parentContainerElement.insertBefore( contentElement, accessiblePeer.domElement );
          }
          else {
            accessiblePeer.parentContainerElement.appendChild( contentElement );
          }
        }
        else if ( accessiblePeer.domElement ) {
          accessiblePeer.domElement.appendChild( contentElement );
        }
      }

      /**
       * Invalidate our current accessible content, triggering recomputation
       * of anything that depended on the old accessible content. This can be
       * combined with a client implementation of invalidateAccessibleContent.
       *
       * @protected
       */
      function invalidateAccessibleContent() {
        var self = this;

        // iteration variable used through this function
        var i = 0;

        // for each accessible peer, clear the parent container if it exists since we will be reinserting labels and
        // the dom element in createPeer
        this.updateAccessiblePeers( function( accessiblePeer ) {
          var parentContainerElement = accessiblePeer.parentContainerElement;
          while ( parentContainerElement && parentContainerElement.hasChildNodes() ) {
            parentContainerElement.removeChild( parentContainerElement.lastChild );
          }
        } );

        // if any parents are flagged as removed from the accessibility tree, set content to null
        var contentDisplayed = this._accessibleContentDisplayed;
        for ( i = 0; i < this._parents.length; i++ ) {
          if ( !this._parents[ i ].accessibleContentDisplayed ) {
            contentDisplayed = false;
          }
        }

        var accessibleContent = null;
        if ( contentDisplayed && this._tagName ) {
          accessibleContent = {
            focusHighlight: this._focusHighlight,
            focusHighlightLayerable: this._focusHighlightLayerable,
            createPeer: function( accessibleInstance ) {

              var uniqueId = accessibleInstance.trail.getUniqueId();

              // create the base DOM element representing this accessible instance
              var domElement = createElement( self._tagName, self._focusable );
              domElement.id = uniqueId;

              // create the parent container element for the dom element and label description elements
              var parentContainerElement = null;
              if ( self._parentContainerTagName ) {
                parentContainerElement = createElement( self._parentContainerTagName, false );
                parentContainerElement.id = 'container-' + uniqueId;

                // provide the aria-role if it is specified
                if ( self._parentContainerAriaRole ) {
                  parentContainerElement.setAttribute( 'role', self._parentContainerAriaRole );
                }
              }

              // create the label DOM element representing this instance
              var labelElement = null;
              if ( self._labelTagName ) {
                labelElement = createElement( self._labelTagName, false );
                labelElement.id = 'label-' + uniqueId;

                if ( self._labelTagName.toUpperCase() === LABEL_TAG ) {
                  labelElement.setAttribute( 'for', uniqueId );
                }
              }

              // create the description DOM element representing this instance
              var descriptionElement = null;
              if ( self._descriptionTagName ) {
                descriptionElement = createElement( self._descriptionTagName, false );
                descriptionElement.id = 'description-' + uniqueId;
              }

              var accessiblePeer = new AccessiblePeer( accessibleInstance, domElement, {
                parentContainerElement: parentContainerElement,
                labelElement: labelElement,
                descriptionElement: descriptionElement
              } );
              accessibleInstance.peer = accessiblePeer;

              // restore whether or not this element is focusable
              if ( self._focusable === null ) {
                self._focusable = _.includes( FORM_ELEMENTS, self._tagName.toUpperCase() );
              }
              self.setFocusable( self._focusable );

              // set the accessible label now that the element has been recreated again
              if ( self._accessibleLabel ) {
                if ( self._labelIsHTML ) {
                  self.setAccessibleLabelAsHTML( self._accessibleLabel );
                }
                else {
                  self.setAccessibleLabel( self._accessibleLabel );
                }
              }

              // set if using aria-label
              if ( self._useAriaLabel ) {
                self.setUseAriaLabel( self._useAriaLabel );
              }

              // resetore hidden
              self.setAccessibleHidden( self._accessibleHidden );

              // restore checked
              self.setAccessibleChecked( self._accessibleChecked );

              // restore input value
              self._inputValue && self.setInputValue( self._inputValue );

              // set the accessible attributes, restoring from a defenseive copy
              var defensiveAttributes = self.accessibleAttributes;
              for ( i = 0; i < defensiveAttributes.length; i++ ) {
                var attribute = defensiveAttributes[ i ].attribute;
                var value = defensiveAttributes[ i ].value;
                self.setAccessibleAttribute( attribute, value );
              }

              // set the accessible description
              if ( self._accessibleDescription ) {
                if ( self._descriptionIsHTML ) {
                  self.setAccessibleDescriptionAsHTML( self._accessibleDescription );
                }
                else {
                  self.setAccessibleDescription( self._accessibleDescription );
                }
              }

              // if element is an input element, set input type
              if ( self._tagName.toUpperCase() === INPUT_TAG && self._inputType ) {
                self.setInputType( self._inputType );
              }

              // restore aria-labelledby and aria-describedby associations
              self._ariaLabelsNode && self.setAriaLabelsNode( self._ariaLabelsNode, self._ariaLabelsAssociation );
              self._ariaDescribesNode && self.setAriaDescribesNode( self._ariaDescribesNode, self._ariaDescribesAssociation );

              // add all listeners to the dom element
              for ( i = 0; i < self._accessibleInputListeners.length; i++ ) {
                self.addDOMEventListeners( self._accessibleInputListeners[ i ], domElement );
              }

              // insert the label and description elements in the correct location if they exist
              labelElement && insertContentElement( accessiblePeer, labelElement, self._prependLabels );
              descriptionElement && insertContentElement( accessiblePeer, descriptionElement, self._prependLabels );

              // Default the focus highlight in this special case to be invisible until selected.
              if ( self._focusHighlightLayerable ) {
                self._focusHighlight.visible = false;
              }

              return accessiblePeer;
            }
          };
        }

        this.accessibleContent = accessibleContent;
      }

      // Patch in a sub-type call if it already exists on the prototype
      if ( proto.invalidateAccessibleContent ) {
        var subtypeInvalidateAccesssibleContent = proto.invalidateAccessibleContent;
        proto.invalidateAccessibleContent = function() {
          subtypeInvalidateAccesssibleContent.call( this );
          invalidateAccessibleContent.call( this );
        };
      }
      else {
        proto.invalidateAccessibleContent = invalidateAccessibleContent;
      }
    }
  };

  scenery.register( 'Accessibility', Accessibility );

  return Accessibility;
} );
// Copyright 2013-2016, University of Colorado Boulder


/**
 * Wraps the context and contains a reference to the canvas, so that we can absorb unnecessary state changes,
 * and possibly combine certain fill operations.
 *
 * TODO: performance analysis, possibly axe this and use direct modification.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/CanvasContextWrapper',['require','PHET_CORE/inherit','SCENERY/scenery','AXON/Property'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Property = require( 'AXON/Property' );

  /**
   * @constructor
   *
   * @param {HTMLCanvasElement} canvas
   * @param {CanvasRenderingContext2D} context
   */
  function CanvasContextWrapper( canvas, context ) {
    this.canvas = canvas;
    this.context = context;

    this.resetStyles();

    phetAllocation && phetAllocation( 'CanvasContextWrapper' );
  }

  scenery.register( 'CanvasContextWrapper', CanvasContextWrapper );

  inherit( Object, CanvasContextWrapper, {
    // set local styles to undefined, so that they will be invalidated later
    resetStyles: function() {
      this.fillStyle = undefined; // null
      this.strokeStyle = undefined; // null
      this.lineWidth = undefined; // 1
      this.lineCap = undefined; // 'butt'
      this.lineJoin = undefined; // 'miter'
      this.lineDash = undefined; // []
      this.lineDashOffset = undefined; // 0
      this.miterLimit = undefined; // 10

      this.font = undefined; // '10px sans-serif'
      this.direction = undefined; // 'inherit'
    },

    /**
     * Sets a (possibly) new width and height, and clears the canvas.
     * @param width
     * @param height
     */
    setDimensions: function( width, height ) {

      //Don't guard against width and height, because we need to clear the canvas.
      //TODO: Is it expensive to clear by setting both the width and the height?  Maybe we just need to set the width to clear it.
      this.canvas.width = width;
      this.canvas.height = height;

      // assume all persistent data could have changed
      this.resetStyles();
    },

    setFillStyle: function( style ) {
      // turn {Property}s into their values when necessary
      if ( style && style instanceof Property ) {
        style = style.value;
      }

      // turn {Color}s into strings when necessary
      if ( style && style.getCanvasStyle ) {
        style = style.getCanvasStyle();
      }

      if ( this.fillStyle !== style ) {
        this.fillStyle = style;

        // allow gradients / patterns
        this.context.fillStyle = style;
      }
    },

    setStrokeStyle: function( style ) {
      // turn {Property}s into their values when necessary
      if ( style && style instanceof Property ) {
        style = style.value;
      }

      // turn {Color}s into strings when necessary
      if ( style && style.getCanvasStyle ) {
        style = style.getCanvasStyle();
      }

      if ( this.strokeStyle !== style ) {
        this.strokeStyle = style;

        // allow gradients / patterns
        this.context.strokeStyle = style;
      }
    },

    setLineWidth: function( width ) {
      if ( this.lineWidth !== width ) {
        this.lineWidth = width;
        this.context.lineWidth = width;
      }
    },

    setLineCap: function( cap ) {
      if ( this.lineCap !== cap ) {
        this.lineCap = cap;
        this.context.lineCap = cap;
      }
    },

    setLineJoin: function( join ) {
      if ( this.lineJoin !== join ) {
        this.lineJoin = join;
        this.context.lineJoin = join;
      }
    },

    setMiterLimit: function( miterLimit ) {
      assert && assert( typeof miterLimit === 'number' );
      if ( this.miterLimit !== miterLimit ) {
        this.miterLimit = miterLimit;
        this.context.miterLimit = miterLimit;
      }
    },

    setLineDash: function( dash ) {
      assert && assert( dash !== undefined, 'undefined line dash would cause hard-to-trace errors' );
      if ( this.lineDash !== dash ) {
        this.lineDash = dash;
        if ( this.context.setLineDash ) {
          this.context.setLineDash( dash === null ? [] : dash ); // see https://github.com/phetsims/scenery/issues/101 for null line-dash workaround
        }
        else if ( this.context.mozDash !== undefined ) {
          this.context.mozDash = dash;
        }
        else if ( this.context.webkitLineDash !== undefined ) {
          this.context.webkitLineDash = dash ? dash : [];
        }
        else {
          // unsupported line dash! do... nothing?
        }
      }
    },

    setLineDashOffset: function( lineDashOffset ) {
      if ( this.lineDashOffset !== lineDashOffset ) {
        this.lineDashOffset = lineDashOffset;
        if ( this.context.lineDashOffset !== undefined ) {
          this.context.lineDashOffset = lineDashOffset;
        }
        else if ( this.context.webkitLineDashOffset !== undefined ) {
          this.context.webkitLineDashOffset = lineDashOffset;
        }
        else {
          // unsupported line dash! do... nothing?
        }
      }
    },

    setFont: function( font ) {
      if ( this.font !== font ) {
        this.font = font;
        this.context.font = font;
      }
    },

    setDirection: function( direction ) {
      if ( this.direction !== direction ) {
        this.direction = direction;
        this.context.direction = direction;
      }
    }
  } );

  return CanvasContextWrapper;
} );


define("PHET_IO/types/TNumber", function(){return function(){ return function(){}; };});
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SCENERY/nodes/TNode',['require','SCENERY/scenery','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TNumber','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );

  /**
   * Wrapper type for phet/scenery's Node
   * @param node
   * @param phetioID
   * @constructor
   */
  function TNode( node, phetioID ) {
    TObject.call( this, node, phetioID );
    assertInstanceOf( node, phet.scenery.Node );
  }

  phetioInherit( TObject, 'TNode', TNode, {

    detach: {
      returnType: TVoid,
      parameterTypes: [],
      implementation: function() {
        this.instance.detach();
      },
      documentation: 'Detaches the node from its parents (if any)'
    },
    isVisible: {
      returnType: TBoolean,
      parameterTypes: [],
      implementation: function() {
        return this.instance.visible;
      },
      documentation: 'Gets a Boolean value indicating whether the node can be seen and interacted with'
    },

    setVisible: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( visible ) {
        this.instance.visible = visible;
      },
      documentation: 'Set whether the node will be visible (and interactive)'
    },

    setPickable: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( pickable ) {
        this.instance.pickable = pickable;
      },
      documentation: 'Set whether the node will be pickable (and hence interactive)'
    },

    isPickable: {
      returnType: TBoolean,
      parameterTypes: [],
      implementation: function() {
        return this.instance.pickable;
      },
      documentation: 'Gets whether the node is pickable (and hence interactive)'
    },

    addPickableListener: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [ TBoolean ] ) ],
      implementation: function( callback ) {
        var inst = this.instance;
        this.instance.on( 'pickability', function() {
          callback( inst.isPickable() );
        } );
      },
      documentation: 'Adds a listener for when pickability of the node changes'
    },

    addVisibleListener: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [ TBoolean ] ) ],
      implementation: function( callback ) {
        var inst = this.instance;
        this.instance.on( 'visibility', function() {
          callback( inst.isVisible() );
        } );
      },
      documentation: 'Adds a listener for when visibility of the node changes'
    },

    setOpacity: {
      returnType: TVoid,
      parameterTypes: [ TNumber() ],
      implementation: function( opacity ) {
        this.instance.opacity = opacity;
      },
      documentation: 'Set opacity between 0-1 (inclusive)'
    },

    setRotation: {
      returnType: TVoid,
      parameterTypes: [ TNumber() ],
      implementation: function( rotation ) {
        this.instance.rotation = rotation;
      },
      documentation: 'Set the rotation of the node, in radians'
    }
  }, {
    documentation: 'The base type for graphical and potentially interactive objects'
  } );

  scenery.register( 'TNode', TNode );

  return TNode;
} );


// Copyright 2012-2016, University of Colorado Boulder

/**
 * A node for the Scenery scene graph. Supports general directed acyclic graphics (DAGs).
 * Handles multiple layers with assorted types (Canvas 2D, SVG, DOM, WebGL, etc.).
 *
 * ## General description of Nodes
 *
 * In Scenery, the visual output is determined by a group of connected nodes (generally known as a scene graph).
 * Each node has a list of 'child' nodes. When a node is visually displayed, its child nodes (children) will also be
 * displayed, along with their children, etc. There is typically one 'root' node that is passed to the Scenery Display
 * whose descendants (nodes that can be traced from the root by child relationships) will be displayed.
 *
 * For instance, say there are nodes named A, B, C, D and E, who have the relationships:
 * - B is a child of A (thus A is a parent of B)
 * - C is a child of A (thus A is a parent of C)
 * - D is a child of C (thus C is a parent of D)
 * - E is a child of C (thus C is a parent of E)
 * where A would be the root node. This can be visually represented as a scene graph, where a line connects a parent
 * node to a child node (where the parent is usually always at the top of the line, and the child is at the bottom):
 * For example:
 *
 *   A
 *  / \
 * B   C
 *    / \
 *   D   E
 *
 * Additionally, in this case:
 * - D is a 'descendant' of A (due to the C being a child of A, and D being a child of C)
 * - A is an 'ancestor' of D (due to the reverse)
 * - C's 'subtree' is C, D and E, which consists of C itself and all of its descendants.
 *
 * Note that Scenery allows some more complicated forms, where nodes can have multiple parents, e.g.:
 *
 *   A
 *  / \
 * B   C
 *  \ /
 *   D
 *
 * In this case, D has two parents (B and C). Scenery disallows any node from being its own ancestor or descendant,
 * so that loops are not possible. When a node has two or more parents, it means that the node's subtree will typically
 * be displayed twice on the screen. In the above case, D would appear both at B's position and C's position. Each
 * place a node would be displayed is known as an 'instance'.
 *
 * Each node has a 'transform' associated with it, which determines how its subtree (that node and all of its
 * descendants) will be positioned. Transforms can contain:
 * - Translation, which moves the position the subtree is displayed
 * - Scale, which makes the displayed subtree larger or smaller
 * - Rotation, which displays the subtree at an angle
 * - or any combination of the above that uses an affine matrix (more advanced transforms with shear and combinations
 *   are possible).
 *
 * Say we have the following scene graph:
 *
 *   A
 *   |
 *   B
 *   |
 *   C
 *
 * where there are the following transforms:
 * - A has a 'translation' that moves the content 100 pixels to the right
 * - B has a 'scale' that doubles the size of the content
 * - C has a 'rotation' that rotates 180-degrees around the origin
 *
 * If C displays a square that fills the area with 0 <= x <= 10 and 0 <= y <= 10, we can determine the position on
 * the display by applying transforms starting at C and moving towards the root node (in this case, A):
 * 1. We apply C's rotation to our square, so the filled area will now be -10 <= x <= 0 and -10 <= y <= 0
 * 2. We apply B's scale to our square, so now we have -20 <= x <= 0 and -20 <= y <= 0
 * 3. We apply A's translation to our square, moving it to 80 <= x <= 100 and -20 <= y <= 0
 *
 * Nodes also have a large number of properties that will affect how their entire subtree is rendered, such as
 * visibility, opacity, etc.
 *
 * ## Creating nodes
 *
 * Generally, there are two types of nodes:
 * - Nodes that don't display anything, but serve as a container for other nodes (e.g. Node itself, HBox, VBox)
 * - Nodes that display content, but ALSO serve as a container (e.g. Circle, Image, Text)
 *
 * When a node is created with the default Node constructor, e.g.:
 *   var node = new Node();
 * then that node will not display anything by itself.
 *
 * Generally subtypes of Node are used for displaying things, such as Circle, e.g.:
 *   var circle = new Circle( 20 ); // radius of 20
 *
 * Almost all nodes (with the exception of leaf-only nodes like Spacer) can contain children.
 *
 * ## Connecting nodes, and rendering order
 *
 * To make a 'childNode' become a 'parentNode', the typical way is to call addChild():
 *   parentNode.addChild( childNode );
 *
 * To remove this connection, you can call:
 *   parentNode.removeChild( childNode );
 *
 * Adding a child node with addChild() puts it at the end of parentNode's list of child nodes. This is important,
 * because the order of children affects what nodes are drawn on the 'top' or 'bottom' visually. Nodes that are at the
 * end of the list of children are generally drawn on top.
 *
 * This is generally easiest to represent by notating scene graphs with children in order from left to right, thus:
 *
 *   A
 *  / \
 * B   C
 *    / \
 *   D   E
 *
 * would indicate that A's children are [B,C], so C's subtree is drawn ON TOP of B. The same is true of C's children
 * [D,E], so E is drawn on top of D. If a node itself has content, it is drawn below that of its children (so C itself
 * would be below D and E).
 *
 * This means that for every scene graph, nodes instances can be ordered from bottom to top. For the above example, the
 * order is:
 * 1. A (on the very bottom visually, may get covered up by other nodes)
 * 2. B
 * 3. C
 * 4. D
 * 5. E (on the very top visually, may be covering other nodes)
 *
 * ## Trails
 *
 * For examples where there are multiple parents for some nodes (also referred to as DAG in some code, as it represents
 * a Directed Acyclic Graph), we need more information about the rendering order (as otherwise nodes could appear
 * multiple places in the visual bottom-to-top order.
 *
 * A Trail is basically a list of nodes, where every node in the list is a child of its previous element, and a parent
 * of its next element. Thus for the scene graph:
 *
 *   A
 *  / \
 * B   C
 *  \ / \
 *   D   E
 *    \ /
 *     F
 *
 * there are actually three instances of F being displayed, with three trails:
 * - [A,B,D,F]
 * - [A,C,D,F]
 * - [A,C,E,F]
 * Note that the trails are essentially listing nodes used in walking from the root (A) to the relevant node (F) using
 * connections between parents and children.
 *
 * The trails above are in order from bottom to top (visually), due to the order of children. Thus since A's children
 * are [B,C] in that order, F with the trail [A,B,D,F] is displayed below [A,C,D,F], because C is after B.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Node',['require','PHET_CORE/inherit','PHET_CORE/extend','AXON/Events','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','DOT/Vector2','DOT/Util','KITE/Shape','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/util/RendererSummary','SCENERY/util/Picker','SCENERY/accessibility/Accessibility','SCENERY/util/CanvasContextWrapper','SCENERY/nodes/TNode','TANDEM/Tandem'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var Events = require( 'AXON/Events' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Transform3 = require( 'DOT/Transform3' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Vector2 = require( 'DOT/Vector2' );
  var Util = require( 'DOT/Util' );
  var Shape = require( 'KITE/Shape' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var RendererSummary = require( 'SCENERY/util/RendererSummary' );
  var Picker = require( 'SCENERY/util/Picker' );
  var Accessibility = require( 'SCENERY/accessibility/Accessibility' );
  require( 'SCENERY/util/CanvasContextWrapper' );
  // commented out so Require.js doesn't balk at the circular dependency
  // require( 'SCENERY/util/Trail' );
  // require( 'SCENERY/util/TrailPointer' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var Tandem = require( 'TANDEM/Tandem' );
  // constants
  var clamp = Util.clamp;

  var globalIdCounter = 1;

  var eventsRequiringBoundsValidation = {
    'childBounds': true,
    'localBounds': true,
    'bounds': true
  };

  function defaultTrailPredicate( node ) {
    return node._parents.length === 0;
  }

  function defaultLeafTrailPredicate( node ) {
    return node._children.length === 0;
  }

  function hasRootedDisplayPredicate( node ) {
    return node._rootedDisplays.length > 0;
  }

  var scratchBounds2 = Bounds2.NOTHING.copy(); // mutable {Bounds2} used temporarily in methods
  var scratchMatrix3 = new Matrix3();

  // Node options, in the order they are executed in the constructor/mutate()
  var NODE_OPTION_KEYS = [
    'children', // List of children to add (in order), see setChildren for more documentation
    'cursor', // CSS cursor to display when over this node, see setCursor() for more documentation
    'visible', // Whether the node is visible, see setVisible() for more documentation
    'pickable', // Whether the node is pickable, see setPickable() for more documentation
    'inputEnabled', // Whether input events can reach into this subtree, see setInputEnabled() for more documentation
    'inputListeners', // The input listeners attached to the Node, see setInputListeners() for more documentation
    'opacity', // Opacity of this node's subtree, see setOpacity() for more documentation
    'matrix', // Transformation matrix of the node, see setMatrix() for more documentation
    'translation', // x/y translation of the node, see setTranslation() for more documentation
    'x', // x translation of the node, see setX() for more documentation
    'y', // y translation of the node, see setY() for more documentation
    'rotation', // rotation (in radians) of the node, see setRotation() for more documentation
    'scale', // scale of the node, see scale() for more documentation
    'localBounds', // bounds of subtree in local coordinate frame, see setLocalBounds() for more documentation
    'maxWidth', // Constrains width of this node, see setMaxWidth() for more documentation
    'maxHeight', // Constrains height of this node, see setMaxHeight() for more documentation
    'leftTop', // The upper-left corner of this node's bounds, see setLeftTop() for more documentation
    'centerTop', // The top-center of this node's bounds, see setCenterTop() for more documentation
    'rightTop', // The upper-right corner of this node's bounds, see setRightTop() for more documentation
    'leftCenter', // The left-center of this node's bounds, see setLeftCenter() for more documentation
    'center', // The center of this node's bounds, see setCenter() for more documentation
    'rightCenter', // The center-right of this node's bounds, see setRightCenter() for more documentation
    'leftBottom', // The bottom-left of this node's bounds, see setLeftBottom() for more documentation
    'centerBottom', // The middle center of this node's bounds, see setCenterBottom() for more documentation
    'rightBottom', // The bottom right of this node's bounds, see setRightBottom() for more documentation
    'left', // The left side of this node's bounds, see setLeft() for more documentation
    'right', // The right side of this node's bounds, see setRight() for more documentation
    'top', // The top side of this node's bounds, see setTop() for more documentation
    'bottom', // The bottom side of this node's bounds, see setBottom() for more documentation
    'centerX', // The x-center of this node's bounds, see setCenterX() for more documentation
    'centerY', // The y-center of this node's bounds, see setCenterY() for more documentation
    'renderer', // The preferred renderer for this subtree, see setRenderer() for more documentation
    'layerSplit', // Forces this subtree into a layer of its own, see setLayerSplit() for more documentation
    'usesOpacity', // Hint that opacity will be changed, see setUsesOpacity() for more documentation
    'cssTransform', // Hint that can trigger using CSS transforms, see setCssTransform() for more documentation
    'excludeInvisible', // If this is invisible, exclude from DOM, see setExcludeInvisible() for more documentation
    'webglScale', // Hint to adjust WebGL scaling quality for this subtree, see setWebglScale() for more documentation
    'preventFit', // Prevents layers from fitting this subtree, see setPreventFit() for more documentation
    'mouseArea', // Changes the area the mouse can interact with, see setMouseArea() for more documentation
    'touchArea', // Changes the area touches can interact with, see setTouchArea() for more documentation
    'clipArea', // Makes things outside of a shape invisible, see setClipArea() for more documentation
    'transformBounds', // Flag that makes bounds tighter, see setTransformBounds() for more documentation
    'accessibleContent', // Sets up accessibility handling, see setAccessibleContent() for more documentation
    'accessibleOrder', // Modifies the keyboard accessibility order, see setAccessibleOrder() for more documentation
    'phetioType', // The corresponding phet-io wrapper type
    'tandem' // For instrumenting Scenery nodes, see setTandem().  This must be last so that (a) the phetioType
    // is available and (b) because when tandem.addInstance is called the node becomes active in the PhET-iO API immediately
  ];

  var DEFAULT_OPTIONS = {
    visible: true,
    opacity: 1,
    pickable: null,
    inputEnabled: true,
    clipArea: null,
    mouseArea: null,
    touchArea: null,
    cursor: null,
    accessibleContent: null,
    accessibleOrder: null,
    transformBounds: false,
    maxWidth: null,
    maxHeight: null,
    renderer: null,
    usesOpacity: false,
    layerSplit: false,
    cssTransform: false,
    excludeInvisible: false,
    webglScale: null,
    preventFit: false
  };

  /**
   * Creates a Node with options.
   * @public
   * @constructor
   * @mixes Events
   * @mixes Accessibility
   *
   * NOTE: Directly created Nodes (not of any subtype, but created with "new Node( ... )") are generally used as
   *       containers, which can hold other Nodes, subtypes of Node that can display things.
   *
   * Node and its subtypes generally have the last constructor parameter reserved for the 'options' object. This is a
   * key-value map that specifies relevant options that are used by Node and subtypes.
   *
   * For example, one of Node's options is bottom, and one of Circle's options is radius. When a circle is created:
   *   var circle = new Circle( {
   *     radius: 10,
   *     bottom: 200
   *   } );
   * This will create a Circle, set its radius (by executing circle.radius = 10, which uses circle.setRadius()), and
   * then will align the bottom of the circle along y=200 (by executing circle.bottom = 200, which uses
   * node.setBottom()).
   *
   * The options are executed in the order specified by each types _mutatorKeys property.
   *
   * The options object is currently not checked to see whether there are property (key) names that are not used, so it
   * is currently legal to do "new Node( { fork_kitchen_spoon: 5 } )".
   *
   * Usually, an option (e.g. 'visible'), when used in a constructor or mutate() call, will directly use the ES5 setter
   * for that property (e.g. node.visible = ...), which generally forwards to a non-ES5 setter function
   * (e.g. node.setVisible( ... )) that is responsible for the behavior. Documentation is generally on these methods
   * (e.g. setVisible), although some methods may be dynamically created to avoid verbosity (like node.leftTop).
   *
   * Sometimes, options invoke a function instead (e.g. 'scale') because the verb and noun are identical. In this case,
   * instead of setting the setter (node.scale = ..., which would override the function), it will instead call
   * the method directly (e.g. node.scale( ... )).
   *
   * @param {Object} [options] - Optional options object, as described above.
   */
  function Node( options ) {
    // supertype call to axon.Events (should just initialize a few properties here, notably _eventListeners and _staticEventListeners)
    Events.call( this );

    // NOTE: All member properties with names starting with '_' are assumed to be @private!

    // @private {number} - Assigns a unique ID to this node (allows trails to get a unique list of IDs)
    this._id = globalIdCounter++;

    // @protected {Tandem|null} - Only one can be provided
    this._tandem = null;

    // @protected {function} - the wrapper type for phet-io
    this._phetioType = TNode;

    // @protected {Array.<Instance>} - All of the Instances tracking this Node
    this._instances = [];

    // @protected {Array.<AccessibleInstance>} - Empty unless the node contains some accessible instance.
    this._accessibleInstances = [];

    // @protected {Array.<Display>} - All displays where this node is the root.
    this._rootedDisplays = [];

    // @protected {Array.<Drawable>} - Drawable states that need to be updated on mutations. Generally added by SVG and
    // DOM elements that need to closely track state (possibly by Canvas to maintain dirty state).
    this._drawables = [];

    // @private {boolean} - Whether this node (and its children) will be visible when the scene is updated. Visible
    // nodes by default will not be pickable either.
    this._visible = DEFAULT_OPTIONS.visible;

    // @private {number} - Opacity, in the range from 0 (fully transparent) to 1 (fully opaque).
    this._opacity = DEFAULT_OPTIONS.opacity;

    // @private {boolean|null} - See setPickable().
    this._pickable = DEFAULT_OPTIONS.pickable;

    // @private {boolean} - Whether input event listeners on this node or descendants on a trail will have input
    // listeners. triggered. Note that this does NOT effect picking, and only prevents some listeners from being fired.
    this._inputEnabled = DEFAULT_OPTIONS.inputEnabled;

    // @private - This node and all children will be clipped by this shape (in addition to any other clipping shapes).
    // {Shape|null} The shape should be in the local coordinate frame.
    this._clipArea = DEFAULT_OPTIONS.clipArea;

    // @private - Areas for hit intersection. If set on a Node, no descendants can handle events.
    this._mouseArea = DEFAULT_OPTIONS.mouseArea; // {Shape|Bounds2} for mouse position in the local coordinate frame
    this._touchArea = DEFAULT_OPTIONS.touchArea; // {Shape|Bounds2} for touch and pen position in the local coordinate frame

    // @private {string|null} - The CSS cursor to be displayed over this node. null should be the default (inherit) value.
    this._cursor = DEFAULT_OPTIONS.cursor;

    // @private {null|Object} - If non-null, this node will be represented in the parallel DOM by the accessible content.
    // The accessibleContent object will be of the form:
    // {
    //   createPeer: function( {AccessibleInstance} ): {AccessiblePeer},
    //   [focusHighlight]: {Bounds2|Shape|Node|string.<'invisible'>}
    // }
    // The focus highlight can be a custom Shape, Node, contain the Node's local bounds, or be invisible.
    this._accessibleContent = DEFAULT_OPTIONS.accessibleContent;

    // @private {Array.<Node> | null} - If provided, it will override the focus order between children (and optionally
    // descendants). If not provided, the focus order will default to the rendering order (first children first, last
    // children last) determined by the children array.
    this._accessibleOrder = DEFAULT_OPTIONS.accessibleOrder;

    // @public (scenery-internal) - Not for public use, but used directly internally for performance.
    this._children = []; // {Array.<Node>} - Ordered array of child nodes.
    this._parents = []; // {Array.<Node>} - Unordered array of parent nodes.

    // @private {boolean} - Whether we will do more accurate (and tight) bounds computations for rotations and shears.
    this._transformBounds = DEFAULT_OPTIONS.transformBounds;

    /*
     * Set up the transform reference. we add a listener so that the transform itself can be modified directly
     * by reference, triggering the event notifications for Scenery The reference to the Transform3 will never change.
     */
    this._transform = new Transform3(); // @private {Transform3}
    this._transformListener = this.onTransformChange.bind( this ); // @private {Function}
    this._transform.onStatic( 'change', this._transformListener ); // NOTE: Listener/transform bound to this node.

    /*
     * Maxmimum dimensions for the node's local bounds before a corrective scaling factor is applied to maintain size.
     * The maximum dimensions are always compared to local bounds, and applied "before" the node's transform.
     * Whenever the local bounds or maximum dimensions of this Node change and it has at least one maximum dimension
     * (width or height), an ideal scale is computed (either the smallest scale for our local bounds to fit the
     * dimension constraints, OR 1, whichever is lower). Then the Node's transform will be scaled (prepended) with
     * a scale adjustment of ( idealScale / alreadyAppliedScaleFactor ).
     * In the simple case where the Node isn't otherwise transformed, this will apply and update the Node's scale so that
     * the node matches the maximum dimensions, while never scaling over 1. Note that manually applying transforms to
     * the Node is fine, but may make the node's width greater than the maximum width.
     * NOTE: If a dimension constraint is null, no resizing will occur due to it. If both maxWidth and maxHeight are null,
     * no scale adjustment will be applied.
     *
     * Also note that setting maxWidth/maxHeight is like adding a local bounds listener (will trigger validation of
     * bounds during the updateDisplay step). NOTE: this means updates to the transform (on a local bounds change) will
     * happen when bounds are validated (validateBounds()), which does not happen synchronously on a child's size
     * change. It does happen at least once in updateDisplay() before rendering, and calling validateBounds() can force
     * a re-check and transform.
     */
    this._maxWidth = DEFAULT_OPTIONS.maxWidth; // @private {number|null}
    this._maxHeight = DEFAULT_OPTIONS.maxHeight; // @private {number|null}
    this._appliedScaleFactor = 1; // @private {number} - Scale applied due to the maximum dimension constraints.

    // @private {Array.<Function>} - For user input handling (mouse/touch).
    this._inputListeners = [];

    // @private {Bounds2} - [mutable] Bounds for this node and its children in the "parent" coordinate frame.
    this._bounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - [mutable] Bounds for this node and its children in the "local" coordinate frame.
    this._localBounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - [mutable] Bounds just for this node, in the "local" coordinate frame.
    this._selfBounds = Bounds2.NOTHING.copy();

    // @private {Bounds2} - [mutable] Bounds just for children of this node (and sub-trees), in the "local" coordinate frame.
    this._childBounds = Bounds2.NOTHING.copy();

    // @private {boolean} - Whether our localBounds have been set (with the ES5 setter/setLocalBounds()) to a custom
    // overridden value. If true, then localBounds itself will not be updated, but will instead always be the
    // overridden value.
    this._localBoundsOverridden = false;

    this._boundsDirty = true; // @private {boolean} - Whether bounds needs to be recomputed to be valid.
    this._localBoundsDirty = true; // @private {boolean} - Whether localBounds needs to be recomputed to be valid.
    this._selfBoundsDirty = true; // @private {boolean} - Whether selfBounds needs to be recomputed to be valid.
    this._childBoundsDirty = true; // @private {boolean} - Whether childBounds needs to be recomputed to be valid.

    if ( assert ) {
      // for assertions later to ensure that we are using the same Bounds2 copies as before
      this._originalBounds = this._bounds;
      this._originalLocalBounds = this._localBounds;
      this._originalSelfBounds = this._selfBounds;
      this._originalChildBounds = this._childBounds;
    }

    // @public (scenery-internal) {Object} - Where rendering-specific settings are stored. They are generally modified
    // internally, so there is no ES5 setter for hints.
    this._hints = {
      // {number} - What type of renderer should be forced for this node. Uses the internal bitmask structure declared
      //            in scenery.js and Renderer.js.
      renderer: DEFAULT_OPTIONS.renderer === null ? 0 : Renderer.fromName( DEFAULT_OPTIONS.renderer ),

      // {boolean} - Whether it is anticipated that opacity will be switched on. If so, having this set to true will
      //             make switching back-and-forth between opacity:1 and other opacities much faster.
      usesOpacity: DEFAULT_OPTIONS.usesOpacity,

      // {boolean} - Whether layers should be split before and after this node.
      layerSplit: DEFAULT_OPTIONS.layerSplit,

      // {boolean} - Whether this node and its subtree should handle transforms by using a CSS transform of a div.
      cssTransform: DEFAULT_OPTIONS.cssTransform,

      // {boolean} - When rendered as Canvas, whether we should use full (device) resolution on retina-like devices.
      //             TODO: ensure that this is working? 0.2 may have caused a regression.
      fullResolution: false,

      // {boolean} - Whether SVG (or other) content should be excluded from the DOM tree when invisible
      //             (instead of just being hidden)
      excludeInvisible: DEFAULT_OPTIONS.excludeInvisible,

      // {number|null} - If non-null, a multiplier to the detected pixel-to-pixel scaling of the WebGL Canvas
      webglScale: DEFAULT_OPTIONS.webglScale,

      // {boolean} - If true, Scenery will not fit any blocks that contain drawables attached to Nodes underneath this
      //             node's subtree. This will typically prevent Scenery from triggering bounds computation for this
      //             sub-tree, and movement of this node or its descendants will never trigger the refitting of a block.
      preventFit: DEFAULT_OPTIONS.preventFit
    };

    // @public (scenery-internal) {number} - A bitmask which specifies which renderers this node (and only this node,
    // not its subtree) supports.
    this._rendererBitmask = Renderer.bitmaskNodeDefault;

    // @public (scenery-internal) {RendererSummary} - A bitmask-like summary of what renderers and options are supported
    // by this node and all of its descendants
    this._rendererSummary = new RendererSummary( this );

    /*
     * So we can traverse only the subtrees that require bounds validation for events firing.
     * This is a sum of the number of events requiring bounds validation on this Node, plus the number of children whose
     * count is non-zero.
     * NOTE: this means that if A has a child B, and B has a boundsEventCount of 5, it only contributes 1 to A's count.
     * This allows us to have changes localized (increasing B's count won't change A or any of A's ancestors), and
     * guarantees that we will know whether a subtree has bounds listeners. Also important: decreasing B's
     * boundsEventCount down to 0 will allow A to decrease its count by 1, without having to check its other children
     * (if we were just using a boolean value, this operation would require A to check if any OTHER children besides
     * B had bounds listeners)
     */
    this._boundsEventCount = 0; // @private {number}
    // @private {number} - This signals that we can validateBounds() on this subtree and we don't have to traverse further
    this._boundsEventSelfCount = 0;

    // Initialize sub-components
    this._picker = new Picker( this );

    // Mix in accessibility
    this.initializeAccessibility();

    // Make sure Node's prototype dispose() is called when dispose() is called, and make sure that it isn't called
    // more than once. See https://github.com/phetsims/scenery/issues/601.
    // @private {boolean}
    this._isDisposed = false;
    if ( assert ) {
      // Wrap the prototype dispose method with a check. NOTE: We will not catch devious cases where the dispose() is
      // overridden after the Node constructor (which may happen).
      var protoDispose = this.dispose;
      this.dispose = function() {
        assert && assert( !this._isDisposed, 'This Node has already been disposed, and cannot be disposed again' );
        protoDispose.call( this );
        assert && assert( this._isDisposed, 'Node.dispose() call is missing from an overridden dispose method' );
      };
    }

    if ( options ) {
      this.mutate( options );
    }

    // Track allocation of nodes internally
    phetAllocation && phetAllocation( 'Node' );

  }

  scenery.register( 'Node', Node );

  inherit( Object, Node, extend( {
    /**
     * This is an array of property (setter) names for Node.mutate(), which are also used when creating nodes with
     * parameter objects.
     * @protected
     *
     * E.g. new scenery.Node( { x: 5, rotation: 20 } ) will create a Path, and apply setters in the order below
     * (node.x = 5; node.rotation = 20)
     *
     * Some special cases exist (for function names). new scenery.Node( { scale: 2 } ) will actually call
     * node.scale( 2 ).
     *
     * The order below is important! Don't change this without knowing the implications.
     *
     * NOTE: Translation-based mutators come before rotation/scale, since typically we think of their operations
     *       occuring "after" the rotation / scaling
     * NOTE: left/right/top/bottom/centerX/centerY are at the end, since they rely potentially on rotation / scaling
     *       changes of bounds that may happen beforehand
     */
    _mutatorKeys: NODE_OPTION_KEYS,

    /**
     * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
     *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
     *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
     * @public (scenery-internal)
     *
     * Should be overridden by subtypes.
     */
    drawableMarkFlags: [],

    /**
     * Inserts a child node at a specific index.
     * @public
     *
     * node.insertChild( 0, childNode ) will insert the child into the beginning of the children array (on the bottom
     * visually).
     *
     * node.insertChild( node.children.length, childNode ) is equivalent to node.addChild( childNode ), and appends it
     * to the end (top visually) of the children array. It is recommended to use node.addChild when possible.
     *
     * NOTE: overridden by Leaf for some subtypes
     *
     * @param {number} index - Index where the inserted child node will be after this operation.
     * @param {Node} node - The new child to insert.
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    insertChild: function( index, node ) {
      assert && assert( node !== null && node !== undefined, 'insertChild cannot insert a null/undefined child' );
      assert && assert( node instanceof Node,
        'addChild/insertChild requires the child to be a Node. Constructor: ' +
        ( node.constructor ? node.constructor.name : 'none' ) );
      assert && assert( !_.includes( this._children, node ), 'Parent already contains child' );
      assert && assert( node !== this, 'Cannot add self as a child' );
      assert && assert( node._parents !== null, 'Tried to insert a disposed child node?' );

      // needs to be early to prevent re-entrant children modifications
      this._picker.onInsertChild( node );
      this.changeBoundsEventCount( node._boundsEventCount > 0 ? 1 : 0 );
      this._rendererSummary.summaryChange( RendererSummary.bitmaskAll, node._rendererSummary.bitmask );

      node._parents.push( this );
      this._children.splice( index, 0, node );

      // If this added subtree contains accessible content, we need to notify any relevant displays
      if ( !node._rendererSummary.isNotAccessible() ) {
        this.onAccessibleAddChild( node );
      }

      node.invalidateBounds();

      // like calling this.invalidateBounds(), but we already marked all ancestors with dirty child bounds
      this._boundsDirty = true;

      this.trigger2( 'childInserted', node, index );

      if ( assertSlow ) { this._picker.audit(); }

      return this; // allow chaining
    },

    /**
     * Appends a child node to our list of children.
     * @public
     *
     * The new child node will be displayed in front (on top) of all of this node's other children.
     *
     * @param {Node} node
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    addChild: function( node ) {
      this.insertChild( this._children.length, node );

      return this; // allow chaining
    },

    /**
     * Removes a child node from our list of children, see http://phetsims.github.io/scenery/doc/#node-removeChild
     * Will fail an assertion if the node is not currently one of our children
     * @public
     *
     * @param {Node} node
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    removeChild: function( node ) {
      assert && assert( node && node instanceof Node, 'Need to call node.removeChild() with a Node.' );
      assert && assert( this.hasChild( node ), 'Attempted to removeChild with a node that was not a child.' );

      var indexOfChild = _.indexOf( this._children, node );

      this.removeChildWithIndex( node, indexOfChild );

      return this; // allow chaining
    },

    /**
     * Removes a child node at a specific index (node.children[ index ]) from our list of children.
     * Will fail if the index is out of bounds.
     * @public
     *
     * @param {number} index
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    removeChildAt: function( index ) {
      assert && assert( index >= 0 );
      assert && assert( index < this._children.length );

      var node = this._children[ index ];

      this.removeChildWithIndex( node, index );

      return this; // allow chaining
    },

    /**
     * Internal method for removing a node (always has the Node and index).
     * @private
     *
     * NOTE: overridden by Leaf for some subtypes
     *
     * @param {Node} node - The child node to remove from this node (it's parent)
     * @param {number} indexOfChild - Should satisfy this.children[ indexOfChild ] === node
     */
    removeChildWithIndex: function( node, indexOfChild ) {
      assert && assert( node && node instanceof Node, 'Need to call node.removeChildWithIndex() with a Node.' );
      assert && assert( this.hasChild( node ), 'Attempted to removeChild with a node that was not a child.' );
      assert && assert( this._children[ indexOfChild ] === node, 'Incorrect index for removeChildWithIndex' );
      assert && assert( node._parents !== null, 'Tried to remove a disposed child node?' );

      var indexOfParent = _.indexOf( node._parents, this );

      // If this added subtree contains accessible content, we need to notify any relevant displays
      // NOTE: Potentially removes bounds listeners here!
      if ( !node._rendererSummary.isNotAccessible() ) {
        this.onAccessibleRemoveChild( node );
      }

      // needs to be early to prevent re-entrant children modifications
      this._picker.onRemoveChild( node );
      this.changeBoundsEventCount( node._boundsEventCount > 0 ? -1 : 0 );
      this._rendererSummary.summaryChange( node._rendererSummary.bitmask, RendererSummary.bitmaskAll );

      node._parents.splice( indexOfParent, 1 );
      this._children.splice( indexOfChild, 1 );

      this.invalidateBounds();
      this._childBoundsDirty = true; // force recomputation of child bounds after removing a child

      this.trigger2( 'childRemoved', node, indexOfChild );

      if ( assertSlow ) { this._picker.audit(); }
    },

    /**
     * Removes all children from this Node.
     * @public
     *
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    removeAllChildren: function() {
      this.setChildren( [] );

      return this; // allow chaining
    },

    /**
     * Sets the children of the Node to be equivalent to the passed-in array of Nodes. Does this by removing all current
     * children, and adding in children from the array.
     * @public
     *
     * NOTE: Overridden in LayoutBox
     *
     * @param {Array.<Node>} children
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setChildren: function( children ) {
      if ( this._children !== children ) {
        // remove all children in a way where we don't have to copy the child array for safety
        while ( this._children.length ) {
          this.removeChild( this._children[ this._children.length - 1 ] );
        }

        var len = children.length;
        for ( var i = 0; i < len; i++ ) {
          this.addChild( children[ i ] );
        }
      }

      return this; // allow chaining
    },
    set children( value ) { this.setChildren( value ); },

    /**
     * Returns a defensive copy of the array of direct children of this node, ordered by what is in front (nodes at
     * the end of the arry are in front of nodes at the start).
     * @public
     *
     * Making changes to the returned result will not affect this node's children.
     *
     * @returns {Array.<Node>}
     */
    getChildren: function() {
      // TODO: ensure we are not triggering this in Scenery code when not necessary!
      return this._children.slice( 0 ); // create a defensive copy
    },
    get children() { return this.getChildren(); },

    /**
     * Returns a count of children, without needing to make a defensive copy.
     * @public
     *
     * @returns {number}
     */
    getChildrenCount: function() {
      return this._children.length;
    },

    /**
     * Returns a defensive copy of our parents. This is an array of parent nodes that is returned in no particular
     * order (as order is not important here).
     * @public
     *
     * NOTE: Modifying the returned array will not in any way modify this node's parents.
     *
     * @returns {Array.<Node>}
     */
    getParents: function() {
      return this._parents.slice( 0 ); // create a defensive copy
    },
    get parents() { return this.getParents(); },

    /**
     * Returns a single parent if it exists, otherwise null (no parents), or an assertion failure (multiple parents).
     * @public
     *
     * @returns {Node|null}
     */
    getParent: function() {
      assert && assert( this._parents.length <= 1, 'Cannot call getParent on a node with multiple parents' );
      return this._parents.length ? this._parents[ 0 ] : null;
    },
    get parent() { return this.getParent(); },

    /**
     * Gets the child at a specific index into the children array.
     * @public
     *
     * @param {number} index
     * @returns {Node}
     */
    getChildAt: function( index ) {
      return this._children[ index ];
    },

    /**
     * Finds the index of a parent Node in the parents array.
     * @public
     *
     * @param {Node} parent - Should be a parent of this node.
     * @returns {number} - An index such that this.parents[ index ] === parent
     */
    indexOfParent: function( parent ) {
      return _.indexOf( this._parents, parent );
    },

    /**
     * Finds the index of a child Node in the children array.
     * @public
     *
     * @param {Node} child - Should be a child of this node.
     * @returns {number} - An index such that this.children[ index ] === child
     */
    indexOfChild: function( child ) {
      return _.indexOf( this._children, child );
    },

    /**
     * Moves this node to the front (end) of all of its parents children array.
     * @public
     *
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    moveToFront: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.moveChildToFront( self );
      } );

      return this; // allow chaining
    },

    /**
     * Moves one of our children to the front (end) of our children array.
     * @public
     *
     * @param {Node} child - Our child to move to the front.
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    moveChildToFront: function( child ) {
      if ( this.indexOfChild( child ) !== this._children.length - 1 ) {
        this.removeChild( child );
        this.addChild( child );
      }

      return this; // allow chaining
    },

    /**
     * Moves this node to the back (front) of all of its parents children array.
     * @public
     *
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    moveToBack: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.moveChildToBack( self );
      } );

      return this; // allow chaining
    },

    /**
     * Moves one of our children to the back (front) of our children array.
     * @public
     *
     * @param {Node} child - Our child to move to the back.
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    moveChildToBack: function( child ) {
      if ( this.indexOfChild( child ) !== 0 ) {
        this.removeChild( child );
        this.insertChild( 0, child );
      }

      return this; // allow chaining
    },

    /**
     * Removes this node from all of its parents.
     * @public
     *
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    detach: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.removeChild( self );
      } );

      return this; // allow chaining
    },

    /**
     * Update our event count, usually by 1 or -1. See documentation on _boundsEventCount in constructor.
     * @private
     *
     * @param {number} n - How to increment/decrement the bounds event listener count
     */
    changeBoundsEventCount: function( n ) {
      if ( n !== 0 ) {
        var zeroBefore = this._boundsEventCount === 0;

        this._boundsEventCount += n;
        assert && assert( this._boundsEventCount >= 0, 'subtree bounds event count should be guaranteed to be >= 0' );

        var zeroAfter = this._boundsEventCount === 0;

        if ( zeroBefore !== zeroAfter ) {
          // parents will only have their count
          var parentDelta = zeroBefore ? 1 : -1;

          var len = this._parents.length;
          for ( var i = 0; i < len; i++ ) {
            this._parents[ i ].changeBoundsEventCount( parentDelta );
          }
        }
      }
    },

    /**
     * Ensures that the cached _selfBounds of this node is accurate. Returns true if any sort of dirty flag was set
     * before this was called.
     * @public
     *
     * @returns {boolean} - Was the self-bounds potentially updated?
     */
    validateSelfBounds: function() {
      // validate bounds of ourself if necessary
      if ( this._selfBoundsDirty ) {
        // Rely on an overloadable method to accomplish computing our self bounds. This should update
        // this._selfBounds itself, returning whether it was actually changed. If it didn't change, we don't want to
        // send a 'selfBounds' event.
        var didSelfBoundsChange = this.updateSelfBounds();
        this._selfBoundsDirty = false;

        if ( didSelfBoundsChange ) {
          this.trigger0( 'selfBounds' );
        }

        return true;
      }

      return false;
    },

    /**
     * Ensures that cached bounds stored on this node (and all children) are accurate. Returns true if any sort of dirty
     * flag was set before this was called.
     * @public
     *
     * @returns {boolean} - Was something potentially updated?
     */
    validateBounds: function() {
      var self = this;
      var i;
      var notificationThreshold = 1e-13;

      var wasDirtyBefore = this.validateSelfBounds();

      // validate bounds of children if necessary
      if ( this._childBoundsDirty ) {
        wasDirtyBefore = true;

        // have each child validate their own bounds
        i = this._children.length;
        while ( i-- ) {
          this._children[ i ].validateBounds();
        }

        // and recompute our _childBounds
        var oldChildBounds = scratchBounds2.set( this._childBounds ); // store old value in a temporary Bounds2
        this._childBounds.set( Bounds2.NOTHING ); // initialize to a value that can be unioned with includeBounds()

        i = this._children.length;
        while ( i-- ) {
          this._childBounds.includeBounds( this._children[ i ]._bounds );
        }

        // run this before firing the event
        this._childBoundsDirty = false;

        if ( !this._childBounds.equals( oldChildBounds ) ) {
          // notifies only on an actual change
          if ( !this._childBounds.equalsEpsilon( oldChildBounds, notificationThreshold ) ) {
            this.trigger0( 'childBounds' );
          }
        }
      }

      if ( this._localBoundsDirty && !this._localBoundsOverridden ) {
        wasDirtyBefore = true;

        this._localBoundsDirty = false; // we only need this to set local bounds as dirty

        var oldLocalBounds = scratchBounds2.set( this._localBounds ); // store old value in a temporary Bounds2

        // local bounds are a union between our self bounds and child bounds
        this._localBounds.set( this._selfBounds ).includeBounds( this._childBounds );

        // apply clipping to the bounds if we have a clip area (all done in the local coordinate frame)
        if ( this.hasClipArea() ) {
          this._localBounds.constrainBounds( this._clipArea.bounds );
        }

        if ( !this._localBounds.equals( oldLocalBounds ) ) {
          if ( !this._localBounds.equalsEpsilon( oldLocalBounds, notificationThreshold ) ) {
            this.trigger0( 'localBounds' );
          }

          // sanity check
          this._boundsDirty = true;
        }

        // adjust our transform to match maximum bounds if necessary on a local bounds change
        if ( this._maxWidth !== null || this._maxHeight !== null ) {
          this.updateMaxDimension( this._localBounds );
        }
      }

      // TODO: layout here?

      if ( this._boundsDirty ) {
        wasDirtyBefore = true;

        // run this before firing the event
        this._boundsDirty = false;

        var oldBounds = scratchBounds2.set( this._bounds ); // store old value in a temporary Bounds2

        // no need to do the more expensive bounds transformation if we are still axis-aligned
        if ( this._transformBounds && !this._transform.getMatrix().isAxisAligned() ) {
          // mutates the matrix and bounds during recursion

          var matrix = scratchMatrix3.set( this.getMatrix() ); // calls below mutate this matrix
          this._bounds.set( Bounds2.NOTHING );
          // Include each painted self individually, transformed with the exact transform matrix.
          // This is expensive, as we have to do 2 matrix transforms for every descendant.
          this._includeTransformedSubtreeBounds( matrix, this._bounds ); // self and children

          if ( this.hasClipArea() ) {
            this._bounds.constrainBounds( this._clipArea.getBoundsWithTransform( matrix ) );
          }
        }
        else {
          // converts local to parent bounds. mutable methods used to minimize number of created bounds instances
          // (we create one so we don't change references to the old one)
          this._bounds.set( this._localBounds );
          this.transformBoundsFromLocalToParent( this._bounds );
        }

        if ( !this._bounds.equals( oldBounds ) ) {
          // if we have a bounds change, we need to invalidate our parents so they can be recomputed
          i = this._parents.length;
          while ( i-- ) {
            this._parents[ i ].invalidateBounds();
          }

          // TODO: consider changing to parameter object (that may be a problem for the GC overhead)
          if ( !this._bounds.equalsEpsilon( oldBounds, notificationThreshold ) ) {
            this.trigger0( 'bounds' );
          }
        }
      }

      // if there were side-effects, run the validation again until we are clean
      if ( this._childBoundsDirty || this._boundsDirty ) {
        // TODO: if there are side-effects in listeners, this could overflow the stack. we should report an error
        // instead of locking up
        this.validateBounds();
      }

      if ( assert ) {
        assert( this._originalBounds === this._bounds, 'Reference for _bounds changed!' );
        assert( this._originalLocalBounds === this._localBounds, 'Reference for _localBounds changed!' );
        assert( this._originalSelfBounds === this._selfBounds, 'Reference for _selfBounds changed!' );
        assert( this._originalChildBounds === this._childBounds, 'Reference for _childBounds changed!' );
      }

      // double-check that all of our bounds handling has been accurate
      if ( assertSlow ) {
        // new scope for safety
        (function() {
          var epsilon = 0.000001;

          var childBounds = Bounds2.NOTHING.copy();
          _.each( self._children, function( child ) { childBounds.includeBounds( child._bounds ); } );

          var localBounds = self._selfBounds.union( childBounds );

          if ( self.hasClipArea() ) {
            localBounds = localBounds.intersection( self._clipArea.bounds );
          }

          var fullBounds = self.localToParentBounds( localBounds );

          assertSlow && assertSlow( self._childBounds.equalsEpsilon( childBounds, epsilon ),
            'Child bounds mismatch after validateBounds: ' +
            self._childBounds.toString() + ', expected: ' + childBounds.toString() );
          assertSlow && assertSlow( self._localBoundsOverridden ||
                                    self._transformBounds ||
                                    self._bounds.equalsEpsilon( fullBounds, epsilon ) ||
                                    self._bounds.equalsEpsilon( fullBounds, epsilon ),
            'Bounds mismatch after validateBounds: ' + self._bounds.toString() +
            ', expected: ' + fullBounds.toString() );
        })();
      }

      return wasDirtyBefore; // whether any dirty flags were set
    },

    /**
     * Recursion for accurate transformed bounds handling. Mutates bounds with the added bounds.
     * Mutates the matrix (parameter), but mutates it back to the starting point (within floating-point error).
     * @private
     *
     * @param {Matrix3} matrix
     * @param {Bounds2} bounds
     */
    _includeTransformedSubtreeBounds: function( matrix, bounds ) {
      if ( !this.selfBounds.isEmpty() ) {
        bounds.includeBounds( this.getTransformedSelfBounds( matrix ) );
      }

      var numChildren = this._children.length;
      for ( var i = 0; i < numChildren; i++ ) {
        var child = this._children[ i ];

        matrix.multiplyMatrix( child._transform.getMatrix() );
        child._includeTransformedSubtreeBounds( matrix, bounds );
        matrix.multiplyMatrix( child._transform.getInverse() );
      }

      return bounds;
    },

    /**
     * Traverses this subtree and validates bounds only for subtrees that have bounds listeners (trying to exclude as
     * much as possible for performance). This is done so that we can do the minimum bounds validation to prevent any
     * bounds listeners from being triggered in further validateBounds() calls without other Node changes being done.
     * This is required for Display's atomic (non-reentrant) updateDisplay(), so that we don't accidentally trigger
     * bounds listeners while computing bounds during updateDisplay().
     * @public (scenery-internal)
     *
     * NOTE: this should pass by (ignore) any overridden localBounds, to trigger listeners below.
     */
    validateWatchedBounds: function() {
      // Since a bounds listener on one of the roots could invalidate bounds on the other, we need to keep running this
      // until they are all clean. Otherwise, side-effects could occur from bounds validations
      // TODO: consider a way to prevent infinite loops here that occur due to bounds listeners triggering cycles
      while ( this.watchedBoundsScan() ) {
        // do nothing
      }
    },

    /**
     * Recursive function for validateWatchedBounds. Returned whether any validateBounds() returned true (means we have
     * to traverse again)
     * @public (scenery-internal)
     *
     * @returns {boolean} - Whether there could have been any changes.
     */
    watchedBoundsScan: function() {
      if ( this._boundsEventSelfCount !== 0 ) {
        // we are a root that should be validated. return whether we updated anything
        return this.validateBounds();
      }
      else if ( this._boundsEventCount > 0 && this._childBoundsDirty ) {
        // descendants have watched bounds, traverse!
        var changed = false;
        var numChildren = this._children.length;
        for ( var i = 0; i < numChildren; i++ ) {
          changed = this._children[ i ].watchedBoundsScan() || changed;
        }
        return changed;
      }
      else {
        // if _boundsEventCount is zero, no bounds are watched below us (don't traverse), and it wasn't changed
        return false;
      }
    },

    /**
     * Marks the bounds of this node as invalid, so they are recomputed before being accessed again.
     * @public
     */
    invalidateBounds: function() {
      // TODO: sometimes we won't need to invalidate local bounds! it's not too much of a hassle though?
      this._boundsDirty = true;
      this._localBoundsDirty = true;

      // and set flags for all ancestors
      var i = this._parents.length;
      while ( i-- ) {
        this._parents[ i ].invalidateChildBounds();
      }
    },

    /**
     * Recursively tag all ancestors with _childBoundsDirty
     * @public (scenery-internal)
     */
    invalidateChildBounds: function() {
      // don't bother updating if we've already been tagged
      if ( !this._childBoundsDirty ) {
        this._childBoundsDirty = true;
        this._localBoundsDirty = true;
        var i = this._parents.length;
        while ( i-- ) {
          this._parents[ i ].invalidateChildBounds();
        }
      }
    },

    /**
     * Should be called to notify that our selfBounds needs to change to this new value.
     * @public
     *
     * @param {Bounds2} [newSelfBounds]
     */
    invalidateSelf: function( newSelfBounds ) {
      assert && assert( newSelfBounds === undefined || newSelfBounds instanceof Bounds2,
        'invalidateSelf\'s newSelfBounds, if proided, needs to be Bounds2' );

      // If no self bounds are provided, rely on the bounds validation to trigger computation (using updateSelfBounds()).
      if ( !newSelfBounds ) {
        this._selfBoundsDirty = true;
        this.invalidateBounds();
        this._picker.onSelfBoundsDirty();
      }
      // Otherwise, set the self bounds directly
      else {
        assert && assert( newSelfBounds.isEmpty() || newSelfBounds.isFinite(), 'Bounds must be empty or finite in invalidateSelf' );

        // Don't recompute the self bounds
        this._selfBoundsDirty = false;

        // if these bounds are different than current self bounds
        if ( !this._selfBounds.equals( newSelfBounds ) ) {
          // set repaint flags
          this.invalidateBounds();
          this._picker.onSelfBoundsDirty();

          // record the new bounds
          this._selfBounds.set( newSelfBounds );

          // fire the event immediately
          this.trigger0( 'selfBounds' );
        }
      }

      if ( assertSlow ) { this._picker.audit(); }
    },

    /**
     * Meant to be overridden by Node sub-types to compute self bounds (if invalidateSelf() with no argments was called).
     * @protected
     *
     * @returns {boolean} - Whether the self bounds changed.
     */
    updateSelfBounds: function() {
      // The Node implementation (un-overridden) will never change the self bounds (always NOTHING).
      assert && assert( this._selfBounds.equals( Bounds2.NOTHING ) );
      return false;
    },

    /**
     * Returns whether a Node is a child of this node.
     * @public
     *
     * @param {Node} potentialChild
     * @returns {boolean} - Whether potentialChild is actually our child.
     */
    hasChild: function( potentialChild ) {
      assert && assert( potentialChild && ( potentialChild instanceof Node ), 'hasChild needs to be called with a Node' );
      var isOurChild = _.includes( this._children, potentialChild );
      assert && assert( isOurChild === _.includes( potentialChild._parents, this ), 'child-parent reference should match parent-child reference' );
      return isOurChild;
    },

    /**
     * Returns our selfBounds (the bounds for this Node's content in the local coordinates, excluding anything from our
     * children and descendants).
     * @public
     *
     * NOTE: Do NOT mutate the returned value!
     *
     * @returns {Bounds2}
     */
    getSelfBounds: function() {
      this.validateSelfBounds();
      return this._selfBounds;
    },
    get selfBounds() { return this.getSelfBounds(); },

    /**
     * Returns a bounding box that should contain all self content in the local coordinate frame (our normal self bounds
     * aren't guaranteed this for Text, etc.)
     * @public
     *
     * Override this to provide different behavior.
     *
     * @returns {Bounds2}
     */
    getSafeSelfBounds: function() {
      this.validateSelfBounds();
      return this._selfBounds;
    },

    /**
     * Returns the bounding box that should contain all content of our children in our local coordinate frame. Does not
     * include our "self" bounds.
     * @public
     *
     * NOTE: Do NOT mutate the returned value!
     *
     * @returns {Bounds2}
     */
    getChildBounds: function() {
      this.validateBounds();
      return this._childBounds;
    },
    get childBounds() { return this.getChildBounds(); },

    /**
     * Returns the bounding box that should contain all content of our children AND our self in our local coordinate
     * frame.
     * @public
     *
     * NOTE: Do NOT mutate the returned value!
     *
     * @returns {Bounds2}
     */
    getLocalBounds: function() {
      this.validateBounds();
      return this._localBounds;
    },
    get localBounds() { return this.getLocalBounds(); },

    /**
     * Allows overriding the value of localBounds (and thus changing things like 'bounds' that depend on localBounds).
     * If it's set to a non-null value, that value will always be used for localBounds until this function is called
     * again. To revert to having Scenery compute the localBounds, set this to null.
     * @public
     *
     * @param {Bounds2|null} localBounds
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setLocalBounds: function( localBounds ) {
      assert && assert( localBounds === null || localBounds instanceof Bounds2, 'localBounds override should be set to either null or a Bounds2' );

      if ( localBounds === null ) {
        // we can just ignore this if we weren't actually overriding local bounds before
        if ( this._localBoundsOverridden ) {
          this._localBoundsOverridden = false;
          this.trigger1( 'localBoundsOverride', false );
          this.invalidateBounds();
        }
      }
      else {
        // just an instance check for now. consider equals() in the future depending on cost
        var changed = !localBounds.equals( this._localBounds ) || !this._localBoundsOverridden;

        if ( changed ) {
          this._localBounds.set( localBounds );
        }

        if ( !this._localBoundsOverridden ) {
          this._localBoundsOverridden = true; // NOTE: has to be done before invalidating bounds, since this disables localBounds computation
          this.trigger1( 'localBoundsOverride', true );
        }

        if ( changed ) {
          this.invalidateBounds();
        }
      }

      return this; // allow chaining
    },
    set localBounds( value ) { return this.setLocalBounds( value ); },

    /**
     * Meant to be overridden in sub-types that have more accurate bounds determination for when we are transformed.
     * Usually rotation is significant here, so that transformed bounds for non-rectangular shapes will be different.
     * @public
     *
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    getTransformedSelfBounds: function( matrix ) {
      this.validateBounds(); // TODO: consider more fine-grained validation?
      // assume that we take up the entire rectangular bounds.
      return this._selfBounds.transformed( matrix );
    },

    /**
     * Sets the flag that determines whether we will require more accurate (and expensive) bounds computation for this
     * node's transform.
     * @public
     *
     * If set to false (default), Scenery will get the bounds of content, and then if rotated will determine the on-axis
     * bounds that completely cover the rotated bounds (potentially larger than actual content).
     * If set to true, Scenery will try to get the bounds of the actual rotated/transformed content.
     *
     * A good example of when this is necessary is if there are a bunch of nested children that each have pi/4 rotations.
     *
     * @param {boolean} transformBounds - Whether accurate transform bounds should be used.
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setTransformBounds: function( transformBounds ) {
      assert && assert( typeof transformBounds === 'boolean', 'transformBounds should be boolean' );

      if ( this._transformBounds !== transformBounds ) {
        this._transformBounds = transformBounds;

        this.invalidateBounds();
      }

      return this; // allow chaining
    },
    set transformBounds( value ) { return this.setTransformBounds( value ); },

    /**
     * Returns whether accurate transformation bounds are used in bounds computation (see setTransformBounds).
     * @public
     *
     * @returns {boolean}
     */
    getTransformBounds: function() {
      return this._transformBounds;
    },
    get transformBounds() { return this.getTransformBounds(); },

    /**
     * Returns the bounding box of this Node and all of its sub-trees (in the "parent" coordinate frame).
     *
     * NOTE: Do NOT mutate the returned value!
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {Bounds2}
     */
    getBounds: function() {
      this.validateBounds();
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },

    /**
     * Like getLocalBounds() in the "local" coordinate frame, but includes only visible nodes.
     * @public
     *
     * @returns {Bounds2}
     */
    getVisibleLocalBounds: function() {
      // defensive copy, since we use mutable modifications below
      var bounds = this.selfBounds.copy();

      var i = this._children.length;
      while ( i-- ) {
        var child = this._children[ i ];
        if ( child.isVisible() ) {
          bounds.includeBounds( child.getVisibleBounds() );
        }
      }

      assert && assert( bounds.isFinite() || bounds.isEmpty(), 'Visible bounds should not be infinite' );
      return bounds;
    },
    get visibleLocalBounds() { return this.getVisibleLocalBounds(); },

    /**
     * Like getBounds() in the "parent" coordinate frame, but includes only visible nodes
     * @public
     *
     * @returns {Bounds2}
     */
    getVisibleBounds: function() {
      return this.getVisibleLocalBounds().transform( this.getMatrix() );
    },
    get visibleBounds() { return this.getVisibleBounds(); },

    /**
     * Hit-tests what is under the pointer, and returns a {Trail} to that node (or null if there is no matching node).
     * @public
     *
     * @param {Pointer} pointer
     * @returns {Trail|null}
     */
    trailUnderPointer: function( pointer ) {
      return this._picker.hitTest( pointer.point, pointer.isMouse, pointer.isTouch || pointer.isPen );
    },

    /**
     * Hit tests the given point, optionally using mouse and touch areas.
     * @public
     *
     * @param {Vector2} point - the point to hit test
     * @param {boolean} isMouse - true if mouse areas should be hit
     * @param {boolean} isTouch - true if touch areas should be hit
     *
     * @returns {Trail|null}
     */
    hitTest: function( point, isMouse, isTouch ) {
      return this._picker.hitTest( point, isMouse, isTouch );
    },

    /*
     * Return a trail to the top node (if any, otherwise null) whose self-rendered area contains the
     * point (in parent coordinates).
     * @public
     *
     * @param {Vector2} point
     * @returns {Trail|null}
     */
    trailUnderPoint: function( point ) {
      assert && assert( point, 'trailUnderPointer requires a point' );

      return this._picker.hitTest( point, false, false );
    },

    /**
     * Returns whether a point (in parent coordinates) is contained in this node's sub-tree.
     * @public
     *
     * @param {Vector2} point
     * @returns {boolean} - Whether the point is contained.
     */
    containsPoint: function( point ) {
      return this.trailUnderPoint( point ) !== null;
    },

    /**
     * Override this for computation of whether a point is inside our self content (defaults to selfBounds check).
     * @protected
     *
     * @param {Vector2} point - Considered to be in the local coordinate frame
     * @returns {boolean}
     */
    containsPointSelf: function( point ) {
      // if self bounds are not null default to checking self bounds
      return this.selfBounds.containsPoint( point );
    },

    /**
     * Returns whether this node's selfBounds is intersected by the specified bounds.
     * @public
     *
     * @param {Bounds2} bounds - Bounds to test, assumed to be in the local coordinate frame.
     * @returns {boolean}
     */
    intersectsBoundsSelf: function( bounds ) {
      // if self bounds are not null, child should override this
      return this.selfBounds.intersectsBounds( bounds );
    },

    /**
     * Whether this Node itself is painted (displays something itself). Meant to be overridden.
     * @public
     *
     * @returns {boolean}
     */
    isPainted: function() {
      // Normal nodes don't render anything
      return false;
    },

    /**
     * Whether this Node's selfBounds are considered to be valid (always containing the displayed self content
     * of this node). Meant to be overridden in subtypes when this can change (e.g. Text).
     * @public
     *
     * If this value would potentially change, please trigger the event 'selfBoundsValid'.
     *
     * @returns {boolean}
     */
    areSelfBoundsValid: function() {
      return true;
    },

    /**
     * Returns whether this node has any parents at all.
     * @public
     *
     * @returns {boolean}
     */
    hasParent: function() {
      return this._parents.length !== 0;
    },

    /**
     * Returns whether this node has any children at all.
     * @public
     *
     * @returns {boolean}
     */
    hasChildren: function() {
      return this._children.length > 0;
    },

    /**
     * Calls the callback on nodes recursively in a depth-first manner.
     * @public
     *
     * @param {Function} callback
     */
    walkDepthFirst: function( callback ) {
      callback( this );
      var length = this._children.length;
      for ( var i = 0; i < length; i++ ) {
        this._children[ i ].walkDepthFirst( callback );
      }
    },

    /**
     * Returns a list of child nodes that intersect the passed in bounds.
     * @public
     *
     * @param {Bounds2} bounds - In the local coordinate frame
     * @returns {Array.<Node>}
     */
    getChildrenWithinBounds: function( bounds ) {
      var result = [];
      var length = this._children.length;
      for ( var i = 0; i < length; i++ ) {
        var child = this._children[ i ];
        if ( !child._bounds.intersection( bounds ).isEmpty() ) {
          result.push( child );
        }
      }
      return result;
    },

    /**
     * Adds an input listener.
     * @public
     *
     * @param {Object} listener
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    addInputListener: function( listener ) {
      assert && assert( !_.includes( this._inputListeners, listener ), 'Input listener already registered on this Node' );

      // don't allow listeners to be added multiple times
      if ( !_.includes( this._inputListeners, listener ) ) {
        this._inputListeners.push( listener );
        this._picker.onAddInputListener();
        if ( assertSlow ) { this._picker.audit(); }
      }
      return this;
    },

    /**
     * Removes an input listener that was previously added with addInputListener.
     * @public
     *
     * @param {Object} listener
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    removeInputListener: function( listener ) {
      // ensure the listener is in our list
      assert && assert( _.includes( this._inputListeners, listener ) );

      this._inputListeners.splice( _.indexOf( this._inputListeners, listener ), 1 );
      this._picker.onRemoveInputListener();
      if ( assertSlow ) { this._picker.audit(); }

      return this;
    },

    /**
     * Returns whether this input listener is currently listening to this node.
     * @public
     *
     * More efficient than checking node.inputListeners, as that includes a defensive copy.
     *
     * @param {Object} listener
     * @returns {boolean}
     */
    hasInputListener: function( listener ) {
      for ( var i = 0; i < this._inputListeners.length; i++ ) {
        if ( this._inputListeners[ i ] === listener ) {
          return true;
        }
      }
      return false;
    },

    /**
     * Interrupts all input listeners that are attached to this node.
     * @public
     *
     * @returns {Node} - For chaining
     */
    interruptInput: function() {
      var listenersCopy = this.inputListeners;

      for ( var i = 0; i < listenersCopy.length; i++ ) {
        var listener = listenersCopy[ i ];

        listener.interrupt && listener.interrupt(); // TODO: get rid of the event?
      }

      return this;
    },

    /**
     * Interrupts all input listeners that are attached to either this node, or a descendant node.
     * @public
     *
     * @returns {Node} - For chaining
     */
    interruptSubtreeInput: function() {
      this.interruptInput();

      var children = this._children.slice();
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].interruptSubtreeInput();
      }

      return this;
    },

    /**
     * Called when the node is added as a child to this node AND the node's subtree contains accessible content.
     * We need to notify all Displays that can see this change, so that they can update the AccessibleInstance tree.
     * @private
     *
     * @param {Node} node
     */
    onAccessibleAddChild: function( node ) {
      // All trails starting with nodes that have display roots, and ending with the added node.
      var trails = node.getTrails( hasRootedDisplayPredicate );
      for ( var i = 0; i < trails.length; i++ ) {
        var trail = trails[ i ];

        // Ignore trails where this node is not the child node's parent. See https://github.com/phetsims/scenery/issues/491
        if ( trail.nodeFromTop( 1 ) !== this ) {
          continue;
        }

        // Notify each Display of the trail
        var rootedDisplays = trail.rootNode()._rootedDisplays;
        for ( var j = 0; j < rootedDisplays.length; j++ ) {
          rootedDisplays[ j ].addAccessibleTrail( trail );
        }
      }
    },

    /**
     * Called when the node is removed as a child from this node AND the node's subtree contains accessible content.
     * We need to notify all Displays that can see this change, so that they can update the AccessibleInstance tree.
     * @private
     *
     * @param {Node} node
     */
    onAccessibleRemoveChild: function( node ) {
      // All trails starting with nodes that have display roots, and ending with the removed node.
      var trails = node.getTrails( hasRootedDisplayPredicate );
      for ( var i = 0; i < trails.length; i++ ) {
        var trail = trails[ i ];

        // Ignore trails where this node is not the child node's parent. See https://github.com/phetsims/scenery/issues/491
        if ( trail.nodeFromTop( 1 ) !== this ) {
          continue;
        }

        // Notify each Display of the trail
        var rootedDisplays = trail.rootNode()._rootedDisplays;
        for ( var j = 0; j < rootedDisplays.length; j++ ) {
          rootedDisplays[ j ].removeAccessibleTrail( trail );
        }
      }
    },

    /**
     * Changes the transform of this node by adding a transform. The default "appends" the transform, so that it will
     * appear to happen to the node before the rest of the transform would apply, but if "prepended", the rest of the
     * transform would apply first.
     * @public
     *
     * As an example, if a Node is centered at (0,0) and scaled by 2:
     * translate( 100, 0 ) would cause the center of the node (in the parent coordinate frame) to be at (200,0).
     * translate( 100, 0, true ) would cause the center of the node (in the parent coordinate frame) to be at (100,0).
     *
     * Allowed call signatures:
     * translate( x {number}, y {number} )
     * translate( x {number}, y {number}, prependInstead {boolean} )
     * translate( vector {Vector2} )
     * translate( vector {Vector2}, prependInstead {boolean} )
     *
     * @param {number} x - The x coordinate
     * @param {number} y - The y coordinate
     * @param {Vector2} vector - If present, the y coordinate (required if x is a number)
     * @param {boolean} [prependInstead] - Whether the transform should be prepended (defaults to false)
     */
    translate: function( x, y, prependInstead ) {
      if ( typeof x === 'number' ) {
        // translate( x, y, prependInstead )
        assert && assert( typeof x === 'number' && isFinite( x ), 'x should be a finite number' );
        assert && assert( typeof y === 'number' && isFinite( y ), 'y should be a finite number' );
        assert && assert( prependInstead === undefined || typeof prependInstead === 'boolean', 'If provided, prependInstead should be boolean' );

        if ( !x && !y ) { return; } // bail out if both are zero
        if ( prependInstead ) {
          this.prependTranslation( x, y );
        }
        else {
          this.appendMatrix( scratchMatrix3.setToTranslation( x, y ) );
        }
      }
      else {
        // translate( vector, prependInstead )
        var vector = x;
        assert && assert( vector instanceof Vector2 && vector.isFinite(), 'translation should be a finite Vector2 if not finite numbers' );
        if ( !vector.x && !vector.y ) { return; } // bail out if both are zero
        this.translate( vector.x, vector.y, y ); // forward to full version
      }
    },

    /**
     * Scales the node's transform. The default "appends" the transform, so that it will
     * appear to happen to the node before the rest of the transform would apply, but if "prepended", the rest of the
     * transform would apply first.
     * @public
     *
     * As an example, if a Node is translated to (100,0):
     * scale( 2 ) will leave the node translated at (100,0), but it will be twice as big around its origin at that location.
     * scale( 2, true ) will shift the node to (200,0).
     *
     * Allowed call signatures:
     * scale( s {number|Vector2}, [prependInstead] {boolean} )
     * scale( x {number}, y {number}, [prependInstead] {boolean} )
     *
     * @param {number} s - Scales in both the X and Y directions
     * @param {number} x - Scales in the X direction
     * @param {number} y - Scales in the Y direction
     * @param {boolean} [prependInstead] - Whether the transform should be prepended (defaults to false)
     */
    scale: function( x, y, prependInstead ) {
      if ( typeof x === 'number' ) {
        assert && assert( isFinite( x ), 'scales should be finite' );
        if ( y === undefined || typeof y === 'boolean' ) {
          // scale( scale, [prependInstead] )
          this.scale( x, x, y );
        }
        else {
          // scale( x, y, [prependInstead] )
          assert && assert( typeof y === 'number' && isFinite( y ), 'scales should be finite numbers' );
          assert && assert( prependInstead === undefined || typeof prependInstead === 'boolean', 'If provided, prependInstead should be boolean' );

          if ( x === 1 && y === 1 ) { return; } // bail out if we are scaling by 1 (identity)
          if ( prependInstead ) {
            this.prependMatrix( Matrix3.scaling( x, y ) );
          }
          else {
            this.appendMatrix( Matrix3.scaling( x, y ) );
          }
        }
      }
      else {
        // scale( vector, [prependInstead] )
        var vector = x;
        assert && assert( vector instanceof Vector2 && vector.isFinite(), 'scale should be a finite Vector2 if not a finite number' );
        this.scale( vector.x, vector.y, y ); // forward to full version
      }
    },

    /**
     * Rotates the node's transform. The default "appends" the transform, so that it will
     * appear to happen to the node before the rest of the transform would apply, but if "prepended", the rest of the
     * transform would apply first.
     * @public
     *
     * As an example, if a Node is translated to (100,0):
     * rotate( Math.PI ) will rotate the node around (100,0)
     * rotate( Math.PI, true ) will rotate the node around the origin, moving it to (-100,0)
     *
     * @param {number} angle - The angle (in radians) to rotate by
     * @param {boolean} [prependInstead] - Whether the transform should be prepended (defaults to false)
     */
    rotate: function( angle, prependInstead ) {
      assert && assert( typeof angle === 'number' && isFinite( angle ), 'angle should be a finite number' );
      assert && assert( prependInstead === undefined || typeof prependInstead === 'boolean' );
      if ( angle % ( 2 * Math.PI ) === 0 ) { return; } // bail out if our angle is effectively 0
      if ( prependInstead ) {
        this.prependMatrix( Matrix3.rotation2( angle ) );
      }
      else {
        this.appendMatrix( Matrix3.rotation2( angle ) );
      }
    },

    /**
     * Rotates the node's transform around a specific point (in the parent coordinate frame) by prepending the transform.
     * @public
     *
     * TODO: determine whether this should use the appendMatrix method
     *
     * @param {Vector2} point - In the parent coordinate frame
     * @param {number} angle - In radians
     * @returns {Node} - For chaining
     */
    rotateAround: function( point, angle ) {
      assert && assert( point instanceof Vector2 && point.isFinite(), 'point should be a finite Vector2' );
      assert && assert( typeof angle === 'number' && isFinite( angle ), 'angle should be a finite number' );

      var matrix = Matrix3.translation( -point.x, -point.y );
      matrix = Matrix3.rotation2( angle ).timesMatrix( matrix );
      matrix = Matrix3.translation( point.x, point.y ).timesMatrix( matrix );
      this.prependMatrix( matrix );
      return this;
    },

    /**
     * Shifts the x coordinate (in the parent coordinate frame) of where the node's origin is transformed to.
     * @public
     *
     * @param {number} x
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setX: function( x ) {
      assert && assert( typeof x === 'number' && isFinite( x ), 'x should be a finite number' );

      this.translate( x - this.getX(), 0, true );
      return this;
    },
    set x( value ) { this.setX( value ); },

    /**
     * Returns the x coordinate (in the parent coorindate frame) of where the node's origin is transformed to.
     * @public
     *
     * @returns {number}
     */
    getX: function() {
      return this._transform.getMatrix().m02();
    },
    get x() { return this.getX(); },

    /**
     * Shifts the y coordinate (in the parent coordinate frame) of where the node's origin is transformed to.
     * @public
     *
     * @param {number} y
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setY: function( y ) {
      assert && assert( typeof y === 'number' && isFinite( y ), 'y should be a finite number' );

      this.translate( 0, y - this.getY(), true );
      return this;
    },
    set y( value ) { this.setY( value ); },

    /**
     * Returns the y coordinate (in the parent coorindate frame) of where the node's origin is transformed to.
     * @public
     *
     * @returns {number}
     */
    getY: function() {
      return this._transform.getMatrix().m12();
    },
    get y() { return this.getY(); },

    /**
     * Typically without rotations or negative parameters, this sets the scale for each axis. In its more general form,
     * it modifies the node's transform so that:
     * - Transforming (1,0) with our transform will result in a vector with magnitude abs( x-scale-magnitude )
     * - Transforming (0,1) with our transform will result in a vector with magnitude abs( y-scale-magnitude )
     * - If parameters are negative, it will flip orientation in that direct.
     * @public
     *
     * Allowed call signatures:
     * setScaleMagnitude( s )
     * setScaleMagnitude( sx, sy )
     * setScaleMagnitude( vector )
     *
     * @param {number} s - Scale for both axes
     * @param {number} sx - Scale for the X axis
     * @param {number} sy - Scale for the Y axis
     * @param {Vector2} vector - Scale for the x/y axes in the vector's components.
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setScaleMagnitude: function( a, b ) {
      var currentScale = this.getScaleVector();

      if ( typeof a === 'number' ) {
        if ( b === undefined ) {
          // to map setScaleMagnitude( scale ) => setScaleMagnitude( scale, scale )
          b = a;
        }
        assert && assert( typeof a === 'number' && isFinite( a ), 'setScaleMagnitude parameters should be finite numbers' );
        assert && assert( typeof b === 'number' && isFinite( b ), 'setScaleMagnitude parameters should be finite numbers' );
        // setScaleMagnitude( x, y )
        this.appendMatrix( Matrix3.scaling( a / currentScale.x, b / currentScale.y ) );
      }
      else {
        // setScaleMagnitude( vector ), where we set the x-scale to vector.x and y-scale to vector.y
        assert && assert( a instanceof Vector2 && a.isFinite(), 'first parameter should be a finite Vector2' );

        this.appendMatrix( Matrix3.scaling( a.x / currentScale.x, a.y / currentScale.y ) );
      }
      return this;
    },

    /**
     * Returns a vector with an entry for each axis, e.g. (5,2) for an affine matrix with rows ((5,0,0),(0,2,0),(0,0,1)).
     * @public
     *
     * It is equivalent to:
     * ( T(1,0).magnitude(), T(0,1).magnitude() ) where T() transforms points with our transform.
     *
     * @returns {Vector2}
     */
    getScaleVector: function() {
      return this._transform.getMatrix().getScaleVector();
    },

    /**
     * Rotates this node's transform so that a unit (1,0) vector would be rotated by this node's transform by the
     * specified amount.
     * @public
     *
     * @param {number} rotation - In radians
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setRotation: function( rotation ) {
      assert && assert( typeof rotation === 'number' && isFinite( rotation ),
        'rotation should be a finite number' );

      this.appendMatrix( scratchMatrix3.setToRotationZ( rotation - this.getRotation() ) );
      return this;
    },
    set rotation( value ) { this.setRotation( value ); },

    /**
     * Returns the rotation (in radians) that would be applied to a unit (1,0) vector when transformed with this Node's
     * transform.
     * @public
     *
     * @returns {number}
     */
    getRotation: function() {
      return this._transform.getMatrix().getRotation();
    },
    get rotation() { return this.getRotation(); },

    /**
     * Modifies the translation of this Node's transform so that the node's local-coordinate origin will be transformed
     * to the passed-in x/y.
     * @public
     *
     * Allowed call signatures:
     * setTranslation( x, y )
     * setTranslation( vector )
     *
     * @param {number} x - X translation
     * @param {number} y - Y translation
     * @param {Vector2} vector - Vector with x/y translation in components
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setTranslation: function( a, b ) {
      var m = this._transform.getMatrix();
      var tx = m.m02();
      var ty = m.m12();

      var dx;
      var dy;

      if ( typeof a === 'number' ) {
        assert && assert( typeof a === 'number' && isFinite( a ), 'Parameters to setTranslation should be finite numbers' );
        assert && assert( typeof b === 'number' && isFinite( b ), 'Parameters to setTranslation should be finite numbers' );
        dx = a - tx;
        dy = b - ty;
      }
      else {
        assert && assert( a instanceof Vector2 && a.isFinite(), 'Should be a finite Vector2' );
        dx = a.x - tx;
        dy = a.y - ty;
      }

      this.translate( dx, dy, true );

      return this;
    },
    set translation( value ) { this.setTranslation( value ); },

    /**
     * Returns a vector of where this Node's local-coordinate origin will be transformed by it's own transform.
     * @public
     *
     * @returns {Vector2}
     */
    getTranslation: function() {
      var matrix = this._transform.getMatrix();
      return new Vector2( matrix.m02(), matrix.m12() );
    },
    get translation() { return this.getTranslation(); },

    /**
     * Appends a transformation matrix to this Node's transform. Appending means this transform is conceptually applied
     * first before the rest of the Node's current transform (i.e. applied in the local coordinate frame).
     * @public
     *
     * @param {Matrix3} matrix
     */
    appendMatrix: function( matrix ) {
      assert && assert( matrix instanceof Matrix3 && matrix.isFinite(), 'matrix should be a finite Matrix3' );
      assert && assert( matrix.getDeterminant() !== 0, 'matrix should not map plane to a line or point' );
      this._transform.append( matrix );
    },

    /**
     * Prepends a transformation matrix to this Node's transform. Prepending means this transform is conceptually applied
     * after the rest of the Node's current transform (i.e. applied in the parent coordinate frame).
     * @public
     *
     * @param {Matrix3} matrix
     */
    prependMatrix: function( matrix ) {
      assert && assert( matrix instanceof Matrix3 && matrix.isFinite(), 'matrix should be a finite Matrix3' );
      assert && assert( matrix.getDeterminant() !== 0, 'matrix should not map plane to a line or point' );
      this._transform.prepend( matrix );
    },

    /**
     * Prepends an (x,y) translation to our Node's transform in an efficient manner without allocating a matrix.
     * see https://github.com/phetsims/scenery/issues/119
     * @public
     *
     * @param {number} x
     * @param {number} y
     */
    prependTranslation: function( x, y ) {
      assert && assert( typeof x === 'number' && isFinite( x ), 'x should be a finite number' );
      assert && assert( typeof y === 'number' && isFinite( y ), 'y should be a finite number' );

      if ( !x && !y ) { return; } // bail out if both are zero

      this._transform.prependTranslation( x, y );
    },

    /**
     * Changes this Node's transform to match the passed-in transformation matrix.
     * @public
     *
     * @param {Matrix3} matrix
     */
    setMatrix: function( matrix ) {
      assert && assert( matrix instanceof Matrix3 && matrix.isFinite(), 'matrix should be a finite Matrix3' );
      assert && assert( matrix.getDeterminant() !== 0, 'matrix should not map plane to a line or point' );

      this._transform.setMatrix( matrix );
    },
    set matrix( value ) { this.setMatrix( value ); },

    /**
     * Returns a Matrix3 representing our Node's transform.
     * @public
     *
     * NOTE: Do not mutate the returned matrix.
     *
     * @returns {Matrix3}
     */
    getMatrix: function() {
      return this._transform.getMatrix();
    },
    get matrix() { return this.getMatrix(); },

    /**
     * Returns a reference to our Node's transform
     * @public
     *
     * @returns {Transform3}
     */
    getTransform: function() {
      // for now, return an actual copy. we can consider listening to changes in the future
      return this._transform;
    },
    get transform() { return this.getTransform(); },

    /**
     * Resets our Node's transform to an identity transform (i.e. no transform is applied).
     * @public
     */
    resetTransform: function() {
      this.setMatrix( Matrix3.IDENTITY );
    },

    /**
     * Callback function that should be called when our transform is changed.
     * @private
     */
    onTransformChange: function() {
      // TODO: why is local bounds invalidation needed here?
      this.invalidateBounds();

      this._picker.onTransformChange();
      if ( assertSlow ) { this._picker.audit(); }

      this.trigger0( 'transform' );
    },

    /**
     * Updates our node's scale and applied scale factor if we need to change our scale to fit within the maximum
     * dimensions (maxWidth and maxHeight). See documentation in constructor for detailed behavior.
     * @private
     *
     * @param {Bounds2} localBounds
     */
    updateMaxDimension: function( localBounds ) {
      var currentScale = this._appliedScaleFactor;
      var idealScale = 1;

      if ( this._maxWidth !== null ) {
        var width = localBounds.width;
        if ( width > this._maxWidth ) {
          idealScale = Math.min( idealScale, this._maxWidth / width );
        }
      }

      if ( this._maxHeight !== null ) {
        var height = localBounds.height;
        if ( height > this._maxHeight ) {
          idealScale = Math.min( idealScale, this._maxHeight / height );
        }
      }

      var scaleAdjustment = idealScale / currentScale;
      if ( scaleAdjustment !== 1 ) {
        this.scale( scaleAdjustment );

        this._appliedScaleFactor = idealScale;
      }
    },

    /**
     * Increments/decrements bounds "listener" count based on the values of maxWidth/maxHeight before and after.
     * null is like no listener, non-null is like having a listener, so we increment for null => non-null, and
     * decrement for non-null => null.
     * @private
     *
     * @param {null | number} beforeMaxLength
     * @param {null | number} afterMaxLength
     */
    onMaxDimensionChange: function( beforeMaxLength, afterMaxLength ) {
      if ( beforeMaxLength === null && afterMaxLength !== null ) {
        this.changeBoundsEventCount( 1 );
        this._boundsEventSelfCount++;
      }
      else if ( beforeMaxLength !== null && afterMaxLength === null ) {
        this.changeBoundsEventCount( -1 );
        this._boundsEventSelfCount--;
      }
    },

    /**
     * Sets the maximum width of the Node (see constructor for documentation on how maximum dimensions work).
     * @public
     *
     * @param {number|null} maxWidth
     */
    setMaxWidth: function( maxWidth ) {
      assert && assert( maxWidth === null || typeof maxWidth === 'number',
        'maxWidth should be null (no constraint) or a number' );

      if ( this._maxWidth !== maxWidth ) {
        // update synthetic bounds listener count (to ensure our bounds are validated at the start of updateDisplay)
        this.onMaxDimensionChange( this._maxWidth, maxWidth );

        this._maxWidth = maxWidth;

        this.updateMaxDimension( this._localBounds );
      }
    },
    set maxWidth( value ) { this.setMaxWidth( value ); },

    /**
     * Returns the maximum width (if any) of the Node.
     * @public
     *
     * @returns {number|null}
     */
    getMaxWidth: function() {
      return this._maxWidth;
    },
    get maxWidth() { return this.getMaxWidth(); },

    /**
     * Sets the maximum height of the Node (see constructor for documentation on how maximum dimensions work).
     * @public
     *
     * @param {number|null} maxHeight
     */
    setMaxHeight: function( maxHeight ) {
      assert && assert( maxHeight === null || typeof maxHeight === 'number',
        'maxHeight should be null (no constraint) or a number' );

      if ( this._maxHeight !== maxHeight ) {
        // update synthetic bounds listener count (to ensure our bounds are validated at the start of updateDisplay)
        this.onMaxDimensionChange( this._maxHeight, maxHeight );

        this._maxHeight = maxHeight;

        this.updateMaxDimension( this._localBounds );
      }
    },
    set maxHeight( value ) { this.setMaxHeight( value ); },

    /**
     * Returns the maximum height (if any) of the Node.
     * @public
     *
     * @returns {number|null}
     */
    getMaxHeight: function() {
      return this._maxHeight;
    },
    get maxHeight() { return this.getMaxHeight(); },

    /**
     * Shifts this node horizontally so that its left bound (in the parent coordinate frame) is equal to the passed-in
     * 'left' X value.
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @param {number} left - After this operation, node.left should approximately equal this value.
     * @returns {Node} - For chaining
     */
    setLeft: function( left ) {
      assert && assert( typeof left === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting left is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( left - this.getLeft(), 0, true );
      return this; // allow chaining
    },
    set left( value ) { this.setLeft( value ); },

    /**
     * Returns the X value of the left side of the bounding box of this node (in the parent coordinate frame).
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {number}
     */
    getLeft: function() {
      return this.getBounds().minX;
    },
    get left() { return this.getLeft(); },

    /**
     * Shifts this node horizontally so that its right bound (in the parent coordinate frame) is equal to the passed-in
     * 'right' X value.
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @param {number} right - After this operation, node.right should approximately equal this value.
     * @returns {Node} - For chaining
     */
    setRight: function( right ) {
      assert && assert( typeof right === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting right is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( right - this.getRight(), 0, true );
      return this; // allow chaining
    },
    set right( value ) { this.setRight( value ); },

    /**
     * Returns the X value of the right side of the bounding box of this node (in the parent coordinate frame).
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {number}
     */
    getRight: function() {
      return this.getBounds().maxX;
    },
    get right() { return this.getRight(); },

    /**
     * Shifts this node horizontally so that its horizontal center (in the parent coordinate frame) is equal to the
     * passed-in center X value.
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @param {number} x - After this operation, node.centerX should approximately equal this value.
     * @returns {Node} - For chaining
     */
    setCenterX: function( x ) {
      assert && assert( typeof x === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting centerX is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( x - this.getCenterX(), 0, true );
      return this; // allow chaining
    },
    set centerX( value ) { this.setCenterX( value ); },

    /**
     * Returns the X value of this node's horizontal center (in the parent coordinate frame)
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {number}
     */
    getCenterX: function() {
      return this.getBounds().getCenterX();
    },
    get centerX() { return this.getCenterX(); },

    /**
     * Shifts this node vertically so that its vertical center (in the parent coordinate frame) is equal to the
     * passed-in center Y value.
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @param {number} y - After this operation, node.centerY should approximately equal this value.
     * @returns {Node} - For chaining
     */
    setCenterY: function( y ) {
      assert && assert( typeof y === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting centerY is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( 0, y - this.getCenterY(), true );
      return this; // allow chaining
    },
    set centerY( value ) { this.setCenterY( value ); },

    /**
     * Returns the Y value of this node's vertical center (in the parent coordinate frame)
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {number}
     */
    getCenterY: function() {
      return this.getBounds().getCenterY();
    },
    get centerY() { return this.getCenterY(); },

    /**
     * Shifts this node vertically so that its top (in the parent coordinate frame) is equal to the passed-in Y value.
     * @public
     *
     * NOTE: top is the lowest Y value in our bounds.
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @param {number} top - After this operation, node.top should approximately equal this value.
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setTop: function( top ) {
      assert && assert( typeof top === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting top is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( 0, top - this.getTop(), true );
      return this; // allow chaining
    },
    set top( value ) { this.setTop( value ); },

    /**
     * Returns the lowest Y value of this node's bounding box (in the parent coordinate frame).
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {number}
     */
    getTop: function() {
      return this.getBounds().minY;
    },
    get top() { return this.getTop(); },

    /**
     * Shifts this node vertically so that its bottom (in the parent coordinate frame) is equal to the passed-in Y value.
     * @public
     *
     * NOTE: top is the highest Y value in our bounds.
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @param {number} top - After this operation, node.bottom should approximately equal this value.
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setBottom: function( bottom ) {
      assert && assert( typeof bottom === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting bottom is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( 0, bottom - this.getBottom(), true );
      return this; // allow chaining
    },
    set bottom( value ) { this.setBottom( value ); },

    /**
     * Returns the highest Y value of this node's bounding box (in the parent coordinate frame).
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {number}
     */
    getBottom: function() {
      return this.getBounds().maxY;
    },
    get bottom() { return this.getBottom(); },

    /*
     * Convenience locations
     *
     * Upper is in terms of the visual layout in Scenery and other programs, so the minY is the "upper", and minY is the "lower"
     *
     *             left (x)     centerX        right
     *          ---------------------------------------
     * top  (y) | leftTop     centerTop     rightTop
     * centerY  | leftCenter  center        rightCenter
     * bottom   | leftBottom  centerBottom  rightBottom
     *
     * NOTE: This requires computation of this node's subtree bounds, which may incur some performance loss.
     */

    /**
     * Sets the position of the upper-left corner of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} leftTop
     * @returns {Node} - For chaining
     */
    setLeftTop: function( leftTop ) {
      assert && assert( leftTop instanceof Vector2 && leftTop.isFinite(), 'leftTop should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting leftTop is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( leftTop.minus( this.getLeftTop() ), true );
      return this;
    },
    set leftTop( value ) { this.setLeftTop( value ); },

    /**
     * Returns the upper-left corner of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getLeftTop: function() {
      return this.getBounds().getLeftTop();
    },
    get leftTop() { return this.getLeftTop(); },

    /**
     * Sets the position of the center-top location of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} centerTop
     * @returns {Node} - For chaining
     */
    setCenterTop: function( centerTop ) {
      assert && assert( centerTop instanceof Vector2 && centerTop.isFinite(), 'centerTop should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting centerTop is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( centerTop.minus( this.getCenterTop() ), true );
      return this;
    },
    set centerTop( value ) { this.setCenterTop( value ); },

    /**
     * Returns the center-top location of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getCenterTop: function() {
      return this.getBounds().getCenterTop();
    },
    get centerTop() { return this.getCenterTop(); },

    /**
     * Sets the position of the upper-right corner of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} rightTop
     * @returns {Node} - For chaining
     */
    setRightTop: function( rightTop ) {
      assert && assert( rightTop instanceof Vector2 && rightTop.isFinite(), 'rightTop should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting rightTop is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( rightTop.minus( this.getRightTop() ), true );
      return this;
    },
    set rightTop( value ) { this.setRightTop( value ); },

    /**
     * Returns the upper-right corner of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getRightTop: function() {
      return this.getBounds().getRightTop();
    },
    get rightTop() { return this.getRightTop(); },

    /**
     * Sets the position of the center-left of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} leftCenter
     * @returns {Node} - For chaining
     */
    setLeftCenter: function( leftCenter ) {
      assert && assert( leftCenter instanceof Vector2 && leftCenter.isFinite(), 'leftCenter should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting leftCenter is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( leftCenter.minus( this.getLeftCenter() ), true );
      return this;
    },
    set leftCenter( value ) { this.setLeftCenter( value ); },

    /**
     * Returns the center-left corner of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getLeftCenter: function() {
      return this.getBounds().getLeftCenter();
    },
    get leftCenter() { return this.getLeftCenter(); },

    /**
     * Sets the center of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} center
     * @returns {Node} - For chaining
     */
    setCenter: function( center ) {
      assert && assert( center instanceof Vector2 && center.isFinite(), 'center should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting center is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( center.minus( this.getCenter() ), true );
      return this;
    },
    set center( value ) { this.setCenter( value ); },

    /**
     * Returns the center of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getCenter: function() {
      return this.getBounds().getCenter();
    },
    get center() { return this.getCenter(); },

    /**
     * Sets the position of the center-right of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} rightCenter
     * @returns {Node} - For chaining
     */
    setRightCenter: function( rightCenter ) {
      assert && assert( rightCenter instanceof Vector2 && rightCenter.isFinite(), 'rightCenter should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting rightCenter is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( rightCenter.minus( this.getRightCenter() ), true );
      return this;
    },
    set rightCenter( value ) { this.setRightCenter( value ); },

    /**
     * Returns the center-right of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getRightCenter: function() {
      return this.getBounds().getRightCenter();
    },
    get rightCenter() { return this.getRightCenter(); },

    /**
     * Sets the position of the lower-left corner of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} leftBottom
     * @returns {Node} - For chaining
     */
    setLeftBottom: function( leftBottom ) {
      assert && assert( leftBottom instanceof Vector2 && leftBottom.isFinite(), 'leftBottom should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting leftBottom is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( leftBottom.minus( this.getLeftBottom() ), true );
      return this;
    },
    set leftBottom( value ) { this.setLeftBottom( value ); },

    /**
     * Returns the lower-left corner of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getLeftBottom: function() {
      return this.getBounds().getLeftBottom();
    },
    get leftBottom() { return this.getLeftBottom(); },

    /**
     * Sets the position of the center-bottom of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} centerBottom
     * @returns {Node} - For chaining
     */
    setCenterBottom: function( centerBottom ) {
      assert && assert( centerBottom instanceof Vector2 && centerBottom.isFinite(), 'centerBottom should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting centerBottom is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( centerBottom.minus( this.getCenterBottom() ), true );
      return this;
    },
    set centerBottom( value ) { this.setCenterBottom( value ); },

    /**
     * Returns the center-bottom of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getCenterBottom: function() {
      return this.getBounds().getCenterBottom();
    },
    get centerBottom() { return this.getCenterBottom(); },

    /**
     * Sets the position of the lower-right corner of this node's bounds to the specified point.
     * @public
     *
     * @param {Vector2} rightBottom
     * @returns {Node} - For chaining
     */
    setRightBottom: function( rightBottom ) {
      assert && assert( rightBottom instanceof Vector2 && rightBottom.isFinite(), 'rightBottom should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting rightBottom is invalid when the node has invalid (empty/NaN/infinite) bounds.' );

      this.translate( rightBottom.minus( this.getRightBottom() ), true );
      return this;
    },
    set rightBottom( value ) { this.setRightBottom( value ); },

    /**
     * Returns the lower-right corner of this node's bounds.
     * @public
     *
     * @returns {Vector2}
     */
    getRightBottom: function() {
      return this.getBounds().getRightBottom();
    },
    get rightBottom() { return this.getRightBottom(); },

    /**
     * Returns the width of this node's bounding box (in the parent coordinate frame).
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {number}
     */
    getWidth: function() {
      return this.getBounds().getWidth();
    },
    get width() { return this.getWidth(); },

    /**
     * Returns the height of this node's bounding box (in the parent coordinate frame).
     * @public
     *
     * NOTE: This may require computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {number}
     */
    getHeight: function() {
      return this.getBounds().getHeight();
    },
    get height() { return this.getHeight(); },

    /**
     * Returns the unique integral ID for this node.
     * @public
     *
     * @returns {number}
     */
    getId: function() {
      return this._id;
    },
    get id() { return this.getId(); },

    /**
     * Sets whether this node is visible.
     * @public
     *
     * @param {boolean} visible
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    setVisible: function( visible ) {
      assert && assert( typeof visible === 'boolean' );

      if ( visible !== this._visible ) {
        this._visible = visible;

        // changing visibility can affect pickability pruning, which affects mouse/touch bounds
        this._picker.onVisibilityChange();
        if ( assertSlow ) { this._picker.audit(); }

        this.trigger0( 'visibility' );
      }
      return this;
    },
    set visible( value ) { this.setVisible( value ); },

    /**
     * Returns whether this node is visible.
     * @public
     *
     * @returns {boolean}
     */
    isVisible: function() {
      return this._visible;
    },
    get visible() { return this.isVisible(); },

    /**
     * Sets the opacity of this node (and its sub-tree), where 0 is fully transparent, and 1 is fully opaque.
     * @public
     *
     * NOTE: opacity is clamped to be between 0 and 1.
     *
     * @param {number} opacity
     */
    setOpacity: function( opacity ) {
      assert && assert( typeof opacity === 'number' && isFinite( opacity ), 'opacity should be a finite number' );

      var clampedOpacity = clamp( opacity, 0, 1 );
      if ( clampedOpacity !== this._opacity ) {
        this._opacity = clampedOpacity;

        this.trigger0( 'opacity' );
      }
    },
    set opacity( value ) { this.setOpacity( value ); },

    /**
     * Returns the opacity of this node.
     * @public
     *
     * @returns {number}
     */
    getOpacity: function() {
      return this._opacity;
    },
    get opacity() { return this.getOpacity(); },

    /**
     * Sets whether this node (and its subtree) will allow hit-testing (and thus user interaction), controlling what
     * Trail is returned from node.trailUnderPoint().
     * @public
     *
     * Pickable can take one of three values:
     * - null: (default) pass-through behavior. Hit-testing will prune this subtree if there are no
     *         ancestors/descendants with either pickable: true set or with any input listeners.
     * - false: Hit-testing is pruned, nothing under a pickable: false will respond to events or be picked.
     * - true: Hit-testing will not be pruned in this subtree, except for pickable: false cases.
     *
     * Hit testing is accomplished mainly with node.trailUnderPointer() and node.trailUnderPoint(), following the
     * above rules. Nodes that are not pickable (pruned) will not have input events targeted to them.
     *
     * Thus in order for a Node (really, a Trail) to be able to receive input events:
     * 1. If the node or one of its ancestors has pickable: false OR is invisible, the node *will not* receive events
     *    or hit testing.
     * 2. If the node or one of its ancestors or descendants is pickable: true OR has an input listener attached, it
     *    *will* receive events or hit testing.
     * 3. Otherwise, it *will not* receive events or hit testing.
     *
     * This is useful for semi-transparent overlays or other visual elements that should be displayed but should not
     * prevent objects below from being manipulated by user input, and the default null value is used to increase
     * performance by ignoring areas that don't need user input.
     *
     * NOTE: If you want something to be picked "mouse is over it", but block input events even if there are listeners,
     *       then pickable:false is not appropriate, and inputEnabled:false is preferred.
     *
     * For a visual example of how pickability interacts with input listeners and visibility, see the notes at the
     * bottom of http://phetsims.github.io/scenery/doc/implementation-notes, or scenery/assets/pickability.svg.
     *
     * @param {boolean|null} pickable
     */
    setPickable: function( pickable ) {
      assert && assert( pickable === null || typeof pickable === 'boolean' );

      if ( this._pickable !== pickable ) {
        var oldPickable = this._pickable;

        // no paint or invalidation changes for now, since this is only handled for the mouse
        this._pickable = pickable;

        this._picker.onPickableChange( oldPickable, pickable );
        if ( assertSlow ) { this._picker.audit(); }
        // TODO: invalidate the cursor somehow? #150

        this.trigger0( 'pickability' );
      }
    },
    set pickable( value ) { this.setPickable( value ); },

    /**
     * Returns the pickability of this node.
     * @public
     *
     * @returns {boolean|null}
     */
    isPickable: function() {
      return this._pickable;
    },
    get pickable() { return this.isPickable(); },

    /**
     * Sets whether input is enabled for this node and its subtree. If false, input event listeners will not be fired
     * on this node or its descendants in the picked Trail. This does NOT effect picking (what Trail/nodes are under
     * a pointer), but only effects what listeners are fired.
     * @public
     *
     * Additionally, this will affect cursor behavior. If inputEnabled=false, descendants of this Node will not be
     * checked when determining what cursor will be shown. Instead, if a pointer (e.g. mouse) is over a descendant,
     * this Node's cursor will be checked first, then ancestors will be checked as normal.
     *
     * @param {boolean} inputEnabled
     */
    setInputEnabled: function( inputEnabled ) {
      assert && assert( typeof inputEnabled === 'boolean' );

      if ( this._inputEnabled !== inputEnabled ) {
        this._inputEnabled = inputEnabled;

        this.trigger0( 'inputEnabled' );
      }
    },
    set inputEnabled( value ) { this.setInputEnabled( value ); },

    /**
     * Returns whether input is enabled for this Node and its subtree. See setInputEnabled for more documentation.
     * @public
     *
     * @returns {boolean}
     */
    isInputEnabled: function() {
      return this._inputEnabled;
    },
    get inputEnabled() { return this.isInputEnabled(); },

    /**
     * Sets all of the input listeners attached to this Node.
     * @public
     *
     * This is equivalent to removing all current input listeners with removeInputListener() and adding all new
     * listeners (in order) with addInputListener().
     *
     * @param {Array.<Object>} inputlisteners - The input listeners to add.
     * @returns {Node} - For chaining
     */
    setInputListeners: function( inputListeners ) {
      assert && assert( inputListeners instanceof Array );

      // Remove all old input listeners
      while ( this._inputListeners.length ) {
        this.removeInputListener( this._inputListeners[ 0 ] );
      }

      // Add in all new input listeners
      for ( var i = 0; i < inputListeners.length; i++ ) {
        this.addInputListener( inputListeners[ i ] );
      }

      return this;
    },
    set inputListeners( value ) { this.setInputListeners( value ); },

    /**
     * Returns a copy of all of our input listeners.
     * @public
     *
     * @returns {Array.<Object>}
     */
    getInputListeners: function() {
      return this._inputListeners.slice( 0 ); // defensive copy
    },
    get inputListeners() { return this.getInputListeners(); },

    /**
     * Sets the CSS cursor string that should be used when the mouse is over this node. null is the default, and
     * indicates that ancestor nodes (or the browser default) should be used.
     * @public
     *
     * @param {string|null} cursor - A CSS cursor string, like 'pointer', or 'none'
     */
    setCursor: function( cursor ) {
      assert && assert( typeof cursor === 'string' || cursor === null );

      // TODO: consider a mapping of types to set reasonable defaults
      /*
       auto default none inherit help pointer progress wait crosshair text vertical-text alias copy move no-drop not-allowed
       e-resize n-resize w-resize s-resize nw-resize ne-resize se-resize sw-resize ew-resize ns-resize nesw-resize nwse-resize
       context-menu cell col-resize row-resize all-scroll url( ... ) --> does it support data URLs?
       */

      // allow the 'auto' cursor type to let the ancestors or scene pick the cursor type
      this._cursor = cursor === 'auto' ? null : cursor;
    },
    set cursor( value ) { this.setCursor( value ); },

    /**
     * Returns the CSS cursor string for this node, or null if there is no cursor specified.
     * @public
     *
     * @returns {string|null}
     */
    getCursor: function() {
      return this._cursor;
    },
    get cursor() { return this.getCursor(); },

    /**
     * Sets the hit-tested mouse area for this node (see constructor for more advanced documentation). Use null for the
     * default behavior.
     * @public
     *
     * @param {Bounds2|Shape|null} area
     */
    setMouseArea: function( area ) {
      assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'mouseArea needs to be a kite.Shape, dot.Bounds2, or null' );

      if ( this._mouseArea !== area ) {
        this._mouseArea = area; // TODO: could change what is under the mouse, invalidate!

        this._picker.onMouseAreaChange();
        if ( assertSlow ) { this._picker.audit(); }
      }
    },
    set mouseArea( value ) { this.setMouseArea( value ); },

    /**
     * Returns the hit-tested mouse area for this node.
     * @public
     *
     * @returns {Bounds2|Shape|null}
     */
    getMouseArea: function() {
      return this._mouseArea;
    },
    get mouseArea() { return this.getMouseArea(); },

    /**
     * Sets the hit-tested touch area for this node (see constructor for more advanced documentation). Use null for the
     * default behavior.
     * @public
     *
     * @param {Bounds2|Shape|null} area
     */
    setTouchArea: function( area ) {
      assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'touchArea needs to be a kite.Shape, dot.Bounds2, or null' );

      if ( this._touchArea !== area ) {
        this._touchArea = area; // TODO: could change what is under the touch, invalidate!

        this._picker.onTouchAreaChange();
        if ( assertSlow ) { this._picker.audit(); }
      }
    },
    set touchArea( value ) { this.setTouchArea( value ); },

    /**
     * Returns the hit-tested touch area for this node.
     * @public
     *
     * @returns {Bounds2|Shape|null}
     */
    getTouchArea: function() {
      return this._touchArea;
    },
    get touchArea() { return this.getTouchArea(); },

    /**
     * Sets a clipped shape where only content in our local coordinate frame that is inside the clip area will be shown
     * (anything outside is fully transparent).
     * @public
     *
     * @param {Shape|null} shape
     */
    setClipArea: function( shape ) {
      assert && assert( shape === null || shape instanceof Shape, 'clipArea needs to be a kite.Shape, or null' );

      if ( this._clipArea !== shape ) {
        this._clipArea = shape;

        this.trigger0( 'clip' );

        this.invalidateBounds();
        this._picker.onClipAreaChange();

        if ( assertSlow ) { this._picker.audit(); }
      }
    },
    set clipArea( value ) { this.setClipArea( value ); },

    /**
     * Returns the clipped area for this node.
     * @public
     *
     * @returns {Shape|null}
     */
    getClipArea: function() {
      return this._clipArea;
    },
    get clipArea() { return this.getClipArea(); },

    /**
     * Returns whether this node has a clip area.
     * @public
     *
     * @returns {boolean}
     */
    hasClipArea: function() {
      return this._clipArea !== null;
    },

    /**
     * Sets the accessible focus order for this node. This includes not only focussed items, but elements that can be
     * placed in the parallel DOM. If provided, it will override the focus order between children (and
     * optionally descendants). If not provided, the focus order will default to the rendering order (first children
     * first, last children last), determined by the children array.
     * @public
     *
     * @param {Array.<Node>|null} accessibleOrder
     */
    setAccessibleOrder: function( accessibleOrder ) {
      assert && assert( accessibleOrder === null || accessibleOrder instanceof Array );

      if ( this._accessibleOrder !== accessibleOrder ) {
        this._accessibleOrder = accessibleOrder;

        var trails = this.getTrails( hasRootedDisplayPredicate );
        for ( var i = 0; i < trails.length; i++ ) {
          var trail = trails[ i ];
          var rootedDisplays = trail.rootNode()._rootedDisplays;
          for ( var j = 0; j < rootedDisplays.length; j++ ) {
            rootedDisplays[ j ].changedAccessibleOrder( trail );
          }
        }

        this.trigger0( 'accessibleOrder' );
      }
    },
    set accessibleOrder( value ) { this.setAccessibleOrder( value ); },

    /**
     * Returns the accessible (focus) order for this node.
     * @public
     *
     * @returns {Array.<Node>|null}
     */
    getAccessibleOrder: function() {
      return this._accessibleOrder;
    },
    get accessibleOrder() { return this.getAccessibleOrder(); },

    /**
     * Sets the accessible content for a Node. See constructor for more information.
     * @public (scenery-internal)
     *
     * @param {null|Object} accessibleContent
     */
    setAccessibleContent: function( accessibleContent ) {
      assert && assert( accessibleContent === null || accessibleContent instanceof Object );

      if ( this._accessibleContent !== accessibleContent ) {
        var oldAccessibleContent = this._accessibleContent;
        this._accessibleContent = accessibleContent;

        var trails = this.getTrails( hasRootedDisplayPredicate );
        for ( var i = 0; i < trails.length; i++ ) {
          var trail = trails[ i ];
          var rootedDisplays = trail.rootNode()._rootedDisplays;
          for ( var j = 0; j < rootedDisplays.length; j++ ) {
            rootedDisplays[ j ].changedAccessibleContent( trail, oldAccessibleContent, accessibleContent );
          }
        }

        this.trigger0( 'accessibleContent' );
      }
    },
    set accessibleContent( value ) { this.setAccessibleContent( value ); },

    /**
     * Returns the accessible content for this node.
     * @public (scenery-internal)
     *
     *
     * @returns {null|Object}
     */
    getAccessibleContent: function() {
      return this._accessibleContent;
    },
    get accessibleContent() { return this.getAccessibleContent(); },

    /**
     * Sets what self renderers (and other bitmask flags) are supported by this node.
     * @protected
     *
     * @param {number} bitmask
     */
    setRendererBitmask: function( bitmask ) {
      assert && assert( typeof bitmask === 'number' && isFinite( bitmask ) );

      if ( bitmask !== this._rendererBitmask ) {
        this._rendererBitmask = bitmask;

        this._rendererSummary.selfChange();
        this.trigger0( 'rendererBitmask' );
      }
    },

    /**
     * Meant to be overridden, so that it can be called to ensure that the renderer bitmask will be up-to-date.
     * @protected
     */
    invalidateSupportedRenderers: function() {

    },

    /*---------------------------------------------------------------------------*
     * Hints
     *----------------------------------------------------------------------------*/

    /**
     * Sets a preferred renderer for this node and its sub-tree. Scenery will attempt to use this renderer under here
     * unless it isn't supported, OR another preferred renderer is set as a closer ancestor. Acceptable values are:
     * - null (default, no preference)
     * - 'canvas'
     * - 'svg'
     * - 'dom'
     * - 'webgl'
     * @public
     *
     * @param {string|null} renderer
     */
    setRenderer: function( renderer ) {
      assert && assert( renderer === null || renderer === 'canvas' || renderer === 'svg' || renderer === 'dom' || renderer === 'webgl',
        'Renderer input should be null, or one of: "canvas", "svg", "dom" or "webgl".' );

      var newRenderer = 0;
      if ( renderer === 'canvas' ) {
        newRenderer = Renderer.bitmaskCanvas;
      }
      else if ( renderer === 'svg' ) {
        newRenderer = Renderer.bitmaskSVG;
      }
      else if ( renderer === 'dom' ) {
        newRenderer = Renderer.bitmaskDOM;
      }
      else if ( renderer === 'webgl' ) {
        newRenderer = Renderer.bitmaskWebGL;
      }
      assert && assert( ( renderer === null ) === ( newRenderer === 0 ),
        'We should only end up with no actual renderer if renderer is null' );

      if ( this._hints.renderer !== newRenderer ) {
        this._hints.renderer = newRenderer;

        this.trigger1( 'hint', 'renderer' );
      }
    },
    set renderer( value ) { this.setRenderer( value ); },

    /**
     * Returns the preferred renderer (if any) of this node, as a string.
     * @public
     *
     * @returns {string|null}
     */
    getRenderer: function() {
      if ( this._hints.renderer === 0 ) {
        return null;
      }
      else if ( this._hints.renderer === Renderer.bitmaskCanvas ) {
        return 'canvas';
      }
      else if ( this._hints.renderer === Renderer.bitmaskSVG ) {
        return 'svg';
      }
      else if ( this._hints.renderer === Renderer.bitmaskDOM ) {
        return 'dom';
      }
      else if ( this._hints.renderer === Renderer.bitmaskWebGL ) {
        return 'webgl';
      }
      assert && assert( false, 'Seems to be an invalid renderer?' );
      return this._hints.renderer;
    },
    get renderer() { return this.getRenderer(); },

    /**
     * Sets whether or not Scenery will try to put this node (and its descendants) into a separate SVG/Canvas/WebGL/etc.
     * layer, different from other siblings or other nodes. Can be used for performance purposes.
     * @public
     *
     * @param {boolean} split
     */
    setLayerSplit: function( split ) {
      assert && assert( typeof split === 'boolean' );

      if ( split !== this._hints.layerSplit ) {
        this._hints.layerSplit = split;
        this.trigger1( 'hint', 'layerSplit' );
      }
    },
    set layerSplit( value ) { this.setLayerSplit( value ); },

    /**
     * Returns whether the layerSplit performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    isLayerSplit: function() {
      return this._hints.layerSplit;
    },
    get layerSplit() { return this.isLayerSplit(); },

    /**
     * Sets whether or not Scenery will take into account that this Node plans to use opacity. Can have performance
     * gains if there need to be multiple layers for this node's descendants.
     * @public
     *
     * @param {boolean} usesOpacity
     */
    setUsesOpacity: function( usesOpacity ) {
      assert && assert( typeof usesOpacity === 'boolean' );

      if ( usesOpacity !== this._hints.usesOpacity ) {
        this._hints.usesOpacity = usesOpacity;
        this.trigger1( 'hint', 'usesOpacity' );
      }
    },
    set usesOpacity( value ) { this.setUsesOpacity( value ); },

    /**
     * Returns whether the usesOpacity performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    getUsesOpacity: function() {
      return this._hints.usesOpacity;
    },
    get usesOpacity() { return this.getUsesOpacity(); },

    /**
     * Sets a flag for whether whether the contents of this Node and its children should be displayed in a separate
     * DOM element that is transformed with CSS transforms. It can have potential speedups, since the browser may not
     * have to rerasterize contents when it is animated.
     * @public
     *
     * @param {boolean} cssTransform
     */
    setCSSTransform: function( cssTransform ) {
      assert && assert( typeof cssTransform === 'boolean' );

      if ( cssTransform !== this._hints.cssTransform ) {
        this._hints.cssTransform = cssTransform;
        this.trigger1( 'hint', 'cssTransform' );
      }
    },
    set cssTransform( value ) { this.setCSSTransform( value ); },

    /**
     * Returns wehther the cssTransform performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    isCSSTransformed: function() {
      return this._hints.cssTransform;
    },
    get cssTransform() { return this._hints.cssTransform; },

    /**
     * Sets a performance flag for whether layers/DOM elements should be excluded (or included) when things are
     * invisible. The default is false, and invisible content is in the DOM, but hidden.
     * @public
     *
     * @param {boolean} excludeInvisible
     */
    setExcludeInvisible: function( excludeInvisible ) {
      assert && assert( typeof excludeInvisible === 'boolean' );

      if ( excludeInvisible !== this._hints.excludeInvisible ) {
        this._hints.excludeInvisible = excludeInvisible;
        this.trigger1( 'hint', 'excludeInvisible' );
      }
    },
    set excludeInvisible( value ) { this.setExcludeInvisible( value ); },

    /**
     * Returns whether the excludeInvisible performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    isExcludeInvisible: function() {
      return this._hints.excludeInvisible;
    },
    get excludeInvisible() { return this.isExcludeInvisible(); },

    setPreventFit: function( preventFit ) {
      assert && assert( typeof preventFit === 'boolean' );

      if ( preventFit !== this._hints.preventFit ) {
        this._hints.preventFit = preventFit;
        this.trigger1( 'hint', 'preventFit' );
      }
    },
    set preventFit( value ) { this.setPreventFit( value ); },

    /**
     * Returns whether the preventFit performance flag is set.
     * @public
     *
     * @returns {boolean}
     */
    isPreventFit: function() {
      return this._hints.preventFit;
    },
    get preventFit() { return this.isPreventFit(); },

    /**
     * Sets whether there is a custom WebGL scale applied to the Canvas, and if so what scale.
     * @public
     *
     * @param {number|null} webglScale
     */
    setWebGLScale: function( webglScale ) {
      assert && assert( webglScale === null || ( typeof webglScale === 'number' && isFinite( webglScale ) ) );

      if ( webglScale !== this._hints.webglScale ) {
        this._hints.webglScale = webglScale;
        this.trigger1( 'hint', 'webglScale' );
      }
    },
    set webglScale( value ) { this.setWebGLScale( value ); },

    /**
     * Returns the value of the webglScale performance flag.
     * @public
     *
     * @returns {number|null}
     */
    getWebGLScale: function() {
      return this._hints.webglScale;
    },
    get webglScale() { return this.getWebGLScale(); },

    /**
     * Sets the phetioType of this node, a wrapper type like TCheckBox
     * @public
     *
     * @param {function} phetioType
     * @returns {Node}
     */
    setPhetioType: function( phetioType ) {
      assert && assert( typeof phetioType === 'function', 'phetioValue should be a function' );
      if ( this._phetioType !== TNode ) {
        assert && assert( phetioType === this._phetioType, 'Node cannot be given multiple phetioTypes' );
      }

      this._phetioType = phetioType;

      return this; // for chaining
    },
    set phetioType( value ) { this.setPhetioType( value ); },

    /**
     * Returns the phetioType previously set with setPhetioType().
     * @public
     *
     * @returns {function}
     */
    getPhetioType: function() {
      return this._phetioType;
    },
    get phetioType() { return this.getPhetioType(); },

    /**
     * Sets the tandem of this node. This should generally be done after the node is fully constructed, and preferably
     * within the node.mutate() call that sets other options (which is called from the constructor).
     * @public
     *
     * @param {Tandem} tandem
     * @returns {Node}
     */
    setTandem: function( tandem ) {
      assert && assert( tandem instanceof Tandem );

      if ( tandem !== this._tandem ) {
        assert && assert( !this._tandem || this._tandem.id === tandem.id,
          'Node cannot be given multiple tandems with different IDs' );

        this._tandem = tandem;

        this._tandem.addInstance( this, this._phetioType );
      }

      return this; // for chaining
    },
    set tandem( value ) { this.setTandem( value ); },

    /**
     * Returns the tandem previously set with setTandem().
     * @public
     *
     * @returns {Tandem}
     */
    getTandem: function() {
      return this._tandem;
    },
    get tandem() { return this.getTandem(); },

    /*---------------------------------------------------------------------------*
     * Trail operations
     *----------------------------------------------------------------------------*/

    /**
     * Returns the one Trail that starts from a node with no parents (or if the predicate is present, a node that
     * satisfies it), and ends at this node. If more than one Trail would satisfy these conditions, an assertion is
     * thrown (please use getTrails() for those cases).
     * @public
     *
     * @param {function( node ) : boolean} [predicate] - If supplied, we will only return trails rooted at a node that
     *                                                   satisfies predicate( node ) == true
     * @returns {Trail}
     */
    getUniqueTrail: function( predicate ) {

      // Without a predicate, we'll be able to bail out the instant we hit a node with 2+ parents, and it makes the
      // logic easier.
      if ( !predicate ) {
        var trail = new scenery.Trail();
        var node = this; // eslint-disable-line consistent-this

        while ( node ) {
          assert && assert( node._parents.length <= 1,
            'getUniqueTrail found a node with ' + node._parents.length + ' parents.' );

          trail.addAncestor( node );
          node = node._parents[ 0 ]; // should be undefined if there aren't any parents
        }

        return trail;
      }
      // With a predicate, we need to explore multiple parents (since the predicate may filter out all but one)
      else {
        var trails = this.getTrails( predicate );

        assert && assert( trails.length === 1,
          'getUniqueTrail found ' + trails.length + ' matching trails for the predicate' );

        return trails[ 0 ];
      }
    },

    /**
     * Returns a Trail rooted at rootNode and ends at this node. Throws an assertion if the number of trails that match
     * this condition isn't exactly 1.
     * @public
     *
     * @param {Node} rootNode
     * @returns {Trail}
     */
    getUniqueTrailTo: function( rootNode ) {
      return this.getUniqueTrail( function( node ) {
        return rootNode === node;
      } );
    },

    /**
     * Returns an array of all Trails that start from nodes with no parent (or if a predicate is present, those that
     * satisfy the predicate), and ends at this node.
     * @public
     *
     * @param {function( node ) : boolean} [predicate] - If supplied, we will only return Trails rooted at nodes that
     *                                                   satisfy predicate( node ) == true.
     * @returns {Array.<Trail>}
     */
    getTrails: function( predicate ) {
      predicate = predicate || defaultTrailPredicate;

      var trails = [];
      var trail = new scenery.Trail( this );
      scenery.Trail.appendAncestorTrailsWithPredicate( trails, trail, predicate );

      return trails;
    },

    /**
     * Returns an array of all Trails rooted at rootNode and end at this node.
     * @public

     * @param {Node} rootNode
     * @returns {Array.<Trail>}
     */
    getTrailsTo: function( rootNode ) {
      return this.getTrails( function( node ) {
        return node === rootNode;
      } );
    },

    /**
     * Returns an array of all Trails rooted at this node and end with nodes with no children (or if a predicate is
     * present, those that satisfy the predicate).
     * @public
     *
     * @param {function( node ) : boolean} [predicate] - If supplied, we will only return Trails ending at nodes that
     *                                                   satisfy predicate( node ) == true.
     * @returns {Array.<Trail>}
     */
    getLeafTrails: function( predicate ) {
      predicate = predicate || defaultLeafTrailPredicate;

      var trails = [];
      var trail = new scenery.Trail( this );
      scenery.Trail.appendDescendantTrailsWithPredicate( trails, trail, predicate );

      return trails;
    },

    /**
     * Returns an array of all Trails rooted at this node and end with leafNode.
     * @public
     *
     * @param {Node} leafNode
     * @returns {Array.<Trail>}
     */
    getLeafTrailsTo: function( leafNode ) {
      return this.getLeafTrails( function( node ) {
        return node === leafNode;
      } );
    },

    /**
     * Returns a Trail rooted at this node and ending at a node that has no children (or if a predicate is provided, a
     * node that satisfies the predicate). If more than one trail matches this description, an assertion will be fired.
     * @public
     *
     * @param {function( node ) : boolean} [predicate] - If supplied, we will return a Trail that ends with a node that
     *                                                   satisfies predicate( node ) == true
     * @returns {Trail}
     */
    getUniqueLeafTrail: function( predicate ) {
      var trails = this.getLeafTrails( predicate );

      assert && assert( trails.length === 1,
        'getUniqueLeafTrail found ' + trails.length + ' matching trails for the predicate' );

      return trails[ 0 ];
    },

    /**
     * Returns a Trail rooted at this node and ending at leafNode. If more than one trail matches this description,
     * an assertion will be fired.
     * @public
     *
     * @param {Node} leafNode
     * @returns {Trail}
     */
    getUniqueLeafTrailTo: function( leafNode ) {
      return this.getUniqueLeafTrail( function( node ) {
        return node === leafNode;
      } );
    },

    /*
     * Returns all nodes in the connected component, returned in an arbitrary order, including nodes that are ancestors
     * of this node.
     * @public
     *
     * @returns {Array.<Node>}
     */
    getConnectedNodes: function() {
      var result = [];
      var fresh = this._children.concat( this._parents ).concat( this );
      while ( fresh.length ) {
        var node = fresh.pop();
        if ( !_.includes( result, node ) ) {
          result.push( node );
          fresh = fresh.concat( node._children, node._parents );
        }
      }
      return result;
    },

    /*
     * Returns all nodes in the subtree with this node as its root, returned in an arbitrary order. Like
     * getConnectedNodes, but doesn't include parents.
     * @public
     *
     * @returns {Array.<Node>}
     */
    getSubtreeNodes: function() {
      var result = [];
      var fresh = this._children.concat( this );
      while ( fresh.length ) {
        var node = fresh.pop();
        if ( !_.includes( result, node ) ) {
          result.push( node );
          fresh = fresh.concat( node._children );
        }
      }
      return result;
    },

    /**
     * Returns a recursive data structure that represents the nested ordering of accessible content for this Node's
     * subtree. Each "Item" will have the type { trail: {Trail}, children: {Array.<Item>} }, forming a tree-like
     * structure.
     * @public
     *
     * @returns {Array.<Item>}
     */
    getNestedAccessibleOrder: function() {
      var currentTrail = new scenery.Trail( this );
      var pruneStack = []; // {Array.<Node>} - A list of nodes to prune

      // {Array.<Item>} - The main result we will be returning. It is the top-level array where child items will be
      // inserted.
      var result = [];

      // {Array.<Array.<Item>>} A stack of children arrays, where we should be inserting items into the top array.
      // We will start out with the result, and as nested levels are added, the children arrays of those items will be
      // pushed and poppped, so that the top array on this stack is where we should insert our next child item.
      var nestedChildStack = [ result ];

      function addTrailsForNode( node, overridePruning ) {
        // If subtrees were specified with accessibleOrder, they should be skipped from the ordering of ancestor subtrees,
        // otherwise we could end up having multiple references to the same trail (which should be disallowed).
        var pruneCount = 0;
        // count the number of times our node appears in the pruneStack
        _.each( pruneStack, function( pruneNode ) {
          if ( node === pruneNode ) {
            pruneCount++;
          }
        } );

        // If overridePruning is set, we ignore one reference to our node in the prune stack. If there are two copies,
        // however, it means a node was specified in a accessibleOrder that already needs to be pruned (so we skip it instead
        // of creating duplicate references in the tab order).
        if ( pruneCount > 1 || ( pruneCount === 1 && !overridePruning ) ) {
          return;
        }

        // Pushing item and its children array, if accessible
        if ( node.accessibleContent ) {
          var item = {
            trail: currentTrail.copy(),
            children: []
          };
          nestedChildStack[ nestedChildStack.length - 1 ].push( item );
          nestedChildStack.push( item.children );
        }

        // Pushing pruned nodes to the stack (if ordered), AND visiting trails to ordered nodes.
        if ( node._accessibleOrder ) {
          // push specific focused nodes to the stack
          pruneStack = pruneStack.concat( node._accessibleOrder );

          _.each( node._accessibleOrder, function( descendant ) {
            // Find all descendant references to the node.
            // NOTE: We are not reordering trails (due to descendant constraints) if there is more than one instance for
            // this descendant node.
            _.each( node.getLeafTrailsTo( descendant ), function( descendantTrail ) {
              descendantTrail.removeAncestor(); // strip off 'node', so that we handle only children

              // same as the normal order, but adding a full trail (since we may be referencing a descendant node)
              currentTrail.addDescendantTrail( descendantTrail );
              addTrailsForNode( descendant, true ); // 'true' overrides one reference in the prune stack (added above)
              currentTrail.removeDescendantTrail( descendantTrail );
            } );
          } );
        }

        // Visit everything. If there is an accessibleOrder, those trails were already visited, and will be excluded.
        var numChildren = node._children.length;
        for ( var i = 0; i < numChildren; i++ ) {
          var child = node._children[ i ];

          currentTrail.addDescendant( child, i );
          addTrailsForNode( child, false );
          currentTrail.removeDescendant();
        }

        // Popping pruned nodes from the stack (if ordered)
        if ( node._accessibleOrder ) {
          // pop focused nodes from the stack (that were added above)
          _.each( node._accessibleOrder, function( descendant ) {
            pruneStack.pop();
          } );
        }

        // Popping children array if accessible
        if ( node.accessibleContent ) {
          nestedChildStack.pop();
        }
      }

      addTrailsForNode( this, false );

      return result;
    },

    /**
     * Returns all nodes that are connected to this node, sorted in topological order.
     * @public
     *
     * @returns {Array.<Node>}
     */
    getTopologicallySortedNodes: function() {
      // see http://en.wikipedia.org/wiki/Topological_sorting
      var edges = {};
      var s = [];
      var l = [];
      var n;
      _.each( this.getConnectedNodes(), function( node ) {
        edges[ node.id ] = {};
        _.each( node._children, function( m ) {
          edges[ node.id ][ m.id ] = true;
        } );
        if ( !node.parents.length ) {
          s.push( node );
        }
      } );

      function handleChild( m ) {
        delete edges[ n.id ][ m.id ];
        if ( _.every( edges, function( children ) { return !children[ m.id ]; } ) ) {
          // there are no more edges to m
          s.push( m );
        }
      }

      while ( s.length ) {
        n = s.pop();
        l.push( n );

        _.each( n._children, handleChild );
      }

      // ensure that there are no edges left, since then it would contain a circular reference
      assert && assert( _.every( edges, function( children ) {
        return _.every( children, function( final ) { return false; } );
      } ), 'circular reference check' );

      return l;
    },

    /**
     * Returns whether this.addChild( child ) will not cause circular references.
     * @public
     *
     * @param {Node} child
     * @returns {boolean}
     */
    canAddChild: function( child ) {
      if ( this === child || _.includes( this._children, child ) ) {
        return false;
      }

      // see http://en.wikipedia.org/wiki/Topological_sorting
      // TODO: remove duplication with above handling?
      var edges = {};
      var s = [];
      var l = [];
      var n;
      _.each( this.getConnectedNodes().concat( child.getConnectedNodes() ), function( node ) {
        edges[ node.id ] = {};
        _.each( node._children, function( m ) {
          edges[ node.id ][ m.id ] = true;
        } );
        if ( !node.parents.length && node !== child ) {
          s.push( node );
        }
      } );
      edges[ this.id ][ child.id ] = true; // add in our 'new' edge
      function handleChild( m ) {
        delete edges[ n.id ][ m.id ];
        if ( _.every( edges, function( children ) { return !children[ m.id ]; } ) ) {
          // there are no more edges to m
          s.push( m );
        }
      }

      while ( s.length ) {
        n = s.pop();
        l.push( n );

        _.each( n._children, handleChild );

        // handle our new edge
        if ( n === this ) {
          handleChild( child );
        }
      }

      // ensure that there are no edges left, since then it would contain a circular reference
      return _.every( edges, function( children ) {
        return _.every( children, function( final ) { return false; } );
      } );
    },

    /**
     * To be overridden in paintable node types. Should hook into the drawable's prototype (presumably).
     * @protected
     *
     * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
     * coordinate frame of this node.
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} matrix - The transformation matrix already applied to the context.
     */
    canvasPaintSelf: function( wrapper, matrix ) {

    },

    /**
     * Renders this Node only (its self) into the Canvas wrapper, in its local coordinate frame.
     * @public
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} matrix - The current transformation matrix associated with the wrapper
     */
    renderToCanvasSelf: function( wrapper, matrix ) {
      if ( this.isPainted() && ( this._rendererBitmask & Renderer.bitmaskCanvas ) ) {
        this.canvasPaintSelf( wrapper, matrix );
      }
    },

    /**
     * Renders this node and its descendants into the Canvas wrapper.
     * @public
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} [matrix] - Optional transform to be applied
     */
    renderToCanvasSubtree: function( wrapper, matrix ) {
      matrix = matrix || Matrix3.identity();

      wrapper.resetStyles();

      this.renderToCanvasSelf( wrapper, matrix );
      for ( var i = 0; i < this._children.length; i++ ) {
        var child = this._children[ i ];

        if ( child.isVisible() ) {
          var requiresScratchCanvas = child._opacity !== 1 || child._clipArea;

          wrapper.context.save();
          matrix.multiplyMatrix( child._transform.getMatrix() );
          matrix.canvasSetTransform( wrapper.context );
          if ( requiresScratchCanvas ) {
            var canvas = document.createElement( 'canvas' );
            canvas.width = wrapper.canvas.width;
            canvas.height = wrapper.canvas.height;
            var context = canvas.getContext( '2d' );
            var childWrapper = new scenery.CanvasContextWrapper( canvas, context );

            matrix.canvasSetTransform( context );

            child.renderToCanvasSubtree( childWrapper, matrix );

            wrapper.context.save();
            if ( child._clipArea ) {
              wrapper.context.beginPath();
              child._clipArea.writeToContext( wrapper.context );
              wrapper.context.clip();
            }
            wrapper.context.setTransform( 1, 0, 0, 1, 0, 0 ); // identity
            wrapper.context.globalAlpha = child._opacity;
            wrapper.context.drawImage( canvas, 0, 0 );
            wrapper.context.restore();
          }
          else {
            child.renderToCanvasSubtree( wrapper, matrix );
          }
          matrix.multiplyMatrix( child._transform.getInverse() );
          wrapper.context.restore();
        }
      }
    },

    /**
     * @deprecated
     * Render this node to the Canvas (clearing it first)
     * @public
     *
     * @param {HTMLCanvasElement} canvas
     * @param {CanvasRenderingContext2D} context
     * @param {Function} callback - Called with no arguments
     * @param {string} [backgroundColor]
     */
    // @public (API compatibility for now): Render this node to the Canvas (clearing it first)
    renderToCanvas: function( canvas, context, callback, backgroundColor ) {
      // should basically reset everything (and clear the Canvas)
      canvas.width = canvas.width;

      if ( backgroundColor ) {
        context.fillStyle = backgroundColor;
        context.fillRect( 0, 0, canvas.width, canvas.height );
      }

      var wrapper = new scenery.CanvasContextWrapper( canvas, context );

      this.renderToCanvasSubtree( wrapper, Matrix3.identity() );

      callback && callback(); // this was originally asynchronous, so we had a callback
    },

    /**
     * Renders this node to a canvas. If toCanvas( callback ) is used, the canvas will contain the node's
     * entire bounds (if no x/y/width/height is provided)
     * @public
     *
     * @param {Function} callback - callback( canvas, x, y, width, height ) is called, where x,y are computed if not specified.
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toCanvas: function( callback, x, y, width, height ) {
      assert && assert( typeof callback === 'function' );
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );

      var padding = 2; // padding used if x and y are not set

      // for now, we add an unpleasant hack around Text and safe bounds in general. We don't want to add another Bounds2 object per Node for now.
      var bounds = this.getBounds().union( this.localToParentBounds( this.getSafeSelfBounds() ) );
      assert && assert( !bounds.isEmpty() ||
                        ( x !== undefined && y !== undefined && width !== undefined && height !== undefined ),
        'Should not call toCanvas on a Node with empty bounds, unless all dimensions are provided' );

      x = x !== undefined ? x : Math.ceil( padding - bounds.minX );
      y = y !== undefined ? y : Math.ceil( padding - bounds.minY );
      width = width !== undefined ? width : Math.ceil( bounds.getWidth() + 2 * padding );
      height = height !== undefined ? height : Math.ceil( bounds.getHeight() + 2 * padding );

      var canvas = document.createElement( 'canvas' );
      canvas.width = width;
      canvas.height = height;
      var context = canvas.getContext( '2d' );

      // shift our rendering over by the desired amount
      context.translate( x, y );

      // for API compatibility, we apply our own transform here
      this._transform.getMatrix().canvasAppendTransform( context );

      var wrapper = new scenery.CanvasContextWrapper( canvas, context );

      this.renderToCanvasSubtree( wrapper, Matrix3.translation( x, y ).timesMatrix( this._transform.getMatrix() ) );

      callback( canvas, x, y, width, height ); // we used to be asynchronous
    },

    /**
     * Renders this node to a Canvas, then calls the callback with the data URI from it.
     * @public
     *
     * @param {Function} callback - callback( dataURI {string}, x, y, width, height ) is called, where x,y are computed if not specified.
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toDataURL: function( callback, x, y, width, height ) {
      assert && assert( typeof callback === 'function' );
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );

      this.toCanvas( function( canvas, x, y, width, height ) {
        // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined
        callback( canvas.toDataURL(), x, y, width, height );
      }, x, y, width, height );
    },

    /**
     * Calls the callback with an HTMLImageElement that contains this Node's subtree's visual form.
     * Will always be asynchronous.
     * @public
     *
     * @param {Function} callback - callback( image {HTMLImageElement}, x, y ) is called
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toImage: function( callback, x, y, width, height ) {
      assert && assert( typeof callback === 'function' );
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );

      this.toDataURL( function( url, x, y ) {
        // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined
        var img = document.createElement( 'img' );
        img.onload = function() {
          callback( img, x, y );
          try {
            delete img.onload;
          }
          catch( e ) {
            // do nothing
          } // fails on Safari 5.1
        };
        img.src = url;
      }, x, y, width, height );
    },

    /**
     * Calls the callback with an Image node that contains this Node's subtree's visual form. This is always
     * asynchronous, but the resulting image node can be used with any back-end (Canvas/WebGL/SVG/etc.)
     * @public
     *
     * @param {Function} callback - callback( imageNode {Image} ) is called
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toImageNodeAsynchronous: function( callback, x, y, width, height ) {
      assert && assert( typeof callback === 'function' );
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );

      this.toImage( function( image, x, y ) {
        callback( new scenery.Node( {
          children: [
            new scenery.Image( image, { x: -x, y: -y } )
          ]
        } ) );
      }, x, y, width, height );
    },

    /**
     * Creates a Node containing an Image node that contains this Node's subtree's visual form. This is always
     * synchronous, but the resulting image node can ONLY used with Canvas/WebGL (NOT SVG).
     * @public
     *
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toCanvasNodeSynchronous: function( x, y, width, height ) {
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );

      var result = null;
      this.toCanvas( function( canvas, x, y ) {
        result = new scenery.Node( {
          children: [
            new scenery.Image( canvas, { x: -x, y: -y } )
          ]
        } );
      }, x, y, width, height );
      assert && assert( result, 'toCanvasNodeSynchronous requires that the node can be rendered only using Canvas' );
      return result;
    },

    /**
     * Returns an Image that renders this Node. This is always synchronous, and sets initialWidth/initialHeight so that
     * we have the bounds immediately.  Use this method if you need to reduce the number of parent Nodes.
     *
     * NOTE: the resultant Image should be positioned using its bounds rather than (x,y).  To create a Node that can be
     * positioned like any other node, please use toDataURLNodeSynchronous.
     * @public
     *
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toDataURLImageSynchronous: function( x, y, width, height ) {
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );

      var result;
      this.toDataURL( function( dataURL, x, y, width, height ) {
        result = new scenery.Image( dataURL, { x: -x, y: -y, initialWidth: width, initialHeight: height } );
      }, x, y, width, height );
      assert && assert( result, 'toDataURL failed to return a result synchronously' );
      return result;
    },

    /**
     * Returns a Node that contains this Node's subtree's visual form. This is always synchronous, and sets
     * initialWidth/initialHeight so that we have the bounds immediately.  An extra wrapper Node is provided
     * so that transforms can be done independently.  Use this method if you need to be able to transform the node
     * the same way as if it had not been rasterized.
     * @public
     *
     * @param {number} [x] - The X offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [y] - The Y offset for where the upper-left of the content drawn into the Canvas
     * @param {number} [width] - The width of the Canvas output
     * @param {number} [height] - The height of the Canvas output
     */
    toDataURLNodeSynchronous: function( x, y, width, height ) {
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );

      return new scenery.Node( {
        children: [
          this.toDataURLImageSynchronous( x, y, width, height )
        ]
      } );
    },

    /**
     * Creates a DOM drawable for this Node's self representation.
     * @public (scenery-internal)
     *
     * Implemented by subtypes that support DOM self drawables. There is no need to implement this for subtypes that
     * do not allow the DOM renderer (not set in its rendererBitmask).
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {DOMSelfDrawable}
     */
    createDOMDrawable: function( renderer, instance ) {
      throw new Error( 'createDOMDrawable is abstract. The subtype should either override this method, or not support the DOM renderer' );
    },

    /**
     * Creates an SVG drawable for this Node's self representation.
     * @public (scenery-internal)
     *
     * Implemented by subtypes that support SVG self drawables. There is no need to implement this for subtypes that
     * do not allow the SVG renderer (not set in its rendererBitmask).
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {SVGSelfDrawable}
     */
    createSVGDrawable: function( renderer, instance ) {
      throw new Error( 'createSVGDrawable is abstract. The subtype should either override this method, or not support the DOM renderer' );
    },

    /**
     * Creates a Canvas drawable for this Node's self representation.
     * @public (scenery-internal)
     *
     * Implemented by subtypes that support Canvas self drawables. There is no need to implement this for subtypes that
     * do not allow the Canvas renderer (not set in its rendererBitmask).
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {CanvasSelfDrawable}
     */
    createCanvasDrawable: function( renderer, instance ) {
      throw new Error( 'createCanvasDrawable is abstract. The subtype should either override this method, or not support the DOM renderer' );
    },

    /**
     * Creates a WebGL drawable for this Node's self representation.
     * @public (scenery-internal)
     *
     * Implemented by subtypes that support WebGL self drawables. There is no need to implement this for subtypes that
     * do not allow the WebGL renderer (not set in its rendererBitmask).
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {WebGLSelfDrawable}
     */
    createWebGLDrawable: function( renderer, instance ) {
      throw new Error( 'createWebGLDrawable is abstract. The subtype should either override this method, or not support the DOM renderer' );
    },

    /*---------------------------------------------------------------------------*
     * Instance handling
     *----------------------------------------------------------------------------*/

    /**
     * Returns a reference to the instances array.
     * @public (scenery-internal)
     *
     * @returns {Array.<Instance>}
     */
    getInstances: function() {
      return this._instances;
    },
    get instances() { return this.getInstances(); },

    /**
     * Adds an Instance reference to our array.
     * @public (scenery-internal)
     *
     * @param {Instance} instance
     */
    addInstance: function( instance ) {
      assert && assert( instance instanceof scenery.Instance );
      this._instances.push( instance );
    },

    /**
     * Removes an Instance reference from our array.
     * @public (scenery-internal)
     *
     * @param {Instance} instance
     */
    removeInstance: function( instance ) {
      assert && assert( instance instanceof scenery.Instance );
      var index = _.indexOf( this._instances, instance );
      assert && assert( index !== -1, 'Cannot remove a Instance from a Node if it was not there' );
      this._instances.splice( index, 1 );
    },

    /*---------------------------------------------------------------------------*
     * Accessible Instance handling
     *----------------------------------------------------------------------------*/

    /**
     * Returns a reference to the accessible instances array.
     * @public (scenery-internal)
     *
     * @returns {Array.<AccessibleInstance>}
     */
    getAccessibleInstances: function() {
      return this._accessibleInstances;
    },
    get accessibleInstances() { return this.getAccessibleInstances(); },

    /**
     * Adds an AccessibleInstance reference to our array.
     * @public (scenery-internal)
     *
     * @param {AccessibleInstance} accessibleInstance
     */
    addAccessibleInstance: function( accessibleInstance ) {
      assert && assert( accessibleInstance instanceof scenery.AccessibleInstance );
      this._accessibleInstances.push( accessibleInstance );
    },

    /**
     * Removes an AccessibleInstance reference from our array.
     * @public (scenery-internal)
     *
     * @param {AccessibleInstance} accessibleInstance
     */
    removeAccessibleInstance: function( accessibleInstance ) {
      assert && assert( accessibleInstance instanceof scenery.AccessibleInstance );
      var index = _.indexOf( this._accessibleInstances, accessibleInstance );
      assert && assert( index !== -1, 'Cannot remove an AccessibleInstance from a Node if it was not there' );
      this._accessibleInstances.splice( index, 1 );
    },

    /*---------------------------------------------------------------------------*
     * Display handling
     *----------------------------------------------------------------------------*/

    /**
     * Returns a reference to the display array.
     * @public (scenery-internal)
     *
     * @returns {Array.<Display>}
     */
    getRootedDisplays: function() {
      return this._rootedDisplays;
    },
    get rootedDisplays() { return this.getRootedDisplays(); },

    /**
     * Adds an display reference to our array.
     * @public (scenery-internal)
     *
     * @param {Display} display
     */
    addRootedDisplay: function( display ) {
      assert && assert( display instanceof scenery.Display );
      this._rootedDisplays.push( display );
    },

    /**
     * Removes a Display reference from our array.
     * @public (scenery-internal)
     *
     * @param {Display} display
     */
    removeRootedDisplay: function( display ) {
      assert && assert( display instanceof scenery.Display );
      var index = _.indexOf( this._rootedDisplays, display );
      assert && assert( index !== -1, 'Cannot remove a Display from a Node if it was not there' );
      this._rootedDisplays.splice( index, 1 );
    },

    /*---------------------------------------------------------------------------*
     * Coordinate transform methods
     *----------------------------------------------------------------------------*/

    /**
     * Returns a point transformed from our local coordinate frame into our parent coordinate frame. Applies our node's
     * transform to it.
     * @public
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    localToParentPoint: function( point ) {
      return this._transform.transformPosition2( point );
    },

    /**
     * Returns bounds transformed from our local coordinate frame into our parent coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    localToParentBounds: function( bounds ) {
      return this._transform.transformBounds2( bounds );
    },

    /**
     * Returns a point transformed from our parent coordinate frame into our local coordinate frame. Applies the inverse
     * of our node's transform to it.
     * @public
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    parentToLocalPoint: function( point ) {
      return this._transform.inversePosition2( point );
    },

    /**
     * Returns bounds transformed from our parent coordinate frame into our local coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    parentToLocalBounds: function( bounds ) {
      return this._transform.inverseBounds2( bounds );
    },

    /**
     * A mutable-optimized form of localToParentBounds() that will modify the provided bounds, transforming it from our
     * local coordinate frame to our parent coordinate frame.
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2} - The same bounds object.
     */
    transformBoundsFromLocalToParent: function( bounds ) {
      return bounds.transform( this._transform.getMatrix() );
    },

    /**
     * A mutable-optimized form of parentToLocalBounds() that will modify the provided bounds, transforming it from our
     * parent coordinate frame to our local coordinate frame.
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2} - The same bounds object.
     */
    transformBoundsFromParentToLocal: function( bounds ) {
      return bounds.transform( this._transform.getInverse() );
    },

    /**
     * Returns a new matrix (fresh copy) that would transform points from our local coordinate frame to the global
     * coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @returns {Matrix3}
     */
    getLocalToGlobalMatrix: function() {
      var node = this; // eslint-disable-line consistent-this

      // we need to apply the transformations in the reverse order, so we temporarily store them
      var matrices = [];

      // concatenation like this has been faster than getting a unique trail, getting its transform, and applying it
      while ( node ) {
        matrices.push( node._transform.getMatrix() );
        assert && assert( node._parents[ 1 ] === undefined, 'getLocalToGlobalMatrix unable to work for DAG' );
        node = node._parents[ 0 ];
      }

      var matrix = Matrix3.identity(); // will be modified in place

      // iterate from the back forwards (from the root node to here)
      for ( var i = matrices.length - 1; i >= 0; i-- ) {
        matrix.multiplyMatrix( matrices[ i ] );
      }

      // NOTE: always return a fresh copy, getGlobalToLocalMatrix depends on it to minimize instance usage!
      return matrix;
    },

    /**
     * Returns a Transform3 that would transform things from our local coordinate frame to the global coordinate frame.
     * Equivalent to getUniqueTrail().getTransform(), but faster.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @returns {Transform3}
     */
    getUniqueTransform: function() {
      return new Transform3( this.getLocalToGlobalMatrix() );
    },

    /**
     * Returns a new matrix (fresh copy) that would transform points from the global coordinate frame to our local
     * coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @returns {Matrix3}
     */
    getGlobalToLocalMatrix: function() {
      return this.getLocalToGlobalMatrix().invert();
    },

    /**
     * Transforms a point from our local coordinate frame to the global coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    localToGlobalPoint: function( point ) {
      var node = this; // eslint-disable-line consistent-this
      var resultPoint = point.copy();
      while ( node ) {
        // in-place multiplication
        node._transform.getMatrix().multiplyVector2( resultPoint );
        assert && assert( node._parents[ 1 ] === undefined, 'localToGlobalPoint unable to work for DAG' );
        node = node._parents[ 0 ];
      }
      return resultPoint;
    },

    /**
     * Transforms a point from the global coordinate frame to our local coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    globalToLocalPoint: function( point ) {
      var node = this; // eslint-disable-line consistent-this
      // TODO: performance: test whether it is faster to get a total transform and then invert (won't compute individual inverses)

      // we need to apply the transformations in the reverse order, so we temporarily store them
      var transforms = [];
      while ( node ) {
        transforms.push( node._transform );
        assert && assert( node._parents[ 1 ] === undefined, 'globalToLocalPoint unable to work for DAG' );
        node = node._parents[ 0 ];
      }

      // iterate from the back forwards (from the root node to here)
      var resultPoint = point.copy();
      for ( var i = transforms.length - 1; i >= 0; i-- ) {
        // in-place multiplication
        transforms[ i ].getInverse().multiplyVector2( resultPoint );
      }
      return resultPoint;
    },

    /**
     * Transforms bounds from our local coordinate frame to the global coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    localToGlobalBounds: function( bounds ) {
      // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations
      // it also seems to be a bit faster this way
      return bounds.transformed( this.getLocalToGlobalMatrix() );
    },

    /**
     * Transforms bounds from the global coordinate frame to our local coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    globalToLocalBounds: function( bounds ) {
      // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations
      return bounds.transformed( this.getGlobalToLocalMatrix() );
    },

    /**
     * Transforms a point from our parent coordinate frame to the global coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    parentToGlobalPoint: function( point ) {
      assert && assert( this.parents.length <= 1, 'parentToGlobalPoint unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].localToGlobalPoint( point ) : point;
    },

    /**
     * Transforms bounds from our parent coordinate frame to the global coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    parentToGlobalBounds: function( bounds ) {
      assert && assert( this.parents.length <= 1, 'parentToGlobalBounds unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].localToGlobalBounds( bounds ) : bounds;
    },

    /**
     * Transforms a point from the global coordinate frame to our parent coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Vector2} point
     * @returns {Vector2}
     */
    globalToParentPoint: function( point ) {
      assert && assert( this.parents.length <= 1, 'globalToParentPoint unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].globalToLocalPoint( point ) : point;
    },

    /**
     * Transforms bounds from the global coordinate frame to our parent coordinate frame. If it includes a
     * rotation, the resulting bounding box will include every point that could have been in the original bounding box
     * (and it can be expanded).
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * @param {Bounds2} bounds
     * @returns {Bounds2}
     */
    globalToParentBounds: function( bounds ) {
      assert && assert( this.parents.length <= 1, 'globalToParentBounds unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].globalToLocalBounds( bounds ) : bounds;
    },

    /**
     * Returns a bounding box for this Node (and its sub-tree) in the global coordinate frame.
     * @public
     *
     * NOTE: If there are multiple instances of this node (e.g. this or one ancestor has two parents), it will fail
     * with an assertion (since the transform wouldn't be uniquely defined).
     *
     * NOTE: This requires computation of this node's subtree bounds, which may incur some performance loss.
     *
     * @returns {Bounds2}
     */
    getGlobalBounds: function() {
      assert && assert( this.parents.length <= 1, 'globalBounds unable to work for DAG' );
      return this.parentToGlobalBounds( this.getBounds() );
    },
    get globalBounds() { return this.getGlobalBounds(); },

    /**
     * Returns the bounds of any other node in our local coordinate frame.
     *
     * NOTE: If this node or the passed in node have multiple instances (e.g. this or one ancestor has two parents), it will fail
     * with an assertion.
     *
     * TODO: Possible to be well-defined and have multiple instances of each.
     *
     * @param {Node} node
     * @returns {Bounds2}
     */
    boundsOf: function( node ) {
      return this.globalToLocalBounds( node.getGlobalBounds() );
    },

    /**
     * Returns the bounds of this node in another node's local coordinate frame.
     *
     * NOTE: If this node or the passed in node have multiple instances (e.g. this or one ancestor has two parents), it will fail
     * with an assertion.
     *
     * TODO: Possible to be well-defined and have multiple instances of each.
     *
     * @param {Node} node
     * @returns {Bounds2}
     */
    boundsTo: function( node ) {
      return node.globalToLocalBounds( this.getGlobalBounds() );
    },

    /*---------------------------------------------------------------------------*
     * Drawable handling
     *----------------------------------------------------------------------------*/

    /**
     * Adds the drawable to our list of drawables to notify of visual changes.
     * @public (scenery-internal)
     *
     * @param {Drawable} drawable
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    attachDrawable: function( drawable ) {
      this._drawables.push( drawable );
      return this; // allow chaining
    },

    /**
     * Removes the drawable from our list of drawables to notify of visual changes.
     * @public (scenery-internal)
     *
     * @param {Drawable} drawable
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    detachDrawable: function( drawable ) {
      var index = _.indexOf( this._drawables, drawable );

      assert && assert( index >= 0, 'Invalid operation: trying to detach a non-referenced drawable' );

      this._drawables.splice( index, 1 ); // TODO: replace with a remove() function
      return this;
    },

    /**
     * Scans the options object for key names that correspond to ES5 setters or other setter functions, and calls those
     * with the values.
     * @public
     *
     * For example:
     *
     * node.mutate( { top: 0, left: 5 } );
     *
     * will be equivalent to:
     *
     * node.left = 5;
     * node.top = 0;
     *
     * In particular, note that the order is different. Mutators will be applied in the order of _mutatorKeys, which can
     * be added to by subtypes.
     *
     * Additionally, some keys are actually direct function names, like 'scale'. mutate( { scale: 2 } ) will call
     * node.scale( 2 ) instead of activating an ES5 setter directly.
     *
     * @param {Object} [options]
     * @returns {Node} - Returns 'this' reference, for chaining
     */
    mutate: function( options ) {
      if ( !options ) {
        return this;
      }

      assert && assert( Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );

      if ( assert ) {
        assert && assert( _.filter( [ 'translation', 'x', 'left', 'right', 'centerX', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom', 'centerBottom', 'rightBottom' ], function( key ) { return options[ key ] !== undefined; } ).length <= 1,
          'More than one mutation on this Node set the x component, check ' + Object.keys( options ).join( ',' ) );

        assert && assert( _.filter( [ 'translation', 'y', 'top', 'bottom', 'centerY', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom', 'centerBottom', 'rightBottom' ], function( key ) { return options[ key ] !== undefined; } ).length <= 1,
          'More than one mutation on this Node set the y component, check ' + Object.keys( options ).join( ',' ) );
      }

      var self = this;

      _.each( this._mutatorKeys, function( key ) {
        // See https://github.com/phetsims/scenery/issues/580 for more about passing undefined.
        assert && assert( !options.hasOwnProperty( key ) || options[ key ] !== undefined || key === 'phetioType',
          'Undefined not allowed for Node key: ' + key );

        if ( options[ key ] !== undefined ) {
          var descriptor = Object.getOwnPropertyDescriptor( Node.prototype, key );

          // if the key refers to a function that is not ES5 writable, it will execute that function with the single argument
          if ( descriptor && typeof descriptor.value === 'function' ) {
            self[ key ]( options[ key ] );
          }
          else {
            self[ key ] = options[ key ];
          }
        }
      } );

      return this; // allow chaining
    },

    /**
     * Whether this Node has been disposed.
     * @public
     *
     * @returns {boolean}
     */
    isDisposed: function() {
      return this._isDisposed;
    },
    get disposed() { return this.isDisposed(); },

    /**
     * Override for extra information in the fing output (from Display.getDebugHTML()).
     * @protected (scenery-internal)
     *
     * @returns {string}
     */
    getDebugHTMLExtras: function() {
      return '';
    },

    /**
     * Makes this Node's subtree available for inspection.
     * @public
     */
    inspect: function() {
      localStorage.scenerySnapshot = JSON.stringify( {
        type: 'Subtree',
        rootNodeId: this.id,
        nodes: scenery.serializeConnectedNodes( this )
      } );
    },

    /**
     * Returns a debugging string that is an attempted serialization of this node's sub-tree.
     * @public
     *
     * @param {string} spaces - Whitespace to add
     * @param {boolean} [includeChildren]
     */
    toString: function( spaces, includeChildren ) {
      return this.constructor.name + '#' + this.id;
    },

    /**
     * Performs checks to see if the internal state of Instance references is correct at a certain point in/after the
     * Display's updateDisplay().
     * @private
     */
    auditInstanceSubtreeForDisplay: function( display ) {
      if ( assertSlow ) {
        var numInstances = this._instances.length;
        for ( var i = 0; i < numInstances; i++ ) {
          var instance = this._instances[ i ];
          if ( instance.display === display ) {
            assertSlow( instance.trail.isValid(),
              'Invalid trail on Instance: ' + instance.toString() + ' with trail ' + instance.trail.toString() );
          }
        }

        // audit all of the children
        this.children.forEach( function( child ) {
          child.auditInstanceSubtreeForDisplay( display );
        } );
      }
    },

    /**
     * Tracks when an event listener is added, so that we can prune hit testing for performance.
     * @private
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    onEventListenerAdded: function( eventName, listener ) {
      if ( eventName in eventsRequiringBoundsValidation ) {
        this.changeBoundsEventCount( 1 );
        this._boundsEventSelfCount++;
      }
    },

    /**
     * Tracks when an event listener is removed, so that we can prune hit testing for performance.
     * @private
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    onEventListenerRemoved: function( eventName, listener ) {
      if ( eventName in eventsRequiringBoundsValidation ) {
        this.changeBoundsEventCount( -1 );
        this._boundsEventSelfCount--;
      }
    }
  }, Events.prototype, {
    /**
     * Adds a listener for a specific event name. Overridden so we can track specific types of listeners.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    on: function onOverride( eventName, listener ) {
      Events.prototype.on.call( this, eventName, listener );
      this.onEventListenerAdded( eventName, listener );
    },

    /**
     * Adds a listener for a specific event name, that guarantees it won't trigger changes to the listener list when
     * the listener is called. Overridden so we can track specific types of listeners.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    onStatic: function onStaticOverride( eventName, listener ) {
      Events.prototype.onStatic.call( this, eventName, listener );
      this.onEventListenerAdded( eventName, listener );
    },

    /**
     * Removes a listener for a specific event name. Overridden so we can track specific types of listeners.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    off: function offOverride( eventName, listener ) {
      var index = Events.prototype.off.call( this, eventName, listener );
      assert && assert( index >= 0, 'Node.off was called but no listener was removed' );
      this.onEventListenerRemoved( eventName, listener );
      return index;
    },

    /**
     * Removes a listener for a specific event name, that guarantees it won't trigger changes to the listener list when
     * the listener is called. Overridden so we can track specific types of listeners.
     * @public
     *
     * @param {string} eventName
     * @param {Function} listener
     */
    offStatic: function offStaticOverride( eventName, listener ) {
      var index = Events.prototype.offStatic.call( this, eventName, listener );
      assert && assert( index >= 0, 'Node.offStatic was called but no listener was removed' );
      this.onEventListenerRemoved( eventName, listener );
      return index;
    },

    /**
     * Disposes the node, releasing all references that it maintained.
     * @public
     */
    dispose: function() {
      // See constructor for Node disposal checks
      this._isDisposed = true;

      // When disposing, remove all children and parents. See https://github.com/phetsims/scenery/issues/629
      this.removeAllChildren();
      this.detach();

      Events.prototype.dispose.call( this ); // TODO: don't rely on Events

      if ( this._tandem ) {
        this._tandem.removeInstance( this );
        this._tandem = null;
      }
    },

    /**
     * Disposes this node and all other descendant nodes.
     * @public
     *
     * NOTE: Use with caution, as you should not re-use any Node touched by this. Not compatible with most DAG
     *       techniques.
     */
    disposeSubtree: function() {
      if ( !this.isDisposed() ) {
        // makes a copy before disposing
        var children = this.children;

        this.dispose();

        for ( var i = 0; i < children.length; i++ ) {
          children[ i ].disposeSubtree();
        }
      }
    }
  } ) );

  Node.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

  // mixin accessibility
  Accessibility.mixin( Node );

  return Node;
} );

// Copyright 2016-2017, University of Colorado Boulder

/**
 * A Node that will align child (content) node within a specific bounding box.
 *
 * If a custom alignBounds is provided, content will be aligned within that bounding box. Otherwise, it will be aligned
 * within a bounding box with the left-top corner of (0,0) of the necessary size to include both the content and
 * all of the margins.
 *
 * There are four margins: left, right, top, bottom. They can be set independently, or multiple can be set at the
 * same time (xMargin, yMargin and margin).
 *
 * NOTE: AlignBox resize may not happen immediately, and may be delayed until bounds of a alignBox's child occurs.
 *       layout updates can be forced with invalidateAlignment(). If the alignBox's content that changed is connected
 *       to a Scenery display, its bounds will update when Display.updateDisplay() will called, so this will guarantee
 *       that the layout will be applied before it is displayed. alignBox.getBounds() will not force a refresh, and
 *       may return stale bounds.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/AlignBox',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );

  var ALIGNMENT_CONTAINER_OPTION_KEYS = [
    'alignBounds', // {Bounds2|null} - See setAlignBounds() for more documentation
    'xAlign', // {string} - 'left', 'center', or 'right', see setXAlign() for more documentation
    'yAlign', // {string} - 'top', 'center', or 'bottom', see setYAlign() for more documentation
    'margin', // {number} - Sets all margins, see setMargin() for more documentation
    'xMargin', // {number} - Sets horizontal margins, see setXMargin() for more documentation
    'yMargin', // {number} - Sets vertical margins, see setYMargin() for more documentation
    'leftMargin', // {number} - Sets left margin, see setLeftMargin() for more documentation
    'rightMargin', // {number} - Sets right margin, see setRightMargin() for more documentation
    'topMargin', // {number} - Sets top margin, see setTopMargin() for more documentation
    'bottomMargin', // {number} - Sets bottom margin, see setBottomMargin() for more documentation
    'group' // {AlignGroup|null} - Share bounds with others, see setGroup() for more documentation
  ];

  /**
   * An individual container for an alignment group. Will maintain its size to match that of the group by overriding
   * its localBounds, and will position its content inside its localBounds by respecting its alignment and margins.
   * @constructor
   * @public
   *
   * @param {Node} content - Content to align inside of the alignBox
   * @param {Object} [options] - AlignBox-specific options are documented in ALIGNMENT_CONTAINER_OPTION_KEYS
   *                             above, and can be provided along-side options for Node
   */
  function AlignBox( content, options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );

    // @private {Node} - Our actual content
    this._content = content;

    // @private {Bounds2|null} - Controls the bounds in which content is aligned.
    this._alignBounds = null;

    // @private {string} - How to align the content when the alignBounds are larger than our content with its margins.
    this._xAlign = 'center';
    this._yAlign = 'center';

    // @private {number} - How much space should be on each side.
    this._leftMargin = 0;
    this._rightMargin = 0;
    this._topMargin = 0;
    this._bottomMargin = 0;

    // @private {AlignGroup|null} - If available, an AlignGroup that will control our alignBounds
    this._group = null;

    // @private {function} - Callback for when bounds change (takes no arguments)
    this._contentBoundsListener = this.invalidateAlignment.bind( this );

    // @private {boolean} - Used to prevent loops
    this._layoutLock = false;

    // Will be removed by dispose()
    this._content.on( 'bounds', this._contentBoundsListener );

    Node.call( this, _.extend( {}, options, {
      children: [ this._content ]
    } ) );
  }

  scenery.register( 'AlignBox', AlignBox );

  inherit( Node, AlignBox, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: ALIGNMENT_CONTAINER_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),

    /**
     * Triggers recomputation of the alignment. Should be called if it needs to be refreshed.
     * @public
     *
     * NOTE: alignBox.getBounds() will not trigger a bounds validation for our content, and thus WILL NOT trigger
     * layout. content.getBounds() should trigger it, but invalidateAligment() is the preferred method for forcing a
     * re-check.
     */
    invalidateAlignment: function() {
      sceneryLog && sceneryLog.AlignBox && sceneryLog.AlignBox( 'AlignBox#' + this.id + ' invalidateAlignment' );
      sceneryLog && sceneryLog.AlignBox && sceneryLog.push();

      // The group update will change our alignBounds if required.
      if ( this._group ) {
        this._group.onAlignBoxResized( this );
      }

      // If the alignBounds didn't change, we'll still need to update our own layout
      this.updateLayout();

      sceneryLog && sceneryLog.AlignBox && sceneryLog.pop();
    },

    /**
     * Sets the alignment bounds (the bounds in which our content will be aligned). If null, AlignBox will act
     * as if the alignment bounds have a left-top corner of (0,0) and with a width/height that fits the content and
     * bounds.
     * @public
     *
     * NOTE: If the group is a valid AlignGroup, it will be responsible for setting the alignBounds.
     *
     * @param {Bounds2|null} alignBounds
     * @returns {AlignBox} - For chaining
     */
    setAlignBounds: function( alignBounds ) {
      assert && assert( alignBounds === null || ( alignBounds instanceof Bounds2 && !alignBounds.isEmpty() && alignBounds.isFinite() ),
        'alignBounds should be a non-empty finite Bounds2' );

      // See if the bounds have changed. If both are Bounds2 with the same value, we won't update it.
      if ( this._alignBounds !== alignBounds &&
           ( !alignBounds ||
             !this._alignBounds ||
             !alignBounds.equals( this._alignBounds ) ) ) {
        this._alignBounds = alignBounds;

        this.updateLayout();
      }
      return this;
    },
    set alignBounds( value ) { this.setAlignBounds( value ); },

    /**
     * Returns the current alignment bounds (if available, see setAlignBounds for details).
     * @public
     *
     * @returns {Bounds2|null}
     */
    getAlignBounds: function() {
      return this._alignBounds;
    },
    get alignBounds() { return this.getAlignBounds(); },

    /**
     * Sets the attachment to an AlignGroup. When attached, our alignBounds will be controlled by the group.
     * @public
     *
     * @param {AlignGroup|null} group
     * @returns {AlignBox} - For chaining
     */
    setGroup: function( group ) {
      assert && assert( group === null || group instanceof scenery.AlignGroup, 'group should be an AlignGroup' );

      if ( this._group !== group ) {
        // Remove from a previous group
        if ( this._group ) {
          this._group.removeAlignBox( this );
        }

        this._group = group;

        // Add to a new group
        if ( this._group ) {
          this._group.addAlignBox( this );
        }
      }

      return this;
    },
    set group( value ) { this.setGroup( value ); },

    /**
     * Returns the attached alignment group (if one exists), or null otherwise.
     * @public
     *
     * @returns {AlignGroup|null}
     */
    getGroup: function() {
      return this._group;
    },
    get group() { return this.getGroup(); },

    /**
     * Sets the horizontal alignment of this box.
     * @public
     *
     * Available values are 'left', 'center', or 'right'.
     *
     * @param {string} xAlign
     * @returns {AlignBox} - For chaining
     */
    setXAlign: function( xAlign ) {
      assert && assert( xAlign === 'left' || xAlign === 'center' || xAlign === 'right',
        'xAlign should be one of: \'left\', \'center\', or \'right\'' );

      if ( this._xAlign !== xAlign ) {
        this._xAlign = xAlign;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set xAlign( value ) { this.setXAlign( value ); },

    /**
     * Returns the current horizontal alignment of this box.
     * @public
     *
     * @returns {string} - See setXAlign for values.
     */
    getXAlign: function() {
      return this._xAlign;
    },
    get xAlign() { return this.getXAlign(); },

    /**
     * Sets the vertical alignment of this box.
     * @public
     *
     * Available values are 'top', 'center', or 'bottom'.
     *
     * @param {string} yAlign
     * @returns {AlignBox} - For chaining
     */
    setYAlign: function( yAlign ) {
      assert && assert( yAlign === 'top' || yAlign === 'center' || yAlign === 'bottom',
        'yAlign should be one of: \'top\', \'center\', or \'bottom\'' );

      if ( this._yAlign !== yAlign ) {
        this._yAlign = yAlign;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set yAlign( value ) { this.setYAlign( value ); },

    /**
     * Returns the current vertical alignment of this box.
     * @public
     *
     * @returns {string} - See setYAlign for values.
     */
    getYAlign: function() {
      return this._yAlign;
    },
    get yAlign() { return this.getYAlign(); },

    /**
     * Sets the margin of this box (setting margin values for all sides at once).
     * @public
     *
     * This margin is the minimum amount of horizontal space that will exist between the content the sides of this
     * box.
     *
     * @param {number} margin
     * @returns {AlignBox} - For chaining
     */
    setMargin: function( margin ) {
      assert && assert( typeof margin === 'number' && isFinite( margin ) && margin >= 0,
        'margin should be a finite non-negative number' );

      if ( this._leftMargin !== margin ||
           this._rightMargin !== margin ||
           this._topMargin !== margin ||
           this._bottomMargin !== margin ) {
        this._leftMargin = this._rightMargin = this._topMargin = this._bottomMargin = margin;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set margin( value ) { this.setMargin( value ); },

    /**
     * Returns the current margin of this box (assuming all margin values are the same).
     * @public
     *
     * @returns {number} - See setMargin for more information.
     */
    getMargin: function() {
      assert && assert( this._leftMargin === this._rightMargin &&
                        this._leftMargin === this._topMargin &&
                        this._leftMargin === this._bottomMargin,
        'Getting margin does not have a unique result if the left and right margins are different' );
      return this._leftMargin;
    },
    get margin() { return this.getMargin(); },

    /**
     * Sets the horizontal margin of this box (setting both left and right margins at once).
     * @public
     *
     * This margin is the minimum amount of horizontal space that will exist between the content and the left and
     * right sides of this box.
     *
     * @param {number} xMargin
     * @returns {AlignBox} - For chaining
     */
    setXMargin: function( xMargin ) {
      assert && assert( typeof xMargin === 'number' && isFinite( xMargin ) && xMargin >= 0,
        'xMargin should be a finite non-negative number' );

      if ( this._leftMargin !== xMargin || this._rightMargin !== xMargin ) {
        this._leftMargin = this._rightMargin = xMargin;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set xMargin( value ) { this.setXMargin( value ); },

    /**
     * Returns the current horizontal margin of this box (assuming the left and right margins are the same).
     * @public
     *
     * @returns {number} - See setXMargin for more information.
     */
    getXMargin: function() {
      assert && assert( this._leftMargin === this._rightMargin,
        'Getting xMargin does not have a unique result if the left and right margins are different' );
      return this._leftMargin;
    },
    get xMargin() { return this.getXMargin(); },

    /**
     * Sets the vertical margin of this box (setting both top and bottom margins at once).
     * @public
     *
     * This margin is the minimum amount of vertical space that will exist between the content and the top and
     * bottom sides of this box.
     *
     * @param {number} yMargin
     * @returns {AlignBox} - For chaining
     */
    setYMargin: function( yMargin ) {
      assert && assert( typeof yMargin === 'number' && isFinite( yMargin ) && yMargin >= 0,
        'yMargin should be a finite non-negative number' );

      if ( this._topMargin !== yMargin || this._bottomMargin !== yMargin ) {
        this._topMargin = this._bottomMargin = yMargin;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set yMargin( value ) { this.setYMargin( value ); },

    /**
     * Returns the current vertical margin of this box (assuming the top and bottom margins are the same).
     * @public
     *
     * @returns {number} - See setYMargin for more information.
     */
    getYMargin: function() {
      assert && assert( this._topMargin === this._bottomMargin,
        'Getting yMargin does not have a unique result if the top and bottom margins are different' );
      return this._topMargin;
    },
    get yMargin() { return this.getYMargin(); },

    /**
     * Sets the left margin of this box.
     * @public
     *
     * This margin is the minimum amount of horizontal space that will exist between the content and the left side of
     * the box.
     *
     * @param {number} leftMargin
     * @returns {AlignBox} - For chaining
     */
    setLeftMargin: function( leftMargin ) {
      assert && assert( typeof leftMargin === 'number' && isFinite( leftMargin ) && leftMargin >= 0,
        'leftMargin should be a finite non-negative number' );

      if ( this._leftMargin !== leftMargin ) {
        this._leftMargin = leftMargin;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set leftMargin( value ) { this.setLeftMargin( value ); },

    /**
     * Returns the current left margin of this box.
     * @public
     *
     * @returns {number} - See setLeftMargin for more information.
     */
    getLeftMargin: function() {
      return this._leftMargin;
    },
    get leftMargin() { return this.getLeftMargin(); },

    /**
     * Sets the right margin of this box.
     * @public
     *
     * This margin is the minimum amount of horizontal space that will exist between the content and the right side of
     * the container.
     *
     * @param {number} rightMargin
     * @returns {AlignBox} - For chaining
     */
    setRightMargin: function( rightMargin ) {
      assert && assert( typeof rightMargin === 'number' && isFinite( rightMargin ) && rightMargin >= 0,
        'rightMargin should be a finite non-negative number' );

      if ( this._rightMargin !== rightMargin ) {
        this._rightMargin = rightMargin;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set rightMargin( value ) { this.setRightMargin( value ); },

    /**
     * Returns the current right margin of this box.
     * @public
     *
     * @returns {number} - See setRightMargin for more information.
     */
    getRightMargin: function() {
      return this._rightMargin;
    },
    get rightMargin() { return this.getRightMargin(); },

    /**
     * Sets the top margin of this box.
     * @public
     *
     * This margin is the minimum amount of vertical space that will exist between the content and the top side of the
     * container.
     *
     * @param {number} topMargin
     * @returns {AlignBox} - For chaining
     */
    setTopMargin: function( topMargin ) {
      assert && assert( typeof topMargin === 'number' && isFinite( topMargin ) && topMargin >= 0,
        'topMargin should be a finite non-negative number' );

      if ( this._topMargin !== topMargin ) {
        this._topMargin = topMargin;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set topMargin( value ) { this.setTopMargin( value ); },

    /**
     * Returns the current top margin of this box.
     * @public
     *
     * @returns {number} - See setTopMargin for more information.
     */
    getTopMargin: function() {
      return this._topMargin;
    },
    get topMargin() { return this.getTopMargin(); },

    /**
     * Sets the bottom margin of this box.
     * @public
     *
     * This margin is the minimum amount of vertical space that will exist between the content and the bottom side of the
     * container.
     *
     * @param {number} bottomMargin
     * @returns {AlignBox} - For chaining
     */
    setBottomMargin: function( bottomMargin ) {
      assert && assert( typeof bottomMargin === 'number' && isFinite( bottomMargin ) && bottomMargin >= 0,
        'bottomMargin should be a finite non-negative number' );

      if ( this._bottomMargin !== bottomMargin ) {
        this._bottomMargin = bottomMargin;

        // Trigger re-layout
        this.invalidateAlignment();
      }

      return this;
    },
    set bottomMargin( value ) { this.setBottomMargin( value ); },

    /**
     * Returns the current bottom margin of this box.
     * @public
     *
     * @returns {number} - See setBottomMargin for more information.
     */
    getBottomMargin: function() {
      return this._bottomMargin;
    },
    get bottomMargin() { return this.getBottomMargin(); },

    /**
     * Returns the bounding box of this box's content. This will include any margins.
     * @private
     *
     * @returns {Bounds2}
     */
    getContentBounds: function() {
      sceneryLog && sceneryLog.AlignBox && sceneryLog.AlignBox( 'AlignBox#' + this.id + ' getContentBounds' );
      sceneryLog && sceneryLog.AlignBox && sceneryLog.push();

      var bounds = this._content.bounds;

      sceneryLog && sceneryLog.AlignBox && sceneryLog.pop();

      return new Bounds2( bounds.left - this._leftMargin,
                          bounds.top - this._topMargin,
                          bounds.right + this._rightMargin,
                          bounds.bottom + this._bottomMargin );
    },

    /**
     * Conditionally updates a certain property of our content's positioning.
     * @private
     *
     * Essentially does the following (but prevents infinite loops by not applying changes if the numbers are very
     * similar):
     * this._content[ propName ] = this.localBounds[ propName ] + offset;
     *
     * @param {string} propName - A positional property on both Node and Bounds2, e.g. 'left'
     * @param {number} offset - Offset to be applied to the localBounds location.
     */
    updateProperty: function( propName, offset ) {
      var currentValue = this._content[ propName ];
      var newValue = this.localBounds[ propName ] + offset;

      // Prevent infinite loops or stack overflows by ignoring tiny changes
      if ( Math.abs( currentValue - newValue ) > 1e-5 ) {
        this._content[ propName ] = newValue;
      }
    },

    /**
     * Updates the layout of this alignment box.
     * @private
     */
    updateLayout: function() {
      if ( this._layoutLock ) { return; }
      this._layoutLock = true;

      sceneryLog && sceneryLog.AlignBox && sceneryLog.AlignBox( 'AlignBox#' + this.id + ' updateLayout' );
      sceneryLog && sceneryLog.AlignBox && sceneryLog.push();

      // If we have alignBounds, use that.
      if ( this._alignBounds !== null ) {
        this.localBounds = this._alignBounds;
      }
      // Otherwise, we'll grab a Bounds2 anchored at the upper-left with our required dimensions.
      else {
        var widthWithMargin = this._leftMargin + this._content.width + this._rightMargin;
        var heightWithMargin = this._topMargin + this._content.height + this._bottomMargin;
        this.localBounds = new Bounds2( 0, 0, widthWithMargin, heightWithMargin );
      }

      // Don't try to lay out empty bounds
      if ( !this._content.localBounds.isEmpty() ) {

        if ( this._xAlign === 'center' ) {
          this.updateProperty( 'centerX', ( this.leftMargin - this.rightMargin ) / 2 );
        }
        else if ( this._xAlign === 'left' ) {
          this.updateProperty( 'left', this._leftMargin );
        }
        else if ( this._xAlign === 'right' ) {
          this.updateProperty( 'right', -this._rightMargin );
        }
        else {
          assert && assert( 'Bad xAlign: ' + this._xAlign );
        }

        if ( this._yAlign === 'center' ) {
          this.updateProperty( 'centerY', ( this.topMargin - this.bottomMargin ) / 2 );
        }
        else if ( this._yAlign === 'top' ) {
          this.updateProperty( 'top', this._topMargin );
        }
        else if ( this._yAlign === 'bottom' ) {
          this.updateProperty( 'bottom', -this._bottomMargin );
        }
        else {
          assert && assert( 'Bad yAlign: ' + this._yAlign );
        }
      }

      sceneryLog && sceneryLog.AlignBox && sceneryLog.pop();

      this._layoutLock = false;
    },

    /**
     * Disposes this box, releasing listeners and any references to an AlignGroup
     * @public
     */
    dispose: function() {
      // Remove our listener
      this._content.off( 'bounds', this._contentBoundsListener );

      // Disconnects from the group
      this.group = null;

      Node.prototype.dispose.call( this );
    }
  } );

  return AlignBox;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Removes a single (the first) matching object from an Array.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/arrayRemove',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  /*
   * @param {Array} arr
   * @param {*} item - The item to remove from the array
   */
  function arrayRemove( arr, item ) {
    assert && assert( arr instanceof Array, 'arrayRemove either takes an Array' );

    var index = _.indexOf( arr, item );
    assert && assert( index >= 0, 'item not found in Array' );

    arr.splice( index, 1 );
  }

  phetCore.register( 'arrayRemove', arrayRemove );

  return arrayRemove;
} );
// Copyright 2016-2016, University of Colorado Boulder

/**
 * A group of alignment boxes that follow the constraints:
 * 1. Every box will have the same bounds, with an upper-left of (0,0)
 * 2. The box sizes will be the smallest possible to fit every box's content (with respective padding).
 * 3. Each box is responsible for positioning its content in its bounds (with customizable alignment and padding).
 *
 * Align boxes can be dynamically created and disposed, and only active boxes will be considered for the bounds.
 *
 * Since many sun components do not support resizing their contents dynamically, you may need to populate the AlignGroup
 * in the order of largest to smallest so that a fixed size container is large enough to contain the largest item.
 *
 * NOTE: Align box resizes may not happen immediately, and may be delayed until bounds of a align box's child occurs.
 *       layout updates can be forced with group.updateLayout(). If the align box's content that changed is connected
 *       to a Scenery display, its bounds will update when Display.updateDisplay() will called, so this will guarantee
 *       that the layout will be applied before it is displayed.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/AlignGroup',['require','SCENERY/nodes/AlignBox','PHET_CORE/arrayRemove','DOT/Bounds2','PHET_CORE/inherit','SCENERY/nodes/Node','AXON/NumberProperty','SCENERY/scenery'],function( require ) {
  'use strict';

  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var arrayRemove = require( 'PHET_CORE/arrayRemove' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var NumberProperty = require( 'AXON/NumberProperty' );
  var scenery = require( 'SCENERY/scenery' );

  var globalId = 1;

  /**
   * Creates an alignment group that can be composed of multiple boxes.
   * @constructor
   * @public
   *
   * Use createBox() to create alignment boxes. You can dispose() individual boxes, or call dispose() on this
   * group to dispose all of them.
   *
   * It is also possible to create AlignBox instances independently and assign their 'group' to this AlignGroup.
   *
   * @param {Object} [options]
   */
  function AlignGroup( options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on options object is a code smell' );

    options = _.extend( {
      matchHorizontal: true, // {boolean} - Whether the boxes should have all matching widths (otherwise it fits to size)
      matchVertical: true  // {boolean} - Whether the boxes should have all matching heights (otherwise it fits to size)
    }, options );

    assert && assert( typeof options.matchHorizontal === 'boolean' );
    assert && assert( typeof options.matchVertical === 'boolean' );

    // @private {Array.<AlignBox>}
    this._alignBoxes = [];

    // @private {boolean}
    this._matchHorizontal = options.matchHorizontal;

    // @private {boolean}
    this._matchVertical = options.matchVertical;

    // @private {boolean} - Gets locked when certain layout is performed.
    this._resizeLock = false;

    // @private {Property.<boolean>}
    this._maxWidthProperty = new NumberProperty( 0 );

    // @private {Property.<boolean>}
    this._maxHeightProperty = new NumberProperty( 0 );

    // @private {number}
    this.id = globalId++;
  }

  scenery.register( 'AlignGroup', AlignGroup );

  inherit( Object, AlignGroup, {
    /**
     * Returns the current maximum width of the grouped content.
     * @public
     *
     * @returns {number} - Non-negative amount of width
     */
    getMaxWidth: function() {
      return this._maxWidthProperty.value;
    },
    get maxWidth() { return this.getMaxWidth(); },

    /**
     * Returns the Property holding the current maximum width of the grouped content.
     * @public
     *
     * @returns {Property.<number>} - Property with a non-negative amount of width
     */
    getMaxWidthProperty: function() {
      return this._maxWidthProperty;
    },
    get maxWidthProperty() { return this.getMaxWidthProperty(); },

    /**
     * Returns the current maximum height of the grouped content.
     * @public
     *
     * @returns {number} - Non-negative amount of height
     */
    getMaxHeight: function() {
      return this._maxHeightProperty.value;
    },
    get maxHeight() { return this.getMaxHeight(); },

    /**
     * Returns the Property holding the current maximum height of the grouped content.
     * @public
     *
     * @returns {Property.<number>} - Property with a non-negative amount of height
     */
    getMaxHeightProperty: function() {
      return this._maxHeightProperty;
    },
    get maxHeightProperty() { return this.getMaxHeightProperty(); },

    /**
     * Creates an alignment box with the given content and options.
     * @public
     *
     * @param {Node} content - Note that the content may be repositioned into place.
     * @param {Object} [options] - See AlignBox's constructor below for specific alignment options (it will be passed
     *                             through to the constructed AlignBox).
     */
    createBox: function( content, options ) {
      assert && assert( content instanceof Node );

      // Setting the group should call our addAlignBox()
      return new AlignBox( content, _.extend( {
        group: this
      }, options ) );
    },

    /**
     * Sets whether the widths of the align boxes should all match. If false, each box will use its preferred width
     * (usually equal to the content width + horizontal margins).
     * @public
     *
     * @param {boolean} matchHorizontal
     * @returns {AlignGroup} - For chaining
     */
    setMatchHorizontal: function( matchHorizontal ) {
      assert && assert( typeof matchHorizontal === 'boolean' );

      if ( this._matchHorizontal !== matchHorizontal ) {
        this._matchHorizontal = matchHorizontal;

        // Update layout, since it will probably change
        this.updateLayout();
      }

      return this;
    },
    set matchHorizontal( value ) { this.setMatchHorizontal( value ); },

    /**
     * Returns whether boxes currently are horizontally matched. See setMatchHorizontal() for details.
     * @public
     *
     * @returns {boolean}
     */
    getMatchHorizontal: function() {
      return this._matchHorizontal;
    },
    get matchHorizontal() { return this.getMatchHorizontal(); },

    /**
     * Sets whether the heights of the align boxes should all match. If false, each box will use its preferred height
     * (usually equal to the content height + vertical margins).
     * @public
     *
     * @param {boolean} matchVertical
     * @returns {AlignGroup} - For chaining
     */
    setMatchVertical: function( matchVertical ) {
      assert && assert( typeof matchVertical === 'boolean' );

      if ( this._matchVertical !== matchVertical ) {
        this._matchVertical = matchVertical;

        // Update layout, since it will probably change
        this.updateLayout();
      }

      return this;
    },
    set matchVertical( value ) { this.setMatchVertical( value ); },

    /**
     * Returns whether boxes currently are vertically matched. See setMatchVertical() for details.
     * @public
     *
     * @returns {boolean}
     */
    getMatchVertical: function() {
      return this._matchVertical;
    },
    get matchVertical() { return this.getMatchVertical(); },

    /**
     * Dispose all of the boxes.
     * @public
     */
    dispose: function() {
      for ( var i = this._alignBoxes.length - 1; i >= 0; i-- ) {
        this._alignBoxes[ i ].dispose();
      }
    },

    /**
     * Updates the localBounds and alignment for each alignBox.
     * @public
     *
     * NOTE: Calling this will usually not be necessary outside of Scenery, but this WILL trigger bounds revalidation
     *       for every alignBox, which can force the layout code to run.
     */
    updateLayout: function() {
      if ( this._resizeLock ) { return; }
      this._resizeLock = true;

      sceneryLog && sceneryLog.AlignGroup && sceneryLog.AlignGroup(
        'AlignGroup#' + this.id + ' updateLayout' );
      sceneryLog && sceneryLog.AlignGroup && sceneryLog.push();

      sceneryLog && sceneryLog.AlignGroup && sceneryLog.AlignGroup( 'AlignGroup computing maximum dimension' );
      sceneryLog && sceneryLog.AlignGroup && sceneryLog.push();

      // Compute the maximum dimension of our alignBoxs' content
      var maxWidth = 0;
      var maxHeight = 0;
      for ( var i = 0; i < this._alignBoxes.length; i++ ) {
        var alignBox = this._alignBoxes[ i ];

        var bounds = alignBox.getContentBounds();

        // Ignore bad bounds
        if ( bounds.isEmpty() || !bounds.isFinite() ) {
          continue;
        }

        maxWidth = Math.max( maxWidth, bounds.width );
        maxHeight = Math.max( maxHeight, bounds.height );
      }

      sceneryLog && sceneryLog.AlignGroup && sceneryLog.pop();
      sceneryLog && sceneryLog.AlignGroup && sceneryLog.AlignGroup( 'AlignGroup applying to boxes' );
      sceneryLog && sceneryLog.AlignGroup && sceneryLog.push();

      this._maxWidthProperty.value = maxWidth;
      this._maxHeightProperty.value = maxHeight;

      if ( maxWidth > 0 && maxHeight > 0 ) {
        // Apply that maximum dimension for each alignBox
        for ( i = 0; i < this._alignBoxes.length; i++ ) {
          this.setBoxBounds( this._alignBoxes[ i ], maxWidth, maxHeight );
        }
      }

      sceneryLog && sceneryLog.AlignGroup && sceneryLog.pop();
      sceneryLog && sceneryLog.AlignGroup && sceneryLog.pop();

      this._resizeLock = false;
    },

    /**
     * Sets a box's bounds based on our maximum dimensions.
     * @private
     *
     * @param {AlignBox} alignBox
     * @param {number} maxWidth
     * @param {number} maxHeight
     */
    setBoxBounds: function( alignBox, maxWidth, maxHeight ) {
      var alignBounds;

      // If we match both dimensions, we don't have to inspect the box's preferred size
      if ( this._matchVertical && this._matchHorizontal ) {
        alignBounds = new Bounds2( 0, 0, maxWidth, maxHeight );
      }
      else {
        // Grab the preferred size
        var contentBounds = alignBox.getContentBounds();

        // Match one orientation
        if ( this._matchVertical ) {
          alignBounds = new Bounds2( 0, 0, contentBounds.width, maxHeight );
        }
        else if ( this._matchHorizontal ) {
          alignBounds = new Bounds2( 0, 0, maxWidth, contentBounds.height );
        }
        // If not matching anything, just use its preferred size
        else {
          alignBounds = contentBounds;
        }
      }

      alignBox.alignBounds = alignBounds;
    },

    /**
     * Lets the group know that the alignBox has had its content resized. Called by the AlignBox
     * @public (scenery-internal)
     *
     * @param {AlignBox} alignBox
     */
    onAlignBoxResized: function( alignBox ) {
      // TODO: in the future, we could only update this specific alignBox if the others don't need updating.
      this.updateLayout();
    },

    /**
     * Adds the AlignBox to the group
     * @private
     *
     * @param {AlignBox} alignBox
     */
    addAlignBox: function( alignBox ) {
      this._alignBoxes.push( alignBox );

      // Trigger an update when a alignBox is added
      this.updateLayout();
    },

    /**
     * Removes the AlignBox from the group
     * @public (scenery-internal)
     *
     * @param {AlignBox} alignBox
     */
    removeAlignBox: function( alignBox ) {
      arrayRemove( this._alignBoxes, alignBox );

      // Trigger an update when a alignBox is removed
      this.updateLayout();
    }
  } );

  return AlignGroup;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Basic width and height, like a Bounds2 but without the location defined.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'DOT/Dimension2',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  require( 'DOT/Bounds2' );

  /**
   * Creates a 2-dimensional size with a width and height
   * @constructor
   * @public
   *
   * @param {number} width
   * @param {number} height
   */
  function Dimension2( width, height ) {
    // @public {number} - Width of the dimension
    this.width = width;

    // @public {number} - Height of the dimension
    this.height = height;
  }

  dot.register( 'Dimension2', Dimension2 );

  inherit( Object, Dimension2, {
    /**
     * Debugging string for the dimension.
     * @public
     *
     * @returns {string}
     */
    toString: function() {
      return '[' + this.width + 'w, ' + this.height + 'h]';
    },

    /**
     * Sets this dimension to be a copy of another dimension.
     * @public
     *
     * This is the mutable form of the function copy(). This will mutate (change) this dimension, in addition to returning
     * this dimension itself.
     *
     * @param {Dimension2} dimension
     * @returns {Dimension2}
     */
    set: function( dimension ) {
      this.width = dimension.width;
      this.height = dimension.height;
      return this;
    },

    /**
     * Sets the width of the dimension, returning this.
     * @public
     *
     * @param {number} width
     * @returns {Dimension2}
     */
    setWidth: function( width ) {
      this.width = width;
      return this;
    },

    /**
     * Sets the height of the dimension, returning this.
     * @public
     *
     * @param {number} height
     * @returns {Dimension2}
     */
    setHeight: function( height ) {
      this.height = height;
      return this;
    },

    /**
     * Creates a copy of this dimension, or if a dimension is passed in, set that dimension's values to ours.
     * @public
     *
     * This is the immutable form of the function set(), if a dimension is provided. This will return a new dimension,
     * and will not modify this dimension.
     *
     * @param {Dimension2} [dimension] - If not provided, creates a new Vector2 with filled in values. Otherwise, fills
     *                                   in the values of the provided dimension so that it equals this dimension.
     * @returns {Dimension2}
     */
    copy: function( dimension ) {
      if ( dimension ) {
        return dimension.set( this );
      }
      else {
        return new Dimension2( this.width, this.height );
      }
    },

    /**
     * Creates a Bounds2 from this dimension based on passing in the minimum (top-left) corner as (x,y).
     * @public
     *
     * @param {number} [x] - Minimum x coordinate of the bounds, or 0 if not provided.
     * @param {number} [y] - Minimum y coordinate of the bounds, or 0 if not provided.
     * @returns {Bounds2}
     */
    toBounds: function( x, y ) {
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      return new dot.Bounds2( x, y, this.width + x, this.height + y );
    },

    /**
     * Exact equality comparison between this dimension and another dimension.
     * @public
     *
     * @param {Dimension2} other
     * @returns {boolean} - Whether the two dimensions have equal width and height
     */
    equals: function( other ) {
      return this.width === other.width && this.height === other.height;
    }
  } );

  return Dimension2;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Creates the namespace for this repository.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'PHETCOMMON/phetcommon',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  // modules
  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'phetcommon' );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Transform between model and view coordinate frames,
 * and provides convenience methods over an actual dot.Transform3
 *
 * Requires that the transform is "aligned", i.e., it can be built only from component-wise translation and scaling.
 * Equivalently, the output x coordinate should not depend on the input y, and the output y shouldn't depend on the
 * input x.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid
 */
define( 'PHETCOMMON/view/ModelViewTransform2',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Matrix3','DOT/Transform3','PHETCOMMON/phetcommon'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var phetcommon = require( 'PHETCOMMON/phetcommon' );

  /**
   * @param matrix
   * @constructor
   */
  function ModelViewTransform2( matrix ) {
    Transform3.call( this, matrix );
  }

  phetcommon.register( 'ModelViewTransform2', ModelViewTransform2 );

  inherit( Transform3, ModelViewTransform2, {

    // @public convenience model => view
    modelToViewPosition: function( point ) { return this.transformPosition2( point ); },
    modelToViewXY: function( x, y ) { return new Vector2( this.modelToViewX( x ), this.modelToViewY( y ) ); },
    modelToViewX: function( x ) { return this.matrix.m00() * x + this.matrix.m02();},
    modelToViewY: function( y ) { return this.matrix.m11() * y + this.matrix.m12();},
    modelToViewDelta: function( vector ) { return this.transformDelta2( vector ); },
    modelToViewNormal: function( normal ) { return this.transformNormal2( normal ); },
    modelToViewDeltaX: function( x ) { return this.transformDeltaX( x ); },
    modelToViewDeltaY: function( y ) { return this.transformDeltaY( y ); },
    modelToViewBounds: function( bounds ) { return this.transformBounds2( bounds ); },
    modelToViewShape: function( shape ) { return this.transformShape( shape ); },
    modelToViewRay: function( ray ) { return this.transformRay2( ray ); },

    // @public convenience view => model
    viewToModelPosition: function( point ) { return this.inversePosition2( point ); },
    viewToModelXY: function( x, y ) { return new Vector2( this.viewToModelX( x ), this.viewToModelY( y ) ); },
    viewToModelX: function( x ) {
      var inverse = this.getInverse();
      return inverse.m00() * x + inverse.m02();
    },
    viewToModelY: function( y ) {
      var inverse = this.getInverse();
      return inverse.m11() * y + inverse.m12();
    },
    viewToModelDelta: function( vector ) { return this.inverseDelta2( vector ); },
    viewToModelDeltaXY: function( x, y ) { return new Vector2( this.viewToModelDeltaX( x ), this.viewToModelDeltaY( y ) ); },
    viewToModelNormal: function( normal ) { return this.inverseNormal2( normal ); },
    viewToModelDeltaX: function( x ) { return this.inverseDeltaX( x ); },
    viewToModelDeltaY: function( y ) { return this.inverseDeltaY( y ); },
    viewToModelBounds: function( bounds ) { return this.inverseBounds2( bounds ); },
    viewToModelShape: function( shape ) { return this.inverseShape( shape ); },
    viewToModelRay: function( ray ) { return this.inverseRay2( ray ); },

    // @public @overrides Transform3.invalidate
    invalidate: function() {
      assert && assert( this.matrix.isAligned(),
        'Our current ModelViewTransform2 implementation will not work with arbitrary rotations.' );

      Transform3.prototype.invalidate.call( this );
    }
  } );

  /*---------------------------------------------------------------------------*
   * Factory methods
   *----------------------------------------------------------------------------*/

  /**
   * Creates a ModelViewTransform that uses the identity transform (i.e. model coordinates are the same as view coordinates)
   * @returns {ModelViewTransform2}
   * @public
   */
  ModelViewTransform2.createIdentity = function() {
    return new ModelViewTransform2( Matrix3.IDENTITY );
  };

  /**
   * Creates a ModelViewTransform that has the specified scale and offset such that
   * view = model * scale + offset
   *
   * @param offset {Vector2} the offset in view coordinates
   * @param scale  {number} the scale to map model to view
   * @returns {ModelViewTransform2}
   * @public
   */
  ModelViewTransform2.createOffsetScaleMapping = function( offset, scale ) {
    return new ModelViewTransform2( Matrix3.affine( scale, 0, 0, scale, offset.x, offset.y ) );
  };

  /**
   * Creates a shearless ModelViewTransform that has the specified scale and offset such that
   * view.x = model.x * xScale + offset.x
   * view.y = model.y * yScale + offset.y
   *
   * @param offset {Vector2} the offset in view coordinates
   * @param xScale {number} the scale to map model to view in the x-dimension
   * @param yScale {number} the scale to map model to view in the y-dimension
   * @returns {ModelViewTransform2}
   * @public
   */
  ModelViewTransform2.createOffsetXYScaleMapping = function( offset, xScale, yScale ) {
    return new ModelViewTransform2( Matrix3.affine( xScale, 0, 0, yScale, offset.x, offset.y ) );
  };

  /**
   * Creates a shearless ModelViewTransform that maps the specified model point to the specified view point, with the given x and y scales.
   *
   * @param modelPoint {Vector2} the reference point in the model which maps to the specified view point
   * @param viewPoint  {Vector2} the reference point in the view
   * @param xScale     {number} the amount to scale in the x direction
   * @param yScale     {number} the amount to scale in the y direction
   * @returns {ModelViewTransform2}
   * @public
   */
  ModelViewTransform2.createSinglePointXYScaleMapping = function( modelPoint, viewPoint, xScale, yScale ) {
    // mx * scale + ox = vx
    // my * scale + oy = vy
    var offsetX = viewPoint.x - modelPoint.x * xScale;
    var offsetY = viewPoint.y - modelPoint.y * yScale;
    return this.createOffsetXYScaleMapping( new Vector2( offsetX, offsetY ), xScale, yScale );
  };

  /**
   * Creates a shearless ModelViewTransform that maps the specified model point to the specified view point, with the given scale factor for both x and y dimensions.
   *
   * @param modelPoint {Vector2} the reference point in the model which maps to the specified view point
   * @param viewPoint  {Vector2} the reference point in the view
   * @param scale      {number} the amount to scale in the x and y directions
   * @returns {ModelViewTransform2}
   * @public
   */
  ModelViewTransform2.createSinglePointScaleMapping = function( modelPoint, viewPoint, scale ) {
    return this.createSinglePointXYScaleMapping( modelPoint, viewPoint, scale, scale );
  };

  /**
   * Creates a shearless ModelViewTransform that maps the specified model point to the specified view point, with the given scale factor for both x and y dimensions,
   * but inverting the y axis so that +y in the model corresponds to -y in the view.
   * Inverting the y axis is commonly necessary since +y is usually up in textbooks and -y is down in pixel coordinates.
   *
   * @param modelPoint {Vector2} the reference point in the model which maps to the specified view point
   * @param viewPoint  {Vector2} the reference point in the view
   * @param scale      {number} the amount to scale in the x and y directions
   * @returns {ModelViewTransform2}
   * @public
   */
  ModelViewTransform2.createSinglePointScaleInvertedYMapping = function( modelPoint, viewPoint, scale ) {
    return this.createSinglePointXYScaleMapping( modelPoint, viewPoint, scale, -scale );
  };

  /**
   * Creates a shearless ModelViewTransform that maps the specified rectangle in the model to the specified rectangle in the view,
   * so that any point x% of the way across and y% down in the model rectangle will be mapped to the corresponding point x% across and y% down in the view rectangle.
   * Linear extrapolation is performed outside of the rectangle bounds.
   *
   * @param modelBounds {Bounds2} the reference rectangle in the model, must have area > 0
   * @param viewBounds  {Bounds2} the reference rectangle in the view, must have area > 0
   * @returns {ModelViewTransform2}
   * @public
   */
  ModelViewTransform2.createRectangleMapping = function( modelBounds, viewBounds ) {
    var m00 = viewBounds.width / modelBounds.width;
    var m02 = viewBounds.x - m00 * modelBounds.x;
    var m11 = viewBounds.height / modelBounds.height;
    var m12 = viewBounds.y - m11 * modelBounds.y;
    return new ModelViewTransform2( Matrix3.affine( m00, 0, 0, m11, m02, m12 ) );
  };

  /**
   * Creates a shearless ModelViewTransform that maps the specified rectangle in the model to the specified rectangle in the view,
   * so that any point x% of the way across and y% down in the model rectangle will be mapped to the corresponding point x% across and (100-y)% down in the view rectangle.
   * Linear extrapolation is performed outside of the rectangle bounds.
   * Inverting the y axis is commonly necessary since +y is usually up in textbooks and -y is down in pixel coordinates.
   *
   * @param modelBounds {Bounds2} the reference rectangle in the model, must have area > 0
   * @param viewBounds  {Bounds2} the reference rectangle in the view, must have area > 0
   * @returns {ModelViewTransform2}
   * @public
   */
  ModelViewTransform2.createRectangleInvertedYMapping = function( modelBounds, viewBounds ) {
    var m00 = viewBounds.width / modelBounds.width;
    var m02 = viewBounds.x - m00 * modelBounds.x;
    var m11 = -viewBounds.height / modelBounds.height;
    // vY == (mY + mHeight) * m11 + m12
    var m12 = viewBounds.y - m11 * modelBounds.getMaxY();
    return new ModelViewTransform2( Matrix3.affine( m00, 0, 0, m11, m02, m12 ) );
  };

  return ModelViewTransform2;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Immutable font object.
 *
 * Examples:
 * new scenery.Font().font                      // "10px sans-serif" (the default)
 * new scenery.Font( { family: 'serif' } ).font // "10px serif"
 * new scenery.Font( { weight: 'bold' } ).font  // "bold 10px sans-serif"
 * new scenery.Font( { size: 16 } ).font        // "16px sans-serif"
 * var font = new scenery.Font( {
 *   family: '"Times New Roman", serif',
 *   style: 'italic',
 *   lineHeight: 10
 * } );
 * font.font;                                   // "italic 10px/10 'Times New Roman', serif"
 * font.family;                                 // "'Times New Roman', serif"
 * font.weight;                                 // 400 (the default)
 *
 * Useful specs:
 * http://www.w3.org/TR/css3-fonts/
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Font',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  // @private {Array.<string>} - Valid values for the 'style' property of Font
  var VALID_STYLES = [ 'normal', 'italic', 'oblique' ];

  // @private {Array.<string>} - Valid values for the 'variant' property of Font
  var VALID_VARIANTS = [ 'normal', 'small-caps' ];

  // @private {Array.<string>} - Valid values for the 'weight' property of Font
  var VALID_WEIGHTS = [ 'normal', 'bold', 'bolder', 'lighter',
                        '100', '200', '300', '400', '500', '600', '700', '800', '900' ];

  // @private {Array.<string>} - Valid values for the 'stretch' property of Font
  var VALID_STRETCHES = [ 'normal', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed',
                          'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded' ];

  /**
   * @public
   * @constructor
   *
   * Font options objects (if provided) support the following options:
   * {
   *   style: {string} - 'normal', 'italic' or 'oblique',
   *   variant: {string} - 'normal' or 'small-caps',
   *   weight: {string|number} - 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600',
   *                             '700', '800', '900', or a number that when cast to a string will be one of the strings
   *                             above.
   *   stretch: {string} - 'normal', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed',
   *                       'semi-expanded', 'expanded', 'extra-expanded' or 'ultra-expanded'
   *   size: {string|number} - A valid CSS font-size string, or a number representing a quantity of 'px'
   *   lineHeight: {string} - A valid CSS line-height, typically 'normal', a number, a CSS length (e.g. '15px'), or
   *                          a percentage of the normal height.
   *   family: {string} - A comma-separated list of families, which can include generic families (preferably at the
   *                      end) such as 'serif', 'sans-serif', 'cursive', 'fantasy' and 'monospace'. If there is any
   *                      question about escaping (such as spaces in a font name), the family should be surrounded
   *                      by double quotes.
   * }
   *
   * Font strings should be a valid CSS3 font declaration value (see http://www.w3.org/TR/css3-fonts/) which consists
   * of the following pattern:
   *   [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]? <‘font-size’>
   *   [ / <‘line-height’> ]? <‘font-family’> ]
   *
   * @param {string|Object} [options] - A valid CSS 'font' string or an options object as described above.
   */
  function Font( options ) {
    // @private {string} - See https://www.w3.org/TR/css-fonts-3/#propdef-font-style
    this._style = 'normal';

    // @private {string} - See https://www.w3.org/TR/css-fonts-3/#font-variant-css21-values
    this._variant = 'normal';

    // @private {string} - See https://www.w3.org/TR/css-fonts-3/#propdef-font-weight
    this._weight = 'normal';

    // @private {string} - See https://www.w3.org/TR/css-fonts-3/#propdef-font-stretch
    this._stretch = 'normal';

    // @private {string} - See https://www.w3.org/TR/css-fonts-3/#propdef-font-size
    this._size = '10px';

    // @private {string} - See https://www.w3.org/TR/CSS2/visudet.html#propdef-line-height
    this._lineHeight = 'normal';

    // @private {string} - See https://www.w3.org/TR/css-fonts-3/#propdef-font-family
    this._family = 'sans-serif';

    var type = typeof options;
    assert && assert( options === undefined || type === 'string' || ( type === 'object' && Object.getPrototypeOf( options ) === Object.prototype ),
      'options should be a string or a raw object');

    if ( type === 'string' ) {
      // parse a somewhat proper CSS3 form (not guaranteed to handle it precisely the same as browsers yet)

      // split based on whitespace allowed by CSS spec (more restrictive than regular regexp whitespace)
      var tokens = _.filter( options.split( /[\x09\x0A\x0C\x0D\x20]/ ), function( token ) { return token.length > 0; } ); // eslint-disable-line no-control-regex

      // pull tokens out until we reach something that doesn't match. that must be the font size (according to spec)
      for ( var i = 0; i < tokens.length; i++ ) {
        var token = tokens[ i ];
        if ( token === 'normal' ) {
          // nothing has to be done, everything already normal as default
        }
        else if ( _.includes( VALID_STYLES, token ) ) {
          assert && assert( this._style === 'normal', 'Style cannot be applied twice. Already set to "' + this._style + '", attempt to replace with "' + token + '"' );
          this._style = token;
        }
        else if ( _.includes( VALID_VARIANTS, token ) ) {
          assert && assert( this._variant === 'normal', 'Variant cannot be applied twice. Already set to "' + this._variant + '", attempt to replace with "' + token + '"' );
          this._variant = token;
        }
        else if ( _.includes( VALID_WEIGHTS, token ) ) {
          assert && assert( this._weight === 'normal', 'Weight cannot be applied twice. Already set to "' + this._weight + '", attempt to replace with "' + token + '"' );
          this._weight = token;
        }
        else if ( _.includes( VALID_STRETCHES, token ) ) {
          assert && assert( this._stretch === 'normal', 'Stretch cannot be applied twice. Already set to "' + this._stretch + '", attempt to replace with "' + token + '"' );
          this._stretch = token;
        }
        else {
          // not a style/variant/weight/stretch, must be a font size, possibly with an included line-height
          var subtokens = token.split( /\// ); // extract font size from any line-height
          this._size = subtokens[ 0 ];
          if ( subtokens[ 1 ] ) {
            this._lineHeight = subtokens[ 1 ];
          }
          // all future tokens are guaranteed to be part of the font-family if it is given according to spec
          this._family = tokens.slice( i + 1 ).join( ' ' );
          break;
        }
      }
    }
    else if ( type === 'object' ) {
      if ( options.style !== undefined ) {
        this._style = options.style;
      }
      if ( options.variant !== undefined ) {
        this._variant = options.variant;
      }
      if ( options.weight !== undefined ) {
        this._weight = '' + options.weight; // cast it to a string explicitly
      }
      if ( options.stretch !== undefined ) {
        this._stretch = options.stretch;
      }
      if ( options.size !== undefined ) {
        this._size = Font.castSize( options.size );
      }
      if ( options.lineHeight !== undefined ) {
        this._lineHeight = options.lineHeight;
      }
      if ( options.family !== undefined ) {
        this._family = options.family;
      }
    }

    // sanity checks to prevent errors in interpretation or in the font shorthand usage
    assert && assert( typeof this._style === 'string' && _.includes( VALID_STYLES, this._style ),
      'Font style must be one of "normal", "italic", or "oblique"' );
    assert && assert( typeof this._variant === 'string' && _.includes( VALID_VARIANTS, this._variant ),
      'Font variant must be "normal" or "small-caps"' );
    assert && assert( typeof this._weight === 'string' && _.includes( VALID_WEIGHTS, this._weight ),
      'Font weight must be one of "normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", or "900"' );
    assert && assert( typeof this._stretch === 'string' && _.includes( VALID_STRETCHES, this._stretch ),
      'Font stretch must be one of "normal", "ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "semi-expanded", "expanded", "extra-expanded", or "ultra-expanded"' );
    assert && assert( typeof this._size === 'string' && !_.includes( [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ], this._size[ this._size.length - 1 ] ),
      'Font size must be either passed as a number (not a string, interpreted as px), or must contain a suffix for percentage, absolute or relative units, or an explicit size constant' );
    assert && assert( typeof this._lineHeight === 'string' );
    assert && assert( typeof this._family === 'string' );

    // @private {string} - Initialize the shorthand font property (stored as _font)
    this._font = this.computeShorthand();

    phetAllocation && phetAllocation( 'Font' );
  }

  scenery.register( 'Font', Font );

  inherit( Object, Font, {
    /**
     * Returns this font's CSS shorthand, which includes all of the font's information reduced into a single string.
     * @public
     *
     * This can be used for CSS as the 'font' attribute, or is needed to set Canvas fonts.
     *
     * https://www.w3.org/TR/css-fonts-3/#propdef-font contains detailed information on how this is formatted.
     *
     * @returns {string}
     */
    getFont: function() {
      return this._font;
    },
    get font() { return this.getFont(); },

    /**
     * Returns this font's style. See the constructor for more details on valid values.
     * @public
     *
     * @returns {string}
     */
    getStyle: function() {
      return this._style;
    },
    get style() { return this.getStyle(); },

    /**
     * Returns this font's variant. See the constructor for more details on valid values.
     * @public
     *
     * @returns {string}
     */
    getVariant: function() {
      return this._variant;
    },
    get variant() { return this.getVariant(); },

    /**
     * Returns this font's weight. See the constructor for more details on valid values.
     * @public
     *
     * NOTE: If a numeric weight was passed in, it has been cast to a string, and a string will be returned here.
     *
     * @returns {string}
     */
    getWeight: function() {
      return this._weight;
    },
    get weight() { return this.getWeight(); },

    /**
     * Returns this font's stretch. See the constructor for more details on valid values.
     * @public
     *
     * @returns {string}
     */
    getStretch: function() {
      return this._stretch;
    },
    get stretch() { return this.getStretch(); },

    /**
     * Returns this font's size. See the constructor for more details on valid values.
     * @public
     *
     * NOTE: If a numeric size was passed in, it has been cast to a string, and a string will be returned here.
     *
     * @returns {string}
     */
    getSize: function() {
      return this._size;
    },
    get size() { return this.getSize(); },

    /**
     * Returns this font's line-height. See the constructor for more details on valid values.
     * @public
     *
     * @returns {string}
     */
    getLineHeight: function() {
      return this._lineHeight;
    },
    get lineHeight() { return this.getLineHeight(); },

    /**
     * Returns this font's family. See the constructor for more details on valid values.
     * @public
     *
     * @returns {string}
     */
    getFamily: function() {
      return this._family;
    },
    get family() { return this.getFamily(); },

    /**
     * Returns a new Font object, which is a copy of this object. If options are provided, they override the current
     * values in this object.
     * @public
     *
     * @param {Object} [options] - See the constructor for the object format
     * @returns {Font}
     */
    copy: function( options ) {
      return new Font( _.extend( {
        style: this._style,
        variant: this._variant,
        weight: this._weight,
        stretch: this._stretch,
        size: this._size,
        lineHeight: this._lineHeight,
        family: this._family
      }, options ) );
    },

    /**
     * Computes the combined CSS shorthand font string.
     * @private
     *
     * https://www.w3.org/TR/css-fonts-3/#propdef-font contains details about the format.
     *
     * @returns {string}
     */
    computeShorthand: function() {
      var ret = '';
      if ( this._style !== 'normal' ) { ret += this._style + ' '; }
      if ( this._variant !== 'normal' ) { ret += this._variant + ' '; }
      if ( this._weight !== 'normal' ) { ret += this._weight + ' '; }
      if ( this._stretch !== 'normal' ) { ret += this._stretch + ' '; }
      ret += this._size;
      if ( this._lineHeight !== 'normal' ) { ret += '/' + this._lineHeight; }
      ret += ' ' + this._family;
      return ret;
    },

    /**
     * Returns this font's CSS shorthand, which includes all of the font's information reduced into a single string.
     * @public
     *
     * NOTE: This is an alias of getFont().
     *
     * This can be used for CSS as the 'font' attribute, or is needed to set Canvas fonts.
     *
     * https://www.w3.org/TR/css-fonts-3/#propdef-font contains detailed information on how this is formatted.
     *
     * @returns {string}
     */
    toCSS: function() {
      return this.getFont();
    }
  }, {
    /**
     * Converts a generic size to a specific CSS pixel string, assuming 'px' for numbers.
     * @public
     *
     * @param {string|number} size - If it's a number, 'px' will be appended
     * @returns {string}
     */
    castSize: function( size ) {
      if ( typeof size === 'number' ) {
        return size + 'px'; // add the pixels suffix by default for numbers
      }
      else {
        return size; // assume that it's a valid to-spec string
      }
    }
  } );

  // @public {Font} - Default Font object (since they are immutable).
  Font.DEFAULT = new Font();

  return Font;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Creates the namespace for this repository.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/sceneryPhet',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  // modules
  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'sceneryPhet' );
} );
// Copyright 2016, University of Colorado Boulder

/**
 * Tandem type for the PhET Scenery Font class
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SCENERY/util/TFont',['require','SCENERY/scenery','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );

  /**
   * @constructor
   * Wrapper type for phet/scenery's Font class
   * @param {Font} font - An instance of a phet.scenery.Font type
   * @param {string} phetioID - Full name of this font instance
   */
  function TFont( font, phetioID ) {
    TObject.call( this, font, phetioID );
    assertInstanceOf( font, phet.scenery.Font );
  }

  phetioInherit( TObject, 'TFont', TFont, {}, {

    // Info from Font.js
    documentation: 'Font handling for text drawing. Options: <br>' +
                   'style: normal      // normal | italic | oblique <br>' +
                   'variant: normal    // normal | small-caps <br>' +
                   'weight: normal     // normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 <br>' +
                   'stretch: normal    // normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded <br>' +
                   'size: 10px         // absolute-size | relative-size | length | percentage -- unitless number interpreted as px. absolute suffixes: cm, mm, in, pt, pc, px. relative suffixes: em, ex, ch, rem, vw, vh, vmin, vmax. <br>' +
                   'lineHeight: normal // normal | number | length | percentage -- NOTE: Canvas spec forces line-height to normal <br>' +
                   'family: sans-serif // comma-separated list of families, including generic families (serif, sans-serif, cursive, fantasy, monospace). ideally escape with double-quotes',


    /**
     * Decodes a state into a Font.
     * Use stateObject as the Font constructor's options argument
     * @param {Object} stateObject
     * @returns {Font}
     */
    fromStateObject: function( stateObject ) {
      return new phet.scenery.Font( stateObject );
    },

    /**
     * Encodes a Font instance to a state.
     * Serialize this font's configuration to an options object
     * @param {Font} instance
     * @returns {Object}
     */
    toStateObject: function( font ) {
      return {
        style: font.getStyle(),
        variant: font.getVariant(),
        weight: font.getWeight(),
        stretch: font.getStretch(),
        size: font.getSize(),
        lineHeight: font.getLineHeight(),
        family: font.getFamily()
      };
    }
  } );

  scenery.register( 'TFont', TFont );

  return TFont;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Encapsulation of the font used for PhET simulations.
 * Provides PhET-specific defaults, and guarantees a fallback for font family.
 *
 * Sample use:
 * new PhetFont( { family: 'Futura', size: 24, weight: 'bold' } )
 * new PhetFont( 24 )
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/PhetFont',['require','SCENERY/util/Font','PHET_CORE/inherit','SCENERY_PHET/sceneryPhet','TANDEM/Tandem','SCENERY/util/TFont'],function( require ) {
  'use strict';

  // modules
  var Font = require( 'SCENERY/util/Font' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TFont = require( 'SCENERY/util/TFont' ); // TODO: we should have TPhetFont

  /**
   * @param {number|Object} [options] if number this is the font size, otherwise same options as scenery.Font
   * @constructor
   */
  function PhetFont( options ) {

    // convenience constructor: new PhetFont( {number|string} size )
    if ( typeof options === 'number' || typeof options === 'string' ) {
      options = { size: options };
    }

    assert && assert( arguments.length === 0 || arguments.length === 1, 'Too many arguments' );

    // PhET defaults
    options = _.extend( {
      family: 'Arial',
      tandem: Tandem.tandemOptional()
    }, options );

    // Guarantee a fallback family
    assert && assert( options.family );
    options.family = options.family + ', sans-serif';

    Font.call( this, options );

    options.tandem.addInstance( this, TFont );
  }

  sceneryPhet.register( 'PhetFont', PhetFont );

  return inherit( Font, PhetFont );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Constants used in multiple locations within the 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (MLearner)
 */

define( 'PENDULUM_LAB/common/PendulumLabConstants',['require','SCENERY/nodes/AlignGroup','DOT/Dimension2','PHETCOMMON/view/ModelViewTransform2','PENDULUM_LAB/pendulumLab','SCENERY_PHET/PhetFont','DOT/Vector2'],function( require ) {
  'use strict';

  // modules
  var AlignGroup = require( 'SCENERY/nodes/AlignGroup' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Vector2 = require( 'DOT/Vector2' );

  var PANEL_CORNER_RADIUS = 5;
  var PANEL_X_MARGIN = 10;
  var PANEL_Y_MARGIN = 8;
  var PANEL_BACKGROUND_COLOR = 'rgb( 230, 230, 230 )';

  var PendulumLabConstants = {
    // Some other colors
    BACKGROUND_COLOR: 'rgb( 255, 255, 255 )',
    FIRST_PENDULUM_COLOR: 'rgb( 0, 0, 255 )',
    SECOND_PENDULUM_COLOR: 'rgb( 255, 0, 0 )',
    ACCELERATION_ARROW_COLOR: 'rgb( 255, 253, 56 )',
    VELOCITY_ARROW_COLOR: 'rgb( 41, 253, 46 )',

    // Energy colors
    KINETIC_ENERGY_COLOR: 'rgb( 31, 202, 46 )',
    POTENTIAL_ENERGY_COLOR: 'rgb( 55, 132, 213 )',
    THERMAL_ENERGY_COLOR: 'rgb( 253, 87, 31 )',
    TOTAL_ENERGY_COLOR: 'rgb( 0, 0, 0 )',

    // Fonts
    TITLE_FONT: new PhetFont( 14 ),
    TITLE_FONT_BOLD: new PhetFont( { size: 14, weight: 'bold' } ),
    TICK_FONT: new PhetFont( 12 ),
    READOUT_FONT: new PhetFont( 14 ),
    RULER_FONT: new PhetFont( 10 ),
    PERIOD_TIMER_TITLE_FONT: new PhetFont( 14 ),
    PERIOD_TIMER_READOUT_FONT: new PhetFont( 14 ),
    VALUE_OF_GRAVITY_FONT: new PhetFont( 14 ),
    GRAVITY_COMBO_FONT: new PhetFont( 12 ),
    PENDULUM_LABEL_FONT: new PhetFont( { size: 32, weight: 'bold' } ),
    PROTRACTOR_DEGREES_FONT: new PhetFont( { size: 14, weight: 'bold' } ),
    RETURN_BUTTON_FONT: new PhetFont( 14 ),
    ENERGY_HEADER_FONT: new PhetFont( { size: 11, weight: 'bold' } ),
    ENERGY_BAR_FONT: new PhetFont( { size: 13, weight: 'bold' } ),
    DIALOG_TITLE_FONT: new PhetFont( 22 ),
    LEGEND_ABBREVIATION_FONT: new PhetFont( { size: 16, weight: 'bold' } ),
    LEGEND_DESCRIPTION_FONT: new PhetFont( 16 ),

    TITLE_MAX_WIDTH: 140,
    TICK_LABEL_MAX_WIDTH: 50,

    RIGHT_CONTENT_WIDTH: 170,

    // Spacing between panels/boxes/sides of layout bounds
    PANEL_PADDING: 10,

    // Corner radius of our normal panels
    PANEL_CORNER_RADIUS: PANEL_CORNER_RADIUS,

    // Options for all top-level Panels
    PANEL_OPTIONS: {
      cornerRadius: PANEL_CORNER_RADIUS,
      fill: PANEL_BACKGROUND_COLOR,
      xMargin: PANEL_X_MARGIN,
      yMargin: PANEL_Y_MARGIN
    },

    // Options for AccordionBoxes
    BOX_OPTIONS: {
      cornerRadius: PANEL_CORNER_RADIUS,
      fill: PANEL_BACKGROUND_COLOR,
      contentXMargin: PANEL_X_MARGIN,
      contentYMargin: PANEL_Y_MARGIN
    },

    // sliders
    TRACK_HEIGHT: 0.5,
    THUMB_SIZE: new Dimension2( 13, 22 ),
    THUMB_TOUCH_AREA_X_DILATION: 5,
    THUMB_TOUCH_AREA_Y_DILATION: 4,
    SLIDER_PRECISION: 1,
    TWEAKERS_PRECISION: 2,

    // Spacing between checkboxes, radio buttons, or other items of that nature
    CHECK_RADIO_SPACING: 7,

    // Alignment groups for the left and right panels/boxes
    LEFT_CONTENT_ALIGN_GROUP: new AlignGroup( { matchVertical: false } ),

    // create a model view transform (assuming the dev view screen is 1024 wide and the 618 high)
    // the height of the screen is 4/3 m = 1.33 m
    MODEL_VIEW_TRANSFORM: ModelViewTransform2.createSinglePointScaleInvertedYMapping( Vector2.ZERO, new Vector2( 1024 / 2, 15 ), 618 / 1.33 )
  };

  pendulumLab.register( 'PendulumLabConstants', PendulumLabConstants );

  // @public {Array.<string>}
  PendulumLabConstants.PENDULUM_COLORS = [ PendulumLabConstants.FIRST_PENDULUM_COLOR, PendulumLabConstants.SECOND_PENDULUM_COLOR ];

  return PendulumLabConstants;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Model for period trace of pendulum. Can draw path once or repeat infinite.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/common/model/PeriodTrace',['require','AXON/BooleanProperty','PHET_CORE/inherit','AXON/NumberProperty','PENDULUM_LAB/pendulumLab'],function( require ) {
  'use strict';

  // modules
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var NumberProperty = require( 'AXON/NumberProperty' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );

  /**
   * @constructor
   *
   * @param {Pendulum} pendulum
   */
  function PeriodTrace( pendulum ) {
    var self = this;

    // @private {Pendulum}
    this.pendulum = pendulum;

    // @public {Property.<number>}
    // 0: Trace hasn't started recording.
    // 1: Pendulum had its first zero-crossing, but hasn't reached its first peak.
    // 2: Pendulum reached first peak, and is swinging towards second peak.
    // 3: Pendulum had second peak, but hasn't crossed the zero-line since.
    // 4: Pendulum trace completed.
    this.numberOfPointsProperty = new NumberProperty( 0 );

    // @public {Property.<boolean>}
    this.isVisibleProperty = new BooleanProperty( false );

    // @public {Property.<number>}
    this.elapsedTimeProperty = new NumberProperty( 0 );

    // @public {boolean|null}
    this.counterClockwise = null;

    // @public {number|null}
    this.firstAngle = null;
    this.secondAngle = null;

    pendulum.crossingEmitter.addListener( function( dt, isPositive ) {
      // On the first zero-crossing, detect counterClockwise (direction) and increment. Don't trigger if our pendulum's angle
      // is likely to have been crossing at the top (angle~pi).
      if ( self.numberOfPointsProperty.value === 0 && Math.abs( pendulum.angleProperty.value ) < 0.5 ) {

        // modify numberOfPoints before elapsedTime, so anything waiting for elapsedTime changes while running works
        self.numberOfPointsProperty.value = 1;
        self.counterClockwise = !isPositive;

        // Set our elapsed time to the negative, as this was the elapsed time UNTIL we started. When the next step
        // callback happens, it will increment our elapsedTime to the correct (current) amount.
        self.elapsedTimeProperty.value = -dt;

      }
      // On the third zero-crossing (we passed by the other direction already), increment to end the period trace.
      else if ( self.numberOfPointsProperty.value === 3 ) {

        // modify numberOfPoints after elapsedTime, so anything waiting for elapsedTime changes while running works
        self.elapsedTimeProperty.value += dt;

        self.numberOfPointsProperty.value = 4;
      }
      // Check to see if we looped! Should have peaked before second crossing.
      else if ( self.numberOfPointsProperty.value === 1 ) {
        self.resetPathPoints();
      }
    } );

    pendulum.peakEmitter.addListener( function( theta ) {
      if ( self.numberOfPointsProperty.value === 1 ) {
        self.firstAngle = theta;
        self.numberOfPointsProperty.value = 2;
      }
      else if ( self.numberOfPointsProperty.value === 2 ) {
        self.secondAngle = theta;
        self.numberOfPointsProperty.value = 3;
      }
    } );

    pendulum.stepEmitter.addListener( function( dt ) {
      if ( self.numberOfPointsProperty.value > 0 && self.numberOfPointsProperty.value < 4 ) {
        self.elapsedTimeProperty.value += dt;
      }
    } );

    // clear pendulum path
    var resetPathPoints = this.resetPathPoints.bind( this );
    pendulum.gravityProperty.lazyLink( resetPathPoints );
    pendulum.lengthProperty.lazyLink( resetPathPoints );
    pendulum.isUserControlledProperty.lazyLink( resetPathPoints );

    this.isVisibleProperty.lazyLink( resetPathPoints );
  }

  pendulumLab.register( 'PeriodTrace', PeriodTrace );

  return inherit( Object, PeriodTrace, {
    /**
     * Called when the trace has fully faded away.
     * @public
     */
    onFaded: function() {
      this.isVisibleProperty.value = false;

      // show track continuously
      if ( !this.pendulum.hasPeriodTimer ) {
        this.isVisibleProperty.value = true;
      }
    },

    /**
     * Resets the property set and the path points
     * @public
     */
    reset: function() {
      this.isVisibleProperty.reset();
      this.resetPathPoints();
    },

    /**
     * Resets the path points that are used to draw the period path trace
     * @public
     */
    resetPathPoints: function() {
      this.counterClockwise = null;
      this.firstAngle = null;
      this.secondAngle = null;
      this.numberOfPointsProperty.reset();
      this.elapsedTimeProperty.reset();
    }
  } );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A numeric range.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Andrew Adare
 */
define( 'DOT/Range',['require','DOT/dot'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  /**
   * @param {number} min - the minimum value of the range
   * @param {number} max - the maximum value of the range
   * @constructor
   */
  function Range( min, max ) {

    // @public (read-only) - the minimum value of the range
    this.min = min;

    // @public (read-only) - the maximum value of the range
    this.max = max;

    assert && assert( min <= max );
  }

  dot.register( 'Range', Range );

  Range.prototype = {

    constructor: Range,

    /**
     * Makes a copy of this range
     * @public
     * @returns {Range}
     */
    copy: function() {
      return new Range( this.min, this.max );
    },

    /**
     * Gets the length of this range, that is the difference between the maximum and minimum value of this range
     * @public
     * @returns {number}
     */
    getLength: function() {
      return this.max - this.min;
    },

    /**
     * Gets the center of this range, that is the average value of the maximum and minimum value of this range
     * @public
     * @returns {number}
     */
    getCenter: function() {
      return (this.max + this.min) / 2;
    },

    /**
     * Determines if this range contains the value
     * @public
     * @param {number} value
     * @returns {boolean}
     */
    contains: function( value ) {
      return ( value >= this.min ) && ( value <= this.max );
    },

    /**
     * Does this range contain the specified range?
     * @public
     * @param {Range} range
     * @returns {boolean}
     */
    containsRange: function( range ) {
      return this.min <= range.min && this.max >= range.max;
    },

    /**
     * Determine if this range overlaps (intersects) with another range
     * @public
     * @param {Range} range
     * @returns {boolean}
     */
    intersects: function( range ) {
      return ( this.max >= range.min ) && ( range.max >= this.min );
    },

    /**
     * Do the two ranges overlap with one another?  Note that this assumes that
     * This is a open interval.
     * @public
     * @param {Range} range
     * @returns {boolean}
     */
    intersectsExclusive: function( range ) {
      return ( this.max > range.min ) && ( range.max > this.min );
    },

    /**
     * Converts the attributes of this range to a string
     * @public
     * @returns {string}
     */
    toString: function() {
      return '[Range (min:' + this.min + ' max:' + this.max + ')]';
    },

    /**
     * Constrains a value to the range.
     * @public
     * @param {number} value
     * @returns {number}
     */
    constrainValue: function( value ) {
      return Math.min( Math.max( value, this.min ), this.max );
    },

    /**
     * Determines if this range is equal to other range.
     * @public
     * @param {Range} other
     * @returns {boolean}
     */
    equals: function( other ) {
      return this.min === other.min && this.max === other.max;
    }
  };

  return Range;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Single pendulum model.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/common/model/Pendulum',['require','AXON/BooleanProperty','AXON/Emitter','PHET_CORE/inherit','AXON/NumberProperty','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','PENDULUM_LAB/common/model/PeriodTrace','AXON/Property','DOT/Range','DOT/Util','DOT/Vector2'],function( require ) {
  'use strict';

  // modules
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var NumberProperty = require( 'AXON/NumberProperty' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PeriodTrace = require( 'PENDULUM_LAB/common/model/PeriodTrace' );
  var Property = require( 'AXON/Property' );
  var Range = require( 'DOT/Range' );
  var Util = require( 'DOT/Util' );
  var Vector2 = require( 'DOT/Vector2' );

  // constants
  var TWO_PI = Math.PI * 2;

  // scratch vector for convenience
  var scratchVector = new Vector2();

  /**
   * @constructor
   *
   * @param {number} index - Which pendulum in a system is this?
   * @param {number} mass - mass of pendulum, kg.
   * @param {number} length - length of pendulum, m.
   * @param {boolean} isVisible - Initial visibility of pendulum.
   * @param {Property.<number>} gravityProperty - Property with current gravity value.
   * @param {Property.<number>} frictionProperty - Property with current friction value.
   * @param {Property.<boolean>} isPeriodTraceVisibleProperty - Flag property to track check box value of period trace visibility.
   * @param {boolean} hasPeriodTimer
   */
  function Pendulum( index, mass, length, isVisible, gravityProperty, frictionProperty, isPeriodTraceVisibleProperty, hasPeriodTimer ) {
    var self = this;

    // @public {number}
    this.index = index;

    // @public {Property.<number>} - Length of the pendulum (in meters)
    this.lengthProperty = new NumberProperty( length );

    // @public {Property.<number>} - Mass of the pendulum (in kilograms)
    this.massProperty = new NumberProperty( mass );

    // @public {Property.<number>} - Angle in radians (0 is straight down, positive is to the right)
    this.angleProperty = new NumberProperty( 0 );

    // @public {Property.<number>} - Angular velocity (in radians/second)
    this.angularVelocityProperty = new NumberProperty( 0 );

    // @public {boolean}
    this.hasPeriodTimer = hasPeriodTimer;

    /*---------------------------------------------------------------------------*
    * Derived variables
    *----------------------------------------------------------------------------*/

    // @public {Property.<number>} - Angular acceleration in rad/s^2
    this.angularAccelerationProperty = new NumberProperty( 0 );

    // @public {Property.<Vector2>} - Position from the rotation point
    this.positionProperty = new Property( Vector2.ZERO );

    // @public {Property.<Vector2>}
    this.velocityProperty = new Property( Vector2.ZERO );

    // @public {Property.<Vector2>}
    this.accelerationProperty = new Property( Vector2.ZERO );

    // @public {Property.<number>} - In Joules
    this.kineticEnergyProperty = new NumberProperty( 0 );

    // @public {Property.<number>} - In Joules
    this.potentialEnergyProperty = new NumberProperty( 0 );

    // @public {Property.<number>} - In Joules
    this.thermalEnergyProperty = new NumberProperty( 0 );

    // @public {Property.<boolean>} - Whether the pendulum is currently being dragged.
    this.isUserControlledProperty = new BooleanProperty( false );

    // @public {Property.<boolean>} - Whether the pendulum tick is visible on the protractor.
    this.isTickVisibleProperty = new BooleanProperty( false );

    // @public {Property.<boolean>} - Whether the entire pendulum is visible or not
    this.isVisibleProperty = new BooleanProperty( false );

    // save link to global properties
    // @private
    this.gravityProperty = gravityProperty;
    this.frictionProperty = frictionProperty;

    // @public
    this.stepEmitter = new Emitter();
    this.userMovedEmitter = new Emitter();
    this.crossingEmitter = new Emitter();
    this.peakEmitter = new Emitter();
    this.resetEmitter = new Emitter();

    // default color for this pendulum
    // @public (read-only)
    this.color = PendulumLabConstants.PENDULUM_COLORS[ index ]; // {string}

    // @public {Range} (read-only)
    this.lengthRange = new Range( 0.1, 1.0 );

    // @public {Range} (read-only)
    this.massRange = new Range( 0.1, 1.50 );

    // @public {PeriodTrace}
    this.periodTrace = new PeriodTrace( this );

    // If it NOT repeatable, the PeriodTimer type will control the visibility.
    if ( !hasPeriodTimer ) {
      Property.multilink( [ isPeriodTraceVisibleProperty, this.isVisibleProperty ], function( isPeriodTraceVisible, isVisible ) {
        self.periodTrace.isVisibleProperty.value = isPeriodTraceVisible && isVisible;
      } );
    }

    // make tick on protractor visible after first drag
    this.isUserControlledProperty.lazyLink( function( isUserControlled ) {
      if ( isUserControlled ) {
        self.isTickVisibleProperty.value = true; // Seems like an UI-specific issue, not model

        self.angularVelocityProperty.value = 0;
        self.updateDerivedVariables( false );

        // Clear thermal energy on a drag, see https://github.com/phetsims/pendulum-lab/issues/196
        self.thermalEnergyProperty.value = 0;
      }
    } );

    // make the angle value visible after the first drag
    this.angleProperty.lazyLink( function() {
      if ( self.isUserControlledProperty.value ) {
        self.updateDerivedVariables( false );
        self.userMovedEmitter.emit();
      }
    } );

    // update the angular velocity when the length changes
    this.lengthProperty.lazyLink( function( newLength, oldLength ) {
      self.angularVelocityProperty.value = self.angularVelocityProperty.value * oldLength / newLength;
      self.updateDerivedVariables( false ); // preserve thermal energy
    } );

    this.updateListener = this.updateDerivedVariables.bind( this, false ); // don't add thermal energy on these callbacks
    this.massProperty.lazyLink( this.updateListener );
    gravityProperty.lazyLink( this.updateListener );
  }

  pendulumLab.register( 'Pendulum', Pendulum );

  return inherit( Object, Pendulum, {
    /**
     * Function that returns the instantaneous angular acceleration
     * @private
     *
     * @param {number} theta - angular position
     * @param {number} omega - angular velocity
     * @returns {number}
     */
    omegaDerivative: function( theta, omega ) {
      return -this.frictionTerm( omega ) - ( this.gravityProperty.value / this.lengthProperty.value ) * Math.sin( theta );
    },

    /**
     * Function that returns the tangential drag force on the pendulum per unit mass per unit length
     * The friction term has units of angular acceleration.
     * The friction has a linear and quadratic component (with speed)
     * @private
     *
     * @param {number} omega - the angular velocity of the pendulum
     * @returns {number}
     */
    frictionTerm: function( omega ) {
      return this.frictionProperty.value * this.lengthProperty.value / Math.pow( this.massProperty.value, 1 / 3 ) * omega * Math.abs( omega ) +
             this.frictionProperty.value / Math.pow( this.massProperty.value, 2 / 3 ) * omega;
    },

    /**
     * Stepper function for the pendulum model.
     * It uses a Runge-Kutta approach to solve the angular differential equation
     * @public
     *
     * @param {number} dt
     */
    step: function( dt ) {
      var theta = this.angleProperty.value;

      var omega = this.angularVelocityProperty.value;

      var numSteps = Math.max( 7, dt * 120 );

      // 10 iterations typically maintains about ~11 digits of precision for total energy
      for ( var i = 0; i < numSteps; i++ ) {
        var step = dt / numSteps;

        // Runge Kutta (order 4), where the derivative of theta is omega.
        var k1 = omega * step;
        var l1 = this.omegaDerivative( theta, omega ) * step;
        var k2 = ( omega + 0.5 * l1 ) * step;
        var l2 = this.omegaDerivative( theta + 0.5 * k1, omega + 0.5 * l1 ) * step;
        var k3 = ( omega + 0.5 * l2 ) * step;
        var l3 = this.omegaDerivative( theta + 0.5 * k2, omega + 0.5 * l2 ) * step;
        var k4 = ( omega + l3 ) * step;
        var l4 = this.omegaDerivative( theta + k3, omega + l3 ) * step;
        var newTheta = Pendulum.modAngle( theta + ( k1 + 2 * k2 + 2 * k3 + k4 ) / 6 );
        var newOmega = omega + ( l1 + 2 * l2 + 2 * l3 + l4 ) / 6;

        // did the pendulum crossed the vertical axis (from below)
        // is the pendulum going from left to right or vice versa, or (is the pendulum on the vertical axis and changed position )
        if ( ( newTheta * theta < 0 ) || ( newTheta === 0 && theta !== 0 ) ) {
          this.cross( i * step, ( i + 1 ) * step, newOmega > 0, theta, newTheta );
        }

        // did the pendulum reach a turning point
        // is the pendulum changing is speed from left to right or is the angular speed zero but wasn't zero on the last update
        if ( ( newOmega * omega < 0 ) || ( newOmega === 0 && omega !== 0 ) ) {
          this.peak( theta, newTheta );
        }

        theta = newTheta;
        omega = newOmega;
      }

      // update the angular variables
      this.angleProperty.value = theta;
      this.angularVelocityProperty.value = omega;

      // update the derived variables, taking into account the transfer to thermal energy if friction is present
      this.updateDerivedVariables( this.frictionProperty.value > 0 );

      this.stepEmitter.emit1( dt );
    },

    /**
     * Function that emits when the pendulum is crossing the equilibrium point (theta=0)
     * Given that the time step is finite, we attempt to do a linear interpolation, to find the
     * precise time at which the pendulum cross the vertical.
     * @private
     *
     * @param {number} oldDT
     * @param {number} newDT
     * @param {boolean} isPositiveDirection
     * @param {number} oldTheta
     * @param {number} newTheta
     */
    cross: function( oldDT, newDT, isPositiveDirection, oldTheta, newTheta ) {
      // If we crossed near oldTheta, our crossing DT is near oldDT. If we crossed near newTheta, our crossing DT is close
      // to newDT.
      var crossingDT = Util.linear( oldTheta, newTheta, oldDT, newDT, 0 );

      this.crossingEmitter.emit2( crossingDT, isPositiveDirection );
    },

    /**
     * Sends a signal that the peak angle (turning angle) has been reached
     * It sends the value of the peak angle
     * @private
     *
     * @param {number} oldTheta
     * @param {number} newTheta
     */
    peak: function( oldTheta, newTheta ) {
      // a slightly better estimate is turningAngle =  ( oldTheta + newTheta ) / 2 + (dt/2)*(oldOmega^2+newOmega^2)/(oldOmega-newOmega)
      var turningAngle = ( oldTheta + newTheta > 0 ) ? Math.max( oldTheta, newTheta ) : Math.min( oldTheta, newTheta );
      this.peakEmitter.emit1( turningAngle );
    },

    /**
     * Given the angular position and velocity, this function updates derived variables :
     * namely the various energies( kinetic, thermal, potential and total energy)
     * and the linear variables (position, velocity, acceleration) of the pendulum
     * @private
     *
     * @param {boolean} energyChangeToThermal - is Friction present in the model
     */
    updateDerivedVariables: function( energyChangeToThermal ) {
      var speed = Math.abs( this.angularVelocityProperty.value ) * this.lengthProperty.value;

      this.angularAccelerationProperty.value = this.omegaDerivative( this.angleProperty.value, this.angularVelocityProperty.value );
      var height = this.lengthProperty.value * ( 1 - Math.cos( this.angleProperty.value ) );

      var oldKineticEnergy = this.kineticEnergyProperty.value;
      this.kineticEnergyProperty.value = 0.5 * this.massProperty.value * speed * speed;

      var oldPotentialEnergy = this.potentialEnergyProperty.value;
      this.potentialEnergyProperty.value = this.massProperty.value * this.gravityProperty.value * height;

      if ( energyChangeToThermal ) {
        this.thermalEnergyProperty.value += ( oldKineticEnergy + oldPotentialEnergy ) - ( this.kineticEnergyProperty.value + this.potentialEnergyProperty.value );
      }

      this.positionProperty.value = Vector2.createPolar( this.lengthProperty.value, this.angleProperty.value - Math.PI / 2 );
      this.velocityProperty.value = Vector2.createPolar( this.angularVelocityProperty.value * this.lengthProperty.value, this.angleProperty.value ); // coordinate frame -pi/2, but perpendicular +pi/2

      // add up net forces for the acceleration

      // tangential friction
      this.accelerationProperty.value = Vector2.createPolar( -this.frictionTerm( this.angularVelocityProperty.value ) / this.massProperty.value, this.angleProperty.value );
      // tangential gravity
      this.accelerationProperty.value.add( scratchVector.setPolar( -this.gravityProperty.value * Math.sin( this.angleProperty.value ), this.angleProperty.value ) );
      // radial (centripetal acceleration)
      this.accelerationProperty.value.add( scratchVector.setPolar( this.lengthProperty.value * this.angularVelocityProperty.value * this.angularVelocityProperty.value, this.angleProperty.value + Math.PI / 2 ) );

      this.velocityProperty.notifyListenersStatic();
      this.accelerationProperty.notifyListenersStatic();
    },

    /**
     * Reset all the properties of this model.
     * @public
     */
    reset: function() {
      // Note: We don't reset isVisibleProperty, since it is controlled externally.
      this.lengthProperty.reset();
      this.massProperty.reset();
      this.angleProperty.reset();
      this.angularVelocityProperty.reset();
      this.angularAccelerationProperty.reset();
      this.positionProperty.reset();
      this.velocityProperty.reset();
      this.accelerationProperty.reset();
      this.kineticEnergyProperty.reset();
      this.potentialEnergyProperty.reset();
      this.thermalEnergyProperty.reset();
      this.isUserControlledProperty.reset();
      this.isTickVisibleProperty.reset();

      this.updateDerivedVariables( false );
    },

    /**
     * Function that determines if the pendulum is stationary, i.e. is controlled by the user or not moving
     * @public
     *
     * @returns {boolean}
     */
    isStationary: function() {
      return this.isUserControlledProperty.value || ( this.angleProperty.value === 0 &&
                                                      this.angularVelocityProperty.value === 0 &&
                                                      this.angularAccelerationProperty.value === 0 );
    },

    /**
     * Functions returns an approximate period of the pendulum
     * The so-called small angle approximation is a lower bound to the true period in absence of friction
     * This function is currently used to fade out the path of the period trace
     * @public
     *
     * @returns {number}
     */
    getApproximatePeriod: function() {
      return 2 * Math.PI * Math.sqrt( this.lengthProperty.value / this.gravityProperty.value );
    },

    /**
     * Resets the motion of the Pendulum
     * @public
     */
    resetMotion: function() {
      this.angleProperty.reset();
      this.angularVelocityProperty.reset();

      // ticks are initially invisible
      this.isTickVisibleProperty.reset();

      this.periodTrace.resetPathPoints();

      this.updateDerivedVariables( false );

      this.resetEmitter.emit();
    },

    /**
     * Resets the thermal energy to zero
     * @public
     */
    resetThermalEnergy: function() {
      this.thermalEnergyProperty.reset();
    }
  }, {
    /**
     * Takes our angle modulo 2pi between -pi and pi.
     * @public
     *
     * @param {number} angle
     * @returns {number}
     */
    modAngle: function( angle ) {
      angle = angle % TWO_PI;

      if ( angle < -Math.PI ) {
        angle += TWO_PI;
      }
      if ( angle > Math.PI ) {
        angle -= TWO_PI;
      }

      return angle;
    }
  } );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A numeric range with an optional default value.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'DOT/RangeWithValue',['require','DOT/dot','PHET_CORE/inherit','DOT/Range'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Range = require( 'DOT/Range' );

  /**
   * @param {number} min - the minimum value of the range
   * @param {number} max - the maximum value of the range
   * @param {number} [defaultValue] - default value inside the range
   * @constructor
   */

  function RangeWithValue( min, max, defaultValue ) {

    Range.call( this, min, max );

    // @private - the default value of the range
    this._defaultValue = ( defaultValue === undefined ) ? min : defaultValue;

    assert && assert( ( this._defaultValue >= min ) && ( this._defaultValue <= max ) );
  }

  dot.register( 'RangeWithValue', RangeWithValue );

  return inherit( Range, RangeWithValue, {

    /**
     * Getter for defaultValue
     *
     * @returns {number}
     * @public
     */
    getDefaultValue: function() {
      return this._defaultValue;
    },
    get defaultValue() {
      return this.getDefaultValue();
    },

    /**
     * Converts the attributes of this range to a string
     * @public
     * @returns {string}
     */
    toString: function() {
      return '[Range (min:' + this.min + ' max:' + this.max + ' defaultValue:' + this.defaultValue + ')]';
    },

    /**
     * Determines if this range is equal to other range.
     * Note the default values must match as well.
     * @public
     * @param {Range} other
     * @returns {boolean}
     */
    equals: function( other ) {
      return other instanceof Range && this.min === other.min && this.max === other.max;
    }

  } );
} );


// Copyright 2014-2015, University of Colorado Boulder

/**
 * A movable model element.
 * Semantics of units are determined by the client.
 *
 * @author Andrey Zelenkov (MLearner)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'PENDULUM_LAB/common/model/MovableComponent',['require','AXON/BooleanProperty','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','AXON/Property'],function( require ) {
  'use strict';

  // modules
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var Property = require( 'AXON/Property' );

  /**
   * @constructor
   *
   * @param {boolean} isInitiallyVisible
   */
  function MovableComponent( isInitiallyVisible ) {
    // @public {Property.<Vector2|null>} - Initial value will be set in view, after calculating all bounds of nodes
    this.locationProperty = new Property( null );

    // @public {Property.<boolean>} flag to determine stopwatch state
    this.isVisibleProperty = new BooleanProperty( isInitiallyVisible );
  }

  pendulumLab.register( 'MovableComponent', MovableComponent );

  return inherit( Object, MovableComponent, {
    /**
     * Function that sets the initial location of a movable object and keeps an internal copy of it.
     * @public
     *
     * @param {Vector2} initialLocation
     */
    setInitialLocationValue: function( initialLocation ) {

      // position to use for resetting
      // make a copy of the initial location vector
      this.initialLocation = initialLocation.copy();

      // set the location to the initial location
      this.locationProperty.value = this.initialLocation.copy();
    },

    /**
     * Reset function
     * @public
     */
    reset: function() {

      // Reset the location to the initial location
      this.locationProperty.value = this.initialLocation ? this.initialLocation.copy() : null;

      this.isVisibleProperty.reset();
    }
  } );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Ruler model in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (MLearner)
 */
define( 'PENDULUM_LAB/common/model/Ruler',['require','PHET_CORE/inherit','PENDULUM_LAB/common/model/MovableComponent','PENDULUM_LAB/pendulumLab'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var MovableComponent = require( 'PENDULUM_LAB/common/model/MovableComponent' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );

  /**
   * @constructor
   *
   * @param {boolean} isInitiallyVisible
   */
  function Ruler( isInitiallyVisible ) {
    MovableComponent.call( this, isInitiallyVisible );

    // @public (read-only) - Meters
    this.length = 1;
  }

  pendulumLab.register( 'Ruler', Ruler );

  return inherit( MovableComponent, Ruler );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Stopwatch model in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (MLearner)
 */
define( 'PENDULUM_LAB/common/model/Stopwatch',['require','AXON/BooleanProperty','PHET_CORE/inherit','PENDULUM_LAB/common/model/MovableComponent','AXON/NumberProperty','PENDULUM_LAB/pendulumLab'],function( require ) {
  'use strict';

  // modules
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var MovableComponent = require( 'PENDULUM_LAB/common/model/MovableComponent' );
  var NumberProperty = require( 'AXON/NumberProperty' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );

  /**
   * @constructor
   *
   * @param {boolean} initiallyVisible
   */
  function Stopwatch( initiallyVisible ) {
    assert && assert( typeof initiallyVisible === 'boolean' );

    MovableComponent.call( this, initiallyVisible );

    // @public {Property.<boolean>}
    this.isRunningProperty = new BooleanProperty( false );

    // @public {Property.<number>} passed time
    this.elapsedTimeProperty = new NumberProperty( 0 );
  }

  pendulumLab.register( 'Stopwatch', Stopwatch );

  return inherit( MovableComponent, Stopwatch, {
    /**
     * Resets the stopwatch
     * @public
     */
    reset: function() {
      MovableComponent.prototype.reset.call( this );

      this.isRunningProperty.reset();
      this.elapsedTimeProperty.reset();
    }
  } );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Main model constructor for 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/common/model/PendulumLabModel',['require','PENDULUM_LAB/common/model/Body','AXON/BooleanProperty','PHET_CORE/inherit','AXON/NumberProperty','PENDULUM_LAB/common/model/Pendulum','PENDULUM_LAB/pendulumLab','AXON/Property','DOT/RangeWithValue','PENDULUM_LAB/common/model/Ruler','PENDULUM_LAB/common/model/Stopwatch'],function( require ) {
  'use strict';

  // modules
  var Body = require( 'PENDULUM_LAB/common/model/Body' );
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var NumberProperty = require( 'AXON/NumberProperty' );
  var Pendulum = require( 'PENDULUM_LAB/common/model/Pendulum' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var Property = require( 'AXON/Property' );
  var RangeWithValue = require( 'DOT/RangeWithValue' );
  var Ruler = require( 'PENDULUM_LAB/common/model/Ruler' );
  var Stopwatch = require( 'PENDULUM_LAB/common/model/Stopwatch' );

  /**
   * @constructor
   *
   * @param {Object} [options]
   */
  function PendulumLabModel( options ) {
    var self = this;

    options = _.extend( {
      // {boolean} - Should be true if there is a PeriodTimer handling the trace's visibility.
      hasPeriodTimer: false,

      // {boolean}
      rulerInitiallyVisible: true
    }, options );

    // @public {Property.<Body>}
    this.bodyProperty = new Property( Body.EARTH );

    // @public {Property.<number>} - Gravitational acceleration
    this.gravityProperty = new NumberProperty( Body.EARTH.gravity );

    // @public {Property.<number>} - Tracked for the "Custom" body, so that we can revert to this when the user changes
    //                               from "Planet X" to "Custom"
    this.customGravityProperty = new NumberProperty( Body.EARTH.gravity );

    // @public {Property.<number>} - Speed of time.
    this.timeSpeedProperty = new NumberProperty( 1 );

    // @public {Property.<number>} - Number of visible pendula (2 pendula are handled in the model)
    this.numberOfPendulaProperty = new NumberProperty( 1 );

    // @public {Property.<boolean>}
    this.isPlayingProperty = new BooleanProperty( true );

    // @public {Property.<number>} - Friction coefficient
    this.frictionProperty = new NumberProperty( 0 );

    // @public {Property.<boolean}
    this.isPeriodTraceVisibleProperty = new BooleanProperty( false );

    // @public {Property.<number>}
    this.energyZoomProperty = new NumberProperty( 1 );

    // @public {Array.<Pendulum>}
    this.pendula = [
      new Pendulum( 0, 1, 0.7, true, this.gravityProperty, this.frictionProperty, this.isPeriodTraceVisibleProperty, options.hasPeriodTimer ),
      new Pendulum( 1, 0.5, 1.0, false, this.gravityProperty, this.frictionProperty, this.isPeriodTraceVisibleProperty, options.hasPeriodTimer )
    ];

    // @public (read-only) possible gravity range 0m/s^2 to 25m/s^2
    this.gravityRange = new RangeWithValue( 0, 25, this.gravityProperty.value );

    // @public (read-only) possible friction range
    this.frictionRange = new RangeWithValue( 0, 0.5115, 0 );

    // @public (read-only) model for ruler
    this.ruler = new Ruler( options.rulerInitiallyVisible );

    // @public (read-only) model for stopwatch
    this.stopwatch = new Stopwatch( false );

    // change gravity if body was changed
    this.bodyProperty.lazyLink( function( body, oldBody ) {
      // If it's not custom, set it to its value
      if ( body !== Body.CUSTOM ) {
        self.gravityProperty.value = body.gravity;
      }
      else {
        // If we are switching from Planet X to Custom, don't let them cheat (go back to last custom value)
        if ( oldBody === Body.PLANET_X ) {
          self.gravityProperty.value = self.customGravityProperty.value;
        }
        // For non-Planet X, update our internal custom gravity
        else {
          self.customGravityProperty.value = self.gravityProperty.value;
        }
      }
    } );

    // change body to custom if gravity was changed
    this.gravityProperty.lazyLink( function( gravity ) {
      if ( !_.some( Body.BODIES, function( body ) { return body.gravity === gravity; } ) ) {
        self.bodyProperty.value = Body.CUSTOM;
      }

      if ( self.bodyProperty.value === Body.CUSTOM ) {
        self.customGravityProperty.value = gravity;
      }
    } );

    // change pendulum visibility if number of pendula was changed
    this.numberOfPendulaProperty.link( function( numberOfPendula ) {
      self.pendula.forEach( function( pendulum, pendulumIndex ) {
        pendulum.isVisibleProperty.value = ( numberOfPendula > pendulumIndex );
      } );
    } );
  }

  pendulumLab.register( 'PendulumLabModel', PendulumLabModel );

  return inherit( Object, PendulumLabModel, {
    /**
     * Resets the model.
     * @public
     */
    reset: function() {
      this.bodyProperty.reset();
      this.gravityProperty.reset();
      this.customGravityProperty.reset();
      this.timeSpeedProperty.reset();
      this.numberOfPendulaProperty.reset();
      this.isPlayingProperty.reset();
      this.frictionProperty.reset();
      this.isPeriodTraceVisibleProperty.reset();
      this.energyZoomProperty.reset();

      // reset ruler model
      this.ruler.reset();

      // reset stopwatch model
      this.stopwatch.reset();

      // reset pendulum models
      this.pendula.forEach( function( pendulum ) {
        pendulum.reset();
      } );
    },

    /**
     * Steps the model forward in time.
     * @public
     *
     * @param {number} dt
     */
    step: function( dt ) {
      if ( this.isPlayingProperty.value ) {
        // pick a number as irrational (in the mathematical sense) as possible so that the last digits on the period timer do get stuck to a number
        var periodTimerOffsetFactor = 1.007;

        // For our accuracy guarantees, we cap our DT fairly low. Otherwise the fixed-step model may become inaccurate
        // enough for getting an accurate period timer or speed loss on Jupiter with the shortest length.
        // We apply this BEFORE speed is applied, so that even if we're on a slow device, slow-motion WILL be guaranteed
        // to slow the sim speed down.
        this.modelStep( Math.min( 0.05, dt ) * ( this.timeSpeedProperty.value * periodTimerOffsetFactor ) );
      }
    },

    /**
     * Steps in model time.
     * @private
     *
     * @param {number} dt - change in time measured in seconds
     */
    modelStep: function( dt ) {
      // add time to the stopwatch if it is running
      if ( this.stopwatch.isRunningProperty.value ) {
        this.stopwatch.elapsedTimeProperty.value += dt;
      }

      // loop over the pendula
      for ( var i = 0; i < this.numberOfPendulaProperty.value; i++ ) {
        var pendulum = this.pendula[ i ]; // get the pendulum from the array

        // if the pendulum is moving
        if ( !pendulum.isStationary() ) {
          // prevent infinite motion after friction.
          var dampMotion = ( Math.abs( pendulum.angleProperty.value ) < 1e-3 ) && ( Math.abs( pendulum.angularAccelerationProperty.value ) < 1e-3 ) && ( Math.abs( pendulum.angularVelocityProperty.value ) < 1e-3 );
          if ( dampMotion ) {
            pendulum.angleProperty.value = 0;
            pendulum.angularVelocityProperty.value = 0;
          }
          // step through the pendulum model
          pendulum.step( dt );
        }
      }
    },

    /**
     * Steps forward by a specific amount of time (even if paused).
     * @public
     */
    stepManual: function() {
      this.modelStep( 0.01 ); // advances by 10 ms, see https://github.com/phetsims/pendulum-lab/issues/182
    },

    /**
     * Returns the pendula to rest.
     * @public
     */
    returnPendula: function() {
      //reset the pendula
      this.pendula.forEach( function( pendulum ) {
        pendulum.resetThermalEnergy();
        pendulum.resetMotion();
      } );

      // stop the timer
      if ( this.periodTimer ) {
        this.periodTimer.stop();
      }
    }
  } );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Main model constructor for Energy screen in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/energy/model/EnergyModel',['require','AXON/BooleanProperty','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/model/PendulumLabModel','AXON/Property'],function( require ) {
  'use strict';

  // modules
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabModel = require( 'PENDULUM_LAB/common/model/PendulumLabModel' );
  var Property = require( 'AXON/Property' );

  /**
   * @constructor
   *
   * @param {Object} [options]
   */
  function EnergyModel( options ) {
    options = _.extend( {
      rulerInitiallyVisible: false, // Hide the ruler by default on the energy screens
      energyBoxExpanded: true
    }, options );

    PendulumLabModel.call( this, options );

    // add energy mode property
    this.isEnergyBoxExpandedProperty = new BooleanProperty( options.energyBoxExpanded );

    // @public {Property.<Pendulum>} - The pendulum whose energy will be displayed in the plot.
    this.activeEnergyPendulumProperty = new Property( this.pendula[ 0 ] );
  }

  pendulumLab.register( 'EnergyModel', EnergyModel );

  return inherit( PendulumLabModel, EnergyModel, {
    /**
     * Function that resets all the property associated with the energy model
     * @public
     */
    reset: function() {
      PendulumLabModel.prototype.reset.call( this );
      this.isEnergyBoxExpandedProperty.reset();
      this.activeEnergyPendulumProperty.reset();
    }
  } );
} );

// Copyright 2013-2016, University of Colorado Boulder


/**
 * Points to a specific node (with a trail), and whether it is conceptually before or after the node.
 *
 * There are two orderings:
 * - rendering order: the order that node selves would be rendered, matching the Trail implicit order
 * - nesting order:   the order in depth first with entering a node being "before" and exiting a node being "after"
 *
 * TODO: more seamless handling of the orders. or just exclusively use the nesting order
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/TrailPointer',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  /*
   * isBefore: whether this points to before the node (and its children) have been rendered, or after
   */
  function TrailPointer( trail, isBefore ) {
    assert && assert( trail instanceof scenery.Trail, 'trail is not a trail' );
    this.trail = trail;

    this.setBefore( isBefore );

    phetAllocation && phetAllocation( 'TrailPointer' );
  }

  scenery.register( 'TrailPointer', TrailPointer );

  inherit( Object, TrailPointer, {
    copy: function() {
      return new TrailPointer( this.trail.copy(), this.isBefore );
    },

    setBefore: function( isBefore ) {
      this.isBefore = isBefore;
      this.isAfter = !isBefore;
    },

    // return the equivalent pointer that swaps before and after (may return null if it doesn't exist)
    getRenderSwappedPointer: function() {
      var newTrail = this.isBefore ? this.trail.previous() : this.trail.next();

      if ( newTrail === null ) {
        return null;
      }
      else {
        return new TrailPointer( newTrail, !this.isBefore );
      }
    },

    getRenderBeforePointer: function() {
      return this.isBefore ? this : this.getRenderSwappedPointer();
    },

    getRenderAfterPointer: function() {
      return this.isAfter ? this : this.getRenderSwappedPointer();
    },

    /*
     * In the render order, will return 0 if the pointers are equivalent, -1 if this pointer is before the
     * other pointer, and 1 if this pointer is after the other pointer.
     */
    compareRender: function( other ) {
      assert && assert( other !== null );

      var a = this.getRenderBeforePointer();
      var b = other.getRenderBeforePointer();

      if ( a !== null && b !== null ) {
        // normal (non-degenerate) case
        return a.trail.compare( b.trail );
      }
      else {
        // null "before" point is equivalent to the "after" pointer on the last rendered node.
        if ( a === b ) {
          return 0; // uniqueness guarantees they were the same
        }
        else {
          return a === null ? 1 : -1;
        }
      }
    },

    /*
     * Like compareRender, but for the nested (depth-first) order
     *
     * TODO: optimization?
     */
    compareNested: function( other ) {
      assert && assert( other );

      var comparison = this.trail.compare( other.trail );

      if ( comparison === 0 ) {
        // if trails are equal, just compare before/after
        if ( this.isBefore === other.isBefore ) {
          return 0;
        }
        else {
          return this.isBefore ? -1 : 1;
        }
      }
      else {
        // if one is an extension of the other, the shorter isBefore flag determines the order completely
        if ( this.trail.isExtensionOf( other.trail ) ) {
          return other.isBefore ? 1 : -1;
        }
        else if ( other.trail.isExtensionOf( this.trail ) ) {
          return this.isBefore ? -1 : 1;
        }
        else {
          // neither is a subtrail of the other, so a straight trail comparison should give the answer
          return comparison;
        }
      }
    },

    equalsRender: function( other ) {
      return this.compareRender( other ) === 0;
    },

    equalsNested: function( other ) {
      return this.compareNested( other ) === 0;
    },

    // will return false if this pointer has gone off of the beginning or end of the tree (will be marked with isAfter or isBefore though)
    hasTrail: function() {
      return !!this.trail;
    },

    // TODO: refactor with "Side"-like handling
    // moves this pointer forwards one step in the nested order
    nestedForwards: function() {
      if ( this.isBefore ) {
        if ( this.trail.lastNode()._children.length > 0 ) {
          // stay as before, just walk to the first child
          this.trail.addDescendant( this.trail.lastNode()._children[ 0 ], 0 );
        }
        else {
          // stay on the same node, but switch to after
          this.setBefore( false );
        }
      }
      else {
        if ( this.trail.indices.length === 0 ) {
          // nothing else to jump to below, so indicate the lack of existence
          this.trail = null;
          // stays isAfter
          return null;
        }
        else {
          var index = this.trail.indices[ this.trail.indices.length - 1 ];
          this.trail.removeDescendant();

          if ( this.trail.lastNode()._children.length > index + 1 ) {
            // more siblings, switch to the beginning of the next one
            this.trail.addDescendant( this.trail.lastNode()._children[ index + 1 ], index + 1 );
            this.setBefore( true );
          }
          else {
            // no more siblings. exit on parent. nothing else needed since we're already isAfter
          }
        }
      }
      return this;
    },

    // moves this pointer backwards one step in the nested order
    nestedBackwards: function() {
      if ( this.isBefore ) {
        if ( this.trail.indices.length === 0 ) {
          // jumping off the front
          this.trail = null;
          // stays isBefore
          return null;
        }
        else {
          var index = this.trail.indices[ this.trail.indices.length - 1 ];
          this.trail.removeDescendant();

          if ( index - 1 >= 0 ) {
            // more siblings, switch to the beginning of the previous one and switch to isAfter
            this.trail.addDescendant( this.trail.lastNode()._children[ index - 1 ], index - 1 );
            this.setBefore( false );
          }
          else {
            // no more siblings. enter on parent. nothing else needed since we're already isBefore
          }
        }
      }
      else {
        if ( this.trail.lastNode()._children.length > 0 ) {
          // stay isAfter, but walk to the last child
          var children = this.trail.lastNode()._children;
          this.trail.addDescendant( children[ children.length - 1 ], children.length - 1 );
        }
        else {
          // switch to isBefore, since this is a leaf node
          this.setBefore( true );
        }
      }
      return this;
    },

    // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable
    eachNodeBetween: function( other, callback ) {
      this.eachTrailBetween( other, function( trail ) {
        return callback( trail.lastNode() );
      } );
    },

    // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable
    eachTrailBetween: function( other, callback ) {
      // this should trigger on all pointers that have the 'before' flag, except a pointer equal to 'other'.

      // since we exclude endpoints in the depthFirstUntil call, we need to fire this off first
      if ( this.isBefore ) {
        callback( this.trail );
      }

      this.depthFirstUntil( other, function( pointer ) {
        if ( pointer.isBefore ) {
          return callback( pointer.trail );
        }
      }, true ); // exclude the endpoints so we can ignore the ending 'before' case
    },

    /*
     * Recursively (depth-first) iterates over all pointers between this pointer and 'other', calling
     * callback( pointer ) for each pointer. If excludeEndpoints is truthy, the callback will not be
     * called if pointer is equivalent to this pointer or 'other'.
     *
     * If the callback returns a truthy value, the subtree for the current pointer will be skipped
     * (applies only to before-pointers)
     */
    depthFirstUntil: function( other, callback, excludeEndpoints ) {
      // make sure this pointer is before the other, but allow start === end if we are not excluding endpoints
      assert && assert( this.compareNested( other ) <= ( excludeEndpoints ? -1 : 0 ), 'TrailPointer.depthFirstUntil pointers out of order, possibly in both meanings of the phrase!' );
      assert && assert( this.trail.rootNode() === other.trail.rootNode(), 'TrailPointer.depthFirstUntil takes pointers with the same root' );

      // sanity check TODO: remove later
      this.trail.reindex();
      other.trail.reindex();

      var pointer = this.copy();
      pointer.trail.setMutable(); // this trail will be modified in the iteration, so references to it may be modified

      var first = true;

      while ( !pointer.equalsNested( other ) ) {
        assert && assert( pointer.compareNested( other ) !== 1, 'skipped in depthFirstUntil' );
        var skipSubtree = false;

        if ( first ) {
          // start point
          if ( !excludeEndpoints ) {
            skipSubtree = callback( pointer );
          }
          first = false;
        }
        else {
          // between point
          skipSubtree = callback( pointer );
        }

        if ( skipSubtree && pointer.isBefore ) {
          // to skip the subtree, we just change to isAfter
          pointer.setBefore( false );

          // if we skip a subtree, make sure we don't run past the ending pointer
          if ( pointer.compareNested( other ) === 1 ) {
            break;
          }
        }
        else {
          pointer.nestedForwards();
        }
      }

      // end point
      if ( !excludeEndpoints ) {
        callback( pointer );
      }
    },

    toString: function() {
      return '[' + ( this.isBefore ? 'before' : 'after' ) + ' ' + this.trail.toString().slice( 1 );
    }
  } );

  // same as new TrailPointer( trailA, isBeforeA ).compareNested( new TrailPointer( trailB, isBeforeB ) )
  TrailPointer.compareNested = function( trailA, isBeforeA, trailB, isBeforeB ) {
    var comparison = trailA.compare( trailB );

    if ( comparison === 0 ) {
      // if trails are equal, just compare before/after
      if ( isBeforeA === isBeforeB ) {
        return 0;
      }
      else {
        return isBeforeA ? -1 : 1;
      }
    }
    else {
      // if one is an extension of the other, the shorter isBefore flag determines the order completely
      if ( trailA.isExtensionOf( trailB ) ) {
        return isBeforeB ? 1 : -1;
      }
      else if ( trailB.isExtensionOf( trailA ) ) {
        return isBeforeA ? -1 : 1;
      }
      else {
        // neither is a subtrail of the other, so a straight trail comparison should give the answer
        return comparison;
      }
    }
  };

  return TrailPointer;
} );


// Copyright 2013-2016, University of Colorado Boulder


/**
 * Represents a trail (path in the graph) from a 'root' node down to a descendant node.
 * In a DAG, or with different views, there can be more than one trail up from a node,
 * even to the same root node!
 *
 * It has an array of nodes, in order from the 'root' down to the last node,
 * a length, and an array of indices such that node_i.children[index_i] === node_{i+1}.
 *
 * The indices can sometimes become stale when nodes are added and removed, so Trails
 * can have their indices updated with reindex(). It's designed to be as fast as possible
 * on Trails that are already indexed accurately.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Trail',['require','PHET_CORE/inherit','DOT/Matrix3','DOT/Transform3','SCENERY/scenery','SCENERY/util/TrailPointer','SCENERY/nodes/Node'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );

  var scenery = require( 'SCENERY/scenery' );

  require( 'SCENERY/util/TrailPointer' );

  require( 'SCENERY/nodes/Node' );
  // require( 'SCENERY/util/TrailPointer' );

  function Trail( nodes ) {
    /*
     * Controls the immutability of the trail.
     * If set to true, add/remove descendant/ancestor should fail if assertions are enabled
     * Use setImmutable() or setMutable() to signal a specific type of protection, so it cannot be changed later
     */
    if ( assert ) {
      // only do this if assertions are enabled, otherwise we won't access it at all
      this.immutable = undefined;
    }

    if ( nodes instanceof Trail ) {
      // copy constructor (takes advantage of already built index information)
      var otherTrail = nodes;

      this.nodes = otherTrail.nodes.slice( 0 );
      this.length = otherTrail.length;
      this.uniqueId = otherTrail.uniqueId;
      this.indices = otherTrail.indices.slice( 0 );
      return;
    }

    this.nodes = [];
    this.length = 0;
    this.uniqueId = '';

    // indices[x] stores the index of nodes[x] in nodes[x-1]'s children, e.g. nodes[i].children[ indices[i] ] === nodes[i+1]
    this.indices = [];

    var self = this;
    if ( nodes ) {
      if ( nodes instanceof scenery.Node ) {
        var node = nodes;

        // add just a single node in
        self.addDescendant( node );
      }
      else {
        // process it as an array
        var len = nodes.length;
        for ( var i = 0; i < len; i++ ) {
          self.addDescendant( nodes[ i ] );
        }
      }
    }

    phetAllocation && phetAllocation( 'Trail' );
  }

  scenery.register( 'Trail', Trail );

  inherit( Object, Trail, {
    /**
     * Returns a copy of this Trail that can be modified independently
     * @public
     *
     * @returns {Trail}
     */
    copy: function() {
      return new Trail( this );
    },

    /**
     * Whether the leaf-most Node in our trail will render something
     * @public (scenery-internal)
     *
     * @returns {boolean}
     */
    isPainted: function() {
      return this.lastNode().isPainted();
    },

    // @returns whether all nodes in the trail are still connected from the trail's root to its leaf
    isValid: function() {
      this.reindex();

      var indexLength = this.indices.length;
      for ( var i = 0; i < indexLength; i++ ) {
        if ( this.indices[ i ] < 0 ) {
          return false;
        }
      }

      return true;
    },

    // this trail is visible only if all nodes on it are marked as visible
    isVisible: function() {
      var i = this.nodes.length;
      while ( i-- ) {
        if ( !this.nodes[ i ].isVisible() ) {
          return false;
        }
      }
      return true;
    },

    getOpacity: function() {
      var opacity = 1;
      var i = this.nodes.length;
      while ( i-- ) {
        opacity *= this.nodes[ i ].getOpacity();
      }
      return opacity;
    },

    // essentially whether this node is visited in the hit-testing operation
    isPickable: function() {
      // it won't be if it or any ancestor is pickable: false, or is invisible
      if ( _.some( this.nodes, function( node ) { return node.pickable === false || node.visible === false; } ) ) { return false; }

      // if there is any listener or pickable: true, it will be pickable
      if ( _.some( this.nodes, function( node ) { return node._inputListeners.length > 0 || node._pickable === true; } ) ) { return true; }

      // TODO: Is this even necessary?
      if ( this.lastNode()._picker._subtreePickableCount > 0 ) {
        return true;
      }

      // no listeners or pickable: true, so it will be pruned
      return false;
    },

    get: function( index ) {
      if ( index >= 0 ) {
        return this.nodes[ index ];
      }
      else {
        // negative index goes from the end of the array
        return this.nodes[ this.nodes.length + index ];
      }
    },

    slice: function( startIndex, endIndex ) {
      return new Trail( this.nodes.slice( startIndex, endIndex ) );
    },

    // TODO: consider renaming to subtrailToExcluding and subtrailToIncluding?
    subtrailTo: function( node, excludeNode ) {
      return this.slice( 0, _.indexOf( this.nodes, node ) + ( excludeNode ? 0 : 1 ) );
    },

    isEmpty: function() {
      return this.nodes.length === 0;
    },

    // from local to global
    getMatrix: function() {
      // TODO: performance: can we cache this ever? would need the rootNode to not really change in between
      // this matrix will be modified in place, so always start fresh
      var matrix = Matrix3.identity();

      // from the root up
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 0; i < length; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },

    // from local to next-to-global (ignores root node matrix)
    getAncestorMatrix: function() {
      // TODO: performance: can we cache this ever? would need the rootNode to not really change in between
      // this matrix will be modified in place, so always start fresh
      var matrix = Matrix3.identity();

      // from the root up
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 1; i < length; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },

    // from parent to global
    getParentMatrix: function() {
      // this matrix will be modified in place, so always start fresh
      var matrix = Matrix3.identity();

      // from the root up
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 0; i < length - 1; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },

    // from local to global
    getTransform: function() {
      return new Transform3( this.getMatrix() );
    },

    // from parent to global
    getParentTransform: function() {
      return new Transform3( this.getParentMatrix() );
    },

    addAncestor: function( node, index ) {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with addAncestor' );
      assert && assert( node, 'cannot add falsy value to a Trail' );


      if ( this.nodes.length ) {
        var oldRoot = this.nodes[ 0 ];
        this.indices.unshift( index === undefined ? _.indexOf( node._children, oldRoot ) : index );
      }
      this.nodes.unshift( node );

      this.length++;
      // accelerated version of this.updateUniqueId()
      this.uniqueId = ( this.uniqueId ? node.id + '-' + this.uniqueId : node.id + '' );
      return this;
    },

    removeAncestor: function() {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeAncestor' );
      assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );

      this.nodes.shift();
      if ( this.indices.length ) {
        this.indices.shift();
      }

      this.length--;
      this.updateUniqueId();
      return this;
    },

    addDescendant: function( node, index ) {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with addDescendant' );
      assert && assert( node, 'cannot add falsy value to a Trail' );


      if ( this.nodes.length ) {
        var parent = this.lastNode();
        this.indices.push( index === undefined ? _.indexOf( parent._children, node ) : index );
      }
      this.nodes.push( node );

      this.length++;
      // accelerated version of this.updateUniqueId()
      this.uniqueId = ( this.uniqueId ? this.uniqueId + '-' + node.id : node.id + '' );
      return this;
    },

    removeDescendant: function() {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeDescendant' );
      assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );

      this.nodes.pop();
      if ( this.indices.length ) {
        this.indices.pop();
      }

      this.length--;
      this.updateUniqueId();
      return this;
    },

    addDescendantTrail: function( trail ) {
      var length = trail.length;
      if ( length ) {
        this.addDescendant( trail.nodes[ 0 ] );
      }
      for ( var i = 1; i < length; i++ ) {
        this.addDescendant( trail.nodes[ i ], this.indices[ i - 1 ] );
      }
    },

    removeDescendantTrail: function( trail ) {
      var length = trail.length;
      for ( var i = length - 1; i >= 0; i-- ) {
        assert && assert( this.lastNode() === trail.nodes[ i ] );

        this.removeDescendant();
      }
    },

    // refreshes the internal index references (important if any children arrays were modified!)
    reindex: function() {
      var length = this.length;
      for ( var i = 1; i < length; i++ ) {
        // only replace indices where they have changed (this was a performance hotspot)
        var currentIndex = this.indices[ i - 1 ];
        var baseNode = this.nodes[ i - 1 ];

        if ( baseNode._children[ currentIndex ] !== this.nodes[ i ] ) {
          this.indices[ i - 1 ] = _.indexOf( baseNode._children, this.nodes[ i ] );
        }
      }
    },

    setImmutable: function() {
      // if assertions are disabled, we hope this is inlined as a no-op
      if ( assert ) {
        assert( this.immutable !== false, 'A trail cannot be made immutable after being flagged as mutable' );
        this.immutable = true;
      }

      // TODO: consider setting mutators to null here instead of the function call check (for performance, and profile the differences)

      return this; // allow chaining
    },

    setMutable: function() {
      // if assertions are disabled, we hope this is inlined as a no-op
      if ( assert ) {
        assert( this.immutable !== true, 'A trail cannot be made mutable after being flagged as immutable' );
        this.immutable = false;
      }

      return this; // allow chaining
    },

    areIndicesValid: function() {
      for ( var i = 1; i < this.length; i++ ) {
        var currentIndex = this.indices[ i - 1 ];
        if ( this.nodes[ i - 1 ]._children[ currentIndex ] !== this.nodes[ i ] ) {
          return false;
        }
      }
      return true;
    },

    equals: function( other ) {
      if ( this.length !== other.length ) {
        return false;
      }

      for ( var i = 0; i < this.nodes.length; i++ ) {
        if ( this.nodes[ i ] !== other.nodes[ i ] ) {
          return false;
        }
      }

      return true;
    },

    // returns a new Trail from the root up to the parameter node.
    upToNode: function( node ) {
      var nodeIndex = _.indexOf( this.nodes, node );
      assert && assert( nodeIndex >= 0, 'Trail does not contain the node' );
      return this.slice( 0, _.indexOf( this.nodes, node ) + 1 );
    },

    // whether this trail contains the complete 'other' trail, but with added descendants afterwards
    isExtensionOf: function( other, allowSameTrail ) {
      if ( this.length <= other.length - ( allowSameTrail ? 1 : 0 ) ) {
        return false;
      }

      for ( var i = 0; i < other.nodes.length; i++ ) {
        if ( this.nodes[ i ] !== other.nodes[ i ] ) {
          return false;
        }
      }

      return true;
    },

    // a transform from our local coordinate frame to the other trail's local coordinate frame
    getTransformTo: function( otherTrail ) {
      return new Transform3( this.getMatrixTo( otherTrail ) );
    },

    // returns a matrix that transforms a point in our last node's local coordinate frame to the other trail's last node's local coordinate frame
    getMatrixTo: function( otherTrail ) {
      this.reindex();
      otherTrail.reindex();

      var branchIndex = this.getBranchIndexTo( otherTrail );
      var idx;

      var matrix = Matrix3.IDENTITY;

      // walk our transform down, prepending
      for ( idx = this.length - 1; idx >= branchIndex; idx-- ) {
        matrix = this.nodes[ idx ].getMatrix().timesMatrix( matrix );
      }

      // walk our transform up, prepending inverses
      for ( idx = branchIndex; idx < otherTrail.length; idx++ ) {
        matrix = otherTrail.nodes[ idx ].getTransform().getInverse().timesMatrix( matrix );
      }

      return matrix;
    },

    // the first index that is different between this trail and the other trail
    getBranchIndexTo: function( otherTrail ) {
      assert && assert( this.nodes[ 0 ] === otherTrail.nodes[ 0 ], 'To get a branch index, the trails must have the same root' );

      var branchIndex;

      var min = Math.min( this.length, otherTrail.length );
      for ( branchIndex = 0; branchIndex < min; branchIndex++ ) {
        if ( this.nodes[ branchIndex ] !== otherTrail.nodes[ branchIndex ] ) {
          break;
        }
      }

      return branchIndex;
    },

    /**
     * Returns the last (largest) index into the trail's nodes that has inputEnabled=true.
     * @public
     *
     * @returns {number}
     */
    getLastInputEnabledIndex: function() {
      // Determine how far up the Trail input is determined. The first node with !inputEnabled and after will not have
      // events fired (see https://github.com/phetsims/sun/issues/257)
      var trailStartIndex = -1;
      for ( var j = 0; j < this.length; j++ ) {
        if ( !this.nodes[ j ]._inputEnabled ) {
          break;
        }

        trailStartIndex = j;
      }

      return trailStartIndex;
    },

    /**
     * Returns the leaf-most index, unless there is a Node with inputEnabled=false (in which case, the lowest index
     * for those matching Nodes are returned).
     * @public
     *
     * @returns {number}
     */
    getCursorCheckIndex: function() {
      var lastInputEnabledIndex = this.getLastInputEnabledIndex();
      if ( lastInputEnabledIndex + 1 < this.length ) {
        return lastInputEnabledIndex + 1;
      }
      else {
        return lastInputEnabledIndex;
      }
    },

    // TODO: phase out in favor of get()
    nodeFromTop: function( offset ) {
      return this.nodes[ this.length - 1 - offset ];
    },

    lastNode: function() {
      return this.nodeFromTop( 0 );
    },

    rootNode: function() {
      return this.nodes[ 0 ];
    },

    // returns the previous graph trail in the order of self-rendering
    previous: function() {
      if ( this.nodes.length <= 1 ) {
        return null;
      }

      var top = this.nodeFromTop( 0 );
      var parent = this.nodeFromTop( 1 );

      var parentIndex = _.indexOf( parent._children, top );
      assert && assert( parentIndex !== -1 );
      var arr = this.nodes.slice( 0, this.nodes.length - 1 );
      if ( parentIndex === 0 ) {
        // we were the first child, so give it the trail to the parent
        return new Trail( arr );
      }
      else {
        // previous child
        arr.push( parent._children[ parentIndex - 1 ] );

        // and find its last terminal
        while ( arr[ arr.length - 1 ]._children.length !== 0 ) {
          var last = arr[ arr.length - 1 ];
          arr.push( last._children[ last._children.length - 1 ] );
        }

        return new Trail( arr );
      }
    },

    // like previous(), but keeps moving back until the trail goes to a node with isPainted() === true
    previousPainted: function() {
      var result = this.previous();
      while ( result && !result.isPainted() ) {
        result = result.previous();
      }
      return result;
    },

    // in the order of self-rendering
    next: function() {
      var arr = this.nodes.slice( 0 );

      var top = this.nodeFromTop( 0 );
      if ( top._children.length > 0 ) {
        // if we have children, return the first child
        arr.push( top._children[ 0 ] );
        return new Trail( arr );
      }
      else {
        // walk down and attempt to find the next parent
        var depth = this.nodes.length - 1;

        while ( depth > 0 ) {
          var node = this.nodes[ depth ];
          var parent = this.nodes[ depth - 1 ];

          arr.pop(); // take off the node so we can add the next sibling if it exists

          var index = _.indexOf( parent._children, node );
          if ( index !== parent._children.length - 1 ) {
            // there is another (later) sibling. use that!
            arr.push( parent._children[ index + 1 ] );
            return new Trail( arr );
          }
          else {
            depth--;
          }
        }

        // if we didn't reach a later sibling by now, it doesn't exist
        return null;
      }
    },

    // like next(), but keeps moving back until the trail goes to a node with isPainted() === true
    nextPainted: function() {
      var result = this.next();
      while ( result && !result.isPainted() ) {
        result = result.next();
      }
      return result;
    },

    // calls callback( trail ) for this trail, and each descendant trail. If callback returns true, subtree will be skipped
    eachTrailUnder: function( callback ) {
      // TODO: performance: should be optimized to be much faster, since we don't have to deal with the before/after
      new scenery.TrailPointer( this, true ).eachTrailBetween( new scenery.TrailPointer( this, false ), callback );
    },

    /*
     * Standard Java-style compare. -1 means this trail is before (under) the other trail, 0 means equal, and 1 means this trail is
     * after (on top of) the other trail.
     * A shorter subtrail will compare as -1.
     *
     * Assumes that the Trails are properly indexed. If not, please reindex them!
     *
     * Comparison is for the rendering order, so an ancestor is 'before' a descendant
     */
    compare: function( other ) {
      assert && assert( !this.isEmpty(), 'cannot compare with an empty trail' );
      assert && assert( !other.isEmpty(), 'cannot compare with an empty trail' );
      assert && assert( this.nodes[ 0 ] === other.nodes[ 0 ], 'for Trail comparison, trails must have the same root node' );
      assertSlow && assertSlow( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed on ' + this.toString() );
      assertSlow && assertSlow( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed on ' + other.toString() );

      var minNodeIndex = Math.min( this.indices.length, other.indices.length );
      for ( var i = 0; i < minNodeIndex; i++ ) {
        if ( this.indices[ i ] !== other.indices[ i ] ) {
          if ( this.indices[ i ] < other.indices[ i ] ) {
            return -1;
          }
          else {
            return 1;
          }
        }
      }

      // we scanned through and no nodes were different (one is a subtrail of the other)
      if ( this.nodes.length < other.nodes.length ) {
        return -1;
      }
      else if ( this.nodes.length > other.nodes.length ) {
        return 1;
      }
      else {
        return 0;
      }
    },

    isBefore: function( other ) {
      return this.compare( other ) === -1;
    },

    isAfter: function( other ) {
      return this.compare( other ) === 1;
    },

    localToGlobalPoint: function( point ) {
      // TODO: performance: multiple timesVector2 calls up the chain is probably faster
      return this.getMatrix().timesVector2( point );
    },

    localToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getMatrix() );
    },

    globalToLocalPoint: function( point ) {
      return this.getTransform().inversePosition2( point );
    },

    globalToLocalBounds: function( bounds ) {
      return this.getTransform().inverseBounds2( bounds );
    },

    parentToGlobalPoint: function( point ) {
      // TODO: performance: multiple timesVector2 calls up the chain is probably faster
      return this.getParentMatrix().timesVector2( point );
    },

    parentToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getParentMatrix() );
    },

    globalToParentPoint: function( point ) {
      return this.getParentTransform().inversePosition2( point );
    },

    globalToParentBounds: function( bounds ) {
      return this.getParentTransform().inverseBounds2( bounds );
    },

    updateUniqueId: function() {
      // string concatenation is faster, see http://jsperf.com/string-concat-vs-joins
      var result = '';
      var len = this.nodes.length;
      if ( len > 0 ) {
        result += this.nodes[ 0 ]._id;
      }
      for ( var i = 1; i < len; i++ ) {
        result += '-' + this.nodes[ i ]._id;
      }
      this.uniqueId = result;
      // this.uniqueId = _.map( this.nodes, function( node ) { return node.getId(); } ).join( '-' );
    },

    // concatenates the unique IDs of nodes in the trail, so that we can do id-based lookups
    getUniqueId: function() {
      // sanity checks
      if ( assert ) {
        var oldUniqueId = this.uniqueId;
        this.updateUniqueId();
        assert( oldUniqueId === this.uniqueId );
      }
      return this.uniqueId;
    },

    toString: function() {
      this.reindex();
      if ( !this.length ) {
        return 'Empty Trail';
      }
      return '[Trail ' + this.indices.join( '.' ) + ' ' + this.getUniqueId() + ']';
    },

    // not optimized by any means, meant for debugging.
    toPathString: function() {
      var specialNodes = _.filter( this.nodes, function( n ) { return n.constructor.name !== 'Node'; } );
      return _.map( specialNodes, function( n ) { return n.constructor.name; } ).join( '/' );
    }
  } );

  // like eachTrailBetween, but only fires for painted trails. If callback returns true, subtree will be skipped
  Trail.eachPaintedTrailBetween = function( a, b, callback, excludeEndTrails, rootNode ) {
    Trail.eachTrailBetween( a, b, function( trail ) {
      if ( trail && trail.isPainted() ) {
        return callback( trail );
      }
    }, excludeEndTrails, rootNode );
  };

  // global way of iterating across trails. when callback returns true, subtree will be skipped
  Trail.eachTrailBetween = function( a, b, callback, excludeEndTrails, rootNode ) {
    var aPointer = a ? new scenery.TrailPointer( a.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( rootNode ), true );
    var bPointer = b ? new scenery.TrailPointer( b.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( rootNode ), false );

    // if we are excluding endpoints, just bump the pointers towards each other by one step
    if ( excludeEndTrails ) {
      aPointer.nestedForwards();
      bPointer.nestedBackwards();

      // they were adjacent, so no callbacks will be executed
      if ( aPointer.compareNested( bPointer ) === 1 ) {
        return;
      }
    }

    aPointer.depthFirstUntil( bPointer, function( pointer ) {
      if ( pointer.isBefore ) {
        return callback( pointer.trail );
      }
    }, false );
  };

  // The index at which the two trails diverge. If a.length === b.length === branchIndex, the trails are identical
  Trail.branchIndex = function( a, b ) {
    assert && assert( a.nodes[ 0 ] === b.nodes[ 0 ], 'Branch changes require roots to be the same' );
    var branchIndex;
    var shortestLength = Math.min( a.length, b.length );
    for ( branchIndex = 0; branchIndex < shortestLength; branchIndex++ ) {
      if ( a.nodes[ branchIndex ] !== b.nodes[ branchIndex ] ) {
        break;
      }
    }
    return branchIndex;
  };

  // The subtrail from the root that both trails share
  Trail.sharedTrail = function( a, b ) {
    return a.slice( 0, Trail.branchIndex( a, b ) );
  };

  Trail.appendAncestorTrailsWithPredicate = function( trailResults, trail, predicate ) {
    var root = trail.rootNode();

    if ( predicate( root ) ) {
      trailResults.push( trail.copy() );
    }

    var parentCount = root._parents.length;
    for ( var i = 0; i < parentCount; i++ ) {
      var parent = root._parents[ i ];

      trail.addAncestor( parent );
      Trail.appendAncestorTrailsWithPredicate( trailResults, trail, predicate );
      trail.removeAncestor();
    }
  };

  Trail.appendDescendantTrailsWithPredicate = function( trailResults, trail, predicate ) {
    var lastNode = trail.lastNode();

    if ( predicate( lastNode ) ) {
      trailResults.push( trail.copy() );
    }

    var childCount = lastNode._children.length;
    for ( var i = 0; i < childCount; i++ ) {
      var child = lastNode._children[ i ];

      trail.addDescendant( child, i );
      Trail.appendDescendantTrailsWithPredicate( trailResults, trail, predicate );
      trail.removeDescendant();
    }
  };

  /*
   * Fires subtree(trail) or self(trail) on the callbacks to create disjoint subtrees (trails) that cover exactly the nodes
   * inclusively between a and b in rendering order.
   * We try to consolidate these as much as possible.
   *
   * "a" and "b" are treated like self painted trails in the rendering order
   *
   *
   * Example tree:
   *   a
   *   - b
   *   --- c
   *   --- d
   *   - e
   *   --- f
   *   ----- g
   *   ----- h
   *   ----- i
   *   --- j
   *   ----- k
   *   - l
   *   - m
   *   --- n
   *
   * spannedSubtrees( a, a ) -> self( a );
   * spannedSubtrees( c, n ) -> subtree( a ); NOTE: if b is painted, that wouldn't work!
   * spannedSubtrees( h, l ) -> subtree( h ); subtree( i ); subtree( j ); self( l );
   * spannedSubtrees( c, i ) -> [b,f] --- wait, include e self?
   */
  Trail.spannedSubtrees = function( a, b ) {
    // assert && assert( a.nodes[0] === b.nodes[0], 'Spanned subtrees for a and b requires that a and b have the same root' );

    // a.reindex();
    // b.reindex();

    // var subtrees = [];

    // var branchIndex = Trail.branchIndex( a, b );
    // assert && assert( branchIndex > 0, 'Branch index should always be > 0' );

    // if ( a.length === branchIndex && b.length === branchIndex ) {
    //   // the two trails are equal
    //   subtrees.push( a );
    // } else {
    //   // find the first place where our start isn't the first child
    //   for ( var before = a.length - 1; before >= branchIndex; before-- ) {
    //     if ( a.indices[before-1] !== 0 ) {
    //       break;
    //     }
    //   }

    //   // find the first place where our end isn't the last child
    //   for ( var after = a.length - 1; after >= branchIndex; after-- ) {
    //     if ( b.indices[after-1] !== b.nodes[after-1]._children.length - 1 ) {
    //       break;
    //     }
    //   }

    //   if ( before < branchIndex && after < branchIndex ) {
    //     // we span the entire tree up to nodes[branchIndex-1], so return only that subtree
    //     subtrees.push( a.slice( 0, branchIndex ) );
    //   } else {
    //     // walk the subtrees down from the start
    //     for ( var ia = before; ia >= branchIndex; ia-- ) {
    //       subtrees.push( a.slice( 0, ia + 1 ) );
    //     }

    //     // walk through the middle
    //     var iStart = a.indices[branchIndex-1];
    //     var iEnd = b.indices[branchIndex-1];
    //     var base = a.slice( 0, branchIndex );
    //     var children = base.lastNode()._children;
    //     for ( var im = iStart; im <= iEnd; im++ ) {
    //       subtrees.push( base.copy().addDescendant( children[im], im ) );
    //     }

    //     // walk the subtrees up to the end
    //     for ( var ib = branchIndex; ib <= after; ib++ ) {
    //       subtrees.push( b.slice( 0, ib + 1 ) );
    //     }
    //   }
    // }

    // return subtrees;
  };

  return Trail;
} );



// Copyright 2014-2016, University of Colorado Boulder


/**
 * Pooled structure to record batched events efficiently. How it calls the callback is based on the type
 * (pointer/mspointer/touch/mouse). There is one BatchedDOMEvent for each DOM Event (not for each touch).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/BatchedDOMEvent',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param domEvent
   * @param type
   * @param callback
   */
  function BatchedDOMEvent( domEvent, type, callback ) {
    assert && assert( domEvent, 'for some reason, there is no DOM event?' );

    // called multiple times due to pooling, this should be re-entrant
    this.domEvent = domEvent;
    this.type = type;
    this.callback = callback;
  }

  scenery.register( 'BatchedDOMEvent', BatchedDOMEvent );

  // enum for type
  // TODO: Create a specific enumeration type for this?
  BatchedDOMEvent.POINTER_TYPE = 1;
  BatchedDOMEvent.MS_POINTER_TYPE = 2;
  BatchedDOMEvent.TOUCH_TYPE = 3;
  BatchedDOMEvent.MOUSE_TYPE = 4;
  BatchedDOMEvent.WHEEL_TYPE = 5;

  inherit( Object, BatchedDOMEvent, {
    run: function( input ) {
      var domEvent = this.domEvent;
      var callback = this.callback;

      // process whether anything under the pointers changed before running additional input events
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'validatePointers from batched event' );
      input.validatePointers();
      if ( input.logEvents ) { input.emitter.emit1( 'validatePointers();' );}

      //OHTWO TODO: switch?
      if ( this.type === BatchedDOMEvent.POINTER_TYPE ) {
        callback.call( input, domEvent.pointerId, domEvent.pointerType, input.pointFromEvent( domEvent ), domEvent );
      }
      else if ( this.type === BatchedDOMEvent.MS_POINTER_TYPE ) {
        callback.call( input, domEvent.pointerId, scenery.Input.msPointerType( domEvent ), input.pointFromEvent( domEvent ), domEvent );
      }
      else if ( this.type === BatchedDOMEvent.TOUCH_TYPE ) {
        for ( var i = 0; i < domEvent.changedTouches.length; i++ ) {
          // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList
          var touch = domEvent.changedTouches.item( i );

          callback.call( input, touch.identifier, input.pointFromEvent( touch ), domEvent );
        }
      }
      else if ( this.type === BatchedDOMEvent.MOUSE_TYPE ) {
        if ( callback === input.mouseDown ) {
          callback.call( input, null, input.pointFromEvent( domEvent ), domEvent );
        }
        else {
          callback.call( input, input.pointFromEvent( domEvent ), domEvent );
        }
      }
      else if ( this.type === BatchedDOMEvent.WHEEL_TYPE ) {
        callback.call( input, domEvent );
      }
      else {
        throw new Error( 'bad type value: ' + this.type );
      }
    },

    dispose: function() {
      // clear our references
      this.domEvent = null;
      this.callback = null;
      this.freeToPool();
    }
  } );

  BatchedDOMEvent.fromPointerEvent = function( domEvent, pointFromEvent ) {
    return BatchedDOMEvent.createFromPool( domEvent, pointFromEvent( domEvent ), domEvent.pointerId );
  };

  Poolable.mixin( BatchedDOMEvent, {
    constructorDuplicateFactory: function( pool ) {
      return function( domEvent, type, callback ) {
        if ( pool.length ) {
          var result = pool.pop();
          BatchedDOMEvent.call( result, domEvent, type, callback );
          return result;
        }
        else {
          return new BatchedDOMEvent( domEvent, type, callback );
        }
      };
    }
  } );

  return BatchedDOMEvent;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Scans through potential properties on an object to detect prefixed forms, and returns the first match.
 *
 * E.g. currently:
 * phetCore.detectPrefix( document.createElement( 'div' ).style, 'transform' ) === 'webkitTransform'
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/detectPrefix',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  // @returns the best String str where obj[str] !== undefined, or returns undefined if that is not available
  function detectPrefix( obj, name ) {
    if ( obj[ name ] !== undefined ) { return name; }

    // prepare for camelCase
    name = name.charAt( 0 ).toUpperCase() + name.slice( 1 );

    // Chrome planning to not introduce prefixes in the future, hopefully we will be safe
    if ( obj[ 'moz' + name ] !== undefined ) { return 'moz' + name; }
    if ( obj[ 'Moz' + name ] !== undefined ) { return 'Moz' + name; } // some prefixes seem to have all-caps?
    if ( obj[ 'webkit' + name ] !== undefined ) { return 'webkit' + name; }
    if ( obj[ 'ms' + name ] !== undefined ) { return 'ms' + name; }
    if ( obj[ 'o' + name ] !== undefined ) { return 'o' + name; }
    return undefined;
  }

  phetCore.register( 'detectPrefix', detectPrefix );

  return detectPrefix;
} );
// Copyright 2013-2015, University of Colorado Boulder


/**
 * Feature detection
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Features',['require','PHET_CORE/detectPrefix','SCENERY/scenery'],function( require ) {
  'use strict';

  var detectPrefix = require( 'PHET_CORE/detectPrefix' );
  var scenery = require( 'SCENERY/scenery' );

  var Features = {};
  scenery.register( 'Features', Features );

  function supportsDataURLFormatOutput( format ) {
    try {
      var canvas = document.createElement( 'canvas' );
      canvas.width = 1;
      canvas.height = 1;
      var context = canvas.getContext( '2d' );
      context.fillStyle = 'black';
      context.fillRect( 0, 0, 1, 1 );
      var url = canvas.toDataURL( [ format ] );

      var target = 'data:' + format;
      // var pngFallback = 'data:image/png';

      return url.slice( 0, target.length ) === target;
    }
    catch( e ) {
      return false;
    }
  }

  function supportsDataURLFormatOrigin( name, black1x1Url ) {
    var canvas = document.createElement( 'canvas' );
    canvas.width = 1;
    canvas.height = 1;
    var context = canvas.getContext( '2d' );

    var img = document.createElement( 'img' );
    img.crossOrigin = 'Anonymous'; // maybe setting the CORS attribute will help?

    var loadCall = function() {
      try {
        context.drawImage( img, 0, 0 );
        canvas.toDataURL();
        Features[ name ] = true;
      }
      catch( e ) {
        Features[ name ] = false;
      }
    };
    img.onload = loadCall;
    try {
      img.src = black1x1Url;
      if ( img.complete ) {
        loadCall();
      }
    }
    catch( e ) {
      Features[ name ] = false;
    }
  }

  Features.canvasPNGOutput = supportsDataURLFormatOutput( 'image/png' );
  Features.canvasJPEGOutput = supportsDataURLFormatOutput( 'image/jpeg' );
  Features.canvasGIFOutput = supportsDataURLFormatOutput( 'image/gif' );
  Features.canvasICONOutput = supportsDataURLFormatOutput( 'image/x-icon' );

  // 1x1 black output from Chrome Canvas in PNG
  supportsDataURLFormatOrigin( 'canvasPNGInput', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==' );

  // 1x1 black output from Chrome Canvas in JPEG
  supportsDataURLFormatOrigin( 'canvasJPEGInput', 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD8qqKKKAP/2Q==' );

  /*
   * This is from the following SVG:
   *
   * <?xml version="1.0"?>
   * <svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewport="0 0 1 1" width="1" height="1" >
   *   <rect x="0" y="0" width="1" height="1" rx="0" ry="0" style="fill: black; stroke: none;"></rect>
   * </svg>
   */
  supportsDataURLFormatOrigin( 'canvasSVGInput', 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3cG9ydD0iMCAwIDEgMSIgd2lkdGg9IjEiIGhlaWdodD0iMSIgPg0KICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiByeD0iMCIgcnk9IjAiIHN0eWxlPSJmaWxsOiBibGFjazsgc3Ryb2tlOiBub25lOyI+PC9yZWN0Pg0KPC9zdmc+DQo=' );

  // 1x1 black output from Photoshop in GIF
  supportsDataURLFormatOrigin( 'canvasGIFInput', 'data:image/gif;base64,R0lGODlhAQABAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAABAAEAAAICRAEAOw==' );

  // canvas prefixed names
  var canvas = document.createElement( 'canvas' );
  var ctx = canvas.getContext( '2d' );
  Features.toDataURLHD = detectPrefix( canvas, 'toDataURLHD' );
  Features.createImageDataHD = detectPrefix( ctx, 'createImageDataHD' );
  Features.getImageDataHD = detectPrefix( ctx, 'getImageDataHD' );
  Features.putImageDataHD = detectPrefix( ctx, 'putImageDataHD' );
  Features.currentTransform = detectPrefix( ctx, 'currentTransform' );

  var span = document.createElement( 'span' );
  var div = document.createElement( 'div' );
  Features.textStroke = detectPrefix( span.style, 'textStroke' );
  Features.textStrokeColor = detectPrefix( span.style, 'textStrokeColor' );
  Features.textStrokeWidth = detectPrefix( span.style, 'textStrokeWidth' );

  Features.transform = detectPrefix( div.style, 'transform' );
  Features.transformOrigin = detectPrefix( div.style, 'transformOrigin' );
  Features.backfaceVisibility = detectPrefix( div.style, 'backfaceVisibility' );
  Features.borderRadius = detectPrefix( div.style, 'borderRadius' );

  Features.userSelect = detectPrefix( div.style, 'userSelect' );
  Features.touchAction = detectPrefix( div.style, 'touchAction' );
  Features.touchCallout = detectPrefix( div.style, 'touchCallout' );
  Features.userDrag = detectPrefix( div.style, 'userDrag' );
  Features.tapHighlightColor = detectPrefix( div.style, 'tapHighlightColor' );

  Features.fontSmoothing = detectPrefix( div.style, 'fontSmoothing' );

  Features.requestAnimationFrame = detectPrefix( window, 'requestAnimationFrame' );
  Features.cancelAnimationFrame = detectPrefix( window, 'cancelAnimationFrame' );

  // e.g. Features.setStyle( domElement, Features.transform, '...' ), and doesn't set it if no 'transform' attribute (prefixed or no) is found
  Features.setStyle = function( domElement, optionalKey, value ) {
    if ( optionalKey !== undefined ) {
      domElement.style[ optionalKey ] = value;
    }
  };

  // Whether passive is a supported option for adding event listeners,
  // see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners
  Features.passive = false;
  window.addEventListener( 'test', null, Object.defineProperty( {}, 'passive', {
    get: function() {
      Features.passive = true;
    }
  } ) );

  return Features;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Code for testing which platform is running.  Use sparingly, if at all!
 *
 * Sample usage:
 * if (platform.firefox) {node.renderer = 'canvas';}
 *
 * @author Sam Reid
 */
define( 'PHET_CORE/platform',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  var ua = navigator.userAgent;

  // Checks to see whether we are IE, and if so whether the version matches.
  function isIE( version ) {
    return getInternetExplorerVersion() === version;
  }

  // Whether the browser is most likely Safari running on iOS
  // See http://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari
  function isMobileSafari() {
    return !!(
      ( window.phet && phet.chipper && phet.chipper.queryParameters && phet.chipper.queryParameters[ 'phet-app' ] ) ||
      ( ( ua.match( /(iPod|iPhone|iPad)/ ) || ( navigator.platform === 'MacIntel' && navigator.maxTouchPoints >= 2 ) ) && ua.match( /AppleWebKit/ ) )
    );
  }

  //IE11 no longer reports MSIE in the user agent string, see https://github.com/phetsims/phet-core/issues/12
  //This code is adapted from http://stackoverflow.com/questions/17907445/how-to-detect-ie11
  function getInternetExplorerVersion() {
    var rv = -1;
    var re = null;
    if ( navigator.appName === 'Microsoft Internet Explorer' ) {
      re = new RegExp( 'MSIE ([0-9]{1,}[.0-9]{0,})' );
      if ( re.exec( ua ) !== null ) {
        rv = parseFloat( RegExp.$1 );
      }
    }
    else if ( navigator.appName === 'Netscape' ) {
      re = new RegExp( 'Trident/.*rv:([0-9]{1,}[.0-9]{0,})' );
      if ( re.exec( ua ) !== null ) {
        rv = parseFloat( RegExp.$1 );
      }
    }
    return rv;
  }

  var platform = {
    // Whether the browser is most likely Firefox
    firefox: ua.toLowerCase().indexOf( 'firefox' ) > -1,

    // Whether the browser is most likely Safari running on iOS
    mobileSafari: isMobileSafari(),

    // Whether the browser is a matching version of Safari running on OS X
    safari5: !!( ua.match( /Version\/5\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),
    safari6: !!( ua.match( /Version\/6\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),
    safari7: !!( ua.match( /Version\/7\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),

    // Whether the browser matches any version of safari, including mobile
    safari: isMobileSafari() || !!( ua.match( /Version\// ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),

    // Whether the browser is some type of IE (Internet Explorer)
    ie: getInternetExplorerVersion() !== -1,

    // Whether the browser is a specific version of IE (Internet Explorer)
    ie9: isIE( 9 ),
    ie10: isIE( 10 ),
    ie11: isIE( 11 ),

    // Whether the browser has Android in its user agent
    android: ua.indexOf( 'Android' ) > 0,

    // Whether the browser is Microsoft Edge
    edge: !!ua.match( /Edge\// ),

    // Whether the browser is Chromium-based (usually Chrome)
    chromium: (/chrom(e|ium)/).test( ua.toLowerCase() ) && !ua.match( /Edge\// )
  };
  phetCore.register( 'platform', platform );

  return platform;
} );
// Copyright 2013-2016, University of Colorado Boulder

/**
 * Handles attaching/detaching and forwarding browser input events to displays.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/BrowserEvents',['require','PHET_CORE/arrayRemove','SCENERY/util/Features','PHET_CORE/platform','SCENERY/scenery','SCENERY/input/BatchedDOMEvent'],function( require ) {
  'use strict';

  var arrayRemove = require( 'PHET_CORE/arrayRemove' );
  var Features = require( 'SCENERY/util/Features' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  var BatchedDOMEvent = require( 'SCENERY/input/BatchedDOMEvent' );

  // Sometimes we need to add a listener that does absolutely nothing
  var noop = function noop() {};

  var BrowserEvents = {
    /**
     * Adds a Display to the list of displays that will be notified of input events.
     * @public
     *
     * @param {Display} display
     * @param {boolean} attachToWindow - Whether events should be attached to the window. If false, they will be
     *                                   attached to the Display's domElement.
     */
    addDisplay: function( display, attachToWindow, passiveEvents ) {
      assert && assert( display instanceof scenery.Display );
      assert && assert( typeof attachToWindow === 'boolean' );
      assert && assert( !_.includes( this.attachedDisplays, display ),
        'A display cannot be concurrently attached to events more than one time' );

      this.attachedDisplays.push( display );

      if ( attachToWindow ) {
        // lazily connect listeners
        if ( this.attachedDisplays.length === 1 ) {
          this.connectWindowListeners( passiveEvents );
        }
      }
      else {
        this.addOrRemoveListeners( display.domElement, true, passiveEvents );
      }

      // Only add the wheel listeners directly on the elements, so it won't trigger outside
      display.domElement.addEventListener( 'wheel', this.onwheel, BrowserEvents.getEventOptions( passiveEvents, true ) );
    },

    /**
     * Removes a Display to the list of displays that will be notified of input events.
     * @public
     *
     * @param {Display} display
     * @param {boolean} attachToWindow - The value provided to addDisplay
     */
    removeDisplay: function( display, attachToWindow, passiveEvents ) {
      assert && assert( display instanceof scenery.Display );
      assert && assert( typeof attachToWindow === 'boolean' );
      assert && assert( _.includes( this.attachedDisplays, display ),
        'This display was not already attached to listen for window events' );

      arrayRemove( this.attachedDisplays, display );

      // lazily disconnect listeners
      if ( attachToWindow ) {
        if ( this.attachedDisplays.length === 0 ) {
          this.disconnectWindowListeners( passiveEvents );
        }
      }
      else {
        this.addOrRemoveListeners( display.domElement, false, passiveEvents );
      }

      display.domElement.removeEventListener( 'wheel', this.onwheel, BrowserEvents.getEventOptions( passiveEvents, true ) );
    },

    getEventOptions: function( passiveEvents, isMain ) {
      var passDirectPassiveFlag = Features.passive && passiveEvents !== null;
      if ( !passDirectPassiveFlag ) {
        return false;
      }
      if ( isMain ) {
        return {
          useCapture: false,
          passive: passiveEvents
        };
      }
      else {
        return {
          passive: passiveEvents
        };
      }
    },

    /**
     * {number} - Will be checked/mutated when listeners are added/removed.
     * @private
     */
    listenersAttachedToWindow: 0,

    /**
     * {number} - Will be checked/mutated when listeners are added/removed.
     * @private
     */
    listenersAttachedToElement: 0,

    /**
     * {Array.<Display>} - All Displays that should have input events forwarded.
     * @private
     */
    attachedDisplays: [],

    /**
     * {boolean} - Whether pointer events in the format specified by the W3C specification are allowed.
     * @private
     *
     * NOTE: Pointer events are currently disabled for Firefox due to https://github.com/phetsims/scenery/issues/837.
     */
    canUsePointerEvents: !!( ( window.navigator && window.navigator.pointerEnabled ) || window.PointerEvent ) && !platform.firefox,

    /**
     * {boolean} - Whether pointer events in the format specified by the MS specification are allowed.
     * @private
     */
    canUseMSPointerEvents: window.navigator && window.navigator.msPointerEnabled,

    /**
     * {Array.<string>} - All W3C pointer event types that we care about.
     * @private
     */
    pointerListenerTypes: [
      'pointerdown',
      'pointerup',
      'pointermove',
      'pointerover',
      'pointerout',
      'pointercancel',
      'gotpointercapture',
      'lostpointercapture'
    ],

    /**
     * {Array.<string>} - All MS pointer event types that we care about.
     * @private
     */
    msPointerListenerTypes: [
      'MSPointerDown',
      'MSPointerUp',
      'MSPointerMove',
      'MSPointerOver',
      'MSPointerOut',
      'MSPointerCancel'
    ],

    /**
     * {Array.<string>} - All touch event types that we care about
     * @private
     */
    touchListenerTypes: [
      'touchstart',
      'touchend',
      'touchmove',
      'touchcancel'
    ],

    /**
     * {Array.<string>} - All mouse event types that we care about
     * @private
     */
    mouseListenerTypes: [
      'mousedown',
      'mouseup',
      'mousemove',
      'mouseover',
      'mouseout'
    ],

    /**
     * {Array.<string>} - All wheel event types that we care about
     * @private
     */
    wheelListenerTypes: [
      'wheel'
    ],

    /**
     * Returns all event types that will be listened to on this specific platform.
     * @private
     *
     * @returns {Array.<string>}
     */
    getNonWheelUsedTypes: function() {
      var eventTypes;

      if ( this.canUsePointerEvents ) {
        // accepts pointer events corresponding to the spec at http://www.w3.org/TR/pointerevents/
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'Detected pointer events support, using that instead of mouse/touch events' );

        eventTypes = this.pointerListenerTypes;
      }
      else if ( this.canUseMSPointerEvents ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'Detected MS pointer events support, using that instead of mouse/touch events' );

        eventTypes = this.msPointerListenerTypes;
      }
      else {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'No pointer events support detected, using mouse/touch events' );

        eventTypes = this.touchListenerTypes.concat( this.mouseListenerTypes );
      }

      // eventTypes = eventTypes.concat( this.wheelListenerTypes );

      assert && assert( !_.includes( eventTypes, 'keydown' ),
        'Make sure not to preventDefault key events in the future.' );

      return eventTypes;
    },

    /**
     * Connects event listeners directly to the window.
     * @private
     */
    connectWindowListeners: function( passiveEvents ) {
      this.addOrRemoveListeners( window, true, passiveEvents );
    },

    /**
     * Disconnects event listeners from the window.
     * @private
     */
    disconnectWindowListeners: function( passiveEvents ) {
      this.addOrRemoveListeners( window, false, passiveEvents );
    },

    /**
     * Either adds or removes event listeners to an object, depending on the flag.
     * @private
     *
     * @param {*} element - The element (window or DOM element) to add listeners to.
     * @param {boolean} addOrRemove - If true, listeners will be added. If false, listeners will be removed.
     */
    addOrRemoveListeners: function( element, addOrRemove, passiveEvents ) {
      var documentOptions = BrowserEvents.getEventOptions( passiveEvents, false );
      var mainOptions = BrowserEvents.getEventOptions( passiveEvents, true );

      assert && assert( typeof addOrRemove === 'boolean' );

      var forWindow = element === window;
      assert && assert( !forWindow || ( this.listenersAttachedToWindow > 0 ) === !addOrRemove,
        'Do not add listeners to the window when already attached, or remove listeners when none are attached' );

      var delta = addOrRemove ? 1 : -1;
      if ( forWindow ) {
        this.listenersAttachedToWindow += delta;
      }
      else {
        this.listenersAttachedToElement += delta;
      }
      assert && assert( this.listenersAttachedToWindow === 0 || this.listenersAttachedToElement === 0,
        'Listeners should not be added both with addDisplayToWindow and addDisplayToElement. Use only one.' );

      var method = addOrRemove ? 'addEventListener' : 'removeEventListener';

      // {Array.<string>}
      var eventTypes = this.getNonWheelUsedTypes();

      for ( var i = 0; i < eventTypes.length; i++ ) {
        var type = eventTypes[ i ];

        // If we add input listeners to the window itself, iOS Safari 7 won't send touch events to displays in an
        // iframe unless we also add dummy listeners to the document.
        if ( forWindow ) {
          document[ method ]( type, noop, documentOptions );
        }

        var callback = this[ 'on' + type ];
        assert && assert( !!callback );

        element[ method ]( type, callback, mainOptions ); // false: don't use event capture for now
      }
    },

    /**
     * Sets an event from the window to be batched on all of the displays.
     * @private
     *
     * @param {Event} domEvent
     * @param {BatchedDOMEvent.Type} - TODO: turn to full enumeration?
     * @param {string} inputCallbackName - e.g. 'mouseDown', will trigger Input.mouseDown
     * @param {boolean} triggerImmediate - Whether this will be force-executed now, causing all batched events to fire.
     *                                     Useful for events (like mouseup) that responding synchronously is
     *                                     necessary for certain security-sensitive actions (like triggering
     *                                     full-screen).
     */
    batchWindowEvent: function( domEvent, batchType, inputCallbackName, triggerImmediate ) {
      // NOTE: For now, we don't check whether the event is actually within the display's boundingClientRect. Most
      // displays will want to receive events outside of their bounds (especially for checking drags and mouse-ups
      // outside of their bounds).
      for ( var i = 0; i < this.attachedDisplays.length; i++ ) {
        var display = this.attachedDisplays[ i ];
        var input = display._input;
        input.batchEvent( domEvent, batchType, input[ inputCallbackName ], triggerImmediate );
      }
    },

    /**
     * Listener for window's pointerdown event.
     * @private
     *
     * @param {Event} domEvent
     */
    onpointerdown: function onpointerdown( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointerdown' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      if ( domEvent.pointerType === 'mouse' ) {
        scenery.Display.userGestureEmitter.emit();
      }

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerDown', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's pointerup event.
     * @private
     *
     * @param {Event} domEvent
     */
    onpointerup: function onpointerup( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointerup' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      scenery.Display.userGestureEmitter.emit();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerUp', true );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's pointermove event.
     * @private
     *
     * @param {Event} domEvent
     */
    onpointermove: function onpointermove( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointermove' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerMove', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's pointerover event.
     * @private
     *
     * @param {Event} domEvent
     */
    onpointerover: function onpointerover( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointerover' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerOver', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's pointerout event.
     * @private
     *
     * @param {Event} domEvent
     */
    onpointerout: function onpointerout( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointerout' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerOut', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's pointercancel event.
     * @private
     *
     * @param {Event} domEvent
     */
    onpointercancel: function onpointercancel( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointercancel' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerCancel', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's gotpointercapture event.
     * @private
     *
     * @param {Event} domEvent
     */
    ongotpointercapture: function ongotpointercapture( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'gotpointercapture' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'gotPointerCapture', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's lostpointercapture event.
     * @private
     *
     * @param {Event} domEvent
     */
    onlostpointercapture: function onlostpointercapture( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'lostpointercapture' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'lostPointerCapture', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's MSPointerDown event.
     * @private
     *
     * @param {Event} domEvent
     */
    onMSPointerDown: function onMSPointerDown( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerDown' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerDown', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's MSPointerUp event.
     * @private
     *
     * @param {Event} domEvent
     */
    onMSPointerUp: function onMSPointerUp( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerUp' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerUp', true );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's MSPointerMove event.
     * @private
     *
     * @param {Event} domEvent
     */
    onMSPointerMove: function onMSPointerMove( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerMove' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerMove', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's MSPointerOver event.
     * @private
     *
     * @param {Event} domEvent
     */
    onMSPointerOver: function onMSPointerOver( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerOver' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerOver', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's MSPointerOut event.
     * @private
     *
     * @param {Event} domEvent
     */
    onMSPointerOut: function onMSPointerOut( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerOut' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerOut', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's MSPointerCancel event.
     * @private
     *
     * @param {Event} domEvent
     */
    onMSPointerCancel: function onMSPointerCancel( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerCancel' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerCancel', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's touchstart event.
     * @private
     *
     * @param {Event} domEvent
     */
    ontouchstart: function ontouchstart( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'touchstart' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, 'touchStart', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's touchend event.
     * @private
     *
     * @param {Event} domEvent
     */
    ontouchend: function ontouchend( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'touchend' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      scenery.Display.userGestureEmitter.emit();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, 'touchEnd', true );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's touchmove event.
     * @private
     *
     * @param {Event} domEvent
     */
    ontouchmove: function ontouchmove( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'touchmove' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, 'touchMove', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's touchcancel event.
     * @private
     *
     * @param {Event} domEvent
     */
    ontouchcancel: function ontouchcancel( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'touchcancel' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, 'touchCancel', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's mousedown event.
     * @private
     *
     * @param {Event} domEvent
     */
    onmousedown: function onmousedown( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mousedown' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      scenery.Display.userGestureEmitter.emit();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseDown', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's mouseup event.
     * @private
     *
     * @param {Event} domEvent
     */
    onmouseup: function onmouseup( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mouseup' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      scenery.Display.userGestureEmitter.emit();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseUp', true );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's mousemove event.
     * @private
     *
     * @param {Event} domEvent
     */
    onmousemove: function onmousemove( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mousemove' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseMove', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's mouseover event.
     * @private
     *
     * @param {Event} domEvent
     */
    onmouseover: function onmouseover( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mouseover' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseOver', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's mouseout event.
     * @private
     *
     * @param {Event} domEvent
     */
    onmouseout: function onmouseout( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mouseout' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseOut', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },

    /**
     * Listener for window's wheel event.
     * @private
     *
     * @param {Event} domEvent
     */
    onwheel: function onwheel( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'wheel' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();

      // NOTE: Will be called without a proper 'this' reference. Do NOT rely on it here.
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.WHEEL_TYPE, 'wheel', false );

      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    }
  };

  scenery.register( 'BrowserEvents', BrowserEvents );

  return BrowserEvents;
} );

// Copyright 2013-2015, University of Colorado Boulder

/*
 * A pointer is an abstraction that includes a mouse and touch points (and possibly keys). The mouse is a single
 * pointer, and each finger (for touch) is a pointer.
 *
 * Listeners that can be added to the pointer, and events will be fired on these listeners before any listeners are
 * fired on the Node structure. This is typically very useful for tracking dragging behavior (where the pointer may
 * cross areas where the dragged node is not directly below the pointer any more).
 *
 * A valid listener should be an object. If a listener has a property with a Scenery event name (e.g. 'down' or
 * 'touchmove'), then that property will be assumed to be a method and will be called with the Scenery event (like
 * normal input listeners, see Node.addInputListener).
 *
 * Pointers can have one active "attached" listener, which is the main handler for responding to the events. This helps
 * when the main behavior needs to be interrupted, or to determine if the pointer is already in use. Additionally, this
 * can be used to prevent pointers from dragging or interacting with multiple components at the same time.
 *
 * A listener may have an interrupt() method that will attemp to interrupt its behavior. If it is added as an attached
 * listener, then it must have an interrupt() method.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Pointer',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','AXON/BooleanProperty'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var BooleanProperty = require( 'AXON/BooleanProperty' );

  /**
   * @constructor
   * @protected (scenery-internal)
   *
   * @param {Vector2|null} initialPoint
   * @param {boolean} initialDownState
   */
  function Pointer( initialPoint, initialDownState ) {
    assert && assert( initialPoint === null || initialPoint instanceof Vector2 );
    assert && assert( typeof initialDownState === 'boolean' );

    // @public {Vector2|null} - The location of the pointer in the global coordinate system. If there has no location
    //                          recorded yet, it may be null.
    this.point = initialPoint;

    // @public {Trail|null} - The trail that the pointer is currently over (if it has yet been registered). If the
    //                        pointer has not yet registered a trail, it may be null. If the pointer wasn't over any
    //                        specific trail, then a trail with only the display's rootNode will be set.
    this.trail = null;

    // @public {BooleanProperty} - Whether this pointer is 'down' (pressed).
    this.isDownProperty = new BooleanProperty( initialDownState );

    // @public {BooleanProperty} - Whether there is a main listener "attached" to this pointer. This signals that the
    // listener is "doing" something with the pointer, and that it should be interrupted if other actions need to take
    // over the pointer behavior.
    this.attachedProperty = new BooleanProperty( false );

    // @private {Array.<Object>} - All attached listeners (will be activated in order). See top-level documentation for
    //                             information about listener structure.
    this._listeners = [];

    // @private {Object|null} - Our main "attached" listener, if there is one (otherwise null)
    this._attachedListener = null;

    // @private {string|null} - See setCursor() for more information.
    this._cursor = null;

    phetAllocation && phetAllocation( 'Pointer' );

    // @private {boolean}
    this._pointerCaptured = false;
  }

  scenery.register( 'Pointer', Pointer );

  inherit( Object, Pointer, {
    /**
     * Sets a cursor that takes precedence over cursor values specified on the pointer's trail.
     * @public
     *
     * Typically this can be set when a drag starts (and returned to null when the drag ends), so that the cursor won't
     * change while dragging (regardless of what is actually under the pointer). This generally will only apply to the
     * Mouse subtype of Pointer.
     *
     * NOTE: Consider setting this only for attached listeners in the future (or have a cursor field on pointers).
     *
     * @param {string|null} cursor
     * @returns {Pointer} - For chaining
     */
    setCursor: function( cursor ) {
      this._cursor = cursor;

      return this; // TODO: is chaining actually used? Not that helpful of a pattern with pointers.
    },
    set cursor( value ) { return this.setCursor( value ); },

    /**
     * Returns the current cursor override (or null if there is one). See setCursor().
     * @public
     *
     * @returns {string|null}
     */
    getCursor: function() {
      return this._cursor;
    },
    get cursor() { return this.getCursor(); },

    /**
     * Returns a defensive copy of all listeners attached to this pointer.
     * @public (scenery-internal)
     *
     * @returns {Array.<Object>}
     */
    getListeners: function() {
      return this._listeners.slice();
    },
    get listeners() { return this.getListeners(); },

    /**
     * Adds an input listener to this pointer. If the attach flag is true, then it will be set as the "attached"
     * listener.
     * @public
     *
     * @param {Object} listener - See top-level documentation for description of the listener API
     * @param {boolean} [attach]
     */
    addInputListener: function( listener, attach ) {
      assert && assert( listener, 'A listener must be provided' );
      assert && assert( attach === undefined || typeof attach === 'boolean',
        'If provided, the attach parameter should be a boolean value' );

      assert && assert( !_.includes( this._listeners, listener ),
        'Attempted to add an input listener that was already added' );

      this._listeners.push( listener );

      if ( attach ) {
        this.attach( listener );
      }
    },

    /**
     * Removes an input listener from this pointer.
     * @public
     *
     * @param {Object} listener - See top-level documentation for description of the listener API
     */
    removeInputListener: function( listener ) {
      assert && assert( listener, 'A listener must be provided' );

      var index = _.indexOf( this._listeners, listener );
      assert && assert( index !== -1, 'Could not find the input listener to remove' );

      // If this listener is our attached listener, also detach it
      if ( this.isAttached() && listener === this._attachedListener ) {
        this.detach( listener );
      }

      this._listeners.splice( index, 1 );
    },

    /**
     * Returns whether this pointer has an attached (primary) listener.
     * @public
     *
     * @returns {boolean}
     */
    isAttached: function() {
      return this.attachedProperty.value;
    },

    /**
     * Sets whether this pointer is down/pressed, or up.
     * @public
     *
     * NOTE: Naming convention is for legacy code, would usually have pointer.down
     * TODO: improve name, .setDown( value ) with .down =
     *
     * @param {boolean} value
     */
    set isDown( value ) {
      this.isDownProperty.value = value;
    },

    /**
     * Returns whether this pointer is down/pressed, or up.
     * @public
     *
     * NOTE: Naming convention is for legacy code, would usually have pointer.down
     * TODO: improve name, .isDown() with .down
     *
     * @returns {boolean}
     */
    get isDown() {
      return this.isDownProperty.value;
    },

    /**
     * If there is an attached listener, interrupt it.
     * @public
     *
     * After this executes, this pointer should not be attached.
     */
    interruptAttached: function() {
      if ( this.isAttached() ) {
        this._attachedListener.interrupt(); // Any listener that uses the 'attach' API should have interrupt()
      }
    },

    /**
     * Interrupts all listeners on this pointer.
     * @public
     */
    interruptAll: function() {
      var listeners = this._listeners.slice();
      for ( var i = 0; i < listeners.length; i++ ) {
        var listener = listeners[ i ];
        listener.interrupt && listener.interrupt();
      }
    },

    /**
     * Marks the pointer as attached to this listener.
     * @private
     *
     * @param {Object} listener
     */
    attach: function( listener ) {
      assert && assert( !this.isAttached(), 'Attempted to attach to an already attached pointer' );

      this.attachedProperty.value = true;
      this._attachedListener = listener;
    },

    /**
     * Marks the pointer as detached from a previously attached listener.
     * @private
     *
     * @param {Object} listener
     */
    detach: function( listener ) {
      assert && assert( this.isAttached(), 'Cannot detach a listener if one is not attached' );
      assert && assert( this._attachedListener === listener, 'Cannot detach a different listener' );

      this.attachedProperty.value = false;
      this._attachedListener = null;
    },

    /**
     * Determines whether the point of the pointer has changed (used in mouse/touch/pen).
     * @protected
     *
     * @param {Vector2} point
     * @returns {boolean}
     */
    hasPointChanged: function( point ) {
      return this.point !== point && ( !point || !this.point || !this.point.equals( point ) );
    },

    /**
     * This is called when a capture starts on this pointer. We request it on pointerstart, and if received, we should
     * generally receive events outside the window.
     * @public
     */
    onGotPointerCapture() {
      this._pointerCaptured = true;
    },

    /**
     * This is called when a capture ends on this pointer. This happens normally when the user releases the pointer above
     * the sim or outside, but also in cases where we have NOT received an up/end.
     * @public
     *
     * See https://github.com/phetsims/scenery/issues/1186 for more information. We'll want to interrupt the pointer
     * on this case regardless,
     */
    onLostPointerCapture() {
      if ( this._pointerCaptured ) {
        this.interruptAll();
      }
      this._pointerCaptured = false;
    },

    /**
     * Releases references so it can be garbage collected.
     * @public
     */
    dispose: function() {
      sceneryLog && sceneryLog.Pointer && sceneryLog.Pointer( 'Disposing ' + this.toString() );

      assert && assert( this._attachedListener === null, 'Attached listeners should be cleared before pointer disposal' );
      assert && assert( this._listeners.length === 0, 'Should not have listeners when a pointer is disposed' );
    }
  } );

  return Pointer;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * A Scenery Event is an abstraction over incoming user DOM events.
 *
 * It provides more information (particularly Scenery-related information), and handles a single pointer at a time
 * (DOM TouchEvents can include information for multiple touches at the same time, so the TouchEvent can be passed to
 * multiple Scenery events). Thus it is not save to assume that the DOM event is unique, as it may be shared.
 *
 * NOTE: While the event is being dispatched, its currentTarget may be changed. It is not fully immutable.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Event',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Pointer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Trail = require( 'SCENERY/util/Trail' );
  var Pointer = require( 'SCENERY/input/Pointer' );

  /**
   * @constructor
   *
   * @param {Trail} trail - The trail to the node picked/hit by this input event.
   * @param {string} type - Type of the event, e.g. 'string'
   * @param {Pointer} pointer - The pointer that triggered this event
   * @param {DOM Event} domEvent - The original DOM Event that caused this Event to fire.
   */
  function Event( trail, type, pointer, domEvent ) {
    assert && assert( trail instanceof Trail, 'Event\'s trail parameter should be a {Trail}' );
    assert && assert( typeof type === 'string', 'Event\'s type should be a {string}' );
    assert && assert( pointer instanceof Pointer, 'Event\'s pointer parameter should be a {Pointer}' );
    // TODO: add domEvent type assertion -- will browsers support this?

    // @public {boolean} - Whether this Event has been 'handled'. If so, it will not bubble further.
    this.handled = false;

    // @public {boolean} - Whether this Event has been 'aborted'. If so, no further listeners with it will fire.
    this.aborted = false;

    // @public {Trail} - Path to the leaf-most node "hit" by the event, ordered list, from root to leaf
    this.trail = trail;

    // @public {string} - What event was triggered on the listener, e.g. 'move'
    this.type = type;

    // @public {Pointer} - The pointer that triggered this event
    this.pointer = pointer;

    // @public {DOM Event} - Raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)
    this.domEvent = domEvent;

    // @public {Node|null} - whatever node you attached the listener to, or null when firing events on a Pointer
    this.currentTarget = null;

    // @public {Node} - Leaf-most node in trail
    this.target = trail.lastNode();

    // @public {boolean} - Whether this is the 'primary' mode for the pointer. Always true for touches, and will be true
    // for the mouse if it is the primary (left) mouse button.
    // TODO: don't require check on domEvent (seems sometimes this is passed as null as a hack?)
    this.isPrimary = !pointer.isMouse || !domEvent || domEvent.button === 0;
  }

  scenery.register( 'Event', Event );

  inherit( Object, Event, {
    // like DOM Event.stopPropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event
    handle: function() {
      this.handled = true;
    },

    // like DOM Event.stopImmediatePropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event
    abort: function() {
      this.aborted = true;
    },

    /**
     * Returns whether a typical PressListener (that isn't already attached) could start a drag with this event.
     * @public
     *
     * This can typically be used for patterns where no action should be taken if a press can't be started, e.g.:
     *
     *   down: function( event ) {
     *     if ( !event.canStartPress() ) { return; }
     *
     *     // ... Do stuff to create a node with some type of PressListener
     *
     *     dragListener.press( event );
     *   }
     *
     * NOTE: This ignores non-left mouse buttons (as this is the typical behavior). Custom checks should be done if this
     *       is not suitable.
     *
     * @returns {boolean}
     */
    canStartPress: function() {
      // If the pointer is already attached (some other press probably), it can't start a press.
      // Additionally, we generally want to ignore non-left mouse buttons.
      return !this.pointer.isAttached() && ( !this.pointer.isMouse || this.domEvent.button === 0 );
    }
  } );

  return Event;
} );

// Copyright 2013-2016, University of Colorado Boulder


/**
 * Tracks the mouse state
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Mouse',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector3','SCENERY/input/Pointer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Vector3 = require( 'DOT/Vector3' );
  var Pointer = require( 'SCENERY/input/Pointer' ); // inherits from Pointer

  function Mouse() {
    Pointer.call( this, null, false );

    this.leftDown = false;
    this.middleDown = false;
    this.rightDown = false;

    // mouse wheel delta and mode for the last event, see https://developer.mozilla.org/en-US/docs/Web/Events/wheel
    this.wheelDelta = new Vector3();
    this.wheelDeltaMode = 0; // 0: pixels, 1: lines, 2: pages
  }

  scenery.register( 'Mouse', Mouse );

  inherit( Pointer, Mouse, {
    type: 'mouse',

    isMouse: true,

    down: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse down at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = true;
      switch( event.button ) {
        case 0:
          this.leftDown = true;
          break;
        case 1:
          this.middleDown = true;
          break;
        case 2:
          this.rightDown = true;
          break;
        default:
          throw new Error( 'invalid button: ' + event.button );
      }
      return pointChanged;
    },

    up: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse up at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      switch( event.button ) {
        case 0:
          this.leftDown = false;
          break;
        case 1:
          this.middleDown = false;
          break;
        case 2:
          this.rightDown = false;
          break;
        default:
          throw new Error( 'invalid button: ' + event.button );
      }
      return pointChanged;
    },

    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse move at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },

    over: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse over at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },

    out: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse out at ' + point.toString() );
      // if ( this.point ) { this.point.freeToPool(); }
      // TODO: how to handle the mouse out-of-bounds
      this.point = null;
      return pointChanged;
    },

    wheel: function( event ) {
      this.wheelDelta.setXYZ( event.deltaX, event.deltaY, event.deltaZ );
      this.wheelDeltaMode = event.deltaMode;
    },

    toString: function() {
      return 'Mouse';
    }
  } );

  return Mouse;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Tracks a stylus ('pen') or something with tilt and pressure information
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Pen',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer

  function Pen( id, point, event ) {
    Pointer.call( this, point, true ); // true: pen pointers always start in the down state

    this.id = id;
  }

  scenery.register( 'Pen', Pen );

  inherit( Pointer, Pen, {
    type: 'pen',

    isPen: true,

    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },

    end: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },

    cancel: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },

    toString: function() {
      return 'Pen#' + this.id;
    }
  } );

  return Pen;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Tracks a single touch point
 *
 * IE guidelines for Touch-friendly sites: http://blogs.msdn.com/b/ie/archive/2012/04/20/guidelines-for-building-touch-friendly-sites.aspx
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/Touch',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer

  function Touch( id, point, event ) {
    Pointer.call( this, point, true ); // true: touches always start in the down state

    this.id = id;
  }

  scenery.register( 'Touch', Touch );

  inherit( Pointer, Touch, {
    type: 'touch',

    isTouch: true,

    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      return pointChanged;
    },

    end: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },

    cancel: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      // if ( this.point ) { this.point.freeToPool(); }
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },

    toString: function() {
      return 'Touch#' + this.id;
    }
  } );

  return Touch;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Main handler for user-input events in Scenery.
 *
 * *** Adding input handling to a display
 *
 * Displays do not have event listeners attached by default. To initialize the event system (that will set up
 * listeners), use one of Display's initialize*Events functions.
 *
 * *** Pointers
 *
 * A 'pointer' is an abstract way of describing a mouse, a single touch point, or a pen/stylus, similar to in the
 * Pointer Events specification (https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html). Touch and pen
 * pointers are transient, created when the relevant DOM down event occurs and released when corresponding the DOM up
 * or cancel event occurs. However, the mouse pointer is persistent.
 *
 * Input event listeners can be added to {Node}s directly, or to a pointer. When a DOM event is received, it is first
 * broken up into multiple events (if necessary, e.g. multiple touch points), then the dispatch is handled for each
 * individual Scenery event. Events are first fired for any listeners attached to the pointer that caused the event,
 * then fire on the node directly under the pointer, and if applicable, bubble up the graph to the Scene from which the
 * event was triggered. Events are not fired directly on nodes that are not under the pointer at the time of the event.
 * To handle many common patterns (like button presses, where mouse-ups could happen when not over the button), it is
 * necessary to add those move/up listeners to the pointer itself.
 *
 * *** Listeners and Events
 *
 * Event listeners are added with node.addInputListener( listener ), pointer.addInputListener( listener ) and
 * display.addInputListener( listener ).
 * This listener can be an arbitrary object, and the listener will be triggered by calling listener[eventType]( event ),
 * where eventType is one of the event types as described below, and event is a Scenery event with the
 * following properties:
 * - trail {Trail} - Points to the node under the pointer
 * - pointer {Pointer} - The pointer that triggered the event. Additional information about the mouse/touch/pen can be
 *                       obtained from the pointer, for example event.pointer.point.
 * - type {string} - The base type of the event (e.g. for touch down events, it will always just be "down").
 * - domEvent {UIEvent} - The underlying DOM event that triggered this Scenery event. The DOM event may correspond to
 *                        multiple Scenery events, particularly for touch events. This could be a TouchEvent,
 *                        PointerEvent, MouseEvent, MSPointerEvent, etc.
 * - target {Node} - The leaf-most Node in the trail.
 * - currentTarget {Node} - The Node to which the listener being fired is attached, or null if the listener is being
 *                          fired directly from a pointer.
 *
 * Additionally, listeners may support an interrupt() method that detaches it from pointers, or may support being
 * "attached" to a pointer (indicating a primary role in controlling the pointer's behavior). See Pointer for more
 * information about these interactions.
 *
 * *** Event Types
 *
 * Scenery will fire the following base event types:
 *
 * - down: Triggered when a pointer is pressed down. Touch / pen pointers are created for each down event, and are
 *         active until an up/cancel event is sent.
 * - up: Triggered when a pointer is released normally. Touch / pen pointers will not have any more events associated
 *       with them after an up event.
 * - cancel: Triggered when a pointer is canceled abnormally. Touch / pen pointers will not have any more events
 *           associated with them after an up event.
 * - move: Triggered when a pointer moves.
 * - wheel: Triggered when the (mouse) wheel is scrolled. The associated pointer will have wheelDelta information.
 * - enter: Triggered when a pointer moves over a Node or one of its children. Does not bubble up. Mirrors behavior from
 *          the DOM mouseenter (http://www.w3.org/TR/DOM-Level-3-Events/#event-type-mouseenter)
 * - exit:  Triggered when a pointer moves out from over a Node or one of its children. Does not bubble up. Mirrors
 *          behavior from the DOM mouseleave (http://www.w3.org/TR/DOM-Level-3-Events/#event-type-mouseleave).
 * - over: Triggered when a pointer moves over a Node (not including its children). Mirrors behavior from the DOM
 *         mouseover (http://www.w3.org/TR/DOM-Level-3-Events/#event-type-mouseover).
 * - out: Triggered when a pointer moves out from over a Node (not including its children). Mirrors behavior from the
 *        DOM mouseout (http://www.w3.org/TR/DOM-Level-3-Events/#event-type-mouseout).
 *
 * Before firing the base event type (for example, 'move'), Scenery will also fire an event specific to the type of
 * pointer. For mice, it will fire 'mousemove', for touch events it will fire 'touchmove', and for pen events it will
 * fire 'penmove'. Similarly, for any type of event, it will first fire pointerType+eventType, and then eventType.
 *
 * *** Event Dispatch
 *
 * Events have two methods that will cause early termination: event.abort() will cause no more listeners to be notified
 * for this event, and event.handle() will allow the current level of listeners to be notified (all pointer listeners,
 * or all listeners attached to the current node), but no more listeners after that level will fire. handle and abort
 * are like stopPropagation, stopImmediatePropagation for DOM events, except they do not trigger those DOM methods on
 * the underlying DOM event.
 *
 * Up/down/cancel events all happen separately, but for move events, a specific sequence of events occurs if the pointer
 * changes the node it is over:
 *
 * 1. The move event is fired (and bubbles).
 * 2. An out event is fired for the old topmost Node (and bubbles).
 * 3. exit events are fired for all Nodes in the Trail hierarchy that are now not under the pointer, from the root-most
 *    to the leaf-most. Does not bubble.
 * 4. enter events are fired for all Nodes in the Trail hierarchy that were not under the pointer (but now are), from
 *    the leaf-most to the root-most. Does not bubble.
 * 5. An over event is fired for the new topmost Node (and bubbles).
 *
 * event.abort() and event.handle() will currently not affect other stages in the 'move' sequence (e.g. event.abort() in
 * the 'move' event will not affect the following 'out' event).
 *
 * For each event type:
 *
 * 1. Listeners on the pointer will be triggered first (in the order they were added)
 * 2. Listeners on the target (top-most) Node will be triggered (in the order they were added to that Node)
 * 3. Then if the event bubbles, each Node in the Trail will be triggered, starting from the Node under the top-most
 *    (that just had listeners triggered) and all the way down to the Scene. Listeners are triggered in the order they
 *    were added for each Node.
 * 4. Listeners on the display will be triggered (in the order they were added)
 *
 * For each listener being notified, it will fire the more specific pointerType+eventType first (e.g. 'mousemove'),
 * then eventType next (e.g. 'move').
 *
 * Currently, preventDefault() is called on the associated DOM event if the top-most node has the 'interactive' property
 * set to a truthy value.
 *
 * *** Relevant Specifications
 *
 * DOM Level 3 events spec: http://www.w3.org/TR/DOM-Level-3-Events/
 * Touch events spec: http://www.w3.org/TR/touch-events/
 * Pointer events spec draft: https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html
 *                            http://msdn.microsoft.com/en-us/library/ie/hh673557(v=vs.85).aspx
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid (PhET Interactive Simulations)
 */

define( 'SCENERY/input/Input',['require','SCENERY/input/BatchedDOMEvent','SCENERY/input/BrowserEvents','PHET_CORE/cleanArray','AXON/Emitter','SCENERY/input/Event','PHET_CORE/inherit','SCENERY/input/Mouse','SCENERY/input/Pen','PHET_CORE/platform','SCENERY/scenery','SCENERY/input/Touch','SCENERY/util/Trail','DOT/Vector2'],function( require ) {
  'use strict';

  var BatchedDOMEvent = require( 'SCENERY/input/BatchedDOMEvent' );
  var BrowserEvents = require( 'SCENERY/input/BrowserEvents' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Emitter = require( 'AXON/Emitter' );
  var Event = require( 'SCENERY/input/Event' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Mouse = require( 'SCENERY/input/Mouse' );
  var Pen = require( 'SCENERY/input/Pen' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  var Touch = require( 'SCENERY/input/Touch' );
  var Trail = require( 'SCENERY/util/Trail' );
  var Vector2 = require( 'DOT/Vector2' );

  // Object literal makes it easy to check for the existence of an attribute (compared to [].indexOf()>=0)
  var domEventPropertiesToSerialize = {
    button: true, keyCode: true,
    deltaX: true, deltaY: true, deltaZ: true, deltaMode: true, pointerId: true,
    pointerType: true, charCode: true, which: true, clientX: true, clientY: true, changedTouches: true
  };

  function Input( display, attachToWindow, batchDOMEvents, assumeFullWindow, passiveEvents ) {
    assert && assert( display instanceof scenery.Display );
    assert && assert( typeof attachToWindow === 'boolean' );
    assert && assert( typeof batchDOMEvents === 'boolean' );
    assert && assert( typeof assumeFullWindow === 'boolean' );

    this.display = display;
    this.rootNode = display.rootNode;
    this.attachToWindow = attachToWindow;
    this.batchDOMEvents = batchDOMEvents;
    this.assumeFullWindow = assumeFullWindow;
    this.passiveEvents = passiveEvents;
    this.displayUpdateOnEvent = false;

    this.batchedEvents = [];

    //Pointer for mouse, only created lazily on first mouse event, so no mouse is allocated on tablets
    this.mouse = null;

    this.pointers = [];

    // For PhET-iO
    // TODO: this could be made a general thing
    this.emitter = new Emitter();

    this.pointerAddedListeners = [];
  }

  scenery.register( 'Input', Input );

  inherit( Object, Input, {
    batchEvent: function( domEvent, batchType, callback, triggerImmediate ) {
      // If our display is not interactive, do not respond to any events (but still prevent default)
      if ( this.display.interactive ) {
        this.batchedEvents.push( BatchedDOMEvent.createFromPool( domEvent, batchType, callback ) );
        if ( triggerImmediate || !this.batchDOMEvents ) {
          this.fireBatchedEvents();
        }
        if ( this.displayUpdateOnEvent ) {
          //OHTWO TODO: update the display
        }
      }

      // Always preventDefault on touch events, since we don't want mouse events triggered afterwards. See
      // http://www.html5rocks.com/en/mobile/touchandmouse/ for more information.
      // Additionally, IE had some issues with skipping prevent default, see
      // https://github.com/phetsims/scenery/issues/464 for mouse handling.
      if ( !( this.passiveEvents === true ) && ( callback !== this.mouseDown || platform.ie || platform.edge ) ) {
        domEvent.preventDefault();
      }
    },

    fireBatchedEvents: function() {
      if ( this.batchedEvents.length ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'Input.fireBatchedEvents length:' + this.batchedEvents.length );

        // needs to be done in order
        var len = this.batchedEvents.length;
        for ( var i = 0; i < len; i++ ) {
          var batchedEvent = this.batchedEvents[ i ];
          batchedEvent.run( this );
          batchedEvent.dispose();
        }
        cleanArray( this.batchedEvents );
      }
    },

    clearBatchedEvents: function() {
      this.batchedEvents.length = 0;
    },

    /**
     * Removes all non-Mouse pointers from internal tracking.
     * @public (scenery-internal)
     */
    removeTemporaryPointers: function() {
      var fakeDomEvent = {
        // TODO: Does this break anything
      };

      for ( var i = this.pointers.length - 1; i >= 0; i-- ) {
        var pointer = this.pointers[ i ];
        if ( !pointer.isMouse ) {
          this.pointers.splice( i, 1 );

          // Send exit events. As we can't get a DOM event, we'll send a fake object instead.
          //TODO: consider exit() not taking an event?
          var exitTrail = pointer.trail || new Trail( this.rootNode );
          this.exitEvents( pointer, fakeDomEvent, exitTrail, 0, true );
        }
      }
    },

    connectListeners: function() {
      BrowserEvents.addDisplay( this.display, this.attachToWindow, this.passiveEvents );
    },

    disconnectListeners: function() {
      BrowserEvents.removeDisplay( this.display, this.attachToWindow, this.passiveEvents );
    },

    pointFromEvent: function( domEvent ) {
      var position = Vector2.createFromPool( domEvent.clientX, domEvent.clientY );
      if ( !this.assumeFullWindow ) {
        var domBounds = this.display.domElement.getBoundingClientRect();

        // TODO: consider totally ignoring any with zero width/height, as we aren't attached to the display?
        // For now, don't offset.
        if ( domBounds.width > 0 && domBounds.height > 0 ) {
          position.subtractXY( domBounds.left, domBounds.top );

          // Detect a scaling of the display here (the client bounding rect having different dimensions from our
          // display), and attempt to compensate.
          // NOTE: We can't handle rotation here.
          if ( domBounds.width !== this.display.width || domBounds.height !== this.display.height ) {
            // TODO: Have code verify the correctness here, and that it's not triggering all the time
            position.x *= this.display.width / domBounds.width;
            position.y *= this.display.height / domBounds.height;
          }
        }
      }
      return position;
    },

    addPointer: function( pointer ) {
      this.pointers.push( pointer );

      //Callback for showing pointer events.  Optimized for performance.
      if ( this.pointerAddedListeners.length ) {
        for ( var i = 0; i < this.pointerAddedListeners.length; i++ ) {
          this.pointerAddedListeners[ i ]( pointer );
        }
      }
    },

    addPointerAddedListener: function( listener ) {
      this.pointerAddedListeners.push( listener );
    },

    removePointerAddedListener: function( listener ) {
      var index = this.pointerAddedListeners.indexOf( listener );
      if ( index !== -1 ) {
        this.pointerAddedListeners.splice( index, index + 1 );
      }
    },

    removePointer: function( pointer ) {
      // sanity check version, will remove all instances
      for ( var i = this.pointers.length - 1; i >= 0; i-- ) {
        if ( this.pointers[ i ] === pointer ) {
          this.pointers.splice( i, 1 );
        }
      }
    },

    findPointerById: function( id ) {
      var i = this.pointers.length;
      while ( i-- ) {
        var pointer = this.pointers[ i ];
        if ( pointer.id === id ) {
          return pointer;
        }
      }
      return undefined;
    },

    //Init the mouse on the first mouse event (if any!)
    initMouse: function() {
      this.mouse = new Mouse();
      this.addPointer( this.mouse );
    },

    mouseDown: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseDown(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseDown(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }

      this.mouse.id = id;
      var pointChanged = this.mouse.down( point, event );
      if ( pointChanged ) {
        this.moveEvent( this.mouse, event );
      }
      this.downEvent( this.mouse, event );

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    mouseUp: function( point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseUp(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseUp(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }

      this.mouse.id = null;
      var pointChanged = this.mouse.up( point, event );
      if ( pointChanged ) {
        this.moveEvent( this.mouse, event );
      }
      this.upEvent( this.mouse, event );

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    mouseMove: function( point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseMove(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseMove(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.move( point, event );
      this.moveEvent( this.mouse, event );

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    mouseOver: function( point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseOver(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseOver(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.over( point, event );
      // TODO: how to handle mouse-over (and log it)

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    mouseOut: function( point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseOut(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseOut(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.out( point, event );
      // TODO: how to handle mouse-out (and log it)

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    // called on mouse wheels
    wheel: function( event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'wheel(' + Input.debugKeyEvent( event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'wheel(' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.wheel( event );

      // don't send mouse-wheel events if we don't yet have a mouse location!
      // TODO: Can we set the mouse location based on the wheel event?
      if ( this.mouse.point ) {
        var trail = this.rootNode.trailUnderPointer( this.mouse ) || new Trail( this.rootNode );
        this.dispatchEvent( trail, 'wheel', this.mouse, event, true );
      }

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    // called for each touch point
    touchStart: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchStart(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = new Touch( id, point, event );
      this.addPointer( touch );
      this.downEvent( touch, event );

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    touchEnd: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchEnd(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findPointerById( id );
      if ( touch ) {
        var pointChanged = touch.end( point, event );
        if ( pointChanged ) {
          this.moveEvent( touch, event );
        }
        this.removePointer( touch );
        this.upEvent( touch, event );
      }

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    touchMove: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchMove(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findPointerById( id );
      if ( touch ) {
        touch.move( point, event );
        this.moveEvent( touch, event );
      }

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    touchCancel: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchCancel(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findPointerById( id );
      if ( touch ) {
        var pointChanged = touch.cancel( point, event );
        if ( pointChanged ) {
          this.moveEvent( touch, event );
        }
        this.removePointer( touch );
        this.cancelEvent( touch, event );
      }

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    // called for each touch point
    penStart: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penStart(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = new Pen( id, point, event );
      this.addPointer( pen );
      this.downEvent( pen, event );

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    penEnd: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penEnd(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findPointerById( id );
      if ( pen ) {
        var pointChanged = pen.end( point, event );
        if ( pointChanged ) {
          this.moveEvent( pen, event );
        }
        this.removePointer( pen );
        this.upEvent( pen, event );
      }

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    penMove: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penMove(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findPointerById( id );
      if ( pen ) {
        pen.move( point, event );
        this.moveEvent( pen, event );
      }

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    penCancel: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penCancel(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();

      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findPointerById( id );
      if ( pen ) {
        var pointChanged = pen.cancel( point, event );
        if ( pointChanged ) {
          this.moveEvent( pen, event );
        }
        this.removePointer( pen );
        this.cancelEvent( pen, event );
      }

      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },

    pointerDown: function( id, type, point, event ) {
      // In IE for pointer down events, we want to make sure than the next interactions off the page are sent to
      // this element (it will bubble). See https://github.com/phetsims/scenery/issues/464 and
      // http://news.qooxdoo.org/mouse-capturing.
      var target = this.attachToWindow ? document.body : this.display.domElement;
      if ( target.setPointerCapture && event.pointerId ) {
        target.setPointerCapture( event.pointerId );
      }

      switch( type ) {
        case 'mouse':
          // The actual event afterwards
          this.mouseDown( id, point, event );
          break;
        case 'touch':
          this.touchStart( id, point, event );
          break;
        case 'pen':
          this.penStart( id, point, event );
          break;
        default:
          if ( assert ) {
            throw new Error( 'Unknown pointer type: ' + type );
          }
      }
    },

    pointerUp: function( id, type, point, event ) {
      switch( type ) {
        case 'mouse':
          this.mouseUp( point, event );
          break;
        case 'touch':
          this.touchEnd( id, point, event );
          break;
        case 'pen':
          this.penEnd( id, point, event );
          break;
        default:
          if ( assert ) {
            throw new Error( 'Unknown pointer type: ' + type );
          }
      }
    },

    pointerCancel: function( id, type, point, event ) {
      switch( type ) {
        case 'mouse':
          if ( console && console.log ) {
            console.log( 'WARNING: Pointer mouse cancel was received' );
          }
          break;
        case 'touch':
          this.touchCancel( id, point, event );
          break;
        case 'pen':
          this.penCancel( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },

    pointerMove: function( id, type, point, event ) {
      switch( type ) {
        case 'mouse':
          this.mouseMove( point, event );
          break;
        case 'touch':
          this.touchMove( id, point, event );
          break;
        case 'pen':
          this.penMove( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },

    /**
     * Handles a gotpointercapture event, forwarding it to the proper logical event.
     * @public (scenery-internal)
     *
     * @param {number} id
     * @param {string} type
     * @param {Vector2} point
     * @param {Event} event
     */
    gotPointerCapture( id, type, point, event ) {
      const pointer = this.findPointerById( id );

      if ( pointer ) {
        pointer.onGotPointerCapture();
      }
    },

    /**
     * Handles a lostpointercapture event, forwarding it to the proper logical event.
     * @public (scenery-internal)
     *
     * @param {number} id
     * @param {string} type
     * @param {Vector2} point
     * @param {Event} event
     */
    lostPointerCapture( id, type, point, event ) {
      const pointer = this.findPointerById( id );

      if ( pointer ) {
        pointer.onLostPointerCapture();
      }
    },

    /**
     * Handles a pointerover event, forwarding it to the proper logical event.
     * @public (scenery-internal)
     *
     * @param {number} id
     * @param {string} type
     * @param {Vector2} point
     * @param {DOMEvent} event
     */
    pointerOver( id, type, point, event ) {
      // TODO: accumulate mouse/touch info in the object if needed?
      // TODO: do we want to branch change on these types of events?
    },

    pointerOut: function( id, type, point, event ) {

    },

    pointerEnter: function( id, type, point, event ) {

    },

    pointerLeave: function( id, type, point, event ) {

    },

    upEvent: function( pointer, event ) {
      var trail = this.rootNode.trailUnderPointer( pointer ) || new Trail( this.rootNode );

      this.dispatchEvent( trail, 'up', pointer, event, true );

      // touch pointers are transient, so fire exit/out to the trail afterwards
      if ( pointer.isTouch ) {
        this.exitEvents( pointer, event, trail, 0, true );
      }

      pointer.trail = trail;
    },

    downEvent: function( pointer, event ) {
      var trail = this.rootNode.trailUnderPointer( pointer ) || new Trail( this.rootNode );

      // touch pointers are transient, so fire enter/over to the trail first
      if ( pointer.isTouch ) {
        this.enterEvents( pointer, event, trail, 0, true );
      }

      this.dispatchEvent( trail, 'down', pointer, event, true );

      pointer.trail = trail;
    },

    moveEvent: function( pointer, event ) {
      var changed = this.branchChangeEvents( pointer, event, true );
      if ( changed ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'branch change due to move event' );
      }
    },

    cancelEvent: function( pointer, event ) {
      var trail = this.rootNode.trailUnderPointer( pointer ) || new Trail( this.rootNode );

      this.dispatchEvent( trail, 'cancel', pointer, event, true );

      // touch pointers are transient, so fire exit/out to the trail afterwards
      if ( pointer.isTouch ) {
        this.exitEvents( pointer, event, trail, 0, true );
      }

      pointer.trail = trail;
    },

    // return whether there was a change
    branchChangeEvents: function( pointer, event, isMove ) {
      var trail = this.rootNode.trailUnderPointer( pointer ) || new Trail( this.rootNode );
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'checking branch change: ' + trail.toString() + ' at ' + pointer.point.toString() );
      var oldTrail = pointer.trail || new Trail( this.rootNode ); // TODO: consider a static trail reference

      var lastNodeChanged = oldTrail.lastNode() !== trail.lastNode();

      var branchIndex = Trail.branchIndex( trail, oldTrail );
      var isBranchChange = branchIndex !== trail.length || branchIndex !== oldTrail.length;
      isBranchChange && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'branch change from ' + oldTrail.toString() + ' to ' + trail.toString() );

      // event order matches http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
      if ( isMove ) {
        this.dispatchEvent( trail, 'move', pointer, event, true );
      }

      // we want to approximately mimic http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order
      // TODO: if a node gets moved down 1 depth, it may see both an exit and enter?
      if ( isBranchChange ) {
        this.exitEvents( pointer, event, oldTrail, branchIndex, lastNodeChanged );
        this.enterEvents( pointer, event, trail, branchIndex, lastNodeChanged );
      }

      pointer.trail = trail;
      return isBranchChange;
    },

    enterEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
      if ( trail.length > branchIndex ) {
        for ( var newIndex = trail.length - 1; newIndex >= branchIndex; newIndex-- ) {
          this.dispatchEvent( trail.slice( 0, newIndex + 1 ), 'enter', pointer, event, false );
        }
      }

      if ( lastNodeChanged ) {
        this.dispatchEvent( trail, 'over', pointer, event, true );
      }
    },

    exitEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
      if ( lastNodeChanged ) {
        this.dispatchEvent( trail, 'out', pointer, event, true );
      }

      if ( trail.length > branchIndex ) {
        for ( var oldIndex = branchIndex; oldIndex < trail.length; oldIndex++ ) {
          this.dispatchEvent( trail.slice( 0, oldIndex + 1 ), 'exit', pointer, event, false );
        }
      }
    },

    validatePointers: function() {
      var self = this;

      var i = this.pointers.length;
      while ( i-- ) {
        var pointer = this.pointers[ i ];
        if ( pointer.point ) {
          var changed = self.branchChangeEvents( pointer, null, false );
          if ( changed ) {
            sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'branch change due validatePointers' );
          }
        }
      }
    },

    /**
     * Dispatch to all nodes in the Trail, optionally bubbling down from the leaf to the root.
     * @private
     *
     * @param {Trail} trail
     * @param {string} type
     * @param {Pointer} pointer
     * @param {DOMEvent} event
     * @param {boolean} bubbles - If bubbles is false, the event is only dispatched to the leaf node of the trail.
     */
    dispatchEvent: function( trail, type, pointer, event, bubbles ) {
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'Input: ' + type + ' on ' + trail.toString() + ' for pointer ' + pointer.toString() + ' at ' + pointer.point.toString() );
      assert && assert( trail, 'Falsy trail for dispatchEvent' );

      // NOTE: event is not immutable, as its currentTarget changes
      var inputEvent = new Event( trail, type, pointer, event );

      // first run through the pointer's listeners to see if one of them will handle the event
      this.dispatchToListeners( pointer, pointer.getListeners(), type, inputEvent );

      // if not yet handled, run through the trail in order to see if one of them will handle the event
      // at the base of the trail should be the scene node, so the scene will be notified last
      this.dispatchToTargets( trail, type, pointer, inputEvent, bubbles );

      // Notify input listeners on the Display
      this.dispatchToListeners( pointer, this.display.getInputListeners(), type, inputEvent );
    },

    /**
     * Notifies an array of listeners with a specific event.
     * @private
     *
     * @param {Pointer} pointer
     * @param {Array.<Object>} listeners - Should be a defensive array copy already.
     * @param {string} type
     * @param {Event}
     */
    dispatchToListeners: function( pointer, listeners, type, inputEvent ) {
      if ( inputEvent.handled ) {
        return;
      }

      var specificType = pointer.type + type; // e.g. mouseup, touchup

      for ( var i = 0; i < listeners.length; i++ ) {
        var listener = listeners[ i ];

        ( !inputEvent.aborted && listener[ specificType ] ) && listener[ specificType ]( inputEvent );
        ( !inputEvent.aborted && listener[ type ] ) && listener[ type ]( inputEvent );
      }
    },

    /**
     * Dispatch to all nodes in the Trail, optionally bubbling down from the leaf to the root.
     * @private
     *
     * @param {Trail} trail
     * @param {string} type
     * @param {Pointer} pointer
     * @param {Event} inputEvent
     * @param {boolean} bubbles - If bubbles is false, the event is only dispatched to the leaf node of the trail.
     */
    dispatchToTargets: function( trail, type, pointer, inputEvent, bubbles ) {
      if ( inputEvent.aborted || inputEvent.handled ) {
        return;
      }

      for ( var i = trail.getLastInputEnabledIndex(); i >= 0; bubbles ? i-- : i = -1 ) {
        var target = trail.nodes[ i ];
        if ( target.isDisposed() ) {
          continue;
        }

        inputEvent.currentTarget = target;

        this.dispatchToListeners( pointer, target.getInputListeners(), type, inputEvent );

        // if the input event was aborted or handled, don't follow the trail down another level
        if ( inputEvent.aborted || inputEvent.handled ) {
          return;
        }
      }
    }
  }, {
    serializeDomEvent: function serializeDomEvent( domEvent ) {
      var lines = [];
      for ( var prop in domEvent ) {
        if ( domEventPropertiesToSerialize[ prop ] ) {

          // stringifying dom event object properties can cause circular references, so we avoid that completely
          if ( prop === 'touches' || prop === 'targetTouches' || prop === 'changedTouches' ) {
            var arr = [];
            for ( var i = 0; i < domEvent[ prop ].length; i++ ) {

              // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList
              var touch = domEvent[ prop ].item( i );
              arr.push( serializeDomEvent( touch ) );
            }
            lines.push( prop + ':[' + arr.join( ',' ) + ']' );
          }
          else {
            lines.push( prop + ':' + ( ( typeof domEvent[ prop ] === 'object' ) && ( domEvent[ prop ] !== null ) ? '{}' : JSON.stringify( domEvent[ prop ] ) ) );
          }
        }
      }
      return '{' + lines.join( ',' ) + '}';
    },

    serializeVector2: function( vector ) {
      return 'new dot.Vector2(' + vector.x + ',' + vector.y + ')';
    },

    debugKeyEvent: function( domEvent ) {
      return domEvent.timeStamp + ' ' + domEvent.type;
    },

    debugText: function( vector, domEvent ) {
      return vector.x + ',' + vector.y + ' ' + domEvent.timeStamp + ' ' + domEvent.type;
    },

    // maps the current MS pointer types onto the pointer spec
    msPointerType: function( evt ) {
      if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_TOUCH ) {
        return 'touch';
      }
      else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_PEN ) {
        return 'pen';
      }
      else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_MOUSE ) {
        return 'mouse';
      }
      else {
        return evt.pointerType; // hope for the best
      }
    },

    // Export some key codes for reuse in listeners.
    // TODO: See if these can be replaced by DOM/Browser API support
    KEY_SPACE: 32,
    KEY_ENTER: 13,
    KEY_TAB: 9,
    KEY_RIGHT_ARROW: 39,
    KEY_LEFT_ARROW: 37,
    KEY_UP_ARROW: 38,
    KEY_DOWN_ARROW: 40,
    KEY_SHIFT: 16,
    KEY_ESCAPE: 27,
    KEY_DELETE: 46,
    KEY_BACKSPACE: 8,
    KEY_PAGE_UP: 33,
    KEY_PAGE_DOWN: 34,
    KEY_END: 35,
    KEY_HOME: 36,
    KEY_S: 83,
    KEY_W: 87,
    KEY_A: 65,
    KEY_D: 68,
    KEY_J: 74,
    KEY_C: 67,
    KEY_N: 78,
    KEY_0: 48,
    KEY_9: 57,

    // returns whether or not the keyCode corresponds to pressing an arrow key
    isArrowKey: function( keyCode ) {
      return ( keyCode === Input.KEY_RIGHT_ARROW || keyCode === Input.KEY_LEFT_ARROW ||
               keyCode === Input.KEY_UP_ARROW || keyCode === Input.KEY_DOWN_ARROW );
    },

    // returns true if keycode is one of keys used for range inputs (key codes 33 - 40, inclusive)
    isRangeKey: function( keyCode ) {
      return ( keyCode >= Input.KEY_PAGE_UP && keyCode <= Input.KEY_DOWN_ARROW );
    },

    // returns whether or not the keyCode corresponds to pressing a number key
    isNumberKey: function( keyCode ) {
      return ( keyCode > Input.KEY_0 && keyCode < Input.KEY_9 );
    }
  } );

  Input.BASIC_EVENT_TYPES = [ 'down', 'up', 'cancel', 'move', 'wheel', 'enter', 'exit', 'over', 'out' ];
  Input.EVENT_PREFIXES = [ '', 'mouse', 'touch', 'pen' ];
  Input.ALL_EVENT_TYPES = Input.EVENT_PREFIXES.map( function( prefix ) {
    return Input.BASIC_EVENT_TYPES.map( function( eventName ) {
      return prefix + eventName;
    } );
  } );

  return Input;
} );

// Copyright 2013-2016, University of Colorado Boulder


/**
 * Basic down/up pointer handling for a Node, so that it's easy to handle buttons
 *
 * TODO: test hand handle down, go off screen, up. How to handle that properly?
 * TODO: tests
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/DownUpListener',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Input','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  var Input = require( 'SCENERY/input/Input' );
  var Trail = require( 'SCENERY/util/Trail' );

  /*
   * The 'trail' parameter passed to down/upInside/upOutside will end with the node to which this DownUpListener has been added.
   *
   * Allowed options: {
   *    mouseButton: 0  // The mouse button to use: left: 0, middle: 1, right: 2, see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
   *    down: null      // down( event, trail ) is called when the pointer is pressed down on this node
   *                    // (and another pointer is not already down on it).
   *    up: null        // up( event, trail ) is called after 'down', regardless of the pointer's current location.
   *                    // Additionally, it is called AFTER upInside or upOutside, whichever is relevant
   *    upInside: null  // upInside( event, trail ) is called after 'down', when the pointer is released inside
   *                    // this node (it or a descendant is the top pickable node under the pointer)
   *    upOutside: null // upOutside( event, trail ) is called after 'down', when the pointer is released outside
   *                    // this node (it or a descendant is the not top pickable node under the pointer, even if the
   *                    // same instance is still directly under the pointer)
   * }
   */
  function DownUpListener( options ) {
    var self = this;

    options = _.extend( {
      mouseButton: 0 // allow a different mouse button
    }, options );
    this.options = options; // @private
    this.isDown = false;   // public, whether this listener is down
    this.downCurrentTarget = null; // 'up' is handled via a pointer lister, which will have null currentTarget, so save the 'down' currentTarget
    this.downTrail = null;
    this.pointer = null;
    this.interrupted = false;

    // this listener gets added to the pointer on a 'down'
    this.downListener = {
      // mouse/touch up
      up: function( event ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener (pointer) up for ' + self.downTrail.toString() );
        assert && assert( event.pointer === self.pointer );
        if ( !event.pointer.isMouse || event.domEvent.button === self.options.mouseButton ) {
          self.buttonUp( event );
        }
      },

      interrupt: function() {
        self.interrupt();
      },

      // touch cancel
      cancel: function( event ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener (pointer) cancel for ' + self.downTrail.toString() );
        assert && assert( event.pointer === self.pointer );
        self.buttonUp( event );
      },

      // When the enter or space key is released, trigger an up event
      // TODO: Only trigger this if the enter/space key went down for this node
      keyup: function( event ) {
        var keyCode = event.domEvent.keyCode;
        if ( keyCode === Input.KEY_ENTER || keyCode === Input.KEY_SPACE ) {
          self.buttonUp( event );
        }
      }
    };
  }

  scenery.register( 'DownUpListener', DownUpListener );

  inherit( Object, DownUpListener, {
    buttonDown: function( event ) {
      // already down from another pointer, don't do anything
      if ( this.isDown ) { return; }

      // ignore other mouse buttons
      if ( event.pointer.isMouse && event.domEvent.button !== this.options.mouseButton ) { return; }

      // add our listener so we catch the up wherever we are
      event.pointer.addInputListener( this.downListener );

      this.isDown = true;
      this.downCurrentTarget = event.currentTarget;
      this.downTrail = event.trail.subtrailTo( event.currentTarget, false );
      this.pointer = event.pointer;

      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener buttonDown for ' + this.downTrail.toString() );
      if ( this.options.down ) {
        this.options.down( event, this.downTrail );
      }
    },

    buttonUp: function( event ) {
      this.isDown = false;
      this.pointer.removeInputListener( this.downListener );

      var currentTargetSave = event.currentTarget;
      event.currentTarget = this.downCurrentTarget; // up is handled by a pointer listener, so currentTarget would be null.
      if ( this.options.upInside || this.options.upOutside ) {
        var trailUnderPointer = event.trail;

        // TODO: consider changing this so that it just does a hit check and ignores anything in front?
        var isInside = trailUnderPointer.isExtensionOf( this.downTrail, true ) && !this.interrupted;

        if ( isInside && this.options.upInside ) {
          this.options.upInside( event, this.downTrail );
        }
        else if ( !isInside && this.options.upOutside ) {
          this.options.upOutside( event, this.downTrail );
        }
      }
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener buttonUp for ' + this.downTrail.toString() );
      if ( this.options.up ) {
        this.options.up( event, this.downTrail );
      }
      event.currentTarget = currentTargetSave; // be polite to other listeners, restore currentTarget
    },

    /*---------------------------------------------------------------------------*
     * events called from the node input listener
     *----------------------------------------------------------------------------*/

    // mouse/touch down on this node
    down: function( event ) {
      this.buttonDown( event );
    },

    // Called when input is interrupted on this listener, see https://github.com/phetsims/scenery/issues/218
    interrupt: function() {
      if ( this.isDown ) {
        this.interrupted = true;

        // We create a synthetic event here, as there is no available event here.
        this.buttonUp( {
          // Empty trail, so that it for-sure isn't under our downTrail (guaranteeing that isInside will be false).
          trail: new Trail(),
          currentTarget: this.downCurrentTarget,
          pointer: this.pointer
        } );

        this.interrupted = false;
      }
    },

    // When enter/space pressed for this node, trigger a button down
    keydown: function( event ) {
      var keyCode = event.domEvent.keyCode;
      if ( keyCode === Input.KEY_ENTER || keyCode === Input.KEY_SPACE ) {
        this.buttonDown( event );
      }
    }
  } );

  return DownUpListener;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Wrapper type for SCENERY ButtonListener (not SUN ButtonListener)
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SCENERY/input/TButtonListener',['require','SCENERY/scenery','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * @param {ButtonListener} buttonListener
   * @param {string} phetioID
   * @constructor
   */
  function TButtonListener( buttonListener, phetioID ) {
    TObject.call( this, buttonListener, phetioID );
    assertInstanceOf( buttonListener, phet.scenery.ButtonListener );

    toEventOnEmit( buttonListener.callbackEmitters.up.startedEmitter, buttonListener.callbackEmitters.up.endedEmitter, 'user', phetioID, this.constructor, 'up' );
    toEventOnEmit( buttonListener.callbackEmitters.over.startedEmitter, buttonListener.callbackEmitters.over.endedEmitter, 'user', phetioID, this.constructor, 'over' );
    toEventOnEmit( buttonListener.callbackEmitters.down.startedEmitter, buttonListener.callbackEmitters.down.endedEmitter, 'user', phetioID, this.constructor, 'down' );
    toEventOnEmit( buttonListener.callbackEmitters.out.startedEmitter, buttonListener.callbackEmitters.out.endedEmitter, 'user', phetioID, this.constructor, 'out' );
    toEventOnEmit( buttonListener.startedCallbacksForFireEmitter, buttonListener.endedCallbacksForFireEmitter, 'user', phetioID, this.constructor, 'fire' );
  }

  phetioInherit( TObject, 'TButtonListener', TButtonListener, {}, {
    documentation: 'Button listener',
    events: [ 'up', 'over', 'down', 'out', 'fire' ]
  } );

  scenery.register( 'TButtonListener', TButtonListener );

  return TButtonListener;
} );
// Copyright 2013-2016, University of Colorado Boulder


/**
 * Basic button handling.
 *
 * Uses 4 states:
 * up: mouse not over, not pressed
 * over: mouse over, not pressed
 * down: mouse over, pressed
 * out: mouse not over, pressed
 *
 * TODO: offscreen handling
 * TODO: fix enter/exit edge cases for moving nodes or add/remove child, and when touches are created
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/ButtonListener',['require','SCENERY/scenery','SCENERY/util/Trail','PHET_CORE/inherit','AXON/Emitter','TANDEM/Tandem','SCENERY/input/DownUpListener','SCENERY/input/TButtonListener'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var Tandem = require( 'TANDEM/Tandem' );
  var DownUpListener = require( 'SCENERY/input/DownUpListener' );
  var TButtonListener = require( 'SCENERY/input/TButtonListener' );

  /**
   * Options for the ButtonListener:
   *
   * mouseButton: 0
   * fireOnDown: false // default is to fire on 'up' after 'down', but passing fireOnDown: true will fire on 'down' instead
   * up: null          // Called on an 'up' state change, as up( event, oldState )
   * over: null        // Called on an 'over' state change, as over( event, oldState )
   * down: null        // Called on an 'down' state change, as down( event, oldState )
   * out: null         // Called on an 'out' state change, as out( event, oldState )
   * fire: null        // Called on a state change to/from 'down' (depending on fireOnDown), as fire( event ). Called after the triggering up/over/down event.
   */
  function ButtonListener( options ) {
    var self = this;

    options = _.extend( {

      // When running in PhET-iO brand, the tandem must be supplied
      tandem: Tandem.tandemOptional()
    }, options );

    this.buttonState = 'up'; // public: 'up', 'over', 'down' or 'out'

    this._overCount = 0; // how many pointers are over us (track a count, so we can handle multiple pointers gracefully)

    this._buttonOptions = options; // store the options object so we can call the callbacks

    var states = [ 'up', 'over', 'down', 'out' ];

    // @public (phet-io) - for phet-io event nesting
    this.callbackEmitters = {};
    states.forEach( function( state ) {
      self.callbackEmitters[ state ] = {
        startedEmitter: new Emitter(),
        endedEmitter: new Emitter()
      };
    } );

    // @public (phet-io) - for phet-io event nesting
    this.startedCallbacksForFireEmitter = new Emitter( { indicateCallbacks: false } );

    // @public (phet-io) - for phet-io event nesting
    this.endedCallbacksForFireEmitter = new Emitter( { indicateCallbacks: false } );

    DownUpListener.call( this, {

      mouseButton: options.mouseButton || 0, // forward the mouse button, default to 0 (LMB)

      // parameter to DownUpListener, NOT an input listener itself
      down: function( event, trail ) {
        if ( event.pointer.isKey ) {
          self.enter( event );
        }
        self.setButtonState( event, 'down' );
      },

      // parameter to DownUpListener, NOT an input listener itself
      up: function( event, trail ) {
        self.setButtonState( event, self._overCount > 0 ? 'over' : 'up' );
        if ( event.pointer.isKey ) {
          self.exit( event );
        }
      }
    } );

    options.tandem.addInstance( this, TButtonListener );
  }

  scenery.register( 'ButtonListener', ButtonListener );

  inherit( DownUpListener, ButtonListener, {

    setButtonState: function( event, state ) {
      if ( state !== this.buttonState ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
          'ButtonListener state change to ' + state + ' from ' + this.buttonState + ' for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
        var oldState = this.buttonState;

        this.buttonState = state;

        if ( this._buttonOptions[ state ] ) {

          // For PhET-iO event stream nesting, indicate the start of callbacks
          this.callbackEmitters[ state ].startedEmitter.emit();

          // Then invoke the callback
          this._buttonOptions[ state ]( event, oldState );

          // Then signify that the callbacks completed
          this.callbackEmitters[ state ].endedEmitter.emit();
        }

        if ( this._buttonOptions.fire &&
             this._overCount > 0 &&
             ( this._buttonOptions.fireOnDown ? ( state === 'down' ) : ( oldState === 'down' ) ) ) {

          // For PhET-iO event stream nesting, indicate the start of callbacks
          this.startedCallbacksForFireEmitter.emit();

          // Then fire the event
          this._buttonOptions.fire( event );

          // Then indicate the callbacks completed.
          this.endedCallbacksForFireEmitter.emit();
        }
      }
    },

    enter: function( event ) {
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'ButtonListener enter for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
      this._overCount++;
      if ( this._overCount === 1 ) {
        this.setButtonState( event, this.isDown ? 'down' : 'over' );
      }
    },

    exit: function( event ) {
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'ButtonListener exit for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
      assert && assert( this._overCount > 0, 'Exit events not matched by an enter' );
      this._overCount--;
      if ( this._overCount === 0 ) {
        this.setButtonState( event, this.isDown ? 'out' : 'up' );
      }
    }
  } );

  return ButtonListener;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Like phet-core's extend, but does not overwrite properties with undefined values.
 *
 * For example:
 *
 * extendDefined( { a: 5 }, { a: undefined } ) will return { a: 5 }
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/extendDefined',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function extendDefined( obj ) {
    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
      if ( source ) {
        for ( var prop in source ) {
          var descriptor = Object.getOwnPropertyDescriptor( source, prop );

          if ( descriptor && ( typeof descriptor.get === 'function' || source[ prop ] !== undefined ) ) {
            Object.defineProperty( obj, prop, descriptor );
          }
        }
      }
    } );
    return obj;
  }

  phetCore.register( 'extendDefined', extendDefined );

  return extendDefined;
} );
// Copyright 2012-2016, University of Colorado Boulder

/**
 * A color with RGBA values, assuming the sRGB color space is used.
 *
 * See http://www.w3.org/TR/css3-color/
 *
 * TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Color',['require','PHET_CORE/inherit','SCENERY/scenery','AXON/Property','DOT/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Property = require( 'AXON/Property' );
  var Util = require( 'DOT/Util' );

  // constants
  var clamp = Util.clamp;
  var linear = Util.linear;

  /**
   * Creates a Color with an initial value. Multiple different types of parameters are supported:
   * - new Color( color ) is a copy constructor, for a {Color}
   * - new Color( string ) will parse the string assuming it's a CSS-compatible color, e.g. set( 'red' )
   * - new Color( r, g, b ) is equivalent to setRGBA( r, g, b, 1 ), e.g. set( 255, 0, 128 )
   * - new Color( r, g, b, a ) is equivalent to setRGBA( r, g, b, a ), e.g. set( 255, 0, 128, 0.5 )
   * - new Color( hex ) will set RGB with alpha=1, e.g. set( 0xFF0000 )
   * - new Color( hex, a ) will set RGBA, e.g. set( 0xFF0000, 1 )
   *
   * The 'r', 'g', and 'b' values stand for red, green and blue respectively, and will be clamped to integers in 0-255.
   * The 'a' value stands for alpha, and will be clamped to 0-1 (floating point)
   * 'hex' indicates a 6-decimal-digit format hex number, for example 0xFFAA00 is equivalent to r=255, g=170, b=0.
   */
  function Color( r, g, b, a ) {

    // allow listeners to be notified on any changes. called with listener()
    this.listeners = [];

    this.set( r, g, b, a );

    phetAllocation && phetAllocation( 'Color' );
  }

  scenery.register( 'Color', Color );

  // regex utilities
  var rgbNumber = '(-?\\d{1,3}%?)'; // syntax allows negative integers and percentages
  var aNumber = '(\\d+|\\d*\\.\\d+)'; // decimal point number. technically we allow for '255', even though this will be clamped to 1.
  var rawNumber = '(\\d{1,3})'; // a 1-3 digit number

  // handles negative and percentage values
  function parseRGBNumber( str ) {
    var multiplier = 1;

    // if it's a percentage, strip it off and handle it that way
    if ( str.charAt( str.length - 1 ) === '%' ) {
      multiplier = 2.55;
      str = str.slice( 0, str.length - 1 );
    }

    return Math.round( parseInt( str, 10 ) * multiplier );
  }

  Color.formatParsers = [
    {
      // 'transparent'
      regexp: /^transparent$/,
      apply: function( color, matches ) {
        color.setRGBA( 0, 0, 0, 0 );
      }
    },
    {
      // short hex form, a la '#fff'
      regexp: /^#(\w{1})(\w{1})(\w{1})$/,
      apply: function( color, matches ) {
        color.setRGBA(
          parseInt( matches[ 1 ] + matches[ 1 ], 16 ),
          parseInt( matches[ 2 ] + matches[ 2 ], 16 ),
          parseInt( matches[ 3 ] + matches[ 3 ], 16 ),
          1 );
      }
    },
    {
      // long hex form, a la '#ffffff'
      regexp: /^#(\w{2})(\w{2})(\w{2})$/,
      apply: function( color, matches ) {
        color.setRGBA(
          parseInt( matches[ 1 ], 16 ),
          parseInt( matches[ 2 ], 16 ),
          parseInt( matches[ 3 ], 16 ),
          1 );
      }
    },
    {
      // rgb(...)
      regexp: new RegExp( '^rgb\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setRGBA(
          parseRGBNumber( matches[ 1 ] ),
          parseRGBNumber( matches[ 2 ] ),
          parseRGBNumber( matches[ 3 ] ),
          1 );
      }
    },
    {
      // rgba(...)
      regexp: new RegExp( '^rgba\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + ',' + aNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setRGBA(
          parseRGBNumber( matches[ 1 ] ),
          parseRGBNumber( matches[ 2 ] ),
          parseRGBNumber( matches[ 3 ] ),
          parseFloat( matches[ 4 ] ) );
      }
    },
    {
      // hsl(...)
      regexp: new RegExp( '^hsl\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%\\)$' ),
      apply: function( color, matches ) {
        color.setHSLA(
          parseInt( matches[ 1 ], 10 ),
          parseInt( matches[ 2 ], 10 ),
          parseInt( matches[ 3 ], 10 ),
          1 );
      }
    },
    {
      // hsla(...)
      regexp: new RegExp( '^hsla\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%,' + aNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setHSLA(
          parseInt( matches[ 1 ], 10 ),
          parseInt( matches[ 2 ], 10 ),
          parseInt( matches[ 3 ], 10 ),
          parseFloat( matches[ 4 ] ) );
      }
    }
  ];

  // see http://www.w3.org/TR/css3-color/
  Color.hueToRGB = function( m1, m2, h ) {
    if ( h < 0 ) {
      h = h + 1;
    }
    if ( h > 1 ) {
      h = h - 1;
    }
    if ( h * 6 < 1 ) {
      return m1 + ( m2 - m1 ) * h * 6;
    }
    if ( h * 2 < 1 ) {
      return m2;
    }
    if ( h * 3 < 2 ) {
      return m1 + ( m2 - m1 ) * ( 2 / 3 - h ) * 6;
    }
    return m1;
  };

  /**
   * Convenience function that converts a color spec to a color object if
   * necessary, or simply returns the color object if not.
   * @param {String|Color} colorSpec
   */
  Color.toColor = function( colorSpec ) {
    return colorSpec instanceof Color ? colorSpec : new Color( colorSpec );
  };

  inherit( Object, Color, {
    copy: function() {
      return new Color( this.r, this.g, this.b, this.a );
    },

    /**
     * Sets the values of this Color. Supported styles:
     * - set( color ) is a copy constructor
     * - set( string ) will parse the string assuming it's a CSS-compatible color, e.g. set( 'red' )
     * - set( r, g, b ) is equivalent to setRGBA( r, g, b, 1 ), e.g. set( 255, 0, 128 )
     * - set( r, g, b, a ) is equivalent to setRGBA( r, g, b, a ), e.g. set( 255, 0, 128, 0.5 )
     * - set( hex ) will set RGB with alpha=1, e.g. set( 0xFF0000 )
     * - set( hex, alpha ) will set RGBA, e.g. set( 0xFF0000, 1 )
     */
    set: function( r, g, b, a ) {
      assert && assert( r !== undefined, 'Can\'t call Color.set( undefined )' );

      // support for set( string )
      if ( typeof r === 'string' ) {
        this.setCSS( r );
      }
      // support for set( color )
      else if ( r instanceof Color ) {
        this.setRGBA( r.r, r.g, r.b, r.a );
      }
      // support for set( hex ) and set( hex, alpha )
      else if ( b === undefined ) {
        assert && assert( typeof r === 'number' );
        assert && assert( g === undefined || typeof g === 'number' );

        var red = ( r >> 16 ) & 0xFF;
        var green = ( r >> 8 ) & 0xFF;
        var blue = ( r >> 0 ) & 0xFF;
        var alpha = ( g === undefined ) ? 1 : g;
        this.setRGBA( red, green, blue, alpha );
      }
      // support for set( r, g, b ) and set( r, g, b, a )
      else {
        assert && assert( typeof r === 'number' );
        assert && assert( typeof g === 'number' );
        assert && assert( typeof b === 'number' );
        assert && assert( a === undefined || typeof a === 'number' );
        this.setRGBA( r, g, b, ( a === undefined ) ? 1 : a );
      }

      return this; // support chaining
    },

    // red, integral 0-255
    getRed: function() { return this.r; },
    setRed: function( value ) { return this.setRGBA( value, this.g, this.b, this.a ); },
    get red() { return this.getRed(); },
    set red( value ) { return this.setRed( value ); },

    // green, integral 0-255
    getGreen: function() { return this.g; },
    setGreen: function( value ) { return this.setRGBA( this.r, value, this.b, this.a ); },
    get green() { return this.getGreen(); },
    set green( value ) { return this.setGreen( value ); },

    // blue, integral 0-255
    getBlue: function() { return this.b; },
    setBlue: function( value ) { return this.setRGBA( this.r, this.g, value, this.a ); },
    get blue() { return this.getBlue(); },
    set blue( value ) { return this.setBlue( value ); },

    // alpha, floating 0-1
    getAlpha: function() { return this.a; },
    setAlpha: function( value ) { return this.setRGBA( this.r, this.g, this.b, value ); },
    get alpha() { return this.getAlpha(); },
    set alpha( value ) { return this.setAlpha( value ); },

    // RGB integral between 0-255, alpha (float) between 0-1
    setRGBA: function( red, green, blue, alpha ) {
      this.r = Math.round( clamp( red, 0, 255 ) );
      this.g = Math.round( clamp( green, 0, 255 ) );
      this.b = Math.round( clamp( blue, 0, 255 ) );
      this.a = clamp( alpha, 0, 1 );

      this.updateColor(); // update the cached value

      return this; // allow chaining
    },

    computeCSS: function() {
      if ( this.a === 1 ) {
        return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
      }
      else {
        // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
        // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
        // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
        // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
        var alpha = this.a.toFixed( 20 );
        while ( alpha.length >= 2 && alpha[ alpha.length - 1 ] === '0' && alpha[ alpha.length - 2 ] !== '.' ) {
          alpha = alpha.slice( 0, alpha.length - 1 );
        }

        var alphaString = this.a === 0 || this.a === 1 ? this.a : alpha;
        return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + alphaString + ')';
      }
    },

    toCSS: function() {
      // verify that the cached value is correct (in debugging builds only, defeats the point of caching otherwise)
      assert && assert( this._css === this.computeCSS(), 'CSS cached value is ' + this._css + ', but the computed value appears to be ' + this.computeCSS() );

      return this._css;
    },

    setCSS: function( cssString ) {
      var str = cssString.replace( / /g, '' ).toLowerCase();
      var success = false;

      // replace colors based on keywords
      var keywordMatch = Color.colorKeywords[ str ];
      if ( keywordMatch ) {
        str = '#' + keywordMatch;
      }

      // run through the available text formats
      for ( var i = 0; i < Color.formatParsers.length; i++ ) {
        var parser = Color.formatParsers[ i ];

        var matches = parser.regexp.exec( str );
        if ( matches ) {
          parser.apply( this, matches );
          success = true;
          break;
        }
      }

      if ( !success ) {
        throw new Error( 'scenery.Color unable to parse color string: ' + cssString );
      }

      this.updateColor(); // update the cached value
    },

    // e.g. 0xFF00FF
    toNumber: function() {
      return ( this.r << 16 ) + ( this.g << 8 ) + this.b;
    },

    // called to update the internally cached CSS value
    updateColor: function() {
      assert && assert( !this.immutable, 'Cannot modify an immutable color' );

      assert && assert( typeof this.red === 'number' &&
                        typeof this.green === 'number' &&
                        typeof this.blue === 'number' &&
                        typeof this.alpha === 'number',
        'Ensure color components are numeric: ' + this.toString() );

      assert && assert( isFinite( this.red ) && isFinite( this.green ) && isFinite( this.blue ) && isFinite( this.alpha ),
        'Ensure color components are finite and not NaN' );

      assert && assert( this.red >= 0 && this.red <= 255 &&
                        this.green >= 0 && this.green <= 255 &&
                        this.red >= 0 && this.red <= 255 &&
                        this.alpha >= 0 && this.alpha <= 1,
        'Ensure color components are in the proper ranges: ' + this.toString() );

      var oldCSS = this._css;
      this._css = this.computeCSS();

      // notify listeners if it changed
      if ( oldCSS !== this._css && this.listeners.length ) {
        var listeners = this.listeners.slice( 0 ); // defensive copy. consider removing if it's a performance bottleneck?
        var length = listeners.length;

        for ( var i = 0; i < length; i++ ) {
          listeners[ i ]();
        }
      }
    },

    // allow setting this Color to be immutable when assertions are disabled. any change will throw an error
    setImmutable: function() {
      if ( assert ) {
        this.immutable = true;
      }

      return this; // allow chaining
    },

    /**
     * Returns an object that can be passed to a Canvas context's fillStyle or strokeStyle.
     * @public
     *
     * @returns {string}
     */
    getCanvasStyle: function() {
      return this.toCSS(); // should be inlined, leave like this for future maintainability
    },

    // TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!
    setHSLA: function( hue, saturation, lightness, alpha ) {
      hue = ( hue % 360 ) / 360;                    // integer modulo 360
      saturation = clamp( saturation / 100, 0, 1 ); // percentage
      lightness = clamp( lightness / 100, 0, 1 );   // percentage

      // see http://www.w3.org/TR/css3-color/
      var m1;
      var m2;
      if ( lightness < 0.5 ) {
        m2 = lightness * ( saturation + 1 );
      }
      else {
        m2 = lightness + saturation - lightness * saturation;
      }
      m1 = lightness * 2 - m2;

      this.r = Math.round( Color.hueToRGB( m1, m2, hue + 1 / 3 ) * 255 );
      this.g = Math.round( Color.hueToRGB( m1, m2, hue ) * 255 );
      this.b = Math.round( Color.hueToRGB( m1, m2, hue - 1 / 3 ) * 255 );
      this.a = clamp( alpha, 0, 1 );

      this.updateColor(); // update the cached value

      return this; // allow chaining
    },

    equals: function( color ) {
      return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
    },

    withAlpha: function( alpha ) {
      return new Color( this.r, this.g, this.b, alpha );
    },

    checkFactor: function( factor ) {
      if ( factor < 0 || factor > 1 ) {
        throw new Error( 'factor must be between 0 and 1: ' + factor );
      }
      return ( factor === undefined ) ? 0.7 : factor;
    },

    // matches Java's Color.brighter()
    brighterColor: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.min( 255, Math.floor( this.r / factor ) );
      var green = Math.min( 255, Math.floor( this.g / factor ) );
      var blue = Math.min( 255, Math.floor( this.b / factor ) );
      return new Color( red, green, blue, this.a );
    },

    /**
     * Brightens a color in RGB space. Useful when creating gradients from a
     * single base color.
     *
     * @param color
     * @param factor 0 (no change) to 1 (white)
     * @return lighter (closer to white) version of the original color.
     */
    colorUtilsBrighter: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.min( 255, this.getRed() + Math.floor( factor * ( 255 - this.getRed() ) ) );
      var green = Math.min( 255, this.getGreen() + Math.floor( factor * ( 255 - this.getGreen() ) ) );
      var blue = Math.min( 255, this.getBlue() + Math.floor( factor * ( 255 - this.getBlue() ) ) );
      return new Color( red, green, blue, this.getAlpha() );
    },

    // matches Java's Color.darker()
    darkerColor: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.max( 0, Math.floor( factor * this.r ) );
      var green = Math.max( 0, Math.floor( factor * this.g ) );
      var blue = Math.max( 0, Math.floor( factor * this.b ) );
      return new Color( red, green, blue, this.a );
    },

    /**
     * Darken a color in RGB space. Useful when creating gradients from a single
     * base color.
     *
     * @param color  the original color
     * @param factor 0 (no change) to 1 (black)
     * @return darker (closer to black) version of the original color.
     */
    colorUtilsDarker: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.max( 0, this.getRed() - Math.floor( factor * this.getRed() ) );
      var green = Math.max( 0, this.getGreen() - Math.floor( factor * this.getGreen() ) );
      var blue = Math.max( 0, this.getBlue() - Math.floor( factor * this.getBlue() ) );
      return new Color( red, green, blue, this.getAlpha() );
    },

    /*
     * Like colorUtilsBrighter/Darker, however factor should be in the range -1 to 1, and it will call:
     *   colorUtilsBrighter( factor )   for factor >  0
     *   this                           for factor == 0
     *   colorUtilsDarker( -factor )    for factor <  0
     * Thus:
     * @param factor from -1 (black), to 0 (no change), to 1 (white)
     */
    colorUtilsBrightness: function( factor ) {
      if ( factor === 0 ) {
        return this;
      }
      else if ( factor > 0 ) {
        return this.colorUtilsBrighter( factor );
      }
      else {
        return this.colorUtilsDarker( -factor );
      }
    },

    /*---------------------------------------------------------------------------*
     * listeners TODO: consider mixing in this behavior, it's common
     *----------------------------------------------------------------------------*/

    // listener should be a callback expecting no arguments, listener() will be called when the color changes
    // Allows duplicate copies of listeners
    addChangeListener: function( listener ) {
      assert && assert( listener !== undefined && listener !== null, 'Verify that the listener exists' );
      this.listeners.push( listener );
    },

    // Allows duplicate copies of listeners
    removeChangeListener: function( listener ) {
      assert && assert( _.includes( this.listeners, listener ) );
      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );
    },

    getListenerCount: function() {
      return this.listeners.length;
    },

    toString: function() {
      return this.constructor.name + '[r:' + this.r + ' g:' + this.g + ' b:' + this.b + ' a:' + this.a + ']';
    },

    toStateObject: function() {
      return {
        r: this.r,
        g: this.g,
        b: this.b,
        a: this.a
      };
    }
  } );

  Color.basicColorKeywords = {
    aqua: '00ffff',
    black: '000000',
    blue: '0000ff',
    fuchsia: 'ff00ff',
    gray: '808080',
    green: '008000',
    lime: '00ff00',
    maroon: '800000',
    navy: '000080',
    olive: '808000',
    purple: '800080',
    red: 'ff0000',
    silver: 'c0c0c0',
    teal: '008080',
    white: 'ffffff',
    yellow: 'ffff00'
  };

  Color.colorKeywords = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '00ffff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '00ffff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'ff00ff',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '778899',
    lightslategrey: '778899',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '00ff00',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'ff00ff',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    red: 'ff0000',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'ffffff',
    whitesmoke: 'f5f5f5',
    yellow: 'ffff00',
    yellowgreen: '9acd32'
  };

  // Java compatibility
  Color.BLACK = Color.black = new Color( 0, 0, 0 ).setImmutable();
  Color.BLUE = Color.blue = new Color( 0, 0, 255 ).setImmutable();
  Color.CYAN = Color.cyan = new Color( 0, 255, 255 ).setImmutable();
  Color.DARK_GRAY = Color.darkGray = new Color( 64, 64, 64 ).setImmutable();
  Color.GRAY = Color.gray = new Color( 128, 128, 128 ).setImmutable();
  Color.GREEN = Color.green = new Color( 0, 255, 0 ).setImmutable();
  Color.LIGHT_GRAY = Color.lightGray = new Color( 192, 192, 192 ).setImmutable();
  Color.MAGENTA = Color.magenta = new Color( 255, 0, 255 ).setImmutable();
  Color.ORANGE = Color.orange = new Color( 255, 200, 0 ).setImmutable();
  Color.PINK = Color.pink = new Color( 255, 175, 175 ).setImmutable();
  Color.RED = Color.red = new Color( 255, 0, 0 ).setImmutable();
  Color.WHITE = Color.white = new Color( 255, 255, 255 ).setImmutable();
  Color.YELLOW = Color.yellow = new Color( 255, 255, 0 ).setImmutable();

  /**
   * Interpolates between 2 colors in RGBA space. When distance is 0, color1
   * is returned. When distance is 1, color2 is returned. Other values of
   * distance return a color somewhere between color1 and color2. Each color
   * component is interpolated separately.
   *
   * @param {Color} color1
   * @param {Color} color2
   * @param {number} distance distance between color1 and color2, 0 <= distance <= 1
   * @returns {Color}
   */
  Color.interpolateRGBA = function( color1, color2, distance ) {
    if ( distance < 0 || distance > 1 ) {
      throw new Error( 'distance must be between 0 and 1: ' + distance );
    }
    var r = Math.floor( linear( 0, 1, color1.r, color2.r, distance ) );
    var g = Math.floor( linear( 0, 1, color1.g, color2.g, distance ) );
    var b = Math.floor( linear( 0, 1, color1.b, color2.b, distance ) );
    var a = linear( 0, 1, color1.a, color2.a, distance );
    return new Color( r, g, b, a );
  };

  Color.fromStateObject = function( stateObject ) {
    return new Color( stateObject.r, stateObject.g, stateObject.b, stateObject.a );
  };

  Color.hsla = function( hue, saturation, lightness, alpha ) {
    return new Color( 0, 0, 0, 1 ).setHSLA( hue, saturation, lightness, alpha );
  };

  var scratchColor = new Color( 'blue' );
  Color.checkPaintString = function( cssString ) {
    if ( assert ) {
      try {
        scratchColor.setCSS( cssString );
      }
      catch( e ) {
        assert( false, 'The CSS string is an invalid color: ' + cssString );
      }
    }
  };

  // a Paint of the type that Paintable accepts as fills or strokes
  Color.checkPaint = function( paint ) {
    if ( typeof paint === 'string' ) {
      Color.checkPaintString( paint );
    }
    else if ( ( paint instanceof Property ) && ( typeof paint.value === 'string' ) ) {
      Color.checkPaintString( paint.value );
    }
  };

  return Color;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Mix-in for nodes that support a standard fill and/or stroke (e.g. Text, Path and Path subtypes).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Paintable',['require','SCENERY/scenery','SCENERY/util/Color','KITE/util/LineStyles','SCENERY/display/Renderer','PHET_CORE/extend','PHET_CORE/platform','PHET_CORE/arrayRemove','AXON/Property'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var Color = require( 'SCENERY/util/Color' );
  var LineStyles = require( 'KITE/util/LineStyles' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var extend = require( 'PHET_CORE/extend' );
  var platform = require( 'PHET_CORE/platform' );
  var arrayRemove = require( 'PHET_CORE/arrayRemove' );
  var Property = require( 'AXON/Property' );

  var isSafari5 = platform.safari5;
  var isIE9 = platform.ie9;

  var PAINTABLE_OPTION_KEYS = [
    'fill', // Sets the fill of this node, see setFill() for documentation.
    'fillPickable', // Sets whether the filled area of the node will be treated as 'inside'. See setFillPickable()
    'stroke', // Sets the stroke of this node, see setStroke() for documentation.
    'strokePickable', // Sets whether the stroked area of the node will be treated as 'inside'. See setStrokePickable()
    'lineWidth', // Sets the width of the stroked area, see setLineWidth for documentation.
    'lineCap', // Sets the shape of the stroked area at the start/end of the path, see setLineCap() for documentation.
    'lineJoin', // Sets the shape of the stroked area at joints, see setLineJoin() for documentation.
    'miterLimit', // Sets when lineJoin will switch from miter to bevel, see setMiterLimit() for documentation.
    'lineDash', // Sets a line-dash pattern for the stroke, see setLineDash() for documentation
    'lineDashOffset', // Sets the offset of the line-dash from the start of the stroke, see setLineDashOffset()
    'cachedPaints' // Sets which paints should be cached, even if not displayed. See setCachedPaints()
  ];

  var DEFAULT_OPTIONS = {
    fill: null,
    fillPickable: true,
    stroke: null,
    strokePickable: false,

    // Not set initially, but they are the LineStyles defaults
    lineWidth: LineStyles.DEFAULT_OPTIONS.lineWidth,
    lineCap: LineStyles.DEFAULT_OPTIONS.lineCap,
    lineJoin: LineStyles.DEFAULT_OPTIONS.lineJoin,
    lineDashOffset: LineStyles.DEFAULT_OPTIONS.lineDashOffset,
    miterLimit: LineStyles.DEFAULT_OPTIONS.miterLimit
  };

  var Paintable = {
    /**
     * Applies the mix-in to a subtype of Node.
     * @public
     * @mixin
     *
     * @param {constructor} type - A constructor that inherits from Node
     */
    mixin: function( type ) {
      var proto = type.prototype;

      /**
       * These properties and methods are put directly on the prototype of things that have Paintable mixed in.
       */
      extend( proto, {
        /**
         * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
         *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
         *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
         * @public (scenery-internal)
         * @override
         */
        drawableMarkFlags: proto.drawableMarkFlags.concat( [ 'fill', 'stroke', 'lineWidth', 'lineOptions', 'cachedPaints' ] ),

        /**
         * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
         * order they will be evaluated in.
         * @protected
         *
         * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
         *       cases that may apply.
         */
        _mutatorKeys: PAINTABLE_OPTION_KEYS.concat( proto._mutatorKeys ),

        /**
         * This should be called in the constructor to initialize the paint-specific parts of the Node.
         * @protected
         */
        initializePaintable: function() {
          this._fill = DEFAULT_OPTIONS.fill;
          this._fillPickable = DEFAULT_OPTIONS.fillPickable;

          this._stroke = DEFAULT_OPTIONS.stroke;
          this._strokePickable = DEFAULT_OPTIONS.strokePickable;

          this._cachedPaints = [];
          this._lineDrawingStyles = new LineStyles();
        },

        /**
         * Sets the fill color for the node.
         * @public
         *
         * The fill determines the appearance of the interior part of a Path or Text.
         *
         * Please use null for indicating "no fill" (that is the default). Strings and Scenery Color objects can be
         * provided for a single-color flat appearance, and can be wrapped with an Axon Property. Gradients and patterns
         * can also be provided.
         *
         * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} fill
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setFill: function( fill ) {
          assert && assert( fill === null ||
                            typeof fill === 'string' ||
                            fill instanceof Color ||
                            fill.isPaint ||
                            ( ( fill instanceof Property ) && (
                              typeof fill.value === 'string' ||
                              fill.value instanceof Color
                            ) ),
            'Invalid fill type' );

          if ( assert && typeof fill === 'string' ) {
            Color.checkPaintString( fill );
          }

          // Instance equality used here since it would be more expensive to parse all CSS
          // colors and compare every time the fill changes. Right now, usually we don't have
          // to parse CSS colors. See https://github.com/phetsims/scenery/issues/255
          if ( this._fill !== fill ) {
            this._fill = fill;

            this.invalidateFill();
          }
          return this;
        },
        set fill( value ) { this.setFill( value ); },

        /**
         * Returns the fill (if any) for this Node.
         * @public
         *
         * @returns {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern}
         */
        getFill: function() {
          return this._fill;
        },
        get fill() { return this.getFill(); },

        /**
         * Returns whether there is a fill applied to this Node.
         * @public
         *
         * @returns {boolean}
         */
        hasFill: function() {
          return this._fill !== null;
        },

        /**
         * Returns a property-unwrapped fill if applicable.
         * @public
         *
         * @returns {null|string|Color|LinearGradient|RadialGradient|Pattern}
         */
        getFillValue: function() {
          var fill = this.getFill();

          // Property lookup
          if ( fill instanceof Property ) {
            fill = fill.get();
          }

          return fill;
        },
        get fillValue() { return this.getFillValue(); },

        /**
         * Sets the stroke color for the node.
         * @public
         *
         * The stroke determines the appearance of the region along the boundary of the Path or Text. The shape of the
         * stroked area depends on the base shape (that of the Path or Text) and multiple parameters:
         * lineWidth/lineCap/lineJoin/miterLimit/lineDash/lineDashOffset. It will be drawn on top of any fill on the
         * same node.
         *
         * Please use null for indicating "no stroke" (that is the default). Strings and Scenery Color objects can be
         * provided for a single-color flat appearance, and can be wrapped with an Axon Property. Gradients and patterns
         * can also be provided.
         *
         * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} stroke
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setStroke: function( stroke ) {
          assert && assert( stroke === null ||
                            typeof stroke === 'string' ||
                            stroke instanceof Color ||
                            stroke.isPaint ||
                            ( ( stroke instanceof Property ) && (
                              typeof stroke.value === 'string' ||
                              stroke.value instanceof Color
                            ) ),
            'Invalid stroke type' );

          if ( assert && typeof stroke === 'string' ) {
            Color.checkPaintString( stroke );
          }

          // Instance equality used here since it would be more expensive to parse all CSS
          // colors and compare every time the fill changes. Right now, usually we don't have
          // to parse CSS colors. See https://github.com/phetsims/scenery/issues/255
          if ( this._stroke !== stroke ) {
            this._stroke = stroke;

            this.invalidateStroke();
          }
          return this;
        },
        set stroke( value ) { this.setStroke( value ); },

        /**
         * Returns the stroke (if any) for this Node.
         * @public
         *
         * @returns {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern}
         */
        getStroke: function() {
          return this._stroke;
        },
        get stroke() { return this.getStroke(); },

        /**
         * Returns whether there is a stroke applied to this Node.
         * @public
         *
         * @returns {boolean}
         */
        hasStroke: function() {
          return this._stroke !== null;
        },

        /**
         * Returns whether there will appear to be a stroke for this Node. Properly handles the lineWidth:0 case.
         * @public
         *
         * @returns {boolean}
         */
        hasPaintableStroke: function() {
          // Should not be stroked if the lineWidth is 0, see https://github.com/phetsims/scenery/issues/658
          // and https://github.com/phetsims/scenery/issues/523
          return this.hasStroke() && this.getLineWidth() > 0;
        },

        /**
         * Returns a property-unwrapped stroke if applicable.
         * @public
         *
         * @returns {null|string|Color|LinearGradient|RadialGradient|Pattern}
         */
        getStrokeValue: function() {
          var stroke = this.getStroke();

          // Property lookup
          if ( stroke instanceof Property ) {
            stroke = stroke.get();
          }

          return stroke;
        },
        get strokeValue() { return this.getStrokeValue(); },

        /**
         * Sets whether the fill is marked as pickable.
         * @public
         *
         * @param {boolean} pickable
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setFillPickable: function( pickable ) {
          assert && assert( typeof pickable === 'boolean' );

          if ( this._fillPickable !== pickable ) {
            this._fillPickable = pickable;

            // TODO: better way of indicating that only the node under pointers could have changed, but no paint change is needed?
            this.invalidateFill();
          }
          return this;
        },
        set fillPickable( value ) { this.setFillPickable( value ); },

        /**
         * Returns whether the fill is marked as pickable.
         * @public
         *
         * @returns {boolean}
         */
        isFillPickable: function() {
          return this._fillPickable;
        },
        get fillPickable() { return this.isFillPickable(); },

        /**
         * Sets whether the stroke is marked as pickable.
         * @public
         *
         * @param {boolean} pickable
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setStrokePickable: function( pickable ) {
          assert && assert( typeof pickable === 'boolean', 'strokePickable should be a boolean, not ' + pickable );

          if ( this._strokePickable !== pickable ) {
            this._strokePickable = pickable;

            // TODO: better way of indicating that only the node under pointers could have changed, but no paint change is needed?
            this.invalidateStroke();
          }
          return this;
        },
        set strokePickable( value ) { this.setStrokePickable( value ); },

        /**
         * Returns whether the stroke is marked as pickable.
         * @public
         *
         * @returns {boolean}
         */
        isStrokePickable: function() {
          return this._strokePickable;
        },
        get strokePickable() { return this.isStrokePickable(); },

        /**
         * Sets the line width that will be applied to strokes on this Node.
         * @public
         *
         * @param {number} lineWidth
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setLineWidth: function( lineWidth ) {
          assert && assert( typeof lineWidth === 'number', 'lineWidth should be a number, not ' + lineWidth );
          assert && assert( lineWidth >= 0, 'lineWidth should be non-negative instead of ' + lineWidth );

          if ( this.getLineWidth() !== lineWidth ) {
            this._lineDrawingStyles.lineWidth = lineWidth;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineWidth();
            }
          }
          return this;
        },
        set lineWidth( value ) { this.setLineWidth( value ); },

        /**
         * Returns the line width that would be applied to strokes.
         * @public
         *
         * @returns {number}
         */
        getLineWidth: function() {
          return this._lineDrawingStyles.lineWidth;
        },
        get lineWidth() { return this.getLineWidth(); },

        /**
         * Sets the line cap style. There are three options:
         * - 'butt' (the default) stops the line at the end point
         * - 'round' draws a semicircular arc around the end point
         * - 'square' draws a square outline around the end point (like butt, but extended by 1/2 line width out)
         * @public
         *
         * @param {string} lineCap
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setLineCap: function( lineCap ) {
          assert && assert( lineCap === 'butt' || lineCap === 'round' || lineCap === 'square',
            'lineCap should be one of "butt", "round" or "square", not ' + lineCap );

          if ( this._lineDrawingStyles.lineCap !== lineCap ) {
            this._lineDrawingStyles.lineCap = lineCap;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineCap( value ) { this.setLineCap( value ); },

        /**
         * Returns the line cap style (controls appearance at the start/end of paths)
         * @public
         *
         * @returns {string}
         */
        getLineCap: function() {
          return this._lineDrawingStyles.lineCap;
        },
        get lineCap() { return this.getLineCap(); },

        /**
         * Sets the line join style. There are three options:
         * - 'miter' (default) joins by extending the segments out in a line until they meet. For very sharp
         *           corners, they will be chopped off and will act like 'bevel', depending on what the miterLimit is.
         * - 'round' draws a circular arc to connect the two stroked areas.
         * - 'bevel' connects with a single line segment.
         * @public
         *
         * @param {string} lineJoin
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setLineJoin: function( lineJoin ) {
          assert && assert( lineJoin === 'miter' || lineJoin === 'round' || lineJoin === 'bevel',
            'lineJoin should be one of "miter", "round" or "bevel", not ' + lineJoin );

          if ( this._lineDrawingStyles.lineJoin !== lineJoin ) {
            this._lineDrawingStyles.lineJoin = lineJoin;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineJoin( value ) { this.setLineJoin( value ); },

        /**
         * Returns the current line join style (controls join appearance between drawn segments).
         * @public
         *
         * @returns {string}
         */
        getLineJoin: function() {
          return this._lineDrawingStyles.lineJoin;
        },
        get lineJoin() { return this.getLineJoin(); },

        /**
         * Sets the miterLimit value. This determines how sharp a corner with lineJoin: 'miter' will need to be before
         * it gets cut off to the 'bevel' behavior.
         * @public
         *
         * @param {number} miterLimit
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setMiterLimit: function( miterLimit ) {
          assert && assert( typeof miterLimit === 'number' && isFinite( miterLimit ), 'miterLimit should be a finite number' );

          if ( this._lineDrawingStyles.miterLimit !== miterLimit ) {
            this._lineDrawingStyles.miterLimit = miterLimit;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set miterLimit( value ) { this.setMiterLimit( value ); },

        /**
         * Returns the miterLimit value.
         * @public
         *
         * @returns {number}
         */
        getMiterLimit: function() {
          return this._lineDrawingStyles.miterLimit;
        },
        get miterLimit() { return this.getMiterLimit(); },

        /**
         * Sets the line dash pattern. Should be an array of numbers "on" and "off" alternating. An empty array
         * indicates no dashing.
         * @public
         *
         * @param {Array.<number>} lineDash
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setLineDash: function( lineDash ) {
          assert && assert( lineDash instanceof Array && lineDash.every( function( n ) { return typeof n === 'number' && isFinite( n ) && n >= 0; } ),
            'lineDash should be an array of finite non-negative numbers' );

          if ( this._lineDrawingStyles.lineDash !== lineDash ) {
            this._lineDrawingStyles.lineDash = lineDash || [];
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineDash( value ) { this.setLineDash( value ); },

        /**
         * Gets the line dash pattern. An empty array is the default, indicating no dashing.
         * @public
         *
         * @returns {Array.<number>}
         */
        getLineDash: function() {
          return this._lineDrawingStyles.lineDash;
        },
        get lineDash() { return this.getLineDash(); },

        /**
         * Returns whether the stroke will be dashed.
         * @public
         *
         * @returns {boolean}
         */
        hasLineDash: function() {
          return !!this._lineDrawingStyles.lineDash.length;
        },

        /**
         * Sets the offset of the line dash pattern from the start of the stroke. Defaults to 0.
         * @public
         *
         * @param {number} lineDashOffset
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setLineDashOffset: function( lineDashOffset ) {
          assert && assert( typeof lineDashOffset === 'number' && isFinite( lineDashOffset ),
            'lineDashOffset should be a number, not ' + lineDashOffset );

          if ( this._lineDrawingStyles.lineDashOffset !== lineDashOffset ) {
            this._lineDrawingStyles.lineDashOffset = lineDashOffset;
            this.invalidateStroke();

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineDashOffset( value ) { this.setLineDashOffset( value ); },

        /**
         * Returns the offset of the line dash pattern from the start of the stroke.
         * @public
         *
         * @returns {number}
         */
        getLineDashOffset: function() {
          return this._lineDrawingStyles.lineDashOffset;
        },
        get lineDashOffset() { return this.getLineDashOffset(); },

        /**
         * Sets the LineStyles object (it determines stroke appearance). The passed-in object will be mutated as needed.
         * @public
         *
         * @param {LineStyles} lineStyles
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setLineStyles: function( lineStyles ) {
          assert && assert( lineStyles instanceof LineStyles );

          this._lineDrawingStyles = lineStyles;
          this.invalidateStroke();
          return this;
        },
        set lineStyles( value ) { this.setLineStyles( value ); },

        /**
         * Returns the composite {LineStyles} object, that determines stroke appearance.
         * @public
         *
         * @returns {LineStyles}
         */
        getLineStyles: function() {
          return this._lineDrawingStyles;
        },
        get lineStyles() { return this.getLineStyles(); },

        /**
         * Sets the cached paints to the input array (a defensive copy). Note that it also filters out fills that are
         * not considered paints (e.g. strings, Colors, etc.).
         * @public
         *
         * When this node is displayed in SVG, it will force the presence of the cached paint to be stored in the SVG's
         * <defs> element, so that we can switch quickly to use the given paint (instead of having to create it on the
         * SVG-side whenever the switch is made).
         *
         * Also note that duplicate paints are acceptable, and don't need to be filtered out before-hand.
         *
         * @param {Array.<string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern|null>} paints
         * @returns {Paintable} - Returns 'this' reference, for chaining
         */
        setCachedPaints: function( paints ) {
          this._cachedPaints = paints.filter( function( paint ) { return paint && paint.isPaint; } );

          var stateLen = this._drawables.length;
          for ( var i = 0; i < stateLen; i++ ) {
            this._drawables[ i ].markDirtyCachedPaints();
          }

          return this;
        },
        set cachedPaints( value ) { this.setCachedPaints( value ); },

        /**
         * Returns the cached paints.
         * @public
         *
         * @returns {Array.<string|Color|LinearGradient|RadialGradient|Pattern|null>}
         */
        getCachedPaints: function() {
          return this._cachedPaints;
        },
        get cachedPaints() { return this.getCachedPaints(); },

        /**
         * Adds a cached paint. Does nothing if paint is just a normal fill (string, Color), but for gradients and
         * patterns, it will be made faster to switch to.
         *
         * When this node is displayed in SVG, it will force the presence of the cached paint to be stored in the SVG's
         * <defs> element, so that we can switch quickly to use the given paint (instead of having to create it on the
         * SVG-side whenever the switch is made).
         *
         * Also note that duplicate paints are acceptible, and don't need to be filtered out before-hand.
         *
         * @param {string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern|null} paint
         */
        addCachedPaint: function( paint ) {
          if ( paint && paint.isPaint ) {
            this._cachedPaints.push( paint );

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyCachedPaints();
            }
          }
        },

        /**
         * Removes a cached paint. Does nothing if paint is just a normal fill (string, Color), but for gradients and
         * patterns it will remove any existing cached paint. If it was added more than once, it will need to be removed
         * more than once.
         *
         * When this node is displayed in SVG, it will force the presence of the cached paint to be stored in the SVG's
         * <defs> element, so that we can switch quickly to use the given paint (instead of having to create it on the
         * SVG-side whenever the switch is made).
         *
         * @param {string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern|null} paint
         */
        removeCachedPaint: function( paint ) {
          if ( paint && paint.isPaint ) {
            assert && assert( _.includes( this._cachedPaints, paint ) );

            arrayRemove( this._cachedPaints, paint );

            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyCachedPaints();
            }
          }
        },

        /**
         * Applies the fill to a Canvas context wrapper, before filling.
         * @public (scenery-internal)
         *
         * @param {CanvasContextWrapper} wrapper
         */
        beforeCanvasFill: function( wrapper ) {
          var fillValue = this.getFillValue();

          wrapper.setFillStyle( fillValue );
          if ( fillValue.transformMatrix ) {
            wrapper.context.save();
            fillValue.transformMatrix.canvasAppendTransform( wrapper.context );
          }
        },

        /**
         * Unapplies the fill to a Canvas context wrapper, after filling.
         * @public (scenery-internal)
         *
         * @param {CanvasContextWrapper} wrapper
         */
        afterCanvasFill: function( wrapper ) {
          var fillValue = this.getFillValue();

          if ( fillValue.transformMatrix ) {
            wrapper.context.restore();
          }
        },

        /**
         * Applies the stroke to a Canvas context wrapper, before stroking.
         * @public (scenery-internal)
         *
         * @param {CanvasContextWrapper} wrapper
         */
        beforeCanvasStroke: function( wrapper ) {
          var strokeValue = this.getStrokeValue();

          // TODO: is there a better way of not calling so many things on each stroke?
          wrapper.setStrokeStyle( this._stroke );
          wrapper.setLineWidth( this.getLineWidth() );
          wrapper.setLineCap( this.getLineCap() );
          wrapper.setLineJoin( this.getLineJoin() );
          wrapper.setMiterLimit( this.getMiterLimit() );
          wrapper.setLineDash( this.getLineDash() );
          wrapper.setLineDashOffset( this.getLineDashOffset() );
          if ( strokeValue.transformMatrix ) {
            wrapper.context.save();
            strokeValue.transformMatrix.canvasAppendTransform( wrapper.context );
          }
        },

        /**
         * Unapplies the stroke to a Canvas context wrapper, after stroking.
         * @public (scenery-internal)
         *
         * @param {CanvasContextWrapper} wrapper
         */
        afterCanvasStroke: function( wrapper ) {
          var strokeValue = this.getStrokeValue();

          if ( strokeValue.transformMatrix ) {
            wrapper.context.restore();
          }
        },

        /**
         * If applicable, returns the CSS color for the fill.
         * @public
         *
         * @returns {string}
         */
        getCSSFill: function() {
          var fillValue = this.getFillValue();
          // if it's a Color object, get the corresponding CSS
          // 'transparent' will make us invisible if the fill is null
          return fillValue ? ( fillValue.toCSS ? fillValue.toCSS() : fillValue ) : 'transparent';
        },

        /**
         * If applicable, returns the CSS color for the stroke.
         * @public
         *
         * @returns {string}
         */
        getSimpleCSSStroke: function() {
          var strokeValue = this.getStrokeValue();
          // if it's a Color object, get the corresponding CSS
          // 'transparent' will make us invisible if the fill is null
          return strokeValue ? ( strokeValue.toCSS ? strokeValue.toCSS() : strokeValue ) : 'transparent';
        },

        /**
         * Returns the fill-specific property string for use with toString().
         * @protected (scenery-internal)
         * @override
         *
         * @param {string} spaces - Whitespace to add
         * @param {string} result
         * @returns {string}
         */
        appendFillablePropString: function( spaces, result ) {
          if ( this._fill ) {
            if ( result ) {
              result += ',\n';
            }
            if ( typeof this.getFillValue() === 'string' ) {
              result += spaces + 'fill: \'' + this.getFillValue() + '\'';
            }
            else {
              result += spaces + 'fill: ' + this.getFillValue().toString();
            }
          }

          return result;
        },

        /**
         * Returns the stroke-specific property string for use with toString().
         * @protected (scenery-internal)
         * @override
         *
         * @param {string} spaces - Whitespace to add
         * @param {string} result
         * @returns {string}
         */
        appendStrokablePropString: function( spaces, result ) {
          var self = this;

          function addProp( key, value, nowrap ) {
            if ( result ) {
              result += ',\n';
            }
            if ( !nowrap && typeof value === 'string' ) {
              result += spaces + key + ': \'' + value + '\'';
            }
            else {
              result += spaces + key + ': ' + value;
            }
          }

          if ( this._stroke ) {
            var defaultStyles = new LineStyles();
            if ( typeof this.getStrokeValue() === 'string' ) {
              addProp( 'stroke', this.getStrokeValue() );
            }
            else {
              addProp( 'stroke', this.getStrokeValue().toString(), true );
            }

            _.each( [ 'lineWidth', 'lineCap', 'miterLimit', 'lineJoin', 'lineDashOffset' ], function( prop ) {
              if ( self[ prop ] !== defaultStyles[ prop ] ) {
                addProp( prop, self[ prop ] );
              }
            } );

            if ( this.lineDash.length ) {
              addProp( 'lineDash', JSON.stringify( this.lineDash ), true );
            }
          }

          return result;
        },

        /**
         * Determines the default allowed renderers (returned via the Renderer bitmask) that are allowed, given the
         * current fill options.
         * @public (scenery-internal)
         *
         * This will be used for all types that directly mix in Paintable (i.e. Path and Text), but may be overridden
         * by subtypes.
         *
         * @returns {number} - Renderer bitmask, see Renderer for details
         */
        getFillRendererBitmask: function() {
          var bitmask = 0;

          // Safari 5 has buggy issues with SVG gradients
          if ( !( isSafari5 && this._fill && this._fill.isGradient ) ) {
            bitmask |= Renderer.bitmaskSVG;
          }

          // we always have Canvas support?
          bitmask |= Renderer.bitmaskCanvas;

          if ( !this.hasFill() ) {
            // if there is no fill, it is supported by DOM and WebGL
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }
          else if ( this._fill.isPattern ) {
            // no pattern support for DOM or WebGL (for now!)
          }
          else if ( this._fill.isGradient ) {
            // no gradient support for DOM or WebGL (for now!)
          }
          else {
            // solid fills always supported for DOM and WebGL
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }

          return bitmask;
        },

        /**
         * Determines the default allowed renderers (returned via the Renderer bitmask) that are allowed, given the
         * current stroke options.
         * @public (scenery-internal)
         *
         * This will be used for all types that directly mix in Paintable (i.e. Path and Text), but may be overridden
         * by subtypes.
         *
         * @returns {number} - Renderer bitmask, see Renderer for details
         */
        getStrokeRendererBitmask: function() {
          var bitmask = 0;

          // IE9 has bad dashed strokes, let's force a different renderer in case
          if ( !( isIE9 && this.hasStroke() && this.hasLineDash() ) ) {
            bitmask |= Renderer.bitmaskCanvas;
          }

          // always have SVG support (for now?)
          bitmask |= Renderer.bitmaskSVG;

          if ( !this.hasStroke() ) {
            // allow DOM support if there is no stroke (since the fill will determine what is available)
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }

          return bitmask;
        }
      } );

      /**
       * Paintable's version of invalidateFill(), possibly combined with a client invalidateFill. Invalidates our
       * current fill, triggering recomputation of anything that depended on the old fill's value.
       * @protected
       */
      function invalidateFill() {
        this.invalidateSupportedRenderers();

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyFill();
        }
      }

      // Patch in a sub-type call if it already exists on the prototype
      if ( proto.invalidateFill ) {
        var subtypeInvalidateFill = proto.invalidateFill;
        proto.invalidateFill = function() {
          subtypeInvalidateFill.call( this );
          invalidateFill.call( this );
        };
      }
      else {
        proto.invalidateFill = invalidateFill;
      }

      /**
       * Paintable's version of invalidateStroke(), possibly combined with a client invalidateStroke. Invalidates our
       * current stroke, triggering recomputation of anything that depended on the old stroke's value.
       * @protected
       */
      function invalidateStroke() {
        this.invalidateSupportedRenderers();

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyStroke();
        }
      }

      // Patch in a sub-type call if it already exists on the prototype
      if ( proto.invalidateStroke ) {
        var subtypeInvalidateStroke = proto.invalidateStroke;
        proto.invalidateStroke = function() {
          subtypeInvalidateStroke.call( this );
          invalidateStroke.call( this );
        };
      }
      else {
        proto.invalidateStroke = invalidateStroke;
      }
    }
  };
  scenery.register( 'Paintable', Paintable );

  Paintable.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

  return Paintable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Something that can be displayed with a specific renderer.
 * NOTE: Drawables are assumed to be pooled with PoolableMixin, as freeToPool() is called.
 *
 * A drawable's life-cycle starts with its initialization (calling initializeDrawable once), and ends with its disposal
 * (where it is freed to its own pool).
 *
 * Drawables are part of an unordered drawable "tree" where each drawable can have a parent references. This is used
 * for, among other things, propagation of 'dirty' flags and usage during stitching.
 *
 * Blocks and backbones (sub-types of Drawable) contain children (creating a tree, although shared caches make it more
 * like a DAG). Our Scenery Display is built from a root backbone, that contains blocks. This can be Canvas/SVG, but
 * may also contain a DOM block with another backbone (used for opacity, CSS transforms, etc.).
 *
 * Drawables are part of two inherent linked lists: an "old" and a "new" one. Usually they are the same, but during
 * updates, the "new" linked list is changed to accomodate any changes, and then a stitch process is done to mark which
 * block (parent) we will belong to.
 *
 * As part of stitching or other processes, a Drawable is responsible for recording its pending state changes. Most
 * notably, we need to determine whether a drawable is being added, moved, or removed in the next frame. This is done
 * with an idempotent API using notePendingAddition/notePendingRemoval/notePendingMove. Either:
 *   - One or more notePendingMove() calls are made. When we are updated with updateBlock(), we will move to the
 *     last block referenced with notePendingMove() (which may be a no-op if it is the same block).
 *   - Zero or one notePendingAddition() call is made, and zero or one notePendingRemoval() call is made. Our action is:
 *     - No addition, no removal: nothing done
 *     - No addition, one removal: We are removed from our last block (and then presumably disposed later)
 *     - One addition, no removal: We are added to our new (pending) block, without being removed from anything
 *     - One addition, one removal: We are removed from our last block and added to our new (pending) block.
 * It is set up so that the order of addition/removal calls doesn't matter, since these can occur from within different
 * backbone stitches (removed in one, added in another, or with the order reversed). Our updateBlocks() is guaranteed
 * to be called after all of those have been completed.
 *
 * APIs for drawable types:
 *
 * DOM: {
 *   domElement: {HTMLElement}
 * }
 * Canvas: {
 *   paintCanvas: function( {CanvasContextWrapper} wrapper, {Node} node, {Matrix3} matrix )
 * }
 * SVG: {
 *   svgElement: {SVGElement}
 * }
 * WebGL: {
 *   onAddToBlock: function( {WebGLBlock} block )
 *   onRemoveFromBlock: function( {WebGLBlock} block )
 *   render: function( {ShaderProgram} shaderProgram )
 *   shaderAttributes: {string[]} - names of vertex attributes to be used
 * }
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Drawable',['require','PHET_CORE/inherit','AXON/Events','SCENERY/scenery','SCENERY/display/Renderer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );

  var globalId = 1;

  function Drawable( renderer ) {
    this.initializeDrawable( renderer );
  }

  scenery.register( 'Drawable', Drawable );

  inherit( Events, Drawable, {
    initializeDrawable: function( renderer ) {
      Events.call( this );

      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );

      // unique ID for drawables
      this.id = this.id || globalId++;

      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] initialize ' + this.toString() );

      this.cleanDrawable();

      this.renderer = renderer;

      this.dirty = true;
      this.disposed = false;

      this.linksDirty = false;

      this._visible = true; // {boolean}, ES5 getter/setter provided

      // {boolean} - If false, will cause our parent block to not be fitted. (ES5 getter/setter provided)
      this._fittable = true;

      return this;
    },

    cleanDrawable: function() {
      // what drawble we are being rendered (or put) into (will be filled in later)
      this.parentDrawable = null;
      this.backbone = null; // a backbone reference (if applicable).

      this.pendingParentDrawable = null; // what our parent drawable will be after the stitch is finished
      this.pendingBackbone = null;       // what our backbone will be after the stitch is finished (if applicable)
      this.pendingAddition = false;      // whether we are to be added to a block/backbone in our updateBlock() call
      this.pendingRemoval = false;       // whether we are to be removed from a block/backbone in our updateBlock() call

      assert && assert( !this.previousDrawable && !this.nextDrawable,
        'By cleaning (disposal or fresh creation), we should have disconnected from the linked list' );

      // linked list handling (will be filled in later)
      this.previousDrawable = null;
      this.nextDrawable = null;

      // similar but without recent changes, so that we can traverse both orders at the same time for stitching
      this.oldPreviousDrawable = null;
      this.oldNextDrawable = null;

      this.removeAllEventListeners();
    },

    setVisible: function( visible ) {
      if ( this._visible !== visible ) {
        this._visible = visible;
        this.trigger0( 'visibility' );
      }
    },
    set visible( value ) { this.setVisible( value ); },

    isVisible: function() {
      return this._visible;
    },
    get visible() { return this.isVisible(); },

    // Should be called just after initialization (before being added to blocks) if we aren't fittable.
    setFittable: function( fittable ) {
      if ( this._fittable !== fittable ) {
        this._fittable = fittable;
        this.trigger1( 'fittability', this );
      }
    },
    set fittable( value ) { this.setFittable( value ); },

    isFittable: function() {
      return this._fittable;
    },
    get fittable() { return this.isFittable(); },

    // called to add a block (us) as a child of a backbone
    setBlockBackbone: function( backboneInstance ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] setBlockBackbone ' +
                                                                this.toString() + ' with ' + backboneInstance.toString() );

      // if this is being called, Block will be guaranteed to be loaded
      assert && assert( this instanceof scenery.Block );

      this.parentDrawable = backboneInstance;
      this.backbone = backboneInstance;
      this.pendingParentDrawable = backboneInstance;
      this.pendingBackbone = backboneInstance;
      this.pendingAddition = false;
      this.pendingRemoval = false;
    },

    notePendingAddition: function( display, block, backbone ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingAddition ' +
                                                                this.toString() + ' with ' + block.toString() + ', ' +
                                                                ( backbone ? backbone.toString() : '-' ) );

      assert && assert( backbone !== undefined, 'backbone can be either null or a backbone' );
      assert && assert( block instanceof scenery.Block );

      this.pendingParentDrawable = block;
      this.pendingBackbone = backbone;
      this.pendingAddition = true;

      // if we weren't already marked for an update, mark us
      if ( !this.pendingRemoval ) {
        display.markDrawableChangedBlock( this );
      }
    },

    notePendingRemoval: function( display ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingRemoval ' +
                                                                this.toString() );

      this.pendingRemoval = true;

      // if we weren't already marked for an update, mark us
      if ( !this.pendingAddition ) {
        display.markDrawableChangedBlock( this );
      }
    },

    // moving a drawable that isn't changing backbones, just potentially changing its block.
    // it should not have notePendingAddition or notePendingRemoval called on it.
    notePendingMove: function( display, block ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingMove ' +
                                                                this.toString() + ' with ' + block.toString() );

      assert && assert( block instanceof scenery.Block );

      this.pendingParentDrawable = block;

      if ( !this.pendingRemoval || !this.pendingAddition ) {
        display.markDrawableChangedBlock( this );
      }

      // set both flags, since we need it to be removed and added
      this.pendingAddition = true;
      this.pendingRemoval = true;
    },

    // returns {boolean} whether we changed our block
    updateBlock: function() {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] updateBlock ' + this.toString() +
                                                                ' with add:' + this.pendingAddition +
                                                                ' remove:' + this.pendingRemoval +
                                                                ' old:' + ( this.parentDrawable ? this.parentDrawable.toString() : '-' ) +
                                                                ' new:' + ( this.pendingParentDrawable ? this.pendingParentDrawable.toString() : '-' ) );
      sceneryLog && sceneryLog.Drawable && sceneryLog.push();

      var changed = false;

      if ( this.pendingRemoval || this.pendingAddition ) {
        // we are only unchanged if we have an addition AND removal, and the endpoints are identical
        changed = !this.pendingRemoval || !this.pendingAddition ||
                  this.parentDrawable !== this.pendingParentDrawable ||
                  this.backbone !== this.pendingBackbone;

        if ( changed ) {
          if ( this.pendingRemoval ) {
            sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'removing from ' + this.parentDrawable.toString() );
            this.parentDrawable.removeDrawable( this );

            // remove references if we are not being added back in
            if ( !this.pendingAddition ) {
              this.pendingParentDrawable = null;
              this.pendingBackbone = null;
            }
          }

          this.parentDrawable = this.pendingParentDrawable;
          this.backbone = this.pendingBackbone;

          if ( this.pendingAddition ) {
            sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'adding to ' + this.parentDrawable.toString() );
            this.parentDrawable.addDrawable( this );
          }
        }
        else {
          sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'unchanged' );

          if ( this.pendingAddition && Renderer.isCanvas( this.renderer ) ) {
            this.parentDrawable.onPotentiallyMovedDrawable( this );
          }
        }

        this.pendingAddition = false;
        this.pendingRemoval = false;
      }

      sceneryLog && sceneryLog.Drawable && sceneryLog.pop();

      return changed;
    },

    updateLinks: function() {
      this.oldNextDrawable = this.nextDrawable;
      this.oldPreviousDrawable = this.previousDrawable;
      this.linksDirty = false;
    },

    markDirty: function() {
      if ( !this.dirty ) {
        this.dirty = true;

        // TODO: notify what we want to call repaint() later
        if ( this.parentDrawable ) {
          this.parentDrawable.markDirtyDrawable( this );
        }
      }
    },

    // will ensure that after syncTree phase is done, we will have updateLinks() called on us
    markLinksDirty: function( display ) {
      if ( !this.linksDirty ) {
        this.linksDirty = true;
        display.markDrawableForLinksUpdate( this );
      }
    },

    // marks us for disposal in the next phase of updateDisplay(), and disconnects from the linked list
    markForDisposal: function( display ) {
      // as we are marked for disposal, we disconnect from the linked list (so our disposal setting nulls won't cause issues)
      Drawable.disconnectBefore( this, display );
      Drawable.disconnectAfter( this, display );

      display.markDrawableForDisposal( this );
    },

    // disposes immediately, and makes no guarantees about out linked list's state (disconnects).
    disposeImmediately: function( display ) {
      // as we are marked for disposal, we disconnect from the linked list (so our disposal setting nulls won't cause issues)
      Drawable.disconnectBefore( this, display );
      Drawable.disconnectAfter( this, display );

      this.dispose();
    },

    // generally do not call this directly, use markForDisposal (so Display will dispose us), or disposeImmediately.
    dispose: function() {
      assert && assert( !this.disposed, 'We should not re-dispose drawables' );

      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] dispose ' + this.toString() );
      sceneryLog && sceneryLog.Drawable && sceneryLog.push();

      this.cleanDrawable();
      this.disposed = true;

      // for now
      this.freeToPool();

      sceneryLog && sceneryLog.Drawable && sceneryLog.pop();
    },

    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        assertSlow && assertSlow( !this.disposed,
          'If we are being audited, we assume we are in the drawable display tree, and we should not be marked as disposed' );
        assertSlow && assertSlow( this.renderer, 'Should not have a 0 (no) renderer' );

        assertSlow && assertSlow( !this.backbone || this.parentDrawable,
          'If we have a backbone reference, we must have a parentDrawable (our block)' );

        if ( !allowPendingBlock ) {
          assertSlow && assertSlow( !this.pendingAddition );
          assertSlow && assertSlow( !this.pendingRemoval );
          assertSlow && assertSlow( this.parentDrawable === this.pendingParentDrawable,
            'Assure our parent and pending parent match, if we have updated blocks' );
          assertSlow && assertSlow( this.backbone === this.pendingBackbone,
            'Assure our backbone and pending backbone match, if we have updated blocks' );
        }

        if ( !allowPendingList ) {
          assertSlow && assertSlow( this.oldPreviousDrawable === this.previousDrawable,
            'Pending linked-list references should be cleared by now' );
          assertSlow && assertSlow( this.oldNextDrawable === this.nextDrawable,
            'Pending linked-list references should be cleared by now' );
          assertSlow && assertSlow( !this.linksDirty, 'Links dirty flag should be clean' );
        }

        if ( !allowDirty ) {
          assertSlow && assertSlow( !this.dirty,
            'Should not be dirty at this phase, if we are in the drawable display tree' );
        }
      }
    },

    toString: function() {
      return this.constructor.name + '#' + this.id;
    },

    toDetailedString: function() {
      return this.toString();
    }
  } );

  // a,b {Drawable}, connects the two drawables in the linked list, while cutting the previous connection and marking
  // the links for updates.
  Drawable.connectDrawables = function( a, b, display ) {
    // we don't need to do anything if there is no change
    if ( a.nextDrawable !== b ) {
      // touch previous neighbors
      if ( a.nextDrawable ) {
        a.nextDrawable.markLinksDirty( display );
        a.nextDrawable.previousDrawable = null;
      }
      if ( b.previousDrawable ) {
        b.previousDrawable.markLinksDirty( display );
        b.previousDrawable.nextDrawable = null;
      }

      a.nextDrawable = b;
      b.previousDrawable = a;

      // mark these as needing updates
      a.markLinksDirty( display );
      b.markLinksDirty( display );
    }
  };

  Drawable.disconnectBefore = function( a, display ) {
    // we don't need to do anything if there is no change
    if ( a.previousDrawable ) {
      a.markLinksDirty( display );
      a.previousDrawable.markLinksDirty( display );
      a.previousDrawable.nextDrawable = null;
      a.previousDrawable = null;
    }
  };

  Drawable.disconnectAfter = function( a, display ) {
    // we don't need to do anything if there is no change
    if ( a.nextDrawable ) {
      a.markLinksDirty( display );
      a.nextDrawable.markLinksDirty( display );
      a.nextDrawable.previousDrawable = null;
      a.nextDrawable = null;
    }
  };

  // converts a linked list of drawables to an array (useful for debugging/assertion purposes, should not be used in production code)
  Drawable.listToArray = function( firstDrawable, lastDrawable ) {
    var arr = [];

    // assumes we'll hit lastDrawable, otherwise we'll NPE
    for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
      arr.push( drawable );

      if ( drawable === lastDrawable ) {
        break;
      }
    }

    return arr;
  };

  // converts an old linked list of drawables to an array (useful for debugging/assertion purposes, should not be used in production code)
  Drawable.oldListToArray = function( firstDrawable, lastDrawable ) {
    var arr = [];

    // assumes we'll hit lastDrawable, otherwise we'll NPE
    for ( var drawable = firstDrawable; ; drawable = drawable.oldNextDrawable ) {
      arr.push( drawable );

      if ( drawable === lastDrawable ) {
        break;
      }
    }

    return arr;
  };

  return Drawable;
} );

// Copyright 2014-2016, University of Colorado Boulder


/**
 * A drawable that will paint a single instance.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SelfDrawable',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  /**
   * @constructor
   * @extends Drawable
   * @mixes Poolable
   *
   * @param renderer
   * @param instance
   */
  function SelfDrawable( renderer, instance ) {
    this.initializeSelfDrawable( renderer, instance );
  }

  scenery.register( 'SelfDrawable', SelfDrawable );

  inherit( scenery.Drawable, SelfDrawable, {
    initializeSelfDrawable: function( renderer, instance ) {
      this.drawableVisibilityListener = this.drawableVisibilityListener || this.updateSelfVisibility.bind( this );

      // super initialization
      this.initializeDrawable( renderer );

      this.instance = instance;
      this.node = instance.trail.lastNode();
      this.node.attachDrawable( this );

      this.instance.onStatic( 'selfVisibility', this.drawableVisibilityListener );

      this.updateSelfVisibility();

      return this;
    },

    // @public
    dispose: function() {
      this.instance.offStatic( 'selfVisibility', this.drawableVisibilityListener );

      this.node.detachDrawable( this );

      // free references
      this.instance = null;
      this.node = null;

      Drawable.prototype.dispose.call( this );
    },

    updateSelfVisibility: function() {
      // hide our drawable if it is not relatively visible
      this.visible = this.instance.selfVisible;
    },

    toDetailedString: function() {
      return this.toString() + ' (' + this.instance.trail.toPathString() + ')';
    }
  } );

  SelfDrawable.Poolable = {
    mixin: function( selfDrawableType ) {
      // for pooling, allow <SelfDrawableType>.createFromPool( renderer, instance ) and drawable.freeToPool(). Creation will initialize the drawable to an initial state
      Poolable.mixin( selfDrawableType, {
        defaultFactory: function() {
          return new selfDrawableType();
        },
        constructorDuplicateFactory: function( pool ) {
          return function( renderer, instance ) {
            if ( pool.length ) {
              return pool.pop().initialize( renderer, instance );
            }
            else {
              return new selfDrawableType( renderer, instance );
            }
          };
        }
      } );
    }
  };

  return SelfDrawable;
} );

// Copyright 2014-2017, University of Colorado Boulder

/**
 * Base type for gradients and patterns (and NOT the only type for fills/strokes)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Paint',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var globalId = 1;

  /**
   * @constructor
   * @extends {Object}
   */
  function Paint() {
    // @public (scenery-internal) {string}
    this.id = 'paint' + globalId++;

    // @protected {Matrix3|null}
    this.transformMatrix = null;
  }

  scenery.register( 'Paint', Paint );

  inherit( Object, Paint, {
    // @public {boolean}
    isPaint: true,

    /**
     * Returns an object that can be passed to a Canvas context's fillStyle or strokeStyle.
     * @public
     *
     * @returns {*}
     */
    getCanvasStyle: function() {
      throw new Error( 'abstract method' );
    },

    /**
     * Sets how this paint (pattern/gradient) is transformed, compared with the local coordinate frame of where it is
     * used.
     * @public
     *
     * NOTE: This should only be used before the pattern/gradient is ever displayed.
     * TODO: Catch if this is violated?
     *
     * @param {Matrix3} transformMatrix
     * @returns {Paint} - for chaining
     */
    setTransformMatrix: function( transformMatrix ) {
      if ( this.transformMatrix !== transformMatrix ) {
        this.transformMatrix = transformMatrix;
      }
      return this;
    }
  } );

  return Paint;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Abstract base type for LinearGradient and RadialGradient.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Gradient',['require','PHET_CORE/cleanArray','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/util/Paint','AXON/Property','SCENERY/scenery'],function( require ) {
  'use strict';

  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Paint = require( 'SCENERY/util/Paint' );
  var Property = require( 'AXON/Property' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @constructor
   * @extends Paint
   *
   * TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
   */
  function Gradient() {
    assert && assert( this.constructor.name !== 'Gradient',
      'Please create a LinearGradient or RadialGradient. Do not directly use the supertype Gradient.' );

    Paint.call( this );

    // @private {Array.<{ ratio: {number}, color: {...} }>}
    this.stops = [];

    // @private {number}
    this.lastStopRatio = 0;

    // @private {CanvasGradient|null} - Lazily created
    this.canvasGradient = null;

    // @private {boolean} - Whether we should force a check of whether stops have changed
    this.colorStopsDirty = false;

    // @private {Array.<string>} - Used to check to see if colors have changed since last time
    this.lastColorStopValues = [];
  }

  scenery.register( 'Gradient', Gradient );

  inherit( Paint, Gradient, {
    // @public {boolean}
    isGradient: true,

    /**
     * Adds a color stop to the gradient.
     * @public
     *
     * Color stops should be added in order (monotonically increasing ratio values).
     *
     * NOTE: Color stops should only be added before using the gradient as a fill/stroke. Adding stops afterwards
     *       will result in undefined behavior.
     * TODO: Catch attempts to do the above.
     *
     * @param {number} ratio - Monotonically increasing value in the range of 0 to 1
     * @param {Color|String|Property.<Color|string>|null} color
     * @returns {Gradient} - for chaining
     */
    addColorStop: function( ratio, color ) {
      assert && assert( typeof ratio === 'number', 'Ratio needs to be a number' );
      assert && assert( ratio >= 0 && ratio <= 1, 'Ratio needs to be between 0,1 inclusively' );
      assert && assert( color === null ||
                        typeof color === 'string' ||
                        color instanceof Color ||
                        ( color instanceof Property && ( color.value === null ||
                                                         typeof color.value === 'string' ||
                                                         color.value instanceof Color ) ),
        'Color should match the addColorStop type specification' );

      if ( this.lastStopRatio > ratio ) {
        // fail out, since browser quirks go crazy for this case
        throw new Error( 'Color stops not specified in the order of increasing ratios' );
      }
      else {
        this.lastStopRatio = ratio;
      }

      this.stops.push( {
        ratio: ratio,
        color: color
      } );

      // Easiest to just push a value here, so that it is always the same length as the stops array.
      this.lastColorStopValues.push( '' );

      return this;
    },

    /**
     * Subtypes should return a fresh CanvasGradient type.
     * @protected
     * @abstract
     *
     * @returns {CanvasGradient}
     */
    createCanvasGradient: function() {
      throw new Error( 'abstract method' );
    },

    /**
     * Returns stops suitable for direct SVG use.
     * @public
     *
     * @returns {Array.<{ ratio: {number}, stop: {Color|string|Property.<Color|string|null>|null} }>}
     */
    getSVGStops: function() {
      return this.stops;
    },

    /**
     * Forces a re-check of whether colors have changed, so that the Canvas gradient can be regenerated if
     * necessary.
     * @public
     */
    invalidateCanvasGradient: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'Invalidated Canvas Gradient for #' + this.id );
      this.colorStopsDirty = true;
    },

    /**
     * Compares the current color values with the last-recorded values for the current Canvas gradient.
     * @private
     *
     * This is needed since the values of color properties (or the color itself) may change.
     *
     * @returns {boolean}
     */
    haveCanvasColorStopsChanged: function() {
      if ( this.lastColorStopValues === null ) {
        return true;
      }

      for ( var i = 0; i < this.stops.length; i++ ) {
        if ( Gradient.colorToString( this.stops[ i ].color ) !== this.lastColorStopValues[ i ] ) {
          return true;
        }
      }

      return false;
    },

    /**
     * Returns an object that can be passed to a Canvas context's fillStyle or strokeStyle.
     * @public
     * @override
     *
     * @returns {*}
     */
    getCanvasStyle: function() {
      // Check if we need to regenerate the Canvas gradient
      if ( !this.canvasGradient || ( this.colorStopsDirty && this.haveCanvasColorStopsChanged() ) ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'Regenerating Canvas Gradient for #' + this.id );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();

        this.colorStopsDirty = false;

        cleanArray( this.lastColorStopValues );
        this.canvasGradient = this.createCanvasGradient();

        for ( var i = 0; i < this.stops.length; i++ ) {
          var stop = this.stops[ i ];

          var colorString = Gradient.colorToString( stop.color );
          this.canvasGradient.addColorStop( stop.ratio, colorString );

          // Save it so we can compare next time whether our generated gradient would have changed
          this.lastColorStopValues.push( colorString );
        }

        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }

      return this.canvasGradient;
    }
  } );

  /**
   * Returns the current value of the generally-allowed color types for Gradient, as a string.
   * @public
   *
   * @param {Color|string|Property.<Color|string|null>|null} color
   * @returns {string}
   */
  Gradient.colorToString = function( color ) {
    // to {Color|string|null}
    if ( color instanceof Property ) {
      color = color.value;
    }

    // to {Color|string}
    if ( color === null ) {
      color = 'transparent';
    }

    // to {string}
    if ( color instanceof Color ) {
      color = color.toCSS();
    }

    return color;
  };

  return Gradient;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Listens to the fill or stroke of a Node, and notifies when the actual represented value has changed.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/PaintObserver',['require','SCENERY/util/Color','SCENERY/util/Gradient','PHET_CORE/inherit','AXON/Property','SCENERY/scenery'],function( require ) {
  'use strict';

  var Color = require( 'SCENERY/util/Color' );
  var Gradient = require( 'SCENERY/util/Gradient' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * An observer for a fill or stroke, that will be able to trigger notifications when it changes.
   * @constructor
   *
   * @param {string} type - Either 'fill' or 'stroke'
   * @param {function} changeCallback - To be called on any change (with no arguments)
   */
  function PaintObserver( type, changeCallback ) {
    assert && assert( type === 'fill' || type === 'stroke' );

    // @private {string} - 'fill' or 'stroke'
    this.type = type;

    // @private {string} - Property name on the Node itself
    this.name = '_' + type;

    // @private {function} - Our callback
    this.changeCallback = changeCallback;

    // @private {function} - To be called when a potential change is detected
    this.notifyChangeCallback = this.notifyChanged.bind( this );

    // @private {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern}
    // Our unwrapped fill/stroke value
    this.primary = null;

    // @private {function} - To be called whenever our secondary fill/stroke value may have changed
    this.updateSecondaryListener = this.updateSecondary.bind( this );

    // Tracking needed so we don't add duplicate listeners, see https://github.com/phetsims/axon/issues/129
    // @private {Array.<Property.<*>>} - Indexed the same as the counts.
    this.secondaryListenedProperties = [];
    // @private {Array.<number>}
    this.secondaryListenedCounts = [];
  }

  scenery.register( 'PaintObserver', PaintObserver );

  inherit( Object, PaintObserver, {
    /**
     * Initializes our PaintObserver for a specific Node.
     * @public (scenery-internal)
     *
     * @param {Paintable} node
     */
    initialize: function( node ) {
      assert && assert( node !== null );
      this.node = node;

      this.updatePrimary();
    },

    /**
     * Calls the change callback, and invalidates the paint itself if it's a gradient.
     * @private
     */
    notifyChanged: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] changed ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      var primary = this.node[ this.name ];
      if ( primary instanceof Gradient ) {
        primary.invalidateCanvasGradient();
      }
      this.changeCallback();

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Should be called when our paint (fill/stroke) may have changed.
     * @public (scenery-internal)
     *
     * Should update any listeners (if necessary), and call the callback (if necessary)
     */
    updatePrimary: function() {
      var primary = this.node[ this.name ];
      if ( primary !== this.primary ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] primary update ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();

        this.detachPrimary( this.primary );
        this.primary = primary;
        this.attachPrimary( primary );
        this.notifyChangeCallback();

        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
    },

    /**
     * Called when the value of a "primary" Property (contents of one, main or as a Gradient) is potentially changed.
     * @private
     *
     * @param {string|Color} newPaint
     * @param {string|Color} oldPaint
     */
    updateSecondary: function( newPaint, oldPaint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] secondary update ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      this.detachSecondary( oldPaint );
      this.attachSecondary( newPaint );
      this.notifyChangeCallback();

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Attempt to attach listeners to the paint's primary (the paint itself), or something else that acts like the primary
     * (properties on a gradient).
     * @private
     *
     * TODO: Note that this is called for gradient colors also
     *
     * NOTE: If it's a Property, we'll also need to handle the secondary (part inside the Property).
     *
     * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} paint
     */
    attachPrimary: function( paint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] attachPrimary ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      if ( paint instanceof Property ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] add Property listener ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        this.secondaryLazyLinkProperty( paint );
        this.attachSecondary( paint.get() );
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
      else if ( paint instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] add Color listener ' + this.node.id + '.' + this.name );
        paint.addChangeListener( this.notifyChangeCallback );
      }
      else if ( paint instanceof Gradient ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] add Gradient listeners ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        for ( var i = 0; i < paint.stops.length; i++ ) {
          this.attachPrimary( paint.stops[ i ].color );
        }
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Attempt to detach listeners from the paint's primary (the paint itself).
     * @private
     *
     * TODO: Note that this is called for gradient colors also
     *
     * NOTE: If it's a Property or Gradient, we'll also need to handle the secondaries (part(s) inside the Property(ies)).
     *
     * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} paint
     */
    detachPrimary: function( paint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] detachPrimary ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      if ( paint instanceof Property ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] remove Property listener ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        this.secondaryUnlinkProperty( paint );
        this.detachSecondary( paint.get() );
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
      else if ( paint instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] remove Color listener ' + this.node.id + '.' + this.name );
        paint.removeChangeListener( this.notifyChangeCallback );
      }
      else if ( paint instanceof Gradient ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] remove Gradient listeners ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        for ( var i = 0; i < paint.stops.length; i++ ) {
          this.detachPrimary( paint.stops[ i ].color );
        }
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Attempt to attach listeners to the paint's secondary (part within the Property).
     * @private
     *
     * @param {string|Color} paint
     */
    attachSecondary: function( paint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] attachSecondary ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      if ( paint instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] add Color listener ' + this.node.id + '.' + this.name );
        paint.addChangeListener( this.notifyChangeCallback );
      }

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Attempt to detach listeners from the paint's secondary (part within the Property).
     * @private
     *
     * @param {string|Color} paint
     */
    detachSecondary: function( paint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] detachSecondary ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      if ( paint instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] remove Color listener ' + this.node.id + '.' + this.name );
        paint.removeChangeListener( this.notifyChangeCallback );
      }

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Adds our secondary listener to the Property (unless there is already one, in which case we record the counts).
     * @private
     *
     * @param {Property.<*>} property
     */
    secondaryLazyLinkProperty: function( property ) {
      var index = _.indexOf( this.secondaryListenedProperties, property );
      if ( index >= 0 ) {
        this.secondaryListenedCounts[ index ]++;
      }
      else {
        this.secondaryListenedProperties.push( property );
        this.secondaryListenedCounts.push( 1 );
        property.lazyLink( this.updateSecondaryListener );
      }
    },

    /**
     * Removes our secondary listener from the Property (unless there were more than 1 time we needed to listen to it,
     * in which case we reduce the count).
     * @private
     *
     * @param {Property.<*>} property
     */
    secondaryUnlinkProperty: function( property ) {
      var index = _.indexOf( this.secondaryListenedProperties, property );
      this.secondaryListenedCounts[ index ]--;
      if ( this.secondaryListenedCounts[ index ] === 0 ) {
        this.secondaryListenedProperties.splice( index, 1 );
        this.secondaryListenedCounts.splice( index, 1 );
        property.unlink( this.updateSecondaryListener );
      }
    },

    /**
     * Cleans our state (so it can be potentially re-used).
     * @public (scenery-internal)
     */
    clean: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] clean ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      this.detachPrimary( this.primary );
      this.primary = null;
      this.node = null;

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    }
  } );

  return PaintObserver;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * A mixin to drawables for Paintable nodes that does not store the fill/stroke state, as it just needs to track
 * dirtyness overall.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/PaintableStatelessDrawable',['require','SCENERY/scenery','SCENERY/display/PaintObserver','SCENERY/util/Color'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var PaintObserver = require( 'SCENERY/display/PaintObserver' );
  var Color = require( 'SCENERY/util/Color' );

  var PaintableStatelessDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      proto.initializePaintableStateless = function( renderer, instance ) {
        this.fillCallback = this.fillCallback || this.markDirtyFill.bind( this );
        this.strokeCallback = this.strokeCallback || this.markDirtyStroke.bind( this );
        this.fillObserver = this.fillObserver || new PaintObserver( 'fill', this.fillCallback );
        this.strokeObserver = this.strokeObserver || new PaintObserver( 'stroke', this.strokeCallback );

        this.fillObserver.initialize( instance.node );
        this.strokeObserver.initialize( instance.node );

        return this;
      };

      proto.disposePaintableStateless = function() {
        this.fillObserver.clean();
        this.strokeObserver.clean();
      };

      proto.markDirtyFill = function() {
        assert && Color.checkPaint( this.instance.node._fill );

        this.markPaintDirty();
        this.fillObserver.updatePrimary(); // TODO: look into having the fillObserver be notified of Node changes as our source
      };

      proto.markDirtyStroke = function() {
        assert && Color.checkPaint( this.instance.node._stroke );

        this.markPaintDirty();
        this.strokeObserver.updatePrimary(); // TODO: look into having the strokeObserver be notified of Node changes as our source
      };

      proto.markDirtyLineWidth = function() {
        this.markPaintDirty();
      };

      proto.markDirtyLineOptions = function() {
        this.markPaintDirty();
      };

      proto.markDirtyCachedPaints = function() {
        this.markPaintDirty();
      };
    }
  };

  scenery.register( 'PaintableStatelessDrawable', PaintableStatelessDrawable );

  return PaintableStatelessDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * TODO docs
 *   note paintCanvas() required, and other implementation-specific details
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/CanvasSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param renderer
   * @param instance
   */
  function CanvasSelfDrawable( renderer, instance ) {
    this.initializeCanvasSelfDrawable( renderer, instance );

    throw new Error( 'Should use initialization and pooling' );
  }

  scenery.register( 'CanvasSelfDrawable', CanvasSelfDrawable );

  inherit( SelfDrawable, CanvasSelfDrawable, {
    initializeCanvasSelfDrawable: function( renderer, instance ) {
      // super initialization
      this.initializeSelfDrawable( renderer, instance );

      // this is the same across lifecycles
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );

      instance.relativeTransform.addListener( this.transformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
      instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated

      return this;
    },

    markTransformDirty: function() {
      this.markDirty();
    },

    // general flag set on the state, which we forward directly to the drawable's paint flag
    markPaintDirty: function() {
      this.markDirty();
    },

    update: function() {
      this.dirty = false;
    },

    // @override
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );

      // mark us as dirty when our self visibility changes
      this.markDirty();
    },

    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();

      SelfDrawable.prototype.dispose.call( this );
    }
  } );

  // methods for forwarding dirty messages
  function canvasSelfDirty() {
    // we pass this method and it is only called with blah.call( ... ), where the 'this' reference is set.
    this.markDirty();
  }

  // options takes: type, paintCanvas( wrapper ), usesPaint, and dirtyMethods (array of string names of methods that make the state dirty)
  CanvasSelfDrawable.createDrawable = function( options ) {
    var type = options.type;
    var paintCanvas = options.paintCanvas;
    var usesPaint = options.usesPaint;

    assert && assert( typeof type === 'function' );
    assert && assert( typeof paintCanvas === 'function' );
    assert && assert( typeof usesPaint === 'boolean' );

    inherit( CanvasSelfDrawable, type, {
      initialize: function( renderer, instance ) {
        this.initializeCanvasSelfDrawable( renderer, instance );

        if ( usesPaint ) {
          this.initializePaintableStateless( renderer, instance );
        }

        return this; // allow for chaining
      },

      paintCanvas: paintCanvas,

      update: function() {
        // no action directly needed for the self-drawable case, as we will be repainted in the block
        this.dirty = false;
      },

      dispose: function() {
        CanvasSelfDrawable.prototype.dispose.call( this );

        if ( usesPaint ) {
          this.disposePaintableStateless();
        }
      }
    } );

    // include stubs (stateless) for marking dirty stroke and fill (if necessary). we only want one dirty flag, not multiple ones, for Canvas (for now)
    if ( usesPaint ) {
      PaintableStatelessDrawable.mixin( type );
    }

    // set up pooling
    SelfDrawable.Poolable.mixin( type );

    if ( options.dirtyMethods ) {
      for ( var i = 0; i < options.dirtyMethods.length; i++ ) {
        type.prototype[ options.dirtyMethods[ i ] ] = canvasSelfDirty;
      }
    }

    return type;
  };

  return CanvasSelfDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Canvas drawable for Path nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/PathCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );

  /**
   * A generated CanvasSelfDrawable whose purpose will be drawing our Path. One of these drawables will be created
   * for each displayed instance of a Path.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function PathCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'PathCanvasDrawable', PathCanvasDrawable );

  inherit( CanvasSelfDrawable, PathCanvasDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {PathCanvasDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    /**
     * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
     * @public
     *
     * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
     * other required effects (opacity, clipping, etc.) have already been prepared.
     *
     * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
     *
     * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
     * @param {Node} node - Our node that is being drawn
     * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
     */
    paintCanvas: function( wrapper, node, matrix ) {
      var context = wrapper.context;

      if ( node.hasShape() ) {
        // TODO: fill/stroke delay optimizations?
        context.beginPath();
        node._shape.writeToContext( context );

        if ( node.hasFill() ) {
          node.beforeCanvasFill( wrapper ); // defined in Paintable
          context.fill();
          node.afterCanvasFill( wrapper ); // defined in Paintable
        }

        if ( node.hasPaintableStroke() ) {
          node.beforeCanvasStroke( wrapper ); // defined in Paintable
          context.stroke();
          node.afterCanvasStroke( wrapper ); // defined in Paintable
        }
      }
    },

    // stateless dirty functions
    markDirtyShape: function() { this.markPaintDirty(); },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );

  PaintableStatelessDrawable.mixin( PathCanvasDrawable );

  // This sets up PathCanvasDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( PathCanvasDrawable );

  return PathCanvasDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Handles SVG <defs> and fill/stroke style for SVG elements (by composition, not a mix-in or for inheritance).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/PaintSVGState',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * Returns the SVG style string used to represent a paint.
   *
   * @param {null|string|Color|LinearGradient|RadialGradient|Pattern} paint
   * @param {SVGBlock} svgBlock
   */
  function paintToSVGStyle( paint, svgBlock ) {
    if ( !paint ) {
      // no paint
      return 'none';
    }
    else if ( paint.toCSS ) {
      // Color object paint
      return paint.toCSS();
    }
    else if ( paint.isPaint ) {
      // reference the SVG definition with a URL
      return 'url(#' + paint.id + '-' + ( svgBlock ? svgBlock.id : 'noblock' ) + ')';
    }
    else {
      // plain CSS color
      return paint;
    }
  }

  /**
   * @constructor
   */
  function PaintSVGState() {
    this.initialize();
  }

  scenery.register( 'PaintSVGState', PaintSVGState );

  inherit( Object, PaintSVGState, {
    /**
     * Initializes the state
     * @public
     */
    initialize: function() {
      this.svgBlock = null; // {SVGBlock | null}

      // {string} fill/stroke style fragments that are currently used
      this.fillStyle = 'none';
      this.strokeStyle = 'none';

      // current reference-counted fill/stroke paints (gradients and fills) that will need to be released on changes
      // or disposal
      this.fillPaint = null;
      this.strokePaint = null;

      // these are used by the actual SVG element
      this.updateBaseStyle(); // the main style CSS
      this.strokeDetailStyle = ''; // width/dash/cap/join CSS
    },

    /**
     * Disposes the PaintSVGState, releasing listeners as needed.
     * @public
     */
    dispose: function() {
      // be cautious, release references
      this.releaseFillPaint();
      this.releaseStrokePaint();
    },

    releaseFillPaint: function() {
      if ( this.fillPaint ) {
        this.svgBlock.decrementPaint( this.fillPaint );
        this.fillPaint = null;
      }
    },

    releaseStrokePaint: function() {
      if ( this.strokePaint ) {
        this.svgBlock.decrementPaint( this.strokePaint );
        this.strokePaint = null;
      }
    },

    /**
     * Called when the fill needs to be updated, with the latest defs SVG block
     * @public (scenery-internal)
     *
     * @param {SVGBlock} svgBlock
     * @param {null|string|Color|LinearGradient|RadialGradient|Pattern} fill
     */
    updateFill: function( svgBlock, fill ) {
      assert && assert( this.svgBlock === svgBlock );

      // NOTE: If fill.isPaint === true, this should be different if we switched to a different SVG block.
      var fillStyle = paintToSVGStyle( fill, svgBlock );

      // If our fill paint reference changed
      if ( fill !== this.fillPaint ) {
        // release the old reference
        this.releaseFillPaint();

        // only store a new reference if our new fill is a paint
        if ( fill && fill.isPaint ) {
          this.fillPaint = fill;
          svgBlock.incrementPaint( fill );
        }
      }

      // If we need to update the SVG style of our fill
      if ( fillStyle !== this.fillStyle ) {
        this.fillStyle = fillStyle;
        this.updateBaseStyle();
      }
    },

    /**
     * Called when the stroke needs to be updated, with the latest defs SVG block
     * @public (scenery-internal)
     *
     * @param {SVGBlock} svgBlock
     * @param {null|string|Color|LinearGradient|RadialGradient|Pattern} fill
     */
    updateStroke: function( svgBlock, stroke ) {
      assert && assert( this.svgBlock === svgBlock );

      // NOTE: If stroke.isPaint === true, this should be different if we switched to a different SVG block.
      var strokeStyle = paintToSVGStyle( stroke, svgBlock );

      // If our stroke paint reference changed
      if ( stroke !== this.strokePaint ) {
        // release the old reference
        this.releaseStrokePaint();

        // only store a new reference if our new stroke is a paint
        if ( stroke && stroke.isPaint ) {
          this.strokePaint = stroke;
          svgBlock.incrementPaint( stroke );
        }
      }

      // If we need to update the SVG style of our stroke
      if ( strokeStyle !== this.strokeStyle ) {
        this.strokeStyle = strokeStyle;
        this.updateBaseStyle();
      }
    },

    updateBaseStyle: function() {
      this.baseStyle = 'fill: ' + this.fillStyle + '; stroke: ' + this.strokeStyle + ';';
    },

    updateStrokeDetailStyle: function( node ) {
      var strokeDetailStyle = '';

      var lineWidth = node.getLineWidth();
      if ( lineWidth !== 1 ) {
        strokeDetailStyle += 'stroke-width: ' + lineWidth + ';';
      }

      var lineCap = node.getLineCap();
      if ( lineCap !== 'butt' ) {
        strokeDetailStyle += 'stroke-linecap: ' + lineCap + ';';
      }

      var lineJoin = node.getLineJoin();
      if ( lineJoin !== 'miter' ) {
        strokeDetailStyle += 'stroke-linejoin: ' + lineJoin + ';';
      }

      var miterLimit = node.getMiterLimit();
      strokeDetailStyle += 'stroke-miterlimit: ' + miterLimit + ';';

      if ( node.hasLineDash() ) {
        strokeDetailStyle += 'stroke-dasharray: ' + node.getLineDash().join( ',' ) + ';';
        strokeDetailStyle += 'stroke-dashoffset: ' + node.getLineDashOffset() + ';';
      }

      this.strokeDetailStyle = strokeDetailStyle;
    },

    // called when the defs SVG block is switched (our SVG element was moved to another SVG top-level context)
    updateSVGBlock: function( svgBlock ) {
      // remove paints from the old svgBlock
      var oldSvgBlock = this.svgBlock;
      if ( oldSvgBlock ) {
        if ( this.fillPaint ) {
          oldSvgBlock.decrementPaint( this.fillPaint );
        }
        if ( this.strokePaint ) {
          oldSvgBlock.decrementPaint( this.strokePaint );
        }
      }

      this.svgBlock = svgBlock;

      // add paints to the new svgBlock
      if ( this.fillPaint ) {
        svgBlock.incrementPaint( this.fillPaint );
      }
      if ( this.strokePaint ) {
        svgBlock.incrementPaint( this.strokePaint );
      }
    }
  } );

  return PaintSVGState;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Represents an SVG visual element, and is responsible for tracking changes to the visual element, and then applying
 * any changes at a later time.
 *
 * Abstract methods to implement for concrete implementations:
 *   updateSVGSelf() - Update the SVG element's state to what the Node's self should display
 *   updateDefsSelf( block ) - Update defs on the given block (or if block === null, remove)
 *   initializeState( renderer, instance )
 *   disposeState()
 *
 * Subtypes should also implement drawable.svgElement, as the actual SVG element to be used.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/display/PaintSVGState'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintSVGState = require( 'SCENERY/display/PaintSVGState' );

  function SVGSelfDrawable( renderer, instance ) {
    this.initializeSVGSelfDrawable( renderer, instance );

    throw new Error( 'Should use initialization and pooling' );
  }

  scenery.register( 'SVGSelfDrawable', SVGSelfDrawable );

  inherit( SelfDrawable, SVGSelfDrawable, {
    initializeSVGSelfDrawable: function( renderer, instance, usesPaint, keepElements ) {
      // super initialization
      this.initializeSelfDrawable( renderer, instance );

      this.usesPaint = usesPaint;
      this.keepElements = keepElements;

      this.svgElement = null; // should be filled in by subtype
      this.svgBlock = null; // will be updated by updateSVGBlock()

      this.initializeState( renderer, instance ); // assumes we have a state mixin

      if ( this.usesPaint ) {
        if ( !this.paintState ) {
          this.paintState = new PaintSVGState();
        }
        else {
          this.paintState.initialize();
        }
      }

      return this; // allow chaining
    },

    // @public: called from elsewhere to update the SVG element
    update: function() {
      if ( this.dirty ) {
        this.dirty = false;
        this.updateSVG();
      }
    },

    // @protected: called to update the visual appearance of our svgElement
    updateSVG: function() {
      if ( this.paintDirty ) {
        this.updateSVGSelf( this.node, this.svgElement );
      }

      // sync the differences between the previously-recorded list of cached paints and the new list
      if ( this.usesPaint && this.dirtyCachedPaints ) {
        var newCachedPaints = this.node._cachedPaints.slice(); // defensive copy for now
        var i;
        var j;

        // scan for new cached paints (not in the old list)
        for ( i = 0; i < newCachedPaints.length; i++ ) {
          var newPaint = newCachedPaints[ i ];
          var isNew = true;
          for ( j = 0; j < this.lastCachedPaints.length; j++ ) {
            if ( newPaint === this.lastCachedPaints[ j ] ) {
              isNew = false;
              break;
            }
          }
          if ( isNew ) {
            this.svgBlock.incrementPaint( newPaint );
          }
        }
        // scan for removed cached paints (not in the new list)
        for ( i = 0; i < this.lastCachedPaints.length; i++ ) {
          var oldPaint = this.lastCachedPaints[ i ];
          var isRemoved = true;
          for ( j = 0; j < newCachedPaints.length; j++ ) {
            if ( oldPaint === newCachedPaints[ j ] ) {
              isRemoved = false;
              break;
            }
          }
          if ( isRemoved ) {
            this.svgBlock.decrementPaint( oldPaint );
          }
        }

        this.lastCachedPaints = newCachedPaints;
      }

      // clear all of the dirty flags
      this.setToCleanState();
    },

    // to be used by our passed in options.updateSVG
    updateFillStrokeStyle: function( element ) {
      if ( !this.usesPaint ) {
        return;
      }

      if ( this.dirtyFill ) {
        this.paintState.updateFill( this.svgBlock, this.node.getFillValue() );
      }
      if ( this.dirtyStroke ) {
        this.paintState.updateStroke( this.svgBlock, this.node.getStrokeValue() );
      }
      var strokeDetailDirty = this.dirtyLineWidth || this.dirtyLineOptions;
      if ( strokeDetailDirty ) {
        this.paintState.updateStrokeDetailStyle( this.node );
      }
      if ( this.dirtyFill || this.dirtyStroke || strokeDetailDirty ) {
        element.setAttribute( 'style', this.paintState.baseStyle + this.paintState.strokeDetailStyle );
      }

      this.cleanPaintableState();
    },

    updateSVGBlock: function( svgBlock ) {
      // remove cached paint references from the old svgBlock
      var oldSvgBlock = this.svgBlock;
      if ( this.usesPaint && oldSvgBlock ) {
        for ( var i = 0; i < this.lastCachedPaints.length; i++ ) {
          oldSvgBlock.decrementPaint( this.lastCachedPaints[ i ] );
        }
      }

      this.svgBlock = svgBlock;

      // add cached paint references from the new svgBlock
      if ( this.usesPaint ) {
        for ( var j = 0; j < this.lastCachedPaints.length; j++ ) {
          svgBlock.incrementPaint( this.lastCachedPaints[ j ] );
        }
      }

      this.updateDefsSelf && this.updateDefsSelf( svgBlock );

      this.usesPaint && this.paintState.updateSVGBlock( svgBlock );

      // since fill/stroke IDs may be block-specific, we need to mark them dirty so they will be updated
      this.usesPaint && this.markDirtyFill();
      this.usesPaint && this.markDirtyStroke();
    },

    dispose: function() {
      this.disposeState(); // assumes subtype existence

      if ( !this.keepElements ) {
        // clear the references
        this.svgElement = null;
      }

      // release any defs, and dispose composed state objects
      this.updateDefsSelf && this.updateDefsSelf( null );
      this.usesPaint && this.paintState.dispose();

      this.defs = null;

      this.svgBlock = null;

      SelfDrawable.prototype.dispose.call( this );
    }
  } );

  return SVGSelfDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * A mixin to drawables for nodes that mix in Paintable that need to store state about what the current display is
 * currently showing, so that updates to the node's fill/stroke will only be made on attributes that specifically
 * changed (and no change will be necessary for an attribute that changed back to its original/currently-displayed
 * value). Generally, this is used for DOM and SVG drawables.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/PaintableStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/PaintObserver','SCENERY/util/Color'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var PaintObserver = require( 'SCENERY/display/PaintObserver' );
  var Color = require( 'SCENERY/util/Color' );

  var PaintableStatefulDrawable = {
    /**
     * Given the type (constructor) of a drawable, we'll mix in a combination of:
     * - initialization/disposal with the *State suffix
     * - mark* methods to be called on all drawables of nodes of this type, that set specific dirty flags
     * @public (scenery-internal)
     *
     * This will allow drawables that mix in this type to do the following during an update:
     * 1. Check specific dirty flags (e.g. if the fill changed, update the fill of our SVG element).
     * 2. Call setToCleanState() once done, to clear the dirty flags.
     *
     * @param {function} drawableType - The constructor for the drawable type
     */
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      /**
       * Initializes the paintable part of the stateful mixin state, starting its "lifetime" until it is disposed with
       * disposePaintableState().
       * @protected
       *
       * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
       * @param {Instance} instance
       * @returns {PaintableStatefulDrawable} - Self reference for chaining
       */
      proto.initializePaintableState = function( renderer, instance ) {
        // @protected {boolean} - Whether the fill has changed since our last update.
        this.dirtyFill = true;

        // @protected {boolean} - Stores whether we last had a stroke.
        this.hadStroke = false;

        // @protected {boolean} - Whether the stroke has changed since our last update.
        this.dirtyStroke = true;

        // @protected {boolean} - Whether the lineWidth has changed since our last update.
        this.dirtyLineWidth = true;

        // @protected {boolean} - Whether the line options (cap, join, dash, dashoffset, miterlimit) have changed since
        //                        our last update.
        this.dirtyLineOptions = true;

        // @protected {boolean} - Whether the cached paints has changed since our last update.
        this.dirtyCachedPaints = true;

        // @protected {Array.<null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern>}
        // Stores the last seen cached paints, so we can update our listeners/etc.
        this.lastCachedPaints = [];

        // @private {function} - Callback for when the fill is marked as dirty
        this.fillCallback = this.fillCallback || this.markDirtyFill.bind( this );

        // @private {function} - Callback for when the stroke is marked as dirty
        this.strokeCallback = this.strokeCallback || this.markDirtyStroke.bind( this );

        // @private {PaintObserver} - Observers the fill property for nodes
        this.fillObserver = this.fillObserver || new PaintObserver( 'fill', this.fillCallback );

        // @private {PaintObserver} - Observers the stroke property for nodes
        this.strokeObserver = this.strokeObserver || new PaintObserver( 'stroke', this.strokeCallback );

        // Hook up our fill/stroke observers to this node
        this.fillObserver.initialize( instance.node );
        this.strokeObserver.initialize( instance.node );

        return this;
      };

      /**
       * Cleans the dirty-flag states to the 'not-dirty' option, so that we can listen for future changes.
       * @protected
       */
      proto.cleanPaintableState = function() {
        // TODO: is this being called when we need it to be called?
        this.dirtyFill = false;

        this.dirtyStroke = false;
        this.dirtyLineWidth = false;
        this.dirtyLineOptions = false;
        this.dirtyCachedPaints = false;
        this.hadStroke = this.node.getStroke() !== null;
      };

      /**
       * Disposes the paintable stateful mixin state, so it can be put into the pool to be initialized again.
       * @protected
       */
      proto.disposePaintableState = function() {
        this.fillObserver.clean();
        this.strokeObserver.clean();
      };

      /**
       * Called when the fill of the paintable node changes.
       * @public (scenery-internal)
       */
      proto.markDirtyFill = function() {
        assert && Color.checkPaint( this.instance.node._fill );

        this.dirtyFill = true;
        this.markPaintDirty();
        this.fillObserver.updatePrimary(); // TODO: look into having the fillObserver be notified of Node changes as our source
      };

      /**
       * Called when the stroke of the paintable node changes.
       * @public (scenery-internal)
       */
      proto.markDirtyStroke = function() {
        assert && Color.checkPaint( this.instance.node._stroke );

        this.dirtyStroke = true;
        this.markPaintDirty();
        this.strokeObserver.updatePrimary(); // TODO: look into having the strokeObserver be notified of Node changes as our source
      };

      /**
       * Called when the lineWidth of the paintable node changes.
       * @public (scenery-internal)
       */
      proto.markDirtyLineWidth = function() {
        this.dirtyLineWidth = true;
        this.markPaintDirty();
      };

      /**
       * Called when the line options (lineWidth/lineJoin, etc) of the paintable node changes.
       * @public (scenery-internal)
       */
      proto.markDirtyLineOptions = function() {
        this.dirtyLineOptions = true;
        this.markPaintDirty();
      };

      /**
       * Called when the cached paints of the paintable node changes.
       * @public (scenery-internal)
       */
      proto.markDirtyCachedPaints = function() {
        this.dirtyCachedPaints = true;
        this.markPaintDirty();
      };
    }
  };

  scenery.register( 'PaintableStatefulDrawable', PaintableStatefulDrawable );

  return PaintableStatefulDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * A mixin to drawables for Path that need to store state about what the current display is currently showing,
 * so that updates to the Path will only be made on attributes that specifically changed (and no change will be
 * necessary for an attribute that changed back to its original/currently-displayed value). Generally, this is used
 * for DOM and SVG drawables.
 *
 * This mixin assumes the PaintableStateful mixin is also mixed (always the case for Path stateful drawables).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/PathStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );

  var PathStatefulDrawable = {
    /**
     * Given the type (constructor) of a drawable, we'll mix in a combination of:
     * - initialization/disposal with the *State suffix
     * - mark* methods to be called on all drawables of nodes of this type, that set specific dirty flags
     *
     * This will allow drawables that mix in this type to do the following during an update:
     * 1. Check specific dirty flags (e.g. if the fill changed, update the fill of our SVG element).
     * 2. Call setToCleanState() once done, to clear the dirty flags.
     *
     * @param {function} drawableType - The constructor for the drawable type
     */
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      /**
       * Initializes the stateful mixin state, starting its "lifetime" until it is disposed with disposeState().
       * @protected
       *
       * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
       * @param {Instance} instance
       * @returns {PathStatefulDrawable} - Returns 'this' reference, for chaining
       */
      proto.initializeState = function( renderer, instance ) {
        // @protected {boolean} - Flag marked as true if ANY of the drawable dirty flags are set (basically everything except for transforms, as we
        //                        need to accelerate the transform case.
        this.paintDirty = true;
        this.dirtyShape = true;

        // After adding flags, we'll initialize the mixed-in PaintableStateful state.
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      /**
       * Disposes the stateful mixin state, so it can be put into the pool to be initialized again.
       * @protected
       */
      proto.disposeState = function() {
        this.disposePaintableState();
      };

      /**
       * A "catch-all" dirty method that directly marks the paintDirty flag and triggers propagation of dirty
       * information. This can be used by other mark* methods, or directly itself if the paintDirty flag is checked.
       * @public (scenery-internal)
       *
       * It should be fired (indirectly or directly) for anything besides transforms that needs to make a drawable
       * dirty.
       */
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyShape = function() {
        this.dirtyShape = true;
        this.markPaintDirty();
      };

      /**
       * Clears all of the dirty flags (after they have been checked), so that future mark* methods will be able to flag them again.
       * @public (scenery-internal)
       */
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyShape = false;
      };

      PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  scenery.register( 'PathStatefulDrawable', PathStatefulDrawable );

  return PathStatefulDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * SVG drawable for Path nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/PathSVGDrawable',['require','PHET_CORE/inherit','PHET_CORE/platform','SCENERY/scenery','SCENERY/display/SVGSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PathStatefulDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PathStatefulDrawable = require( 'SCENERY/display/drawables/PathStatefulDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepSVGPathElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  /**
   * A generated SVGSelfDrawable whose purpose will be drawing our Path. One of these drawables will be created
   * for each displayed instance of a Path.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function PathSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'PathSVGDrawable', PathSVGDrawable );

  inherit( SVGSelfDrawable, PathSVGDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {PathSVGDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGPathElements ); // usesPaint: true

      // @protected {SVGPathElement} - Sole SVG element for this drawable, implementing API for SVGSelfDrawable
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'path' );

      return this;
    },

    /**
     * Updates the SVG elements so that they will appear like the current node's representation.
     * @protected
     *
     * Implements the interface for SVGSelfDrawable (and is called from the SVGSelfDrawable's update).
     */
    updateSVGSelf: function() {
      assert && assert( !this.node.requiresSVGBoundsWorkaround(),
        'No workaround for https://github.com/phetsims/scenery/issues/196 is provided at this time, please add an epsilon' );

      var path = this.svgElement;
      if ( this.dirtyShape ) {
        var svgPath = this.node.hasShape() ? this.node._shape.getSVGPath() : '';

        // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980
        // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing
        // the attribute can cause this bug
        if ( !svgPath ) { svgPath = 'M0 0'; }

        // only set the SVG path if it's not the empty string

        // We'll conditionally add another M0 0 to the end of the path if we're on Safari, we're running into a bug in
        // https://github.com/phetsims/gravity-and-orbits/issues/472 (debugged in
        // https://github.com/phetsims/geometric-optics-basics/issues/31) where we're getting artifacts.
        path.setAttribute( 'd', svgPath + ( platform.safari ? ' M0 0' : '' ) );
      }

      // Apply any fill/stroke changes to our element.
      this.updateFillStrokeStyle( path );
    }
  } );

  PathStatefulDrawable.mixin( PathSVGDrawable );

  // This sets up PathSVGDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( PathSVGDrawable );

  return PathSVGDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * A Path draws a Shape with a specific type of fill and stroke. Mixes in Paintable.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Path',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','KITE/Shape','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/nodes/Paintable','SCENERY/display/drawables/PathCanvasDrawable','SCENERY/display/drawables/PathSVGDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );
  var PathCanvasDrawable = require( 'SCENERY/display/drawables/PathCanvasDrawable' );
  var PathSVGDrawable = require( 'SCENERY/display/drawables/PathSVGDrawable' );

  var PATH_OPTION_KEYS = [
    'boundsMethod', // Sets how bounds are determined, see setBoundsMethod() for more documentation.
    'shape' // Sets the shape of the Path, see  setShape() for more documentation.
  ];

  var DEFAULT_OPTIONS = {
    shape: null,
    boundsMethod: 'accurate'
  };

  /**
   * Creates a Path with a given shape specifier (a Shape, a string in the SVG path format, or null to indicate no
   * shape).
   * @public
   * @constructor
   * @extends Node
   * @mixes Paintable
   *
   * Path has two additional options (above what Node provides):
   * - shape: The actual Shape (or a string representing an SVG path, or null).
   * - boundsMethod: Determines how the bounds of a shape are determined.
   *
   * @param {Shape|string|null} shape - The initial Shape to display. See setShape() for more details and documentation.
   * @param {Object} [options] - Path-specific options are documented in PATH_OPTION_KEYS above, and can be provided
   *                             along-side options for Node
   */
  function Path( shape, options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );

    // @private {Shape|null} - The Shape used for displaying this Path.
    // NOTE: _shape can be lazily constructed in subtypes (may be null) if hasShape() is overridden to retun true,
    //       like in Rectangle. This is because usually the actual Shape is already implied by other parameters,
    //       so it is best to not have to compute it on changes.
    // NOTE: Please use hasShape() to determine if we are actually drawing things, as it is subtype-safe.
    this._shape = DEFAULT_OPTIONS.shape;

    // @private {Shape|null}
    // This stores a stroked copy of the Shape which is lazily computed. This can be required for computing bounds
    // of a Shape with a stroke.
    this._strokedShape = null;

    // @private {string}, one of 'accurate', 'unstroked', 'tightPadding', 'safePadding', 'none', see setBoundsMethod()
    this._boundsMethod = DEFAULT_OPTIONS.boundsMethod;

    // @private {Function}, called with no arguments, return value not checked.
    // Used as a listener to Shapes for when they are invalidated. The listeners are not added if the Shape is
    // immutable, and if the Shape becomes immutable, then the listeners are removed.
    this._invalidShapeListener = this.invalidateShape.bind( this );

    // @private {boolean} Whether our shape listener is attached to a shape.
    this._invalidShapeListenerAttached = false;

    this.initializePaintable();

    Node.call( this );

    this.invalidateSupportedRenderers();

    options = extendDefined( {
      shape: shape
    }, options );

    this.mutate( options );
  }

  scenery.register( 'Path', Path );

  inherit( Node, Path, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: PATH_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),

    /**
     * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
     *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
     *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
     * @public (scenery-internal)
     * @override
     */
    drawableMarkFlags: Node.prototype.drawableMarkFlags.concat( [ 'shape' ] ),

    /**
     * This sets the shape of the Path, which determines the shape of its appearance. It should generally not be called
     * on Path subtypes like Line, Rectangle, etc.
     * @public
     *
     * NOTE: When you create a Path with a shape in the constructor, this function will be called.
     *
     * The valid parameter types are:
     * - Shape: (from Kite), normally used.
     * - string: Uses the SVG Path format, see https://www.w3.org/TR/SVG/paths.html (the PATH part of <path d="PATH"/>).
     *           This will immediately be converted to a Shape object, and getShape() or equivalents will return the new
     *           Shape object instead of the original string.
     * - null: Indicates that there is no Shape, and nothing is drawn. Usually used as a placeholder.
     *
     * NOTE: Be aware of the potential for memory leaks. If a Shape is not marked as immutable (with makeImmutable()),
     *       Path will add a listener so that it is updated when the Shape itself changes. If there is a listener
     *       added, keeping a reference to the Shape will also keep a reference to the Path object (and thus whatever
     *       Nodes are connected to the Path). For now, set path.shape = null if you need to release the reference
     *       that the Shape would have, or call dispose() on the Path if it is not needed anymore.
     *
     * @param {Shape|string|null} shape
     * @returns {Path} - Returns 'this' reference, for chaining
     */
    setShape: function( shape ) {
      assert && assert( shape === null || typeof shape === 'string' || shape instanceof Shape,
        'A path\'s shape should either be null, a string, or a Shape' );

      if ( this._shape !== shape ) {
        // Remove Shape invalidation listener if applicable
        if ( this._invalidShapeListenerAttached ) {
          this.detachShapeListener();
        }

        if ( typeof shape === 'string' ) {
          // be content with setShape always invalidating the shape?
          shape = new Shape( shape );
        }
        this._shape = shape;
        this.invalidateShape();

        // Add Shape invalidation listener if applicable
        if ( this._shape && !this._shape.isImmutable() ) {
          this.attachShapeListener();
        }
      }
      return this;
    },
    set shape( value ) { this.setShape( value ); },

    /**
     * Returns the shape that was set for this Path (or for subtypes like Line and Rectangle, will return an immutable
     * Shape that is equivalent in appearance).
     * @public
     *
     * It is best to generally assume modifications to the Shape returned is not supported. If there is no shape
     * currently, null will be returned.
     *
     * @returns {Shape|null}
     */
    getShape: function() {
      return this._shape;
    },
    get shape() { return this.getShape(); },

    /**
     * Returns a lazily-created Shape that has the appearance of the Path's shape but stroked using the current
     * stroke style of the Path.
     * @public
     *
     * NOTE: It is invalid to call this on a Path that does not currently have a Shape (usually a Path where
     *       the shape is set to null).
     *
     * @returns {Shape}
     */
    getStrokedShape: function() {
      assert && assert( this.hasShape(), 'We cannot stroke a non-existing shape' );

      // Lazily compute the stroked shape. It should be set to null when we need to recompute it
      if ( !this._strokedShape ) {
        this._strokedShape = this.getShape().getStrokedShape( this._lineDrawingStyles );
      }

      return this._strokedShape;
    },

    /**
     * Returns a bitmask representing the supported renderers for the current configuration of the Path or subtype.
     * @protected
     *
     * Should be overridden by subtypes to either extend or restrict renderers, depending on what renderers are
     * supported.
     *
     * @returns {number} - A bitmask that includes supported renderers, see Renderer for details.
     */
    getPathRendererBitmask: function() {
      // By default, Canvas and SVG are accepted.
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG;
    },

    /**
     * Triggers a check and update for what renderers the current configuration of this Path or subtype supports.
     * This should be called whenever something that could potentially change supported renderers happen (which can
     * be the shape, properties of the strokes or fills, etc.)
     * @public
     */
    invalidateSupportedRenderers: function() {
      this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getPathRendererBitmask() );
    },

    /**
     * Notifies the Path that the Shape has changed (either the Shape itself has be mutated, a new Shape has been
     * provided).
     * @private
     *
     * NOTE: This should not be called on subtypes of Path after they have been constructed, like Line, Rectangle, etc.
     */
    invalidateShape: function() {
      this.invalidatePath();

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyShape(); // subtypes of Path may not have this, but it's called during construction
      }

      // Disconnect our Shape listener if our Shape has become immutable.
      // see https://github.com/phetsims/sun/issues/270#issuecomment-250266174
      if ( this._invalidShapeListenerAttached && this._shape && this._shape.isImmutable() ) {
        this.detachShapeListener();
      }
    },

    /**
     * Invalidates the node's self-bounds and any other recorded metadata about the outline or bounds of the Shape.
     * @protected
     *
     * This is meant to be used for all Path subtypes (unlike invalidateShape).
     */
    invalidatePath: function() {
      this._strokedShape = null;

      this.invalidateSelf(); // We don't immediately compute the bounds
    },

    /**
     * Attaches a listener to our Shape that will be called whenever the Shape changes.
     * @private
     */
    attachShapeListener: function() {
      assert && assert( !this._invalidShapeListenerAttached, 'We do not want to have two listeners attached!' );

      // Do not attach shape listeners if we are disposed
      if ( !this._isDisposed ) {
        this._shape.onStatic( 'invalidated', this._invalidShapeListener );
        this._invalidShapeListenerAttached = true;
      }
    },

    /**
     * Detaches a previously-attached listener added to our Shape (see attachShapeListener).
     * @private
     */
    detachShapeListener: function() {
      assert && assert( this._invalidShapeListenerAttached, 'We cannot detach an unattached listener' );

      this._shape.offStatic( 'invalidated', this._invalidShapeListener );
      this._invalidShapeListenerAttached = false;
    },

    /**
     * Computes a more efficient selfBounds for our Path.
     * @protected
     * @override
     *
     * @returns {boolean} - Whether the self bounds changed.
     */
    updateSelfBounds: function() {
      var selfBounds = this.hasShape() ? this.computeShapeBounds() : Bounds2.NOTHING;
      var changed = !selfBounds.equals( this._selfBounds );
      if ( changed ) {
        this._selfBounds.set( selfBounds );
      }
      return changed;
    },

    /**
     * Sets the bounds method for the Path. This determines how our (self) bounds are computed, and can particularly
     * determine how expensive to compute our bounds are if we have a stroke.
     * @public
     *
     * There are the following options:
     * - 'accurate' - Always uses the most accurate way of getting bounds. Computes the exact stroked bounds.
     * - 'unstroked' - Ignores any stroke, just gives the filled bounds.
     *                 If there is a stroke, the bounds will be marked as inaccurate
     * - 'tightPadding' - Pads the filled bounds by enough to cover everything except mitered joints.
     *                     If there is a stroke, the bounds wil be marked as inaccurate.
     * - 'safePadding' - Pads the filled bounds by enough to cover all line joins/caps.
     * - 'none' - Returns Bounds2.NOTHING. The bounds will be marked as inaccurate.
     *
     * @param {string} boundsMethod - one of 'accurate', 'unstroked', 'tightPadding', 'safePadding' or 'none'
     * @returns {Path} - Returns 'this' reference, for chaining
     */
    setBoundsMethod: function( boundsMethod ) {
      assert && assert( boundsMethod === 'accurate' ||
                        boundsMethod === 'unstroked' ||
                        boundsMethod === 'tightPadding' ||
                        boundsMethod === 'safePadding' ||
                        boundsMethod === 'none' );
      if ( this._boundsMethod !== boundsMethod ) {
        this._boundsMethod = boundsMethod;
        this.invalidatePath();

        this.trigger0( 'boundsMethod' );

        this.trigger0( 'selfBoundsValid' ); // whether our self bounds are valid may have changed
      }
      return this;
    },
    set boundsMethod( value ) { return this.setBoundsMethod( value ); },

    /**
     * Returns the curent bounds method. See setBoundsMethod for details.
     * @public
     *
     * @returns {string}
     */
    getBoundsMethod: function() {
      return this._boundsMethod;
    },
    get boundsMethod() { return this.getBoundsMethod(); },

    /**
     * Computes the bounds of the Path (or subtype when overridden). Meant to be overridden in subtypes for more
     * efficient bounds computations (but this will work as a fallback). Includes the stroked region if there is a
     * stroke applied to the Path.
     * @public
     *
     * @returns {Bounds2}
     */
    computeShapeBounds: function() {
      // boundsMethod: 'none' will return no bounds
      if ( this._boundsMethod === 'none' ) {
        return Bounds2.NOTHING;
      }
      else {
        // boundsMethod: 'unstroked', or anything without a stroke will then just use the normal shape bounds
        if ( !this.hasPaintableStroke() || this._boundsMethod === 'unstroked' ) {
          return this.getShape().bounds;
        }
        else {
          // 'accurate' will always require computing the full stroked shape, and taking its bounds
          if ( this._boundsMethod === 'accurate' ) {
            return this.getShape().getStrokedBounds( this.getLineStyles() );
          }
          // Otherwise we compute bounds based on 'tightPadding' and 'safePadding', the one difference being that
          // 'safePadding' will include whatever bounds necessary to include miters. Square line-cap requires a
          // slightly extended bounds in either case.
          else {
            var factor;
            // If miterLength (inside corner to outside corner) exceeds miterLimit * strokeWidth, it will get turned to
            // a bevel, so our factor will be based just on the miterLimit.
            if ( this._boundsMethod === 'safePadding' && this.getLineJoin() === 'miter' ) {
              factor = this.getMiterLimit();
            }
            else if ( this.getLineCap() === 'square' ) {
              factor = Math.SQRT2;
            }
            else {
              factor = 1;
            }
            return this.getShape().bounds.dilated( factor * this.getLineWidth() / 2 );
          }
        }
      }
    },

    /**
     * Whether this Node's selfBounds are considered to be valid (always containing the displayed self content
     * of this node). Meant to be overridden in subtypes when this can change (e.g. Text).
     * @public
     * @override
     *
     * If this value would potentially change, please trigger the event 'selfBoundsValid'.
     *
     * @returns {boolean}
     */
    areSelfBoundsValid: function() {
      if ( this._boundsMethod === 'accurate' || this._boundsMethod === 'safePadding' ) {
        return true;
      }
      else if ( this._boundsMethod === 'none' ) {
        return false;
      }
      else {
        return !this.hasStroke(); // 'tightPadding' and 'unstroked' options
      }
    },

    /**
     * Returns our self bounds when our rendered self is transformed by the matrix.
     * @public
     * @override
     *
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    getTransformedSelfBounds: function( matrix ) {
      return ( this._stroke ? this.getStrokedShape() : this.getShape() ).getBoundsWithTransform( matrix );
    },

    /**
     * Called from (and overridden in) the Paintable mixin, invalidates our current stroke, triggering recomputation of
     * anything that depended on the old stroke's value.
     * @protected (scenery-internal)
     */
    invalidateStroke: function() {
      this.invalidatePath();
      this.trigger0( 'selfBoundsValid' ); // Stroke changing could have changed our self-bounds-validitity (unstroked/etc)
    },

    /**
     * Returns whether this Path has an associated Shape (instead of no shape, represented by null)
     * @public
     *
     * @returns {boolean}
     */
    hasShape: function() {
      return !!this._shape;
    },

    /**
     * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
     * coordinate frame of this node.
     * @protected
     * @override
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} matrix - The transformation matrix already applied to the context.
     */
    canvasPaintSelf: function( wrapper, matrix ) {
      //TODO: Have a separate method for this, instead of touching the prototype. Can make 'this' references too easily.
      PathCanvasDrawable.prototype.paintCanvas( wrapper, this, matrix );
    },

    /**
     * Creates a SVG drawable for this Path.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {SVGSelfDrawable}
     */
    createSVGDrawable: function( renderer, instance ) {
      return PathSVGDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a Canvas drawable for this Path.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {CanvasSelfDrawable}
     */
    createCanvasDrawable: function( renderer, instance ) {
      return PathCanvasDrawable.createFromPool( renderer, instance );
    },

    /**
     * Whether this Node itself is painted (displays something itself).
     * @public
     * @override
     *
     * @returns {boolean}
     */
    isPainted: function() {
      // Always true for Path nodes
      return true;
    },

    /**
     * Computes whether the provided point is "inside" (contained) in this Path's self content, or "outside".
     * @protected
     * @override
     *
     * @param {Vector2} point - Considered to be in the local coordinate frame
     * @returns {boolean}
     */
    containsPointSelf: function( point ) {
      var result = false;
      if ( !this.hasShape() ) {
        return result;
      }

      // if this node is fillPickable, we will return true if the point is inside our fill area
      if ( this._fillPickable ) {
        result = this.getShape().containsPoint( point );
      }

      // also include the stroked region in the hit area if strokePickable
      if ( !result && this._strokePickable ) {
        result = this.getStrokedShape().containsPoint( point );
      }
      return result;
    },

    /**
     * Returns whether this Path's selfBounds is intersected by the specified bounds.
     * @public
     *
     * @param {Bounds2} bounds - Bounds to test, assumed to be in the local coordinate frame.
     * @returns {boolean}
     */
    intersectsBoundsSelf: function( bounds ) {
      // TODO: should a shape's stroke be included?
      return this.hasShape() ? this._shape.intersectsBounds( bounds ) : false;
    },

    /**
     * Returns whether we need to apply a transform workaround for https://github.com/phetsims/scenery/issues/196, which
     * only applies when we have a pattern or gradient (e.g. subtypes of Paint).
     * @private
     *
     * @returns {boolean}
     */
    requiresSVGBoundsWorkaround: function() {
      if ( !this._stroke || !this._stroke.isPaint || !this.hasShape() ) {
        return false;
      }

      var bounds = this.computeShapeBounds();
      return bounds.x * bounds.y === 0; // at least one of them was zero, so the bounding box has no area
    },

    /**
     * Override for extra information in the debugging output (from Display.getDebugHTML()).
     * @protected (scenery-internal)
     * @override
     *
     * @returns {string}
     */
    getDebugHTMLExtras: function() {
      return this._shape ? ' (<span style="color: #88f" onclick="window.open( \'data:text/plain;charset=utf-8,\' + encodeURIComponent( \'' + this._shape.getSVGPath() + '\' ) );">path</span>)' : '';
    },

    /**
     * Disposes the path, releasing shape listeners if needed (and preventing new listeners from being added).
     * @public
     * @override
     */
    dispose: function() {
      if ( this._invalidShapeListenerAttached ) {
        this.detachShapeListener();
      }

      Node.prototype.dispose.call( this );
    }
  } );

  // @public {Object} - Initial values for most Node mutator options
  Path.DEFAULT_OPTIONS = _.extend( {}, Node.DEFAULT_OPTIONS, DEFAULT_OPTIONS );

  // mix in support for fills and strokes
  Paintable.mixin( Path );

  return Path;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Creates the namespace for this repository.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */
define( 'SUN/sun',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  // modules
  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'sun' );
} );
// Copyright 2013-2015, University of Colorado Boulder

//TODO see sun#29, reimplement as a subtype of something from sun.buttons
/**
 * Button for expanding/collapsing something.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/ExpandCollapseButton',['require','SCENERY/input/ButtonListener','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','KITE/Shape','SUN/sun','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Property.<boolean>} expandedProperty
   * @param {Object} [options]
   * @constructor
   */
  function ExpandCollapseButton( expandedProperty, options ) {

    options = _.extend( {
      sideLength: 25,  // length of one side of the square button
      tandem: Tandem.tandemRequired()
    }, options );

    Node.call( this );

    // configure the button shape
    var cornerRadius = 0.1 * options.sideLength;
    var buttonShape = Shape.roundRectangle( 0, 0, options.sideLength, options.sideLength, cornerRadius, cornerRadius );

    // configure the +/- symbol on the button
    var symbolLength = 0.6 * options.sideLength;
    var symbolLineWidth = 0.15 * options.sideLength;
    var symbolOptions = {
      lineWidth: symbolLineWidth,
      stroke: 'white',
      centerX: options.sideLength / 2,
      centerY: options.sideLength / 2,
      pickable: false
    };

    // Expand '+' button
    var expandButton = new Path( buttonShape, {
      fill: 'rgb(0, 179, 0 )',
      stroke: 'black',
      lineWidth: 0.5,
      tandem: options.tandem.createTandem( 'expandButton' )
    } );
    var plusSymbolShape = new Shape()
      .moveTo( symbolLength / 2, 0 )
      .lineTo( symbolLength / 2, symbolLength )
      .moveTo( 0, symbolLength / 2 )
      .lineTo( symbolLength, symbolLength / 2 );
    expandButton.addChild( new Path(
      plusSymbolShape,
      _.extend( { tandem: options.tandem.createTandem( 'plusSymbol' ) }, symbolOptions )
    ) );

    // Collapse '-' button
    var collapseButton = new Path( buttonShape, {
      fill: 'rgb( 255, 85, 0 )',
      stroke: 'black',
      lineWidth: 0.5,
      tandem: options.tandem.createTandem( 'collapseButton' )
    } );
    var minusSymbolShape = new Shape()
      .moveTo( -symbolLength / 2, 0 )
      .lineTo( symbolLength / 2, 0 );
    collapseButton.addChild( new Path(
      minusSymbolShape,
      _.extend( { tandem: options.tandem.createTandem( 'minusSymbol' ) }, symbolOptions )
    ) );

    // rendering order
    this.addChild( expandButton );
    this.addChild( collapseButton );

    // click to toggle
    this.cursor = 'pointer';
    this.addInputListener( new ButtonListener( {
      fire: function() {
        expandedProperty.set( !expandedProperty.get() );
      },
      tandem: options.tandem.createTandem( 'buttonListener' )
    } ) );

    // @private
    this.expandedPropertyObserver = function( expanded ) {
      expandButton.visible = !expanded;
      collapseButton.visible = expanded;
    };
    this.expandedProperty = expandedProperty; // @private
    this.expandedProperty.link( this.expandedPropertyObserver ); // must be unlinked in dispose

    this.mutate( options );
  }

  sun.register( 'ExpandCollapseButton', ExpandCollapseButton );

  return inherit( Node, ExpandCollapseButton, {

    // @public - Ensures that this node is eligible for GC.
    dispose: function() {
      this.expandedProperty.unlink( this.expandedPropertyObserver );
      Node.prototype.dispose.call( this );
    }
  } );
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Canvas drawable for Rectangle nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/RectangleCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );

  /**
   * A generated CanvasSelfDrawable whose purpose will be drawing our Rectangle. One of these drawables will be created
   * for each displayed instance of a Rectangle.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function RectangleCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'RectangleCanvasDrawable', RectangleCanvasDrawable );

  inherit( CanvasSelfDrawable, RectangleCanvasDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {RectangleCanvasDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    /**
     * Convenience function for drawing a rectangular path (with our Rectangle node's parameters) to the Canvas context.
     * @private
     *
     * @param {CanvasRenderingContext2D} context - To execute drawing commands on.
     * @param {Node} node - The node whose rectangle we want to draw
     */
    writeRectangularPath: function( context, node ) {
      context.beginPath();
      context.moveTo( node._rectX, node._rectY );
      context.lineTo( node._rectX + node._rectWidth, node._rectY );
      context.lineTo( node._rectX + node._rectWidth, node._rectY + node._rectHeight );
      context.lineTo( node._rectX, node._rectY + node._rectHeight );
      context.closePath();
    },

    /**
     * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
     * @public
     *
     * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
     * other required effects (opacity, clipping, etc.) have already been prepared.
     *
     * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
     *
     * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
     * @param {Node} node - Our node that is being drawn
     * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
     */
    paintCanvas: function( wrapper, node, matrix ) {
      var context = wrapper.context;

      // use the standard version if it's a rounded rectangle, since there is no Canvas-optimized version for that
      if ( node.isRounded() ) {
        context.beginPath();
        var maximumArcSize = node.getMaximumArcSize();
        var arcw = Math.min( node._cornerXRadius, maximumArcSize );
        var arch = Math.min( node._cornerYRadius, maximumArcSize );
        var lowX = node._rectX + arcw;
        var highX = node._rectX + node._rectWidth - arcw;
        var lowY = node._rectY + arch;
        var highY = node._rectY + node._rectHeight - arch;
        if ( arcw === arch ) {
          // we can use circular arcs, which have well defined stroked offsets
          context.arc( highX, lowY, arcw, -Math.PI / 2, 0, false );
          context.arc( highX, highY, arcw, 0, Math.PI / 2, false );
          context.arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false );
          context.arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false );
        }
        else {
          // we have to resort to elliptical arcs
          context.ellipse( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false );
          context.ellipse( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false );
          context.ellipse( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false );
          context.ellipse( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false );
        }
        context.closePath();

        if ( node.hasFill() ) {
          node.beforeCanvasFill( wrapper ); // defined in Paintable
          context.fill();
          node.afterCanvasFill( wrapper ); // defined in Paintable
        }
        if ( node.hasPaintableStroke() ) {
          node.beforeCanvasStroke( wrapper ); // defined in Paintable
          context.stroke();
          node.afterCanvasStroke( wrapper ); // defined in Paintable
        }
      }
      else {
        // TODO: how to handle fill/stroke delay optimizations here?
        if ( node.hasFill() ) {
          // If we need the fill pattern/gradient to have a different transformation, we can't use fillRect.
          // See https://github.com/phetsims/scenery/issues/543
          if ( node.getFillValue().transformMatrix ) {
            this.writeRectangularPath( context, node );
            node.beforeCanvasFill( wrapper ); // defined in Paintable
            context.fill();
            node.afterCanvasFill( wrapper ); // defined in Paintable
          }
          else {
            node.beforeCanvasFill( wrapper ); // defined in Paintable
            context.fillRect( node._rectX, node._rectY, node._rectWidth, node._rectHeight );
            node.afterCanvasFill( wrapper ); // defined in Paintable
          }
        }
        if ( node.hasPaintableStroke() ) {
          // If we need the fill pattern/gradient to have a different transformation, we can't use fillRect.
          // See https://github.com/phetsims/scenery/issues/543
          if ( node.getStrokeValue().transformMatrix ) {
            this.writeRectangularPath( context, node );
            node.beforeCanvasStroke( wrapper ); // defined in Paintable
            context.stroke();
            node.afterCanvasStroke( wrapper ); // defined in Paintable
          }
          else {
            node.beforeCanvasStroke( wrapper ); // defined in Paintable
            context.strokeRect( node._rectX, node._rectY, node._rectWidth, node._rectHeight );
            node.afterCanvasStroke( wrapper ); // defined in Paintable
          }
        }
      }
    },

    // stateless dirty functions
    markDirtyRectangle: function() { this.markPaintDirty(); },

    // TODO: stateless drawable handling!
    markDirtyX: function() {
      this.markDirtyRectangle();
    },
    markDirtyY: function() {
      this.markDirtyRectangle();
    },
    markDirtyWidth: function() {
      this.markDirtyRectangle();
    },
    markDirtyHeight: function() {
      this.markDirtyRectangle();
    },
    markDirtyCornerXRadius: function() {
      this.markDirtyRectangle();
    },
    markDirtyCornerYRadius: function() {
      this.markDirtyRectangle();
    },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );

  PaintableStatelessDrawable.mixin( RectangleCanvasDrawable );

  // This sets up RectangleCanvasDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( RectangleCanvasDrawable );

  return RectangleCanvasDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * DOM drawable for a single painted node.
 *
 * Subtypes should expose the following API that is used by DOMSelfDrawable:
 * - drawable.domElement {HTMLElement} - The primary DOM element that will get transformed and added.
 * - drawable.updateDOM() {function} - Called with no arguments in order to update the domElement's view.
 *
 * TODO: make abstract subtype methods for improved documentation
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/DOMSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/display/Renderer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  require( 'SCENERY/display/Renderer' );

  function DOMSelfDrawable( renderer, instance ) {
    this.initializeDOMSelfDrawable( renderer, instance );

    throw new Error( 'Should use initialization and pooling' );
  }

  scenery.register( 'DOMSelfDrawable', DOMSelfDrawable );

  inherit( SelfDrawable, DOMSelfDrawable, {
    initializeDOMSelfDrawable: function( renderer, instance ) {
      // this is the same across lifecycles
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );

      // super initialization
      this.initializeSelfDrawable( renderer, instance );

      this.forceAcceleration = false; // TODO: for now, check to see if this is used and how to use it
      this.markTransformDirty();

      this.visibilityDirty = true;

      // handle transform changes
      instance.relativeTransform.addListener( this.transformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
      instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated

      return this;
    },

    markTransformDirty: function() {
      // update the visual state available to updateDOM, so that it will update the transform (Text needs to change the transform, so it is included)
      this.transformDirty = true;

      this.markDirty();
    },

    // called from the Node, probably during updateDOM
    getTransformMatrix: function() {
      this.instance.relativeTransform.validate();
      return this.instance.relativeTransform.matrix;
    },

    // called from elsewhere to update the DOM element
    update: function() {
      if ( this.dirty ) {
        this.dirty = false;
        this.updateDOM();

        if ( this.visibilityDirty ) {
          this.visibilityDirty = false;

          this.domElement.style.visibility = this.visible ? '' : 'hidden';
        }

        this.cleanPaintableState && this.cleanPaintableState();
      }
    },

    // @protected: called to update the visual appearance of our domElement
    updateDOM: function() {
      // should generally be overridden by drawable subtypes to implement the update
    },

    // @override
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );

      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },

    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();

      // super call
      SelfDrawable.prototype.dispose.call( this );
    }
  } );

  return DOMSelfDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * A mixin to drawables for Rectangle that need to store state about what the current display is currently showing,
 * so that updates to the Rectangle will only be made on attributes that specifically changed (and no change will be
 * necessary for an attribute that changed back to its original/currently-displayed value). Generally, this is used
 * for DOM and SVG drawables.
 *
 * This mixin assumes the PaintableStateful mixin is also mixed (always the case for Rectangle stateful drawables).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/RectangleStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );

  var RectangleStatefulDrawable = {
    /**
     * Given the type (constructor) of a drawable, we'll mix in a combination of:
     * - initialization/disposal with the *State suffix
     * - mark* methods to be called on all drawables of nodes of this type, that set specific dirty flags
     *
     * This will allow drawables that mix in this type to do the following during an update:
     * 1. Check specific dirty flags (e.g. if the fill changed, update the fill of our SVG element).
     * 2. Call setToCleanState() once done, to clear the dirty flags.
     *
     * @param {function} drawableType - The constructor for the drawable type
     */
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      /**
       * Initializes the stateful mixin state, starting its "lifetime" until it is disposed with disposeState().
       * @protected
       *
       * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
       * @param {Instance} instance
       * @returns {RectangleStatefulDrawable} - Returns 'this' reference, for chaining
       */
      proto.initializeState = function( renderer, instance ) {
        // @protected {boolean} - Flag marked as true if ANY of the drawable dirty flags are set (basically everything except for transforms, as we
        //                        need to accelerate the transform case.
        this.paintDirty = true;
        this.dirtyX = true;
        this.dirtyY = true;
        this.dirtyWidth = true;
        this.dirtyHeight = true;
        this.dirtyCornerXRadius = true;
        this.dirtyCornerYRadius = true;

        // After adding flags, we'll initialize the mixed-in PaintableStateful state.
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      /**
       * Disposes the stateful mixin state, so it can be put into the pool to be initialized again.
       * @protected
       */
      proto.disposeState = function() {
        this.disposePaintableState();
      };

      /**
       * A "catch-all" dirty method that directly marks the paintDirty flag and triggers propagation of dirty
       * information. This can be used by other mark* methods, or directly itself if the paintDirty flag is checked.
       * @public (scenery-internal)
       *
       * It should be fired (indirectly or directly) for anything besides transforms that needs to make a drawable
       * dirty.
       */
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyRectangle = function() {
        // TODO: consider bitmask instead?
        this.dirtyX = true;
        this.dirtyY = true;
        this.dirtyWidth = true;
        this.dirtyHeight = true;
        this.dirtyCornerXRadius = true;
        this.dirtyCornerYRadius = true;
        this.markPaintDirty();
      };

      proto.markDirtyX = function() {
        this.dirtyX = true;
        this.markPaintDirty();
      };
      proto.markDirtyY = function() {
        this.dirtyY = true;
        this.markPaintDirty();
      };
      proto.markDirtyWidth = function() {
        this.dirtyWidth = true;
        this.markPaintDirty();
      };
      proto.markDirtyHeight = function() {
        this.dirtyHeight = true;
        this.markPaintDirty();
      };
      proto.markDirtyCornerXRadius = function() {
        this.dirtyCornerXRadius = true;
        this.markPaintDirty();
      };
      proto.markDirtyCornerYRadius = function() {
        this.dirtyCornerYRadius = true;
        this.markPaintDirty();
      };

      /**
       * Clears all of the dirty flags (after they have been checked), so that future mark* methods will be able to flag them again.
       * @public (scenery-internal)
       */
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyX = false;
        this.dirtyY = false;
        this.dirtyWidth = false;
        this.dirtyHeight = false;
        this.dirtyCornerXRadius = false;
        this.dirtyCornerYRadius = false;
      };

      PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  scenery.register( 'RectangleStatefulDrawable', RectangleStatefulDrawable );

  return RectangleStatefulDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * DOM drawable for Rectangle nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/RectangleDOMDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Matrix3','SCENERY/util/Features','SCENERY/display/DOMSelfDrawable','SCENERY/display/drawables/RectangleStatefulDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Features = require( 'SCENERY/util/Features' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var RectangleStatefulDrawable = require( 'SCENERY/display/drawables/RectangleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepDOMRectangleElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory

  // scratch matrix used in DOM rendering
  var scratchMatrix = Matrix3.dirtyFromPool();

  /**
   * A generated DOMSelfDrawable whose purpose will be drawing our Rectangle. One of these drawables will be created
   * for each displayed instance of a Rectangle.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function RectangleDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'RectangleDOMDrawable', RectangleDOMDrawable );

  inherit( DOMSelfDrawable, RectangleDOMDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {RectangleDOMDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeDOMSelfDrawable( renderer, instance );

      // Stateful mix-in initialization
      this.initializeState( renderer, instance );

      // only create elements if we don't already have them (we pool visual states always, and depending on the platform may also pool the actual elements to minimize
      // allocation and performance costs)
      if ( !this.fillElement || !this.strokeElement ) {
        var fillElement = this.fillElement = document.createElement( 'div' );
        fillElement.style.display = 'block';
        fillElement.style.position = 'absolute';
        fillElement.style.left = '0';
        fillElement.style.top = '0';
        fillElement.style.pointerEvents = 'none';

        var strokeElement = this.strokeElement = document.createElement( 'div' );
        strokeElement.style.display = 'block';
        strokeElement.style.position = 'absolute';
        strokeElement.style.left = '0';
        strokeElement.style.top = '0';
        strokeElement.style.pointerEvents = 'none';
        fillElement.appendChild( strokeElement );
      }

      // @protected {HTMLElement} - Our primary DOM element. This is exposed as part of the DOMSelfDrawable API.
      this.domElement = this.fillElement;

      // Apply CSS needed for future CSS transforms to work properly.
      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    /**
     * Updates our DOM element so that its appearance matches our node's representation.
     * @protected
     *
     * This implements part of the DOMSelfDrawable required API for subtypes.
     */
    updateDOM: function() {
      var node = this.node;
      var fillElement = this.fillElement;
      var strokeElement = this.strokeElement;

      if ( this.paintDirty ) {
        var borderRadius = Math.min( node._cornerXRadius, node._cornerYRadius );
        var borderRadiusDirty = this.dirtyCornerXRadius || this.dirtyCornerYRadius;

        if ( this.dirtyWidth ) {
          fillElement.style.width = node._rectWidth + 'px';
        }
        if ( this.dirtyHeight ) {
          fillElement.style.height = node._rectHeight + 'px';
        }
        if ( borderRadiusDirty ) {
          fillElement.style[ Features.borderRadius ] = borderRadius + 'px'; // if one is zero, we are not rounded, so we do the min here
        }
        if ( this.dirtyFill ) {
          fillElement.style.backgroundColor = node.getCSSFill();
        }

        if ( this.dirtyStroke ) {
          // update stroke presence
          if ( node.hasStroke() ) {
            strokeElement.style.borderStyle = 'solid';
          }
          else {
            strokeElement.style.borderStyle = 'none';
          }
        }

        if ( node.hasStroke() ) {
          // since we only execute these if we have a stroke, we need to redo everything if there was no stroke previously.
          // the other option would be to update stroked information when there is no stroke (major performance loss for fill-only rectangles)
          var hadNoStrokeBefore = !this.hadStroke;

          if ( hadNoStrokeBefore || this.dirtyWidth || this.dirtyLineWidth ) {
            strokeElement.style.width = ( node._rectWidth - node.getLineWidth() ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyHeight || this.dirtyLineWidth ) {
            strokeElement.style.height = ( node._rectHeight - node.getLineWidth() ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyLineWidth ) {
            strokeElement.style.left = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.top = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.borderWidth = node.getLineWidth() + 'px';
          }

          if ( hadNoStrokeBefore || this.dirtyStroke ) {
            strokeElement.style.borderColor = node.getSimpleCSSStroke();
          }

          if ( hadNoStrokeBefore || borderRadiusDirty || this.dirtyLineWidth || this.dirtyLineOptions ) {
            strokeElement.style[ Features.borderRadius ] = ( node.isRounded() || node.getLineJoin() === 'round' ) ? ( borderRadius + node.getLineWidth() / 2 ) + 'px' : '0';
          }
        }
      }

      // shift the element vertically, postmultiplied with the entire transform.
      if ( this.transformDirty || this.dirtyX || this.dirtyY ) {
        scratchMatrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( node._rectX, node._rectY );
        scratchMatrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( scratchMatrix, this.fillElement, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToCleanState();
      this.cleanPaintableState();
      this.transformDirty = false;
    },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      this.disposeState();

      if ( !keepDOMRectangleElements ) {
        // clear the references
        this.fillElement = null;
        this.strokeElement = null;
        this.domElement = null;
      }

      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );

  RectangleStatefulDrawable.mixin( RectangleDOMDrawable );

  // This sets up RectangleDOMDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( RectangleDOMDrawable );

  return RectangleDOMDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * SVG drawable for Rectangle nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/RectangleSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGSelfDrawable','SCENERY/display/drawables/RectangleStatefulDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var RectangleStatefulDrawable = require( 'SCENERY/display/drawables/RectangleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepSVGRectangleElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  /**
   * A generated SVGSelfDrawable whose purpose will be drawing our Rectangle. One of these drawables will be created
   * for each displayed instance of a Rectangle.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function RectangleSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'RectangleSVGDrawable', RectangleSVGDrawable );

  inherit( SVGSelfDrawable, RectangleSVGDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {RectangleSVGDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGRectangleElements ); // usesPaint: true

      this.lastArcW = -1; // invalid on purpose
      this.lastArcH = -1; // invalid on purpose

      // @protected {SVGRectElement} - Sole SVG element for this drawable, implementing API for SVGSelfDrawable
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'rect' );

      return this;
    },

    /**
     * Updates the SVG elements so that they will appear like the current node's representation.
     * @protected
     *
     * Implements the interface for SVGSelfDrawable (and is called from the SVGSelfDrawable's update).
     */
    updateSVGSelf: function() {
      var rect = this.svgElement;

      if ( this.dirtyX ) {
        rect.setAttribute( 'x', this.node._rectX );
      }
      if ( this.dirtyY ) {
        rect.setAttribute( 'y', this.node._rectY );
      }
      if ( this.dirtyWidth ) {
        rect.setAttribute( 'width', this.node._rectWidth );
      }
      if ( this.dirtyHeight ) {
        rect.setAttribute( 'height', this.node._rectHeight );
      }
      if ( this.dirtyCornerXRadius || this.dirtyCornerYRadius || this.dirtyWidth || this.dirtyHeight ) {
        var arcw = 0;
        var arch = 0;

        // workaround for various browsers if rx=20, ry=0 (behavior is inconsistent, either identical to rx=20,ry=20, rx=0,ry=0. We'll treat it as rx=0,ry=0)
        // see https://github.com/phetsims/scenery/issues/183
        if ( this.node.isRounded() ) {
          var maximumArcSize = this.node.getMaximumArcSize();
          arcw = Math.min( this.node._cornerXRadius, maximumArcSize );
          arch = Math.min( this.node._cornerYRadius, maximumArcSize );
        }
        if ( arcw !== this.lastArcW ) {
          this.lastArcW = arcw;
          rect.setAttribute( 'rx', arcw );
        }
        if ( arch !== this.lastArcH ) {
          this.lastArcH = arch;
          rect.setAttribute( 'ry', arch );
        }
      }

      // Apply any fill/stroke changes to our element.
      this.updateFillStrokeStyle( rect );
    }
  } );

  RectangleStatefulDrawable.mixin( RectangleSVGDrawable );

  // This sets up RectangleSVGDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( RectangleSVGDrawable );

  return RectangleSVGDrawable;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * TODO docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid
 */

define( 'SCENERY/display/WebGLSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  function WebGLSelfDrawable( renderer, instance ) {
    this.initializeWebGLSelfDrawable( renderer, instance );

    throw new Error( 'Should use initialization and pooling' );
  }

  scenery.register( 'WebGLSelfDrawable', WebGLSelfDrawable );

  inherit( SelfDrawable, WebGLSelfDrawable, {
    initializeWebGLSelfDrawable: function( renderer, instance ) {
      // super initialization
      this.initializeSelfDrawable( renderer, instance );

      // this is the same across lifecycles
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );

      // when our relative transform changes, notify us in the pre-repaint phase
      instance.relativeTransform.addListener( this.transformListener );

      // trigger precomputation of the relative transform, since we will always need it when it is updated
      instance.relativeTransform.addPrecompute();

      return this;
    },

    markTransformDirty: function() {
      this.markDirty();
    },

    // @override
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );

      // mark us as dirty when our self visibility changes
      this.markDirty();
    },

    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();

      SelfDrawable.prototype.dispose.call( this );
    }
  } );

  return WebGLSelfDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * WebGL drawable for Rectangle nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/RectangleWebGLDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','AXON/Property','SCENERY/display/WebGLSelfDrawable','SCENERY/display/drawables/RectangleStatefulDrawable','SCENERY/display/SelfDrawable','SCENERY/display/Renderer','SCENERY/util/Color'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var Property = require( 'AXON/Property' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );
  var RectangleStatefulDrawable = require( 'SCENERY/display/drawables/RectangleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Color = require( 'SCENERY/util/Color' );

  var scratchColor = new Color( 'transparent' );

  /**
   * A generated WebGLSelfDrawable whose purpose will be drawing our Rectangle. One of these drawables will be created
   * for each displayed instance of a Rectangle.
   * @constructor
   *
   * NOTE: This drawable currently only supports solid fills and no strokes.
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function RectangleWebGLDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'RectangleWebGLDrawable', RectangleWebGLDrawable );

  inherit( WebGLSelfDrawable, RectangleWebGLDrawable, {
    webglRenderer: Renderer.webglVertexColorPolygons,

    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {RectangleWebGLDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      this.initializeWebGLSelfDrawable( renderer, instance );

      // Stateful mix-in initialization
      this.initializeState( renderer, instance );

      if ( !this.vertexArray ) {
        // format [X Y R G B A] for all vertices
        this.vertexArray = new Float32Array( 6 * 6 ); // 6-length components for 6 vertices (2 tris).
      }

      // corner vertices in the relative transform root coordinate space
      this.upperLeft = new Vector2();
      this.lowerLeft = new Vector2();
      this.upperRight = new Vector2();
      this.lowerRight = new Vector2();

      this.transformDirty = true;
      this.includeVertices = true; // used by the processor

      return this;
    },

    onAddToBlock: function( webglBlock ) {
      this.webglBlock = webglBlock; // TODO: do we need this reference?
      this.markDirty();
    },

    onRemoveFromBlock: function( webglBlock ) {
    },

    // @override
    markTransformDirty: function() {
      this.transformDirty = true;

      WebGLSelfDrawable.prototype.markTransformDirty.call( this );
    },

    update: function() {
      if ( this.dirty ) {
        this.dirty = false;

        if ( this.dirtyFill ) {
          this.includeVertices = this.node.hasFill();

          if ( this.includeVertices ) {
            var fill = ( this.node.fill instanceof Property ) ? this.node.fill.value : this.node.fill;
            var color =  scratchColor.set( fill );
            var red = color.red / 255;
            var green = color.green / 255;
            var blue = color.blue / 255;
            var alpha = color.alpha;

            for ( var i = 0; i < 6; i++ ) {
              var offset = i * 6;
              this.vertexArray[ 2 + offset ] = red;
              this.vertexArray[ 3 + offset ] = green;
              this.vertexArray[ 4 + offset ] = blue;
              this.vertexArray[ 5 + offset ] = alpha;
            }
          }
        }

        if ( this.transformDirty || this.dirtyX || this.dirtyY || this.dirtyWidth || this.dirtyHeight ) {
          this.transformDirty = false;

          var x = this.node._rectX;
          var y = this.node._rectY;
          var width = this.node._rectWidth;
          var height = this.node._rectHeight;

          var transformMatrix = this.instance.relativeTransform.matrix; // with compute need, should always be accurate
          transformMatrix.multiplyVector2( this.upperLeft.setXY( x, y ) );
          transformMatrix.multiplyVector2( this.lowerLeft.setXY( x, y + height ) );
          transformMatrix.multiplyVector2( this.upperRight.setXY( x + width, y ) );
          transformMatrix.multiplyVector2( this.lowerRight.setXY( x + width, y + height ) );

          // first triangle XYs
          this.vertexArray[ 0 ] = this.upperLeft.x;
          this.vertexArray[ 1 ] = this.upperLeft.y;
          this.vertexArray[ 6 ] = this.lowerLeft.x;
          this.vertexArray[ 7 ] = this.lowerLeft.y;
          this.vertexArray[ 12 ] = this.upperRight.x;
          this.vertexArray[ 13 ] = this.upperRight.y;

          // second triangle XYs
          this.vertexArray[ 18 ] = this.upperRight.x;
          this.vertexArray[ 19 ] = this.upperRight.y;
          this.vertexArray[ 24 ] = this.lowerLeft.x;
          this.vertexArray[ 25 ] = this.lowerLeft.y;
          this.vertexArray[ 30 ] = this.lowerRight.x;
          this.vertexArray[ 31 ] = this.lowerRight.y;
        }
      }

      this.setToCleanState();
      this.cleanPaintableState();
    },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      // TODO: disposal of buffers?

      this.disposeState();

      // super
      WebGLSelfDrawable.prototype.dispose.call( this );
    }
  } );

  RectangleStatefulDrawable.mixin( RectangleWebGLDrawable );

  // This sets up RectangleWebGLDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( RectangleWebGLDrawable );

  return RectangleWebGLDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * A rectangular node that inherits Path, and allows for optimized drawing and improved rectangle handling.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Rectangle',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','SCENERY/nodes/Path','KITE/Shape','DOT/Bounds2','DOT/Dimension2','SCENERY/util/Features','SCENERY/display/Renderer','SCENERY/display/drawables/RectangleCanvasDrawable','SCENERY/display/drawables/RectangleDOMDrawable','SCENERY/display/drawables/RectangleSVGDrawable','SCENERY/display/drawables/RectangleWebGLDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Features = require( 'SCENERY/util/Features' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var RectangleCanvasDrawable = require( 'SCENERY/display/drawables/RectangleCanvasDrawable' );
  var RectangleDOMDrawable = require( 'SCENERY/display/drawables/RectangleDOMDrawable' );
  var RectangleSVGDrawable = require( 'SCENERY/display/drawables/RectangleSVGDrawable' );
  var RectangleWebGLDrawable = require( 'SCENERY/display/drawables/RectangleWebGLDrawable' );

  var RECTANGLE_OPTION_KEYS = [
    'rectBounds', // Sets x/y/width/height based on bounds. See setRectBounds() for more documentation.
    'rectSize', // Sets width/height based on dimension. See setRectSize() for more documentation.
    'rectX', // Sets x. See setRectX() for more documentation.
    'rectY', // Sets y. See setRectY() for more documentation.
    'rectWidth', // Sets width. See setRectWidth() for more documentation.
    'rectHeight', // Sets height. See setRectHeight() for more documentation.
    'cornerRadius', // Sets corner radii. See setCornerRadius() for more documentation.
    'cornerXRadius', // Sets horizontal corner radius. See setCornerXRadius() for more documentation.
    'cornerYRadius' // Sets vertical corner radius. See setCornerYRadius() for more documentation.
  ];

  /**
   * @public
   * @constructor
   * @extends Path
   *
   * Possible constructor signatures
   * new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius, [options] )
   * new Rectangle( x, y, width, height, [options] )
   * new Rectangle( [options] )
   * new Rectangle( bounds2, [options] )
   * new Rectangle( bounds2, cornerXRadius, cornerYRadius, [options] )
   *
   * Current available options for the options object (custom for Rectangle, not Path or Node):
   * rectX - Left edge of the rectangle in the local coordinate frame
   * rectY - Top edge of the rectangle in the local coordinate frame
   * rectWidth - Width of the rectangle in the local coordinate frame
   * rectHeight - Height of the rectangle in the local coordinate frame
   * cornerXRadius - The x-axis radius for elliptical/circular rounded corners.
   * cornerYRadius - The y-axis radius for elliptical/circular rounded corners.
   * cornerRadius - Sets both "X" and "Y" corner radii above.
   *
   * NOTE: the X and Y corner radii need to both be greater than zero for rounded corners to appear. If they have the
   * same non-zero value, circular rounded corners will be used.
   *
   * Available parameters to the various constructor options:
   * @param {number} x - x-position of the upper-left corner (left bound)
   * @param {number} y - y-position of the upper-left corner (top bound)
   * @param {number} width - width of the rectangle to the right of the upper-left corner, required to be >= 0
   * @param {number} height - height of the rectangle below the upper-left corner, required to be >= 0
   * @param {number} cornerXRadius - positive vertical radius (width) of the rounded corner, or 0 to indicate the corner should be sharp
   * @param {number} cornerYRadius - positive horizontal radius (height) of the rounded corner, or 0 to indicate the corner should be sharp
   * @param {Object} [options] - Rectangle-specific options are documented in RECTANGLE_OPTION_KEYS above, and can be provided
   *                             along-side options for Node
   */
  function Rectangle( x, y, width, height, cornerXRadius, cornerYRadius, options ) {
    // @private {number} - X value of the left side of the rectangle
    this._rectX = 0;

    // @private {number} - Y value of the top side of the rectangle
    this._rectY = 0;

    // @private {number} - Width of the rectangle
    this._rectWidth = 0;

    // @private {number} - Height of the rectangle
    this._rectHeight = 0;

    // @private {number} - X radius of rounded corners
    this._cornerXRadius = 0;

    // @private {number} - Y radius of rounded corners
    this._cornerYRadius = 0;

    if ( typeof x === 'object' ) {
      // allow new Rectangle( bounds2, { ... } ) or new Rectangle( bounds2, cornerXRadius, cornerYRadius, { ... } )
      if ( x instanceof Bounds2 ) {
        // new Rectangle( bounds2, { ... } )
        if ( typeof y !== 'number' ) {
          assert && assert( arguments.length === 1 || arguments.length === 2,
            'new Rectangle( bounds, { ... } ) should only take one or two arguments' );
          assert && assert( y === undefined || typeof y === 'object',
            'new Rectangle( bounds, { ... } ) second parameter should only ever be an options object' );
          assert && assert( y === undefined || Object.getPrototypeOf( y ) === Object.prototype,
            'Extra prototype on Node options object is a code smell' );

          options = extendDefined( {
            rectBounds: x
          }, y ); // Our options object would be at y
        }
        // Rectangle( bounds2, cornerXRadius, cornerYRadius, { ... } )
        else {
          assert && assert( arguments.length === 3 || arguments.length === 4,
            'new Rectangle( bounds, cornerXRadius, cornerYRadius, { ... } ) should only take three or four arguments' );
          assert && assert( height === undefined || typeof height === 'object',
            'new Rectangle( bounds, cornerXRadius, cornerYRadius, { ... } ) fourth parameter should only ever be an options object' );
          assert && assert( height === undefined || Object.getPrototypeOf( height ) === Object.prototype,
            'Extra prototype on Node options object is a code smell' );

          options = extendDefined( {
            rectBounds: x,
            cornerXRadius: y, // ignore Intellij warning, our cornerXRadius is the second parameter
            cornerYRadius: width // ignore Intellij warning, our cornerYRadius is the third parameter
          }, height ); // Our options object would be at height
        }
      }
      // allow new Rectangle( { rectX: x, rectY: y, rectWidth: width, rectHeight: height, ... } )
      else {
        options = x;
      }
    }
    // new Rectangle( x, y, width, height, { ... } )
    else if ( cornerYRadius === undefined ) {
      assert && assert( arguments.length === 4 || arguments.length === 5,
        'new Rectangle( x, y, width, height, { ... } ) should only take four or five arguments' );
      assert && assert( cornerXRadius === undefined || typeof cornerXRadius === 'object',
        'new Rectangle( x, y, width, height, { ... } ) fifth parameter should only ever be an options object' );
      assert && assert( cornerXRadius === undefined || Object.getPrototypeOf( cornerXRadius ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );

      options = extendDefined( {
        rectX: x,
        rectY: y,
        rectWidth: width,
        rectHeight: height
      }, cornerXRadius );
    }
    // new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius, { ... } )
    else {
      assert && assert( arguments.length === 6 || arguments.length === 7,
        'new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius{ ... } ) should only take six or seven arguments' );
      assert && assert( options === undefined || typeof options === 'object',
        'new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius{ ... } ) seventh parameter should only ever be an options object' );
      assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );

      options = extendDefined( {
        rectX: x,
        rectY: y,
        rectWidth: width,
        rectHeight: height,
        cornerXRadius: cornerXRadius,
        cornerYRadius: cornerYRadius
      }, options );
    }

    Path.call( this, null, options );
  }

  scenery.register( 'Rectangle', Rectangle );

  inherit( Path, Rectangle, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: RECTANGLE_OPTION_KEYS.concat( Path.prototype._mutatorKeys ),

    /**
     * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
     *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
     *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
     * @public (scenery-internal)
     * @override
     */
    drawableMarkFlags: Path.prototype.drawableMarkFlags.concat( [ 'x', 'y', 'width', 'height', 'cornerXRadius', 'cornerYRadius' ] ).filter( function( flag ) {
      // We don't want the shape flag, as that won't be called for Path subtypes.
      return flag !== 'shape';
    } ),

    /**
     * Determines the maximum arc size that can be accomodated by the current width and height.
     * @private
     *
     * If the corner radii are the same as the maximum arc size on a square, it will appear to be a circle (the arcs
     * take up all of the room, and leave no straight segments). In the case of a non-square, one direction of edges
     * will exist (e.g. top/bottom or left/right), while the other edges would be fully rounded.
     *
     * @returns {number}
     */
    getMaximumArcSize: function() {
      return Math.min( this._rectWidth / 2, this._rectHeight / 2 );
    },

    /**
     * Determines the default allowed renderers (returned via the Renderer bitmask) that are allowed, given the
     * current stroke options.
     * @public (scenery-internal)
     * @override
     *
     * We can support the DOM renderer if there is a solid-styled stroke with non-bevel line joins
     * (which otherwise wouldn't be supported).
     *
     * @returns {number} - Renderer bitmask, see Renderer for details
     */
    getStrokeRendererBitmask: function() {
      var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
      // DOM stroke handling doesn't YET support gradients, patterns, or dashes (with the current implementation, it shouldn't be too hard)
      if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern && !this.hasLineDash() ) {
        // we can't support the bevel line-join with our current DOM rectangle display
        if ( this.getLineJoin() === 'miter' || ( this.getLineJoin() === 'round' && Features.borderRadius ) ) {
          bitmask |= Renderer.bitmaskDOM;
        }
      }

      if ( !this.hasStroke() ) {
        bitmask |= Renderer.bitmaskWebGL;
      }

      return bitmask;
    },

    /**
     * Determines the allowed renderers that are allowed (or excluded) based on the current Path.
     * @public (scenery-internal)
     * @override
     *
     * @returns {number} - Renderer bitmask, see Renderer for details
     */
    getPathRendererBitmask: function() {
      var bitmask = Renderer.bitmaskCanvas | Renderer.bitmaskSVG;

      var maximumArcSize = this.getMaximumArcSize();

      // If the top/bottom or left/right strokes touch and overlap in the middle (small rectangle, big stroke), our DOM method won't work.
      // Additionally, if we're handling rounded rectangles or a stroke with lineJoin 'round', we'll need borderRadius
      // We also require for DOM that if it's a rounded rectangle, it's rounded with circular arcs (for now, could potentially do a transform trick!)
      if ( ( !this.hasStroke() || ( this.getLineWidth() <= this._rectHeight && this.getLineWidth() <= this._rectWidth ) ) &&
           ( !this.isRounded() || ( Features.borderRadius && this._cornerXRadius === this._cornerYRadius ) ) &&
           this._cornerYRadius <= maximumArcSize && this._cornerXRadius <= maximumArcSize ) {
        bitmask |= Renderer.bitmaskDOM;
      }

      // TODO: why check here, if we also check in the 'stroke' portion?
      if ( !this.hasStroke() && !this.isRounded() ) {
        bitmask |= Renderer.bitmaskWebGL;
      }

      return bitmask;
    },

    /**
     * Sets all of the shape-determining parameters for the rectangle.
     * @public
     *
     * @param {number} x - The x-position of the left side of the rectangle.
     * @param {number} y - The y-position of the top side of the rectangle.
     * @param {number} width - The width of the rectangle.
     * @param {number} height - The height of the rectangle.
     * @param {number} [cornerXRadius] - The horizontal radius of curved corners (0 for sharp corners)
     * @param {number} [cornerYRadius] - The vertical radius of curved corners (0 for sharp corners)
     * @returns {Rectangle} - For chaining
     */
    setRect: function( x, y, width, height, cornerXRadius, cornerYRadius ) {
      var hasXRadius = cornerXRadius !== undefined;
      var hasYRadius = cornerYRadius !== undefined;

      assert && assert( typeof x === 'number' && isFinite( x ) &&
                        typeof y === 'number' && isFinite( y ) &&
                        typeof width === 'number' && isFinite( width ) &&
                        typeof height === 'number' && isFinite( height ), 'x/y/width/height should be finite numbers' );
      assert && assert( !hasXRadius || ( typeof cornerXRadius === 'number' && isFinite( cornerXRadius ) ) &&
                        !hasYRadius || ( typeof cornerYRadius === 'number' && isFinite( cornerYRadius ) ),
                        'Corner radii (if provided) should be finite numbers' );

      // If this doesn't change the rectangle, don't notify about changes.
      if ( this._rectX === x &&
           this._rectY === y &&
           this._rectWidth === width &&
           this._rectHeight === height &&
           ( !hasXRadius || this._cornerXRadius === cornerXRadius ) &&
           ( !hasYRadius || this._cornerYRadius === cornerYRadius ) ) {
        return;
      }

      this._rectX = x;
      this._rectY = y;
      this._rectWidth = width;
      this._rectHeight = height;
      this._cornerXRadius = hasXRadius ? cornerXRadius : this._cornerXRadius;
      this._cornerYRadius = hasYRadius ? cornerYRadius : this._cornerYRadius;

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyRectangle();
      }
      this.invalidateRectangle();

      return this;
    },

    /**
     * Sets the x coordinate of the left side of this rectangle (in the local coordinate frame).
     * @public
     *
     * @param {number} x
     */
    setRectX: function( x ) {
      assert && assert( typeof x === 'number' && isFinite( x ), 'rectX should be a finite number' );

      if ( this._rectX !== x ) {
        this._rectX = x;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyX();
        }

        this.invalidateRectangle();
      }
      return this;
    },
    set rectX( value ) { this.setRectX( value ); },

    /**
     * Returns the x coordinate of the left side of this rectangle (in the local coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getRectX: function() {
      return this._rectX;
    },
    get rectX() { return this.getRectX(); },

    /**
     * Sets the y coordinate of the top side of this rectangle (in the local coordinate frame).
     * @public
     *
     * @param {number} y
     */
    setRectY: function( y ) {
      assert && assert( typeof y === 'number' && isFinite( y ), 'rectY should be a finite number' );

      if ( this._rectY !== y ) {
        this._rectY = y;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyY();
        }

        this.invalidateRectangle();
      }
      return this;
    },
    set rectY( value ) { this.setRectY( value ); },

    /**
     * Returns the y coordinate of the top side of this rectangle (in the local coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getRectY: function() {
      return this._rectY;
    },
    get rectY() { return this.getRectY(); },

    /**
     * Sets the width of the rectangle (in the local coordinate frame).
     * @public
     *
     * @param {number} width
     */
    setRectWidth: function( width ) {
      assert && assert( typeof width === 'number' && isFinite( width ), 'rectWidth should be a finite number' );

      if ( this._rectWidth !== width ) {
        this._rectWidth = width;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyWidth();
        }

        this.invalidateRectangle();
      }
      return this;
    },
    set rectWidth( value ) { this.setRectWidth( value ); },

    /**
     * Returns the width of the rectangle (in the local coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getRectWidth: function() {
      return this._rectWidth;
    },
    get rectWidth() { return this.getRectWidth(); },

    /**
     * Sets the height of the rectangle (in the local coordinate frame).
     * @public
     *
     * @param {number} height
     */
    setRectHeight: function( height ) {
      assert && assert( typeof height === 'number' && isFinite( height ), 'rectHeight should be a finite number' );

      if ( this._rectHeight !== height ) {
        this._rectHeight = height;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyHeight();
        }

        this.invalidateRectangle();
      }
      return this;
    },
    set rectHeight( value ) { this.setRectHeight( value ); },

    /**
     * Returns the height of the rectangle (in the local coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getRectHeight: function() {
      return this._rectHeight;
    },
    get rectHeight() { return this.getRectHeight(); },

    /**
     * Sets the horizontal corner radius of the rectangle (in the local coordinate frame).
     * @public
     *
     * If the cornerXRadius and cornerYRadius are the same, the corners will be rounded circular arcs with that radius
     * (or a smaller radius if the rectangle is too small).
     *
     * If the cornerXRadius and cornerYRadius are different, the corners will be elliptical arcs, and the horizontal
     * radius will be equal to cornerXRadius (or a smaller radius if the rectangle is too small).
     *
     * @param {number} radius
     */
    setCornerXRadius: function( radius ) {
      assert && assert( typeof radius === 'number' && isFinite( radius ), 'cornerXRadius should be a finite number' );

      if ( this._cornerXRadius !== radius ) {
        this._cornerXRadius = radius;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyCornerXRadius();
        }

        this.invalidateRectangle();
      }
      return this;
    },
    set cornerXRadius( value ) { this.setCornerXRadius( value ); },

    /**
     * Returns the horizontal corner radius of the rectangle (in the local coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getCornerXRadius: function() {
      return this._cornerXRadius;
    },
    get cornerXRadius() { return this.getCornerXRadius(); },

    /**
     * Sets the vertical corner radius of the rectangle (in the local coordinate frame).
     * @public
     *
     * If the cornerXRadius and cornerYRadius are the same, the corners will be rounded circular arcs with that radius
     * (or a smaller radius if the rectangle is too small).
     *
     * If the cornerXRadius and cornerYRadius are different, the corners will be elliptical arcs, and the vertical
     * radius will be equal to cornerYRadius (or a smaller radius if the rectangle is too small).
     *
     * @param {number} radius
     */
    setCornerYRadius: function( radius ) {
      assert && assert( typeof radius === 'number' && isFinite( radius ), 'cornerYRadius should be a finite number' );

      if ( this._cornerYRadius !== radius ) {
        this._cornerYRadius = radius;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyCornerYRadius();
        }

        this.invalidateRectangle();
      }
      return this;
    },
    set cornerYRadius( value ) { this.setCornerYRadius( value ); },

    /**
     * Returns the vertical corner radius of the rectangle (in the local coordinate frame).
     * @public
     *
     * @returns {number}
     */
    getCornerYRadius: function() {
      return this._cornerYRadius;
    },
    get cornerYRadius() { return this.getCornerYRadius(); },

    /**
     * Sets the Rectangle's x/y/width/height from the Bounds2 passed in.
     * @public
     *
     * @param {Bounds2} bounds
     * @returns {Rectangle} - For chaining
     */
    setRectBounds: function( bounds ) {
      assert && assert( bounds instanceof Bounds2 );

      this.setRect( bounds.x, bounds.y, bounds.width, bounds.height );

      return this;
    },
    set rectBounds( value ) { this.setRectBounds( value ); },

    /**
     * Returns a new Bounds2 generated from this Rectangle's x/y/width/height.
     * @public
     *
     * @returns {Bounds2}
     */
    getRectBounds: function() {
      return Bounds2.rect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
    },
    get rectBounds() { return this.getRectBounds(); },

    /**
     * Sets the Rectangle's width/height from the Dimension2 size passed in.
     * @public
     *
     * @param {Dimension2} size
     * @returns {Rectangle} - For chaining
     */
    setRectSize: function( size ) {
      assert && assert( size instanceof Dimension2 );

      this.setRectWidth( size.width );
      this.setRectHeight( size.height );

      return this;
    },
    set rectSize( value ) { this.setRectSize( value ); },

    /**
     * Returns a new Dimension2 generated from this Rectangle's width/height.
     * @public
     *
     * @returns {Dimension2}
     */
    getRectSize: function() {
      return new Dimension2( this._rectWidth, this._rectHeight );
    },
    get rectSize() { return this.getRectSize(); },

    /**
     * Sets the width of the rectangle while keeping its right edge (x + width) in the same position
     * @public
     *
     * @param {number} width - New width for the rectangle
     * @returns {Rectangle} - For chaining
     */
    setRectWidthFromRight: function( width ) {
      assert && assert( typeof width === 'number' );

      if ( this._rectWidth !== width ) {
        var right = this._rectX + this._rectWidth;
        this.setRectWidth( width );
        this.setRectX( right - width );
      }

      return this;
    },
    set rectWidthFromRight( value ) { this.setRectWidthFromRight( value ); },
    get rectWidthFromRight() { return this.getRectWidth(); }, // because JSHint complains

    /**
     * Sets the height of the rectangle while keeping its bottom edge (y + height) in the same position
     * @public
     *
     * @param {number} height - New height for the rectangle
     * @returns {Rectangle} - For chaining
     */
    setRectHeightFromBottom: function( height ) {
      assert && assert( typeof height === 'number' );

      if ( this._rectHeight !== height ) {
        var bottom = this._rectY + this._rectHeight;
        this.setRectHeight( height );
        this.setRectY( bottom - height );
      }

      return this;
    },
    set rectHeightFromBottom( value ) { this.setRectHeightFromBottom( value ); },
    get rectHeightFromBottom() { return this.getRectHeight(); }, // because JSHint complains

    /**
     * Returns whether this rectangle has any rounding applied at its corners. If either the x or y corner radius is 0,
     * then there is no rounding applied.
     * @public
     *
     * @returns {boolean}
     */
    isRounded: function() {
      return this._cornerXRadius !== 0 && this._cornerYRadius !== 0;
    },

    /**
     * Computes the bounds of the Rectangle, including any applied stroke. Overridden for efficiency.
     * @public
     * @override
     *
     * @returns {Bounds2}
     */
    computeShapeBounds: function() {
      var bounds = new Bounds2( this._rectX, this._rectY, this._rectX + this._rectWidth, this._rectY + this._rectHeight );
      if ( this._stroke ) {
        // since we are axis-aligned, any stroke will expand our bounds by a guaranteed set amount
        bounds = bounds.dilated( this.getLineWidth() / 2 );
      }
      return bounds;
    },

    /**
     * Returns our self bounds when our rendered self is transformed by the matrix.
     * @public
     * @override
     *
     * @param {Matrix3} matrix
     * @returns {Bounds2}
     */
    getTransformedSelfBounds: function( matrix ) {
      return this.selfBounds.transformed( matrix );
    },

    /**
     * Returns a Shape that is equivalent to our rendered display. Generally used to lazily create a Shape instance
     * when one is needed, without having to do so beforehand.
     * @private
     *
     * @returns {Shape}
     */
    createRectangleShape: function() {
      if ( this.isRounded() ) {
        // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other
        var maximumArcSize = Math.min( this._rectWidth / 2, this._rectHeight / 2 );
        return Shape.roundRectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight,
          Math.min( maximumArcSize, this._cornerXRadius ), Math.min( maximumArcSize, this._cornerYRadius ) ).makeImmutable();
      }
      else {
        return Shape.rectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight ).makeImmutable();
      }
    },

    /**
     * Notifies that the rectangle has changed, and invalidates path information and our cached shape.
     * @private
     */
    invalidateRectangle: function() {
      assert && assert( isFinite( this._rectX ), 'A rectangle needs to have a finite x (' + this._rectX + ')' );
      assert && assert( isFinite( this._rectY ), 'A rectangle needs to have a finite y (' + this._rectY + ')' );
      assert && assert( this._rectWidth >= 0 && isFinite( this._rectWidth ),
        'A rectangle needs to have a non-negative finite width (' + this._rectWidth + ')' );
      assert && assert( this._rectHeight >= 0 && isFinite( this._rectHeight ),
        'A rectangle needs to have a non-negative finite height (' + this._rectHeight + ')' );
      assert && assert( this._cornerXRadius >= 0 && isFinite( this._cornerXRadius ),
        'A rectangle needs to have a non-negative finite arcWidth (' + this._cornerXRadius + ')' );
      assert && assert( this._cornerYRadius >= 0 && isFinite( this._cornerYRadius ),
        'A rectangle needs to have a non-negative finite arcHeight (' + this._cornerYRadius + ')' );

      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;

      // should invalidate the path and ensure a redraw
      this.invalidatePath();

      // since we changed the rectangle arc width/height, it could make DOM work or not
      this.invalidateSupportedRenderers();
    },

    /**
     * Computes whether the provided point is "inside" (contained) in this Rectangle's self content, or "outside".
     * @protected
     * @override
     *
     * Handles axis-aligned optionally-rounded rectangles, although can only do optimized computation if it isn't
     * rounded. If it IS rounded, we check if a corner computation is needed (usually isn't), and only need to check
     * one corner for that test.
     *
     * @param {Vector2} point - Considered to be in the local coordinate frame
     * @returns {boolean}
     */
    containsPointSelf: function( point ) {
      var x = this._rectX;
      var y = this._rectY;
      var width = this._rectWidth;
      var height = this._rectHeight;
      var arcWidth = this._cornerXRadius;
      var arcHeight = this._cornerYRadius;
      var halfLine = this.getLineWidth() / 2;

      var result = true;
      if ( this._strokePickable ) {
        // test the outer boundary if we are stroke-pickable (if also fill-pickable, this is the only test we need)
        var rounded = this.isRounded();
        if ( !rounded && this.getLineJoin() === 'bevel' ) {
          // fall-back for bevel
          return Path.prototype.containsPointSelf.call( this, point );
        }
        var miter = this.getLineJoin() === 'miter' && !rounded;
        result = result && Rectangle.intersects( x - halfLine, y - halfLine,
            width + 2 * halfLine, height + 2 * halfLine,
            miter ? 0 : ( arcWidth + halfLine ), miter ? 0 : ( arcHeight + halfLine ),
            point );
      }

      if ( this._fillPickable ) {
        if ( this._strokePickable ) {
          return result;
        }
        else {
          return Rectangle.intersects( x, y, width, height, arcWidth, arcHeight, point );
        }
      }
      else if ( this._strokePickable ) {
        return result && !Rectangle.intersects( x + halfLine, y + halfLine,
            width - 2 * halfLine, height - 2 * halfLine,
            arcWidth - halfLine, arcHeight - halfLine,
            point );
      }
      else {
        return false; // either fill nor stroke is pickable
      }
    },

    /**
     * Returns whether this Rectangle's selfBounds is intersected by the specified bounds.
     * @public
     *
     * @param {Bounds2} bounds - Bounds to test, assumed to be in the local coordinate frame.
     * @returns {boolean}
     */
    intersectsBoundsSelf: function( bounds ) {
      return !this.computeShapeBounds().intersection( bounds ).isEmpty();
    },

    /**
     * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
     * coordinate frame of this node.
     * @protected
     * @override
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} matrix - The transformation matrix already applied to the context.
     */
    canvasPaintSelf: function( wrapper, matrix ) {
      //TODO: Have a separate method for this, instead of touching the prototype. Can make 'this' references too easily.
      RectangleCanvasDrawable.prototype.paintCanvas( wrapper, this, matrix );
    },

    /**
     * Creates a DOM drawable for this Rectangle.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {DOMSelfDrawable}
     */
    createDOMDrawable: function( renderer, instance ) {
      return RectangleDOMDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a SVG drawable for this Rectangle.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {SVGSelfDrawable}
     */
    createSVGDrawable: function( renderer, instance ) {
      return RectangleSVGDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a Canvas drawable for this Rectangle.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {CanvasSelfDrawable}
     */
    createCanvasDrawable: function( renderer, instance ) {
      return RectangleCanvasDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a WebGL drawable for this Rectangle.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {WebGLSelfDrawable}
     */
    createWebGLDrawable: function( renderer, instance ) {
      return RectangleWebGLDrawable.createFromPool( renderer, instance );
    },

    /*---------------------------------------------------------------------------*
     * Miscellaneous
     *----------------------------------------------------------------------------*/

    /**
     * It is impossible to set another shape on this Path subtype, as its effective shape is determined by other
     * parameters.
     * @public
     * @override
     *
     * @param {Shape|null} shape - Throws an error if it is not null.
     */
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Rectangle to something non-null' );
      }
      else {
        // probably called from the Path constructor
        this.invalidatePath();
      }
    },

    /**
     * Returns an immutable copy of this Path subtype's representation.
     * @public
     * @override
     *
     * NOTE: This is created lazily, so don't call it if you don't have to!
     *
     * @returns {Shape}
     */
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createRectangleShape();
      }
      return this._shape;
    },

    /**
     * Returns whether this Path has an associated Shape (instead of no shape, represented by null)
     * @public
     * @override
     *
     * @returns {boolean}
     */
    hasShape: function() {
      return true;
    },

    /**
     * Sets both of the corner radii to the same value, so that the rounded corners will be circular arcs.
     * @public
     *
     * @param {number} cornerRadius - The radius of the corners
     * @returns {Rectangle} - For chaining
     */
    setCornerRadius: function( cornerRadius ) {
      this.setCornerXRadius( cornerRadius );
      this.setCornerYRadius( cornerRadius );
      return this;
    },
    set cornerRadius( value ) { this.setCornerRadius( value ); },

    /**
     * Returns the corner radius if both the horizontal and vertical corner radii are the same.
     * @public
     *
     * NOTE: If there are different horizontal and vertical corner radii, this will fail an assertion and return the horizontal radius.
     *
     * @returns {number}
     */
    getCornerRadius: function() {
      assert && assert( this._cornerXRadius === this._cornerYRadius,
        'getCornerRadius() invalid if x/y radii are different' );

      return this._cornerXRadius;
    },
    get cornerRadius() { return this.getCornerRadius(); }
  } );

  /**
   * Returns whether a point is within a rounded rectangle.
   * @public
   *
   * @param {number} x - X value of the left side of the rectangle
   * @param {number} y - Y value of the top side of the rectangle
   * @param {number} width - Width of the rectangle
   * @param {number} height - Height of the rectangle
   * @param {number} arcWidth - Horizontal corner radius of the rectangle
   * @param {number} arcHeight - Vertical corner radius of the rectangle
   * @param {Vector2} point - The point that may or may not be in the rounded rectangle
   * @returns {boolean}
   */
  Rectangle.intersects = function( x, y, width, height, arcWidth, arcHeight, point ) {
    var result = point.x >= x &&
                 point.x <= x + width &&
                 point.y >= y &&
                 point.y <= y + height;

    if ( !result || arcWidth <= 0 || arcHeight <= 0 ) {
      return result;
    }

    // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other
    var maximumArcSize = Math.min( width / 2, height / 2 );
    arcWidth = Math.min( maximumArcSize, arcWidth );
    arcHeight = Math.min( maximumArcSize, arcHeight );

    // we are rounded and inside the logical rectangle (if it didn't have rounded corners)

    // closest corner arc's center (we assume the rounded rectangle's arcs are 90 degrees fully, and don't intersect)
    var closestCornerX;
    var closestCornerY;
    var guaranteedInside = false;

    // if we are to the inside of the closest corner arc's center, we are guaranteed to be in the rounded rectangle (guaranteedInside)
    if ( point.x < x + width / 2 ) {
      closestCornerX = x + arcWidth;
      guaranteedInside = guaranteedInside || point.x >= closestCornerX;
    }
    else {
      closestCornerX = x + width - arcWidth;
      guaranteedInside = guaranteedInside || point.x <= closestCornerX;
    }
    if ( guaranteedInside ) { return true; }

    if ( point.y < y + height / 2 ) {
      closestCornerY = y + arcHeight;
      guaranteedInside = guaranteedInside || point.y >= closestCornerY;
    }
    else {
      closestCornerY = y + height - arcHeight;
      guaranteedInside = guaranteedInside || point.y <= closestCornerY;
    }
    if ( guaranteedInside ) { return true; }

    // we are now in the rectangular region between the logical corner and the center of the closest corner's arc.

    // offset from the closest corner's arc center
    var offsetX = point.x - closestCornerX;
    var offsetY = point.y - closestCornerY;

    // normalize the coordinates so now we are dealing with a unit circle
    // (technically arc, but we are guaranteed to be in the area covered by the arc, so we just consider the circle)
    // NOTE: we are rounded, so both arcWidth and arcHeight are non-zero (this is well defined)
    offsetX /= arcWidth;
    offsetY /= arcHeight;

    offsetX *= offsetX;
    offsetY *= offsetY;
    return offsetX + offsetY <= 1; // return whether we are in the rounded corner. see the formula for an ellipse
  };

  /**
   * Creates a rectangle with the specified x/y/width/height.
   * @public
   *
   * See Rectangle's constructor for detailed parameter information.
   *
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {Object} [options]
   * @returns {Rectangle}
   */
  Rectangle.rect = function( x, y, width, height, options ) {
    return new Rectangle( x, y, width, height, 0, 0, options );
  };

  /**
   * Creates a rounded rectangle with the specified x/y/width/height/cornerXRadius/cornerYRadius.
   * @public
   *
   * See Rectangle's constructor for detailed parameter information.
   *
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   * @param {number} cornerXRadius
   * @param {number} cornerYRadius
   * @param {Object} [options]
   * @returns {Rectangle}
   */
  Rectangle.roundedRect = function( x, y, width, height, cornerXRadius, cornerYRadius, options ) {
    return new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius, options );
  };

  /**
   * Creates a rectangle x/y/width/height matching the specified bounds.
   * @public
   *
   * See Rectangle's constructor for detailed parameter information.
   *
   * @param {Bounds2} bounds
   * @param {Object} [options]
   * @returns {Rectangle}
   */
  Rectangle.bounds = function( bounds, options ) {
    return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, options );
  };

  /**
   * Creates a rounded rectangle x/y/width/height matching the specified bounds (Rectangle.bounds, but with additional
   * cornerXRadius and cornerYRadius).
   * @public
   *
   * See Rectangle's constructor for detailed parameter information.
   *
   * @param {Bounds2} bounds
   * @param {number} cornerXRadius
   * @param {number} cornerYRadius
   * @param {Object} [options]
   * @returns {Rectangle}
   */
  Rectangle.roundedBounds = function( bounds, cornerXRadius, cornerYRadius, options ) {
    return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, cornerXRadius, cornerYRadius, options );
  };

  /**
   * Creates a rectangle with top/left of (0,0) with the specified {Dimension2}'s width and height.
   * @public
   *
   * See Rectangle's constructor for detailed parameter information.
   *
   * @param {Dimension2} dimension
   * @param {Object} [options]
   * @returns {Rectangle}
   */
  Rectangle.dimension = function( dimension, options ) {
    return new Rectangle( 0, 0, dimension.width, dimension.height, 0, 0, options );
  };

  return Rectangle;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Escaping of HTML content that will be placed in the body, inside an element as a node.
 *
 * This is NOT for escaping something in other HTML contexts, for example as an attribute value
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'PHET_CORE/escapeHTML',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  function escapeHTML( str ) {
    // see https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet
    // HTML Entity Encoding
    return str
      .replace( /&/g, '&amp;' )
      .replace( /</g, '&lt;' )
      .replace( />/g, '&gt;' )
      .replace( /\"/g, '&quot;' )
      .replace( /\'/g, '&#x27;' )
      .replace( /\//g, '&#x2F;' );
  }

  phetCore.register( 'escapeHTML', escapeHTML );

  return escapeHTML;
} );
// Copyright 2016, University of Colorado Boulder

/**
 * Canvas drawable for Text nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/TextCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );

  /**
   * A generated CanvasSelfDrawable whose purpose will be drawing our Text. One of these drawables will be created
   * for each displayed instance of a Text node.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function TextCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'TextCanvasDrawable', TextCanvasDrawable );

  inherit( CanvasSelfDrawable, TextCanvasDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {TextCanvasDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    /**
     * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
     * @public
     *
     * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
     * other required effects (opacity, clipping, etc.) have already been prepared.
     *
     * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
     *
     * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
     * @param {Node} node - Our node that is being drawn
     * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
     */
    paintCanvas: function( wrapper, node, matrix ) {
      var context = wrapper.context;

      // extra parameters we need to set, but should avoid setting if we aren't drawing anything
      if ( node.hasFill() || node.hasPaintableStroke() ) {
        wrapper.setFont( node._font.getFont() );
        wrapper.setDirection( 'ltr' );
      }

      if ( node.hasFill() ) {
        node.beforeCanvasFill( wrapper ); // defined in Paintable
        context.fillText( node.renderedText, 0, 0 );
        node.afterCanvasFill( wrapper ); // defined in Paintable
      }
      if ( node.hasPaintableStroke() ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.strokeText( node.renderedText, 0, 0 );
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },

    // stateless dirty functions
    markDirtyText: function() { this.markPaintDirty(); },
    markDirtyFont: function() { this.markPaintDirty(); },
    markDirtyBounds: function() { this.markPaintDirty(); },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );

  PaintableStatelessDrawable.mixin( TextCanvasDrawable );

  // This sets up TextCanvasDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( TextCanvasDrawable );

  return TextCanvasDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * A mixin to drawables for Text that need to store state about what the current display is currently showing,
 * so that updates to the Text will only be made on attributes that specifically changed (and no change will be
 * necessary for an attribute that changed back to its original/currently-displayed value). Generally, this is used
 * for DOM and SVG drawables.
 *
 * This mixin assumes the PaintableStateful mixin is also mixed (always the case for Text stateful drawables).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/TextStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );

  var TextStatefulDrawable = {
    /**
     * Given the type (constructor) of a drawable, we'll mix in a combination of:
     * - initialization/disposal with the *State suffix
     * - mark* methods to be called on all drawables of nodes of this type, that set specific dirty flags
     *
     * This will allow drawables that mix in this type to do the following during an update:
     * 1. Check specific dirty flags (e.g. if the fill changed, update the fill of our SVG element).
     * 2. Call setToCleanState() once done, to clear the dirty flags.
     *
     * @param {function} drawableType - The constructor for the drawable type
     */
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      /**
       * Initializes the stateful mixin state, starting its "lifetime" until it is disposed with disposeState().
       * @protected
       *
       * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
       * @param {Instance} instance
       * @returns {TextStatefulDrawable} - Returns 'this' reference, for chaining
       */
      proto.initializeState = function( renderer, instance ) {
        // @protected {boolean} - Flag marked as true if ANY of the drawable dirty flags are set (basically everything except for transforms, as we
        //                        need to accelerate the transform case.
        this.paintDirty = true;
        this.dirtyText = true;
        this.dirtyFont = true;
        this.dirtyBounds = true;

        // After adding flags, we'll initialize the mixed-in PaintableStateful state.
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      /**
       * Disposes the stateful mixin state, so it can be put into the pool to be initialized again.
       * @protected
       */
      proto.disposeState = function() {
        this.disposePaintableState();
      };

      /**
       * A "catch-all" dirty method that directly marks the paintDirty flag and triggers propagation of dirty
       * information. This can be used by other mark* methods, or directly itself if the paintDirty flag is checked.
       * @public (scenery-internal)
       *
       * It should be fired (indirectly or directly) for anything besides transforms that needs to make a drawable
       * dirty.
       */
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyText = function() {
        this.dirtyText = true;
        this.markPaintDirty();
      };
      proto.markDirtyFont = function() {
        this.dirtyFont = true;
        this.markPaintDirty();
      };
      proto.markDirtyBounds = function() {
        this.dirtyBounds = true;
        this.markPaintDirty();
      };

      /**
       * Clears all of the dirty flags (after they have been checked), so that future mark* methods will be able to flag them again.
       * @public (scenery-internal)
       */
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyText = false;
        this.dirtyFont = false;
        this.dirtyBounds = false;
      };

      PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  scenery.register( 'TextStatefulDrawable', TextStatefulDrawable );

  return TextStatefulDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * General utility functions for Scenery
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/Util',['require','SCENERY/scenery','DOT/Matrix3','DOT/Transform3','DOT/Bounds2','DOT/Vector2','SCENERY/util/Features'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Features = require( 'SCENERY/util/Features' );

  // convenience function
  function p( x, y ) {
    return new Vector2( x, y );
  }

  // TODO: remove flag and tests after we're done
  var debugChromeBoundsScanning = false;

  // detect properly prefixed transform and transformOrigin properties
  var transformProperty = Features.transform;
  var transformOriginProperty = Features.transformOrigin || 'transformOrigin'; // fallback, so we don't try to set an empty string property later

  var Util = {
    /*---------------------------------------------------------------------------*
     * Transformation Utilities (TODO: separate file)
     *---------------------------------------------------------------------------*/

    /**
     * Prepares a DOM element for use with applyPreparedTransform(). Applies some CSS styles that are required, but
     * that we don't want to set while animating.
     * @public
     *
     * @param {Element} element
     * @param {boolean} forceAcceleration - Whether graphical acceleration should be forced (may slow things down!)
     */
    prepareForTransform: function( element, forceAcceleration ) {
      element.style[ transformOriginProperty ] = 'top left';
      if ( forceAcceleration ) {
        scenery.Util.setTransformAcceleration( element );
      }
      else {
        scenery.Util.unsetTransformAcceleration( element );
      }
    },

    /**
     * Apply CSS styles that will potentially trigger graphical acceleration. Use at your own risk.
     * @private
     *
     * @param {Element} element
     */
    setTransformAcceleration: function( element ) {
      element.style.webkitBackfaceVisibility = 'hidden';
    },

    /**
     * Unapply CSS styles (from setTransformAcceleration) that would potentially trigger graphical acceleration.
     * @private
     *
     * @param {Element} element
     */
    unsetTransformAcceleration: function( element ) {
      element.style.webkitBackfaceVisibility = '';
    },

    /**
     * Applies the CSS transform of the matrix to the element, with optional forcing of acceleration.
     * NOTE: prepareForTransform should be called at least once on the element before this method is used.
     * @public
     *
     * @param {Matrix3} matrix
     * @param {Element} element
     * @param {boolean} forceAcceleration
     */
    applyPreparedTransform: function( matrix, element, forceAcceleration ) {
      // NOTE: not applying translateZ, see http://stackoverflow.com/questions/10014461/why-does-enabling-hardware-acceleration-in-css3-slow-down-performance
      element.style[ transformProperty ] = matrix.getCSSTransform();
    },

    /**
     * Applies a CSS transform value string to a DOM element.
     * NOTE: prepareForTransform should be called at least once on the element before this method is used.
     * @public
     *
     * @param {string} transformString
     * @param {Element} element
     * @param {boolean} forceAcceleration
     */
    setTransform: function( transformString, element, forceAcceleration ) {
      assert && assert( typeof transformString === 'string' );

      element.style[ transformProperty ] = transformString;
    },

    /**
     * Removes a CSS transform from a DOM element.
     * @public
     *
     * @param {Element} element
     */
    unsetTransform: function( element ) {
      element.style[ transformProperty ] = '';
    },

    /**
     * Ensures that window.requestAnimationFrame and window.cancelAnimationFrame use a native implementation if possible,
     * otherwise using a simple setTimeout internally. See https://github.com/phetsims/scenery/issues/426
     * @public
     */
    polyfillRequestAnimationFrame: function() {
      if ( !window.requestAnimationFrame || !window.cancelAnimationFrame ) {
        // Fallback implementation if no prefixed version is available
        if ( !Features.requestAnimationFrame || !Features.cancelAnimationFrame ) {
          window.requestAnimationFrame = function( callback ) {
            var timeAtStart = Date.now();

            return window.setTimeout( function() {
              callback( Date.now() - timeAtStart );
            }, 16 );
          };
          window.cancelAnimationFrame = clearTimeout;
        }
        // Fill in the non-prefixed names with the prefixed versions
        else {
          window.requestAnimationFrame = window[ Features.requestAnimationFrame ];
          window.cancelAnimationFrame = window[ Features.cancelAnimationFrame ];
        }
      }
    },

    /**
     * Returns the relative size of the context's backing store compared to the actual Canvas. For example, if it's 2,
     * the backing store has 2x2 the amount of pixels (4 times total).
     * @public
     *
     * @param {CanvasRenderingContext2D | WebGLRenderingContext} context
     * @returns {number} The backing store pixel ratio.
     */
    backingStorePixelRatio: function( context ) {
      return context.webkitBackingStorePixelRatio ||
             context.mozBackingStorePixelRatio ||
             context.msBackingStorePixelRatio ||
             context.oBackingStorePixelRatio ||
             context.backingStorePixelRatio || 1;
    },

    /**
     * Returns the scaling factor that needs to be applied for handling a HiDPI Canvas
     * See see http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html#//apple_ref/doc/uid/TP40010542-CH2-SW5
     * And it's updated based on http://www.html5rocks.com/en/tutorials/canvas/hidpi/
     * @public
     *
     * @param {CanvasRenderingContext2D | WebGLRenderingContext} context
     * @returns {number}
     */
    backingScale: function( context ) {
      if ( 'devicePixelRatio' in window ) {
        var backingStoreRatio = Util.backingStorePixelRatio( context );

        return window.devicePixelRatio / backingStoreRatio;
      }
      return 1;
    },

    /*---------------------------------------------------------------------------*
     * Text bounds utilities (TODO: separate file)
     *---------------------------------------------------------------------------*/

    /**
     * Given a data snapshot and transform, calculate range on how large / small the bounds can be. It's
     * very conservative, with an effective 1px extra range to allow for differences in anti-aliasing
     * for performance concerns, this does not support skews / rotations / anything but translation and scaling
     * @public
     *
     * @param {ImageData} imageData
     * @param {number} resolution
     * @param {Transform3} transform
     */
    scanBounds: function( imageData, resolution, transform ) {

      // entry will be true if any pixel with the given x or y value is non-rgba(0,0,0,0)
      var dirtyX = _.map( _.range( resolution ), function() { return false; } );
      var dirtyY = _.map( _.range( resolution ), function() { return false; } );

      for ( var x = 0; x < resolution; x++ ) {
        for ( var y = 0; y < resolution; y++ ) {
          var offset = 4 * ( y * resolution + x );
          if ( imageData.data[ offset ] !== 0 || imageData.data[ offset + 1 ] !== 0 || imageData.data[ offset + 2 ] !== 0 || imageData.data[ offset + 3 ] !== 0 ) {
            dirtyX[ x ] = true;
            dirtyY[ y ] = true;
          }
        }
      }

      var minX = _.indexOf( dirtyX, true );
      var maxX = _.lastIndexOf( dirtyX, true );
      var minY = _.indexOf( dirtyY, true );
      var maxY = _.lastIndexOf( dirtyY, true );

      // based on pixel boundaries. for minBounds, the inner edge of the dirty pixel. for maxBounds, the outer edge of the adjacent non-dirty pixel
      // results in a spread of 2 for the identity transform (or any translated form)
      var extraSpread = resolution / 16; // is Chrome antialiasing really like this? dear god... TODO!!!
      return {
        minBounds: new Bounds2(
          ( minX < 1 || minX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( minX + 1 + extraSpread, 0 ) ).x,
          ( minY < 1 || minY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, minY + 1 + extraSpread ) ).y,
          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( maxX - extraSpread, 0 ) ).x,
          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, maxY - extraSpread ) ).y
        ),
        maxBounds: new Bounds2(
          ( minX < 1 || minX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( minX - 1 - extraSpread, 0 ) ).x,
          ( minY < 1 || minY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, minY - 1 - extraSpread ) ).y,
          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( maxX + 2 + extraSpread, 0 ) ).x,
          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, maxY + 2 + extraSpread ) ).y
        )
      };
    },

    /**
     * Measures accurate bounds of a function that draws things to a Canvas.
     * @public
     *
     * @param {function} renderToContext - Called with the Canvas 2D context as a parameter, should draw to it.
     */
    canvasAccurateBounds: function( renderToContext, options ) {
      // how close to the actual bounds do we need to be?
      var precision = ( options && options.precision ) ? options.precision : 0.001;

      // 512x512 default square resolution
      var resolution = ( options && options.resolution ) ? options.resolution : 128;

      // at 1/16x default, we want to be able to get the bounds accurately for something as large as 16x our initial resolution
      // divisible by 2 so hopefully we avoid more quirks from Canvas rendering engines
      var initialScale = ( options && options.initialScale ) ? options.initialScale : ( 1 / 16 );

      var minBounds = Bounds2.NOTHING;
      var maxBounds = Bounds2.EVERYTHING;

      var canvas = document.createElement( 'canvas' );
      canvas.width = resolution;
      canvas.height = resolution;
      var context = canvas.getContext( '2d' );

      if ( debugChromeBoundsScanning ) {
        $( window ).ready( function() {
          var header = document.createElement( 'h2' );
          $( header ).text( 'Bounds Scan' );
          $( '#display' ).append( header );
        } );
      }

      // TODO: Don't use Transform3 unless it is necessary
      function scan( transform ) {
        // save/restore, in case the render tries to do any funny stuff like clipping, etc.
        context.save();
        transform.matrix.canvasSetTransform( context );
        renderToContext( context );
        context.restore();

        var data = context.getImageData( 0, 0, resolution, resolution );
        var minMaxBounds = Util.scanBounds( data, resolution, transform );

        function snapshotToCanvas( snapshot ) {
          var canvas = document.createElement( 'canvas' );
          canvas.width = resolution;
          canvas.height = resolution;
          var context = canvas.getContext( '2d' );
          context.putImageData( snapshot, 0, 0 );
          $( canvas ).css( 'border', '1px solid black' );
          $( window ).ready( function() {
            //$( '#display' ).append( $( document.createElement( 'div' ) ).text( 'Bounds: ' +  ) );
            $( '#display' ).append( canvas );
          } );
        }

        // TODO: remove after debug
        if ( debugChromeBoundsScanning ) {
          snapshotToCanvas( data );
        }

        context.clearRect( 0, 0, resolution, resolution );

        return minMaxBounds;
      }

      // attempts to map the bounds specified to the entire testing canvas (minus a fine border), so we can nail down the location quickly
      function idealTransform( bounds ) {
        // so that the bounds-edge doesn't land squarely on the boundary
        var borderSize = 2;

        var scaleX = ( resolution - borderSize * 2 ) / ( bounds.maxX - bounds.minX );
        var scaleY = ( resolution - borderSize * 2 ) / ( bounds.maxY - bounds.minY );
        var translationX = -scaleX * bounds.minX + borderSize;
        var translationY = -scaleY * bounds.minY + borderSize;

        return new Transform3( Matrix3.translation( translationX, translationY ).timesMatrix( Matrix3.scaling( scaleX, scaleY ) ) );
      }

      var initialTransform = new Transform3();
      // make sure to initially center our object, so we don't miss the bounds
      initialTransform.append( Matrix3.translation( resolution / 2, resolution / 2 ) );
      initialTransform.append( Matrix3.scaling( initialScale ) );

      var coarseBounds = scan( initialTransform );

      minBounds = minBounds.union( coarseBounds.minBounds );
      maxBounds = maxBounds.intersection( coarseBounds.maxBounds );

      var tempMin;
      var tempMax;
      var refinedBounds;

      // minX
      tempMin = maxBounds.minY;
      tempMax = maxBounds.maxY;
      while ( isFinite( minBounds.minX ) && isFinite( maxBounds.minX ) && Math.abs( minBounds.minX - maxBounds.minX ) > precision ) {
        // use maximum bounds except for the x direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( maxBounds.minX, tempMin, minBounds.minX, tempMax ) ) );

        if ( minBounds.minX <= refinedBounds.minBounds.minX && maxBounds.minX >= refinedBounds.maxBounds.minX ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
            console.log( 'transformed "min" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( minBounds.minX, 0 ) ) );
            console.log( 'transformed "max" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( maxBounds.minX, 0 ) ) );
          }
          break;
        }

        minBounds = minBounds.withMinX( Math.min( minBounds.minX, refinedBounds.minBounds.minX ) );
        maxBounds = maxBounds.withMinX( Math.max( maxBounds.minX, refinedBounds.maxBounds.minX ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
      }

      // maxX
      tempMin = maxBounds.minY;
      tempMax = maxBounds.maxY;
      while ( isFinite( minBounds.maxX ) && isFinite( maxBounds.maxX ) && Math.abs( minBounds.maxX - maxBounds.maxX ) > precision ) {
        // use maximum bounds except for the x direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( minBounds.maxX, tempMin, maxBounds.maxX, tempMax ) ) );

        if ( minBounds.maxX >= refinedBounds.minBounds.maxX && maxBounds.maxX <= refinedBounds.maxBounds.maxX ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }

        minBounds = minBounds.withMaxX( Math.max( minBounds.maxX, refinedBounds.minBounds.maxX ) );
        maxBounds = maxBounds.withMaxX( Math.min( maxBounds.maxX, refinedBounds.maxBounds.maxX ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
      }

      // minY
      tempMin = maxBounds.minX;
      tempMax = maxBounds.maxX;
      while ( isFinite( minBounds.minY ) && isFinite( maxBounds.minY ) && Math.abs( minBounds.minY - maxBounds.minY ) > precision ) {
        // use maximum bounds except for the y direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( tempMin, maxBounds.minY, tempMax, minBounds.minY ) ) );

        if ( minBounds.minY <= refinedBounds.minBounds.minY && maxBounds.minY >= refinedBounds.maxBounds.minY ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }

        minBounds = minBounds.withMinY( Math.min( minBounds.minY, refinedBounds.minBounds.minY ) );
        maxBounds = maxBounds.withMinY( Math.max( maxBounds.minY, refinedBounds.maxBounds.minY ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
      }

      // maxY
      tempMin = maxBounds.minX;
      tempMax = maxBounds.maxX;
      while ( isFinite( minBounds.maxY ) && isFinite( maxBounds.maxY ) && Math.abs( minBounds.maxY - maxBounds.maxY ) > precision ) {
        // use maximum bounds except for the y direction, so we don't miss things that we are looking for
        refinedBounds = scan( idealTransform( new Bounds2( tempMin, minBounds.maxY, tempMax, maxBounds.maxY ) ) );

        if ( minBounds.maxY >= refinedBounds.minBounds.maxY && maxBounds.maxY <= refinedBounds.maxBounds.maxY ) {
          // sanity check - break out of an infinite loop!
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }

        minBounds = minBounds.withMaxY( Math.max( minBounds.maxY, refinedBounds.minBounds.maxY ) );
        maxBounds = maxBounds.withMaxY( Math.min( maxBounds.maxY, refinedBounds.maxBounds.maxY ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
      }

      if ( debugChromeBoundsScanning ) {
        console.log( 'minBounds: ' + minBounds );
        console.log( 'maxBounds: ' + maxBounds );
      }

      var result = new Bounds2(
        ( minBounds.minX + maxBounds.minX ) / 2,
        ( minBounds.minY + maxBounds.minY ) / 2,
        ( minBounds.maxX + maxBounds.maxX ) / 2,
        ( minBounds.maxY + maxBounds.maxY ) / 2
      );

      // extra data about our bounds
      result.minBounds = minBounds;
      result.maxBounds = maxBounds;
      result.isConsistent = maxBounds.containsBounds( minBounds );
      result.precision = Math.max(
        Math.abs( minBounds.minX - maxBounds.minX ),
        Math.abs( minBounds.minY - maxBounds.minY ),
        Math.abs( minBounds.maxX - maxBounds.maxX ),
        Math.abs( minBounds.maxY - maxBounds.maxY )
      );

      // return the average
      return result;
    },

    /*---------------------------------------------------------------------------*
     * WebGL utilities (TODO: separate file)
     *---------------------------------------------------------------------------*/

    /**
     * Finds the smallest power of 2 that is at least as large as n.
     * @public
     *
     * @param {number} n
     * @returns {number} The smallest power of 2 that is greater than or equal n
     */
    toPowerOf2: function( n ) {
      var result = 1;
      while ( result < n ) {
        result *= 2;
      }
      return result;
    },

    /*
     * Creates and compiles a GLSL Shader object in WebGL.
     * @public
     *
     * @param {WebGLRenderingContext} - WebGL Rendering Context
     * @param {number} type - Should be: gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
     * @param {tring} source - The shader source code.
     */
    createShader: function( gl, source, type ) {
      var shader = gl.createShader( type );
      gl.shaderSource( shader, source );
      gl.compileShader( shader );

      if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
        console.log( 'GLSL compile error:' );
        console.log( gl.getShaderInfoLog( shader ) );
        console.log( source );

        // Normally it would be best to throw an exception here, but a context loss could cause the shader parameter check
        // to fail, and we must handle context loss gracefully between any adjacent pair of gl calls.
        // Therefore, we simply report the errors to the console.  See #279
      }

      return shader;
    },

    applyWebGLContextDefaults: function( gl ) {
      // What color gets set when we call gl.clear()
      gl.clearColor( 0, 0, 0, 0 );

      // Blending similar to http://localhost/phet/git/webgl-blendfunctions/blendfuncseparate.html
      gl.enable( gl.BLEND );
      gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
      gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
    },

    /**
     * Check to see whether webgl is supported, using the same strategy as mrdoob and pixi.js
     * @public
     *
     * @param {Array.<string>} [extensions] - A list of WebGL extensions that need to be supported
     * @returns {boolean}
     */
    checkWebGLSupport: function( extensions ) {
      var canvas = document.createElement( 'canvas' );

      var args = { failIfMajorPerformanceCaveat: true };
      try {
        var gl = !!window.WebGLRenderingContext &&
                 ( canvas.getContext( 'webgl', args ) || canvas.getContext( 'experimental-webgl', args ) );

        if ( !gl ) {
          return false;
        }

        if ( extensions ) {
          for ( var i = 0; i < extensions.length; i++ ) {
            if ( gl.getExtension( extensions[ i ] ) === null ) {
              return false;
            }
          }
        }

        return true;
      }
      catch( e ) {
        return false;
      }
    },

    /**
     * Check to see whether IE11 has proper clearStencil support (required for three.js to work well).
     * @public
     *
     * @returns {boolean}
     */
    checkIE11StencilSupport: function() {
      var canvas = document.createElement( 'canvas' );

      try {
        var gl = !!window.WebGLRenderingContext &&
                 ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );

        if ( !gl ) {
          return false;
        }

        // Failure for https://github.com/mrdoob/three.js/issues/3600 / https://github.com/phetsims/molecule-shapes/issues/133
        gl.clearStencil( 0 );
        return gl.getError() === 0;
      }
      catch( e ) {
        return false;
      }
    },

    /**
     * Whether WebGL (with decent performance) is supported by the platform
     * @public {boolean}
     */
    get isWebGLSupported() {
      if ( this._extensionlessWebGLSupport === undefined ) {
        this._extensionlessWebGLSupport = scenery.Util.checkWebGLSupport();
      }
      return this._extensionlessWebGLSupport;
    },

    /**
     * Triggers a loss of a WebGL context, with a delayed restoration.
     * @public
     *
     * NOTE: Only use this for debugging. Should not be called normally.
     *
     * @param {WebGLRenderingContext} gl
     */
    loseContext: function( gl ) {
      var extension = gl.getExtension( 'WEBGL_lose_context' );
      if ( extension ) {
        extension.loseContext();

        setTimeout( function() {
          extension.restoreContext();
        }, 1000 );
      }
    }
  };
  scenery.register( 'Util', Util );

  return Util;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * DOM drawable for Text nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/TextDOMDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Matrix3','SCENERY/display/DOMSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/TextStatefulDrawable','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var TextStatefulDrawable = require( 'SCENERY/display/drawables/TextStatefulDrawable' );
  require( 'SCENERY/util/Util' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepDOMTextElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory

  // scratch matrix used in DOM rendering
  var scratchMatrix = Matrix3.dirtyFromPool();

  /**
   * A generated DOMSelfDrawable whose purpose will be drawing our Text node. One of these drawables will be created
   * for each displayed instance of a Text node.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function TextDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'TextDOMDrawable', TextDOMDrawable );

  inherit( DOMSelfDrawable, TextDOMDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {TextDOMDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeDOMSelfDrawable( renderer, instance );

      // Stateful mix-in initialization
      this.initializeState( renderer, instance );

      // only create elements if we don't already have them (we pool visual states always, and depending on the platform may also pool the actual elements to minimize
      // allocation and performance costs)
      if ( !this.domElement ) {
        // @protected {HTMLElement} - Our primary DOM element. This is exposed as part of the DOMSelfDrawable API.
        this.domElement = document.createElement( 'div' );
        this.domElement.style.display = 'block';
        this.domElement.style.position = 'absolute';
        this.domElement.style.pointerEvents = 'none';
        this.domElement.style.left = '0';
        this.domElement.style.top = '0';
        this.domElement.setAttribute( 'dir', 'ltr' );
      }

      // Apply CSS needed for future CSS transforms to work properly.
      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    /**
     * Updates our DOM element so that its appearance matches our node's representation.
     * @protected
     *
     * This implements part of the DOMSelfDrawable required API for subtypes.
     */
    updateDOM: function() {
      var node = this.node;

      var div = this.domElement;

      if ( this.paintDirty ) {
        if ( this.dirtyFont ) {
          div.style.font = node.getFont();
        }
        if ( this.dirtyStroke ) {
          div.style.color = node.getCSSFill();
        }
        if ( this.dirtyBounds ) { // TODO: this condition is set on invalidateText, so it's almost always true?
          div.style.width = node.getSelfBounds().width + 'px';
          div.style.height = node.getSelfBounds().height + 'px';
          // TODO: do we require the jQuery versions here, or are they vestigial?
          // $div.width( node.getSelfBounds().width );
          // $div.height( node.getSelfBounds().height );
        }
        if ( this.dirtyText ) {
          div.textContent = node.renderedText;
        }
      }

      if ( this.transformDirty || this.dirtyText || this.dirtyFont || this.dirtyBounds ) {
        // shift the text vertically, postmultiplied with the entire transform.
        var yOffset = node.getSelfBounds().minY;
        scratchMatrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( 0, yOffset );
        scratchMatrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( scratchMatrix, div, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToCleanState();
      this.cleanPaintableState();
      this.transformDirty = false;
    },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      this.disposeState();

      if ( !keepDOMTextElements ) {
        // clear the references
        this.domElement = null;
      }

      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  TextStatefulDrawable.mixin( TextDOMDrawable );
  // This sets up TextDOMDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( TextDOMDrawable );

  return TextDOMDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * SVG drawable for Text nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/TextSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','PHET_CORE/platform','SCENERY/display/SVGSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/TextStatefulDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var platform = require( 'PHET_CORE/platform' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var TextStatefulDrawable = require( 'SCENERY/display/drawables/TextStatefulDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepSVGTextElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  // Some browsers (IE/Edge) can't handle our UTF-8 embedding marks AND SVG textLength/spacingAndGlyphs. We disable
  // using these features, because they aren't necessary on these browsers.
  // See https://github.com/phetsims/scenery/issues/455 for more information.
  var useSVGTextLengthAdjustments = !platform.ie && !platform.edge;

  /**
   * A generated SVGSelfDrawable whose purpose will be drawing our Text. One of these drawables will be created
   * for each displayed instance of a Text node.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function TextSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'TextSVGDrawable', TextSVGDrawable );

  inherit( SVGSelfDrawable, TextSVGDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {TextSVGDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGTextElements ); // usesPaint: true

      if ( !this.svgElement ) {
        // @protected {SVGTextElement} - Sole SVG element for this drawable, implementing API for SVGSelfDrawable
        var text = this.svgElement = document.createElementNS( scenery.svgns, 'text' );
        text.appendChild( document.createTextNode( '' ) );

        // TODO: flag adjustment for SVG qualities
        text.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
        text.setAttribute( 'text-rendering', 'geometricPrecision' );
        if ( useSVGTextLengthAdjustments ) {
          text.setAttribute( 'lengthAdjust', 'spacingAndGlyphs' );
        }
        text.setAttributeNS( 'http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve' );
        text.setAttribute( 'direction', 'ltr' );
      }

      return this;
    },

    /**
     * Updates the SVG elements so that they will appear like the current node's representation.
     * @protected
     *
     * Implements the interface for SVGSelfDrawable (and is called from the SVGSelfDrawable's update).
     */
    updateSVGSelf: function() {
      var text = this.svgElement;

      // set all of the font attributes, since we can't use the combined one
      if ( this.dirtyFont ) {
        text.setAttribute( 'font-family', this.node._font.getFamily() );
        text.setAttribute( 'font-size', this.node._font.getSize() );
        text.setAttribute( 'font-style', this.node._font.getStyle() );
        text.setAttribute( 'font-weight', this.node._font.getWeight() );
        text.setAttribute( 'font-stretch', this.node._font.getStretch() );
      }

      // update the text-node's value
      if ( this.dirtyText ) {
        text.lastChild.nodeValue = this.node.renderedText;
      }

      // text length correction, tested with scenery/tests/text-quality-test.html to determine how to match Canvas/SVG rendering (and overall length)
      if ( this.dirtyBounds && useSVGTextLengthAdjustments && isFinite( this.node.selfBounds.width ) ) {
        text.setAttribute( 'textLength', this.node.selfBounds.width );
      }

      // Apply any fill/stroke changes to our element.
      this.updateFillStrokeStyle( text );
    }
  } );

  TextStatefulDrawable.mixin( TextSVGDrawable );

  // This sets up TextSVGDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( TextSVGDrawable );

  return TextSVGDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Different methods of detection of text bounds.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/TextBounds',['require','SCENERY/scenery','SCENERY/util/Font','DOT/Bounds2','SCENERY/util/Util','SCENERY/util/CanvasContextWrapper'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var Font = require( 'SCENERY/util/Font' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Util = require( 'SCENERY/util/Util' );
  var CanvasContextWrapper = require( 'SCENERY/util/CanvasContextWrapper' );

  // @private {string} - ID for a container for our SVG test element (determined to find the size of text elements with SVG)
  var TEXT_SIZE_CONTAINER_ID = 'sceneryTextSizeContainer';

  // @private {string} - ID for our SVG test element (determined to find the size of text elements with SVG)
  var TEXT_SIZE_ELEMENT_ID = 'sceneryTextSizeElement';

  // @private {SVGElement} - Container for our SVG test element (determined to find the size of text elements with SVG)
  var svgTextSizeContainer;

  // @private {SVGElement} - Test SVG element (determined to find the size of text elements with SVG)
  var svgTextSizeElement;

  // Maps CSS {string} => {Bounds2}, so that we can cache the vertical font sizes outside of the Font objects themselves.
  var hybridFontVerticalCache = {};

  var TextBounds = {
    /**
     * Returns a new Bounds2 that is the approximate bounds of a Text node displayed with the specified font and renderedText.
     * @public
     *
     * This method uses an SVG Text element, sets its text, and then determines its size to estimate the size of rendered text.
     *
     * NOTE: Calling code relies on the new Bounds2 instance, as they mutate it.
     *
     * @param {Font} font - The font of the text
     * @param {string} renderedText - Text to display (with any special characters replaced)
     * @returns {Bounds2}
     */
    approximateSVGBounds: function( font, renderedText ) {
      assert && assert( font instanceof Font, 'Font required' );
      assert && assert( typeof renderedText === 'string', 'renderedText required' );

      if ( !svgTextSizeContainer.parentNode ) {
        if ( document.body ) {
          document.body.appendChild( svgTextSizeContainer );
        }
        else {
          throw new Error( 'No document.body and trying to get approximate SVG bounds of a Text node' );
        }
      }
      TextBounds.setSVGTextAttributes( svgTextSizeElement, font, renderedText );
      var rect = svgTextSizeElement.getBBox();
      return new Bounds2( rect.x, rect.y, rect.x + rect.width, rect.y + rect.height );
    },

    /**
     * Returns a new Bounds2 that is the approximate bounds of the specified Text node.
     * @public
     *
     * This method repeatedly renders the text into a Canvas and checks for what pixels are filled. Iteratively doing this for each bound
     * (top/left/bottom/right) until a tolerance results in very accurate bounds of what is displayed.
     *
     * NOTE: Calling code relies on the new Bounds2 instance, as they mutate it.
     *
     * @param {Text} text - The Text node
     * @returns {Bounds2}
     */
    accurateCanvasBounds: function( text ) {
      var svgBounds = TextBounds.approximateSVGBounds( text._font, text.renderedText ); // this seems to be slower than expected, mostly due to Font getters

      //If svgBounds are zero, then return the zero bounds
      if ( !text.renderedText.length || svgBounds.width === 0 ) {
        return svgBounds;
      }

      // NOTE: should return new instance, so that it can be mutated later
      return Util.canvasAccurateBounds( function( context ) {
        context.font = text._font.toCSS();
        context.direction = 'ltr';
        context.fillText( text.renderedText, 0, 0 );
        if ( text.hasPaintableStroke() ) {
          var fakeWrapper = new CanvasContextWrapper( null, context );
          text.beforeCanvasStroke( fakeWrapper );
          context.strokeText( text.renderedText, 0, 0 );
          text.afterCanvasStroke( fakeWrapper );
        }
      }, {
        precision: 0.5,
        resolution: 128,
        initialScale: 32 / Math.max( Math.abs( svgBounds.minX ), Math.abs( svgBounds.minY ), Math.abs( svgBounds.maxX ), Math.abs( svgBounds.maxY ) )
      } );
    },

    /**
     * Returns a possibly-cached (treat as immutable) Bounds2 for use mainly for vertical parameters, given a specific Font.
     * @public
     *
     * Uses SVG bounds determination for this value.
     *
     * @param {Font} font - The font of the text
     * @returns {Bounds2}
     */
    getVerticalBounds: function( font ) {
      assert && assert( font instanceof Font, 'Font required' );

      var css = font.toCSS();

      // Cache these, as it's more expensive
      var verticalBounds = hybridFontVerticalCache[ css ];
      if ( !verticalBounds ) {
        verticalBounds = hybridFontVerticalCache[ css ] = TextBounds.approximateSVGBounds( font, 'm' );
      }

      return verticalBounds;
    },

    /**
     * Returns an approximate width for text, determined by using Canvas' measureText().
     * @public
     *
     * @param {Font} font - The font of the text
     * @param {string} renderedText - Text to display (with any special characters replaced)
     * @returns {number}
     */
    approximateCanvasWidth: function( font, renderedText ) {
      assert && assert( font instanceof Font, 'Font required' );
      assert && assert( typeof renderedText === 'string', 'renderedText required' );

      var context = scenery.scratchContext;
      context.font = font.toCSS();
      context.direction = 'ltr';
      return context.measureText( renderedText ).width;
    },

    /**
     * Returns a new Bounds2 that is the approximate bounds of a Text node displayed with the specified font and renderedText.
     * @public
     *
     * This method uses a hybrid approach, using SVG measurement to determine the height, but using Canvas to determine the width.
     *
     * NOTE: Calling code relies on the new Bounds2 instance, as they mutate it.
     *
     * @param {Font} font - The font of the text
     * @param {string} renderedText - Text to display (with any special characters replaced)
     * @returns {Bounds2}
     */
    approximateHybridBounds: function( font, renderedText ) {
      assert && assert( font instanceof Font, 'Font required' );
      assert && assert( typeof renderedText === 'string', 'renderedText required' );

      var verticalBounds = TextBounds.getVerticalBounds( font );

      var canvasWidth = TextBounds.approximateCanvasWidth( font, renderedText );

      // it seems that SVG bounds generally have x=0, so we hard code that here
      return new Bounds2( 0, verticalBounds.minY, canvasWidth, verticalBounds.maxY );
    },

    /**
     * Returns a new Bounds2 that is the approximate bounds of a Text node displayed with the specified font, given a DOM element
     * @public
     *
     * NOTE: Calling code relies on the new Bounds2 instance, as they mutate it.
     *
     * @param {Font} font - The font of the text
     * @param {Element} element - DOM element created for the text. This is required, as the text handles HTML and non-HTML text differently.
     * @returns {Bounds2}
     */
    approximateDOMBounds: function( font, element ) {
      assert && assert( font instanceof Font, 'Font required' );

      var maxHeight = 1024; // technically this will fail if the font is taller than this!

      // <div style="position: absolute; left: 0; top: 0; padding: 0 !important; margin: 0 !important;"><span id="baselineSpan" style="font-family: Verdana; font-size: 25px;">QuipTaQiy</span><div style="vertical-align: baseline; display: inline-block; width: 0; height: 500px; margin: 0 important!; padding: 0 important!;"></div></div>

      var div = document.createElement( 'div' );
      $( div ).css( {
        position: 'absolute',
        left: 0,
        top: 0,
        padding: '0 !important',
        margin: '0 !important',
        display: 'hidden'
      } );

      var span = document.createElement( 'span' );
      $( span ).css( 'font', font.toCSS() );
      span.appendChild( element );
      span.setAttribute( 'direction', 'ltr' );

      var fakeImage = document.createElement( 'div' );
      $( fakeImage ).css( {
        'vertical-align': 'baseline',
        display: 'inline-block',
        width: 0,
        height: maxHeight + 'px',
        margin: '0 !important',
        padding: '0 !important'
      } );

      div.appendChild( span );
      div.appendChild( fakeImage );

      document.body.appendChild( div );
      var rect = span.getBoundingClientRect();
      var divRect = div.getBoundingClientRect();
      // add 1 pixel to rect.right to prevent HTML text wrapping
      var result = new Bounds2( rect.left, rect.top - maxHeight, rect.right + 1, rect.bottom - maxHeight ).shifted( -divRect.left, -divRect.top );
      document.body.removeChild( div );

      return result;
    },

    /**
     * Returns a new Bounds2 that is the approximate bounds of a Text node displayed with the specified font, given a DOM element
     * @public
     *
     * TODO: Can we use this? What are the differences?
     *
     * NOTE: Calling code relies on the new Bounds2 instance, as they mutate it.
     *
     * @param {Font} font - The font of the text
     * @param {Element} element - DOM element created for the text. This is required, as the text handles HTML and non-HTML text differently.
     * @returns {Bounds2}
     */
    approximateImprovedDOMBounds: function( font, element ) {
      assert && assert( font instanceof Font, 'Font required' );

      // TODO: reuse this div?
      var div = document.createElement( 'div' );
      div.style.display = 'inline-block';
      div.style.font = font.toCSS();
      div.style.color = 'transparent';
      div.style.padding = '0 !important';
      div.style.margin = '0 !important';
      div.style.position = 'absolute';
      div.style.left = '0';
      div.style.top = '0';
      div.setAttribute( 'direction', 'ltr' );
      div.appendChild( element );

      document.body.appendChild( div );
      var bounds = new Bounds2( div.offsetLeft, div.offsetTop, div.offsetLeft + div.offsetWidth + 1, div.offsetTop + div.offsetHeight + 1 );
      document.body.removeChild( div );

      // Compensate for the baseline alignment
      var verticalBounds = TextBounds.getVerticalBounds( font );
      return bounds.shiftedY( verticalBounds.minY );
    },

    /**
     * Modifies an SVG text element's properties to match the specified font and text.
     * @public
     *
     * @param {SVGTextElement} textElement
     * @param {Font} font - The font of the text
     * @param {string} renderedText - Text to display (with any special characters replaced)
     */
    setSVGTextAttributes: function( textElement, font, renderedText ) {
      assert && assert( font instanceof Font, 'Font required' );
      assert && assert( typeof renderedText === 'string', 'renderedText required' );

      textElement.setAttribute( 'direction', 'ltr' );
      textElement.setAttribute( 'font-family', font.getFamily() );
      textElement.setAttribute( 'font-size', font.getSize() );
      textElement.setAttribute( 'font-style', font.getStyle() );
      textElement.setAttribute( 'font-weight', font.getWeight() );
      textElement.setAttribute( 'font-stretch', font.getStretch() );
      textElement.lastChild.nodeValue = renderedText;
    },

    /**
     * Initializes containers and elements required for SVG text measurement.
     * @public
     */
    initializeTextBounds: function() {
      svgTextSizeContainer = document.getElementById( TEXT_SIZE_CONTAINER_ID );

      if ( !svgTextSizeContainer ) {
        // set up the container and text for testing text bounds quickly (using approximateSVGBounds)
        svgTextSizeContainer = document.createElementNS( scenery.svgns, 'svg' );
        svgTextSizeContainer.setAttribute( 'width', '2' );
        svgTextSizeContainer.setAttribute( 'height', '2' );
        svgTextSizeContainer.setAttribute( 'id', TEXT_SIZE_CONTAINER_ID );
        svgTextSizeContainer.setAttribute( 'style', 'visibility: hidden; pointer-events: none; position: absolute; left: -65535px; right: -65535px;' ); // so we don't flash it in a visible way to the user
      }

      svgTextSizeElement = document.getElementById( TEXT_SIZE_ELEMENT_ID );

      // NOTE! copies createSVGElement
      if ( !svgTextSizeElement ) {
        svgTextSizeElement = document.createElementNS( scenery.svgns, 'text' );
        svgTextSizeElement.appendChild( document.createTextNode( '' ) );
        svgTextSizeElement.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
        svgTextSizeElement.setAttribute( 'text-rendering', 'geometricPrecision' );
        svgTextSizeElement.setAttributeNS( 'http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve' );
        svgTextSizeElement.setAttribute( 'id', TEXT_SIZE_ELEMENT_ID );
        svgTextSizeContainer.appendChild( svgTextSizeElement );
      }
    }
  };

  scenery.register( 'TextBounds', TextBounds );

  return TextBounds;
} );


define("PHET_IO/types/TString", function(){return function(){ return function(){}; };});
// Copyright 2016-2017, University of Colorado Boulder

/**
 * Wrapper type for scenery's Text node.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Denzell Barnett (PhET Interactive Simulations)
 */
define( 'SCENERY/nodes/TText',['require','SCENERY/scenery','SCENERY/util/TFont','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/phetioEvents','ifphetio!PHET_IO/types/TNumber','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );
  var TFont = require( 'SCENERY/util/TFont' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var phetioEvents = require( 'ifphetio!PHET_IO/phetioEvents' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );

  /**
   * Wrapper type for scenery's Text node.
   * @param {Text} text
   * @param {string} phetioID
   * @constructor
   */
  function TText( text, phetioID ) {
    TNode.call( this, text, phetioID );
    assertInstanceOf( text, phet.scenery.Text );
    text.on( 'text', function( oldText, newText ) {
      phetioEvents.trigger( 'model', phetioID, TText, 'textChanged', {
        oldText: oldText,
        newText: newText
      } );
    } );
  }

  phetioInherit( TNode, 'TText', TText, {

    addTextChangedListener: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [ TString ] ) ],
      implementation: function( listener ) {
        this.instance.on( 'text', function( oldText, newText ) {
          listener( newText );
        } );
      },
      documentation: 'Add a listener for when the text has changed.'
    },

    setText: {
      returnType: TVoid,
      parameterTypes: [ TString ],
      implementation: function( text ) {
        this.instance.text = text;
      },
      documentation: 'Set the text content'
    },

    getText: {
      returnType: TString,
      parameterTypes: [],
      implementation: function() {
        return this.instance.text;
      },
      documentation: 'Get the text content'
    },

    setFontOptions: {
      returnType: TVoid,
      parameterTypes: [ TFont ],
      implementation: function( font ) {
        this.instance.setFont( font );
      },
      documentation: 'Set font options for this TText instance, e.g. {size: 16, weight: bold}'
    },

    getFontOptions: {
      returnType: TFont,
      parameterTypes: [],
      implementation: function() {
        return this.instance.getFont();
      },
      documentation: 'Get font options for this TText instance as an object'
    },

    setMaxWidth: {
      returnType: TVoid,
      parameterTypes: [ TNumber() ],
      implementation: function( maxWidth ) {
        this.instance.setMaxWidth( maxWidth );
      },
      documentation: 'Set maximum width of text box in px. ' +
                     'If text is wider than maxWidth at its default font size, it is scaled down to fit.'
    },

    getMaxWidth: {
      returnType: TNumber(),
      parameterTypes: [],
      implementation: function() {
        return this.instance.maxWidth;
      },
      documentation: 'Get maximum width of text box in px'
    }
  }, {
    documentation: 'The tandem wrapper type for the scenery Text node',
    events: [ 'textChanged' ]
  } );

  scenery.register( 'TText', TText );

  return TText;
} );
// Copyright 2013-2016, University of Colorado Boulder

/**
 * Displays text that can be filled/stroked.
 *
 * For many font/text-related properties, it's helpful to understand the CSS equivalents (http://www.w3.org/TR/css3-fonts/).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Text',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','PHET_CORE/escapeHTML','PHET_CORE/platform','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/nodes/Paintable','SCENERY/util/Font','TANDEM/Tandem','SCENERY/display/drawables/TextCanvasDrawable','SCENERY/display/drawables/TextDOMDrawable','SCENERY/display/drawables/TextSVGDrawable','SCENERY/util/TextBounds','SCENERY/nodes/TText'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var escapeHTML = require( 'PHET_CORE/escapeHTML' );
  var platform = require( 'PHET_CORE/platform' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );
  var Font = require( 'SCENERY/util/Font' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TextCanvasDrawable = require( 'SCENERY/display/drawables/TextCanvasDrawable' );
  var TextDOMDrawable = require( 'SCENERY/display/drawables/TextDOMDrawable' );
  var TextSVGDrawable = require( 'SCENERY/display/drawables/TextSVGDrawable' );
  var TextBounds = require( 'SCENERY/util/TextBounds' );
  var TText = require( 'SCENERY/nodes/TText' );

  // constants
  var TEXT_OPTION_KEYS = [
    'boundsMethod', // Sets how bounds are determined for text, see setBoundsMethod() for more documentation
    'text', // Sets the text to be displayed, see setText() for more documentation
    'font', // Sets the font used for the text, see setFont() for more documentation
    'fontWeight', // Sets the weight of the current font, see setFont() for more documentation
    'fontFamily', // Sets the family of the current font, see setFont() for more documentation
    'fontStretch', // Sets the stretch of the current font, see setFont() for more documentation
    'fontStyle', // Sets the style of the current font, see setFont() for more documentation
    'fontSize' // Sets the size of the current font, see setFont() for more documentation
  ];

  // SVG bounds seems to be malfunctioning for Safari 5. Since we don't have a reproducible test machine for
  // fast iteration, we'll guess the user agent and use DOM bounds instead of SVG.
  // Hopefully the two contraints rule out any future Safari versions (fairly safe, but not impossible!)
  // @private {boolean}
  var useDOMAsFastBounds = window.navigator.userAgent.indexOf( 'like Gecko) Version/5' ) !== -1 &&
                           window.navigator.userAgent.indexOf( 'Safari/' ) !== -1;

  /**
   * @public
   * @constructor
   * @extends Node
   *
   * @param {string|number} text - See setText() for more documentation
   * @param {Object} [options] - Text-specific options are documented in TEXT_OPTION_KEYS above, and can be provided
   *                             along-side options for Node
   */
  function Text( text, options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );

    // @private {string} - The text to display. We'll initialize this by mutating.
    this._text = '';

    // @private {Font} - The font with which to display the text.
    this._font = Font.DEFAULT;

    // @private {string}
    this._boundsMethod = 'hybrid';

    // @private {boolean} - Whether the text is rendered as HTML or not. if defined (in a subtype constructor), use that value instead
    this._isHTML = this._isHTML === undefined ? false : this._isHTML;

    // {null|string} - The actual string displayed (can have non-breaking spaces and embedding marks rewritten).
    // When this is null, its value needs to be recomputed
    this._cachedRenderedText = null;

    this.initializePaintable();

    options = extendDefined( {
      fill: '#000000', // Default to black filled text
      text: text,
      tandem: Tandem.tandemOptional(),
      phetioType: TText
    }, options );

    Node.call( this, options );

    this.invalidateSupportedRenderers(); // takes care of setting up supported renderers
  }

  scenery.register( 'Text', Text );

  inherit( Node, Text, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: TEXT_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),

    /**
     * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
     *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
     *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
     * @public (scenery-internal)
     * @override
     */
    drawableMarkFlags: Node.prototype.drawableMarkFlags.concat( [ 'text', 'font', 'bounds' ] ),

    /**
     * Sets the text displayed by our node.
     * @public
     *
     * @param {string|number} text - The text to display. If it's a number, it will be cast to a string
     * @returns {Text} - For chaining
     */
    setText: function( text ) {
      assert && assert( text !== null && text !== undefined, 'Text should be defined and non-null. Use the empty string if needed.' );
      assert && assert( typeof text === 'number' || typeof text === 'string', 'text should be a string or number' );

      // cast it to a string (for numbers, etc., and do it before the change guard so we don't accidentally trigger on non-changed text)
      text = '' + text;

      if ( text !== this._text ) {
        var oldText = this._text;
        this._text = text;
        this._cachedRenderedText = null;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyText();
        }

        this.invalidateText();
        this.trigger2( 'text', oldText, text );
      }
      return this;
    },
    set text( value ) { this.setText( value ); },

    /**
     * Returns the text displayed by our node.
     * @public
     *
     * NOTE: If a number was provided to setText(), it will not be returned as a number here.
     *
     * @returns {string}
     */
    getText: function() {
      return this._text;
    },
    get text() { return this.getText(); },

    /**
     * Returns a potentially modified version of this.text, where spaces are replaced with non-breaking spaces,
     * and embedding marks are potentially simplified.
     * @public
     *
     * @returns {string}
     */
    getRenderedText: function() {
      if ( this._cachedRenderedText === null ) {
        // Using the non-breaking space (&nbsp;) encoded as 0x00A0 in UTF-8
        this._cachedRenderedText = this._text.replace( ' ', '\xA0' );

        if ( platform.edge ) {
          // Simplify embedding marks to work around an Edge bug, see https://github.com/phetsims/scenery/issues/520
          this._cachedRenderedText = Text.simplifyEmbeddingMarks( this._cachedRenderedText );
        }
      }

      return this._cachedRenderedText;
    },
    get renderedText() { return this.getRenderedText(); },

    /**
     * Sets the method that is used to determine bounds from the text.
     * @public
     *
     * Possible values:
     * - 'fast' - Measures using SVG, can be inaccurate. Can't be rendered in Canvas.
     * - 'fastCanvas' - Like 'fast', but allows rendering in Canvas.
     * - 'accurate' - Recursively renders to a Canvas to accurately determine bounds. Slow, but works with all renderers.
     * - 'hybrid' - [default] Cache SVG height, and uses Canvas measureText for the width.
     *
     * TODO: deprecate fast/fastCanvas options?
     *
     * NOTE: Most of these are unfortunately not hard guarantees that content is all inside of the returned bounds.
     *       'accurate' should probably be the only one where that guarantee can be assumed. Things like cyrillic in
     *       italic, combining marks and other unicode features can fail to be detected. This is particularly relevant
     *       for the height, as certain stacked accent marks or descenders can go outside of the prescribed range,
     *       and fast/canvasCanvas/hybrid will always return the same vertical bounds (top and bottom) for a given font
     *       when the text isn't the empty string.
     *
     * @param {string} method - One of the above methods
     * @returns {Text} - For chaining.
     */
    setBoundsMethod: function( method ) {
      assert && assert( method === 'fast' || method === 'fastCanvas' || method === 'accurate' || method === 'hybrid', 'Unknown Text boundsMethod' );
      if ( method !== this._boundsMethod ) {
        this._boundsMethod = method;
        this.invalidateSupportedRenderers();

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyBounds();
        }

        this.invalidateText();

        this.trigger0( 'boundsMethod' );

        this.trigger0( 'selfBoundsValid' ); // whether our self bounds are valid may have changed
      }
      return this;
    },
    set boundsMethod( value ) { this.setBoundsMethod( value ); },

    /**
     * Returns the current method to estimate the bounds of the text. See setBoundsMethod() for more information.
     * @public
     *
     * @returns {string}
     */
    getBoundsMethod: function() {
      return this._boundsMethod;
    },
    get boundsMethod() { return this.getBoundsMethod(); },

    /**
     * Returns a bitmask representing the supported renderers for the current configuration of the Text node.
     * @protected
     *
     * @returns {number} - A bitmask that includes supported renderers, see Renderer for details.
     */
    getTextRendererBitmask: function() {
      var bitmask = 0;

      // canvas support (fast bounds may leak out of dirty rectangles)
      if ( this._boundsMethod !== 'fast' && !this._isHTML ) {
        bitmask |= Renderer.bitmaskCanvas;
      }
      if ( !this._isHTML ) {
        bitmask |= Renderer.bitmaskSVG;
      }

      // fill and stroke will determine whether we have DOM text support
      bitmask |= Renderer.bitmaskDOM;

      return bitmask;
    },

    /**
     * Triggers a check and update for what renderers the current configuration supports.
     * This should be called whenever something that could potentially change supported renderers happen (which can
     * be isHTML, boundsMethod, etc.)
     * @public
     */
    invalidateSupportedRenderers: function() {
      this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getTextRendererBitmask() );
    },

    /**
     * Notifies that something about the text's potential bounds have changed (different text, different stroke or font,
     * etc.)
     * @private
     */
    invalidateText: function() {
      this.invalidateSelf();

      // TODO: consider replacing this with a general dirty flag notification, and have DOM update bounds every frame?
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyBounds();
      }

      // we may have changed renderers if parameters were changed!
      this.invalidateSupportedRenderers();
    },

    /**
     * Computes a more efficient selfBounds for our Text.
     * @protected
     * @override
     *
     * @returns {boolean} - Whether the self bounds changed.
     */
    updateSelfBounds: function() {
      // TODO: don't create another Bounds2 object just for this!
      var selfBounds;

      // investigate http://mudcu.be/journal/2011/01/html5-typographic-metrics/
      if ( this._isHTML || ( useDOMAsFastBounds && this._boundsMethod !== 'accurate' ) ) {
        selfBounds = TextBounds.approximateDOMBounds( this._font, this.getDOMTextNode() );
      }
      else if ( this._boundsMethod === 'hybrid' ) {
        selfBounds = TextBounds.approximateHybridBounds( this._font, this.renderedText );
      }
      else if ( this._boundsMethod === 'accurate' ) {
        selfBounds = TextBounds.accurateCanvasBounds( this );
      }
      else {
        assert && assert( this._boundsMethod === 'fast' || this._boundsMethod === 'fastCanvas' );
        selfBounds = TextBounds.approximateSVGBounds( this._font, this.renderedText );
      }

      // for now, just add extra on, ignoring the possibility of mitered joints passing beyond
      if ( this.hasStroke() ) {
        selfBounds.dilate( this.getLineWidth() / 2 );
      }

      var changed = !selfBounds.equals( this._selfBounds );
      if ( changed ) {
        this._selfBounds.set( selfBounds );
      }
      return changed;
    },

    /**
     * Called from (and overridden in) the Paintable mixin, invalidates our current stroke, triggering recomputation of
     * anything that depended on the old stroke's value.
     * @protected (scenery-internal)
     */
    invalidateStroke: function() {
      // stroke can change both the bounds and renderer
      this.invalidateText();
    },

    /**
     * Called from (and overridden in) the Paintable mixin, invalidates our current fill, triggering recomputation of
     * anything that depended on the old fill's value.
     * @protected (scenery-internal)
     */
    invalidateFill: function() {
      // fill type can change the renderer (gradient/fill not supported by DOM)
      this.invalidateText();
    },

    /**
     * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
     * coordinate frame of this node.
     * @protected
     * @override
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} matrix - The transformation matrix already applied to the context.
     */
    canvasPaintSelf: function( wrapper, matrix ) {
      //TODO: Have a separate method for this, instead of touching the prototype. Can make 'this' references too easily.
      TextCanvasDrawable.prototype.paintCanvas( wrapper, this, matrix );
    },

    /**
     * Creates a DOM drawable for this Text.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {DOMSelfDrawable}
     */
    createDOMDrawable: function( renderer, instance ) {
      return TextDOMDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a SVG drawable for this Text.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {SVGSelfDrawable}
     */
    createSVGDrawable: function( renderer, instance ) {
      return TextSVGDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a Canvas drawable for this Text.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {CanvasSelfDrawable}
     */
    createCanvasDrawable: function( renderer, instance ) {
      return TextCanvasDrawable.createFromPool( renderer, instance );
    },

    /**
     * Returns a DOM element that contains the specified text.
     * @public (scenery-internal)
     *
     * This is needed since we have to handle HTML text differently.
     *
     * @returns {Element}
     */
    getDOMTextNode: function() {
      if ( this._isHTML ) {
        var span = document.createElement( 'span' );
        span.innerHTML = this._text;
        return span;
      }
      else {
        return document.createTextNode( this.renderedText );
      }
    },

    /**
     * Returns a bounding box that should contain all self content in the local coordinate frame (our normal self bounds
     * aren't guaranteed this for Text)
     * @public
     * @override
     *
     * We need to add additional padding around the text when the text is in a container that could clip things badly
     * if the text is larger than the normal bounds computation.
     *
     * @returns {Bounds2}
     */
    getSafeSelfBounds: function() {
      var expansionFactor = 1; // we use a new bounding box with a new size of size * ( 1 + 2 * expansionFactor )

      var selfBounds = this.getSelfBounds();

      // NOTE: we'll keep this as an estimate for the bounds including stroke miters
      return selfBounds.dilatedXY( expansionFactor * selfBounds.width, expansionFactor * selfBounds.height );
    },

    /**
     * Sets the font of the Text node.
     * @public
     *
     * This can either be a Scenery Font object, or a string. The string format is described by Font's constructor, and
     * is basically the CSS3 font shortcut format. If a string is provided, it will be wrapped with a new (immutable)
     * Scenery Font object.
     *
     * @param {Font|string} font
     * @returns {Node} - For chaining.
     */
    setFont: function( font ) {
      assert && assert( font instanceof Font || typeof font === 'string',
        'Fonts provided to setFont should be a Font object or a string in the CSS3 font shortcut format' );

      // We need to detect whether things have updated in a different way depending on whether we are passed a string
      // or a Font object.
      var changed = font !== ( ( typeof font === 'string' ) ? this._font.toCSS() : this._font );
      if ( changed ) {
        // Wrap so that our _font is of type {Font}
        this._font = ( typeof font === 'string' ) ? new Font( font ) : font;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyFont();
        }

        this.invalidateText();
      }
      return this;
    },
    set font( value ) { this.setFont( value ); },

    /**
     * Returns a string representation of the current Font.
     * @public
     *
     * This returns the CSS3 font shortcut that is a possible input to setFont(). See Font's constructor for detailed
     * information on the ordering of information.
     *
     * NOTE: If a Font object was provided to setFont(), this will not currently return it.
     * TODO: Can we refactor so we can have access to (a) the Font object, and possibly (b) the initially provided value.
     *
     * @returns {string}
     */
    getFont: function() {
      return this._font.getFont();
    },
    get font() { return this.getFont(); },

    /**
     * Sets the weight of this node's font.
     * @public
     *
     * The font weight supports the following options:
     *   'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900',
     *   or a number that when cast to a string will be one of the strings above.
     *
     * @param {string|number} weight - See above
     * @returns {Text} - For chaining.
     */
    setFontWeight: function( weight ) {
      return this.setFont( this._font.copy( {
        weight: weight
      } ) );
    },
    set fontWeight( value ) { this.setFontWeight( value ); },

    /**
     * Returns the weight of this node's font, see setFontWeight() for details.
     * @public
     *
     * NOTE: If a numeric weight was passed in, it has been cast to a string, and a string will be returned here.
     *
     * @returns {string}
     */
    getFontWeight: function() {
      return this._font.getWeight();
    },
    get fontWeight() { return this.getFontWeight(); },

    /**
     * Sets the family of this node's font.
     * @public
     *
     * @param {string} family - A comma-separated list of families, which can include generic families (preferably at
     *                          the end) such as 'serif', 'sans-serif', 'cursive', 'fantasy' and 'monospace'. If there
     *                          is any question about escaping (such as spaces in a font name), the family should be
     *                          surrounded by double quotes.
     * @returns {Text} - For chaining.
     */
    setFontFamily: function( family ) {
      return this.setFont( this._font.copy( {
        family: family
      } ) );
    },
    set fontFamily( value ) { this.setFontFamily( value ); },

    /**
     * Returns the family of this node's font, see setFontFamily() for details.
     * @public
     *
     * @returns {string}
     */
    getFontFamily: function() {
      return this._font.getFamily();
    },
    get fontFamily() { return this.getFontFamily(); },

    /**
     * Sets the stretch of this node's font.
     * @public
     *
     * The font stretch supports the following options:
     *   'normal', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed',
     *   'semi-expanded', 'expanded', 'extra-expanded' or 'ultra-expanded'
     *
     * @param {string} stretch - See above
     * @returns {Text} - For chaining.
     */
    setFontStretch: function( stretch ) {
      return this.setFont( this._font.copy( {
        stretch: stretch
      } ) );
    },
    set fontStretch( value ) { this.setFontStretch( value ); },

    /**
     * Returns the stretch of this node's font, see setFontStretch() for details.
     * @public
     *
     * @returns {string}
     */
    getFontStretch: function() {
      return this._font.getStretch();
    },
    get fontStretch() { return this.getFontStretch(); },

    /**
     * Sets the style of this node's font.
     * @public
     *
     * The font style supports the following options: 'normal', 'italic' or 'oblique'
     *
     * @param {string} style - See above
     * @returns {Text} - For chaining.
     */
    setFontStyle: function( style ) {
      return this.setFont( this._font.copy( {
        style: style
      } ) );
    },
    set fontStyle( value ) { this.setFontStyle( value ); },

    /**
     * Returns the style of this node's font, see setFontStyle() for details.
     * @public
     *
     * @returns {string}
     */
    getFontStyle: function() {
      return this._font.getStyle();
    },
    get fontStyle() { return this.getFontStyle(); },

    /**
     * Sets the size of this node's font.
     * @public
     *
     * The size can either be a number (created as a quantity of 'px'), or any general CSS font-size string (for
     * example, '30pt', '5em', etc.)
     *
     * @param {string|number} size - See above
     * @returns {Text} - For chaining.
     */
    setFontSize: function( size ) {
      return this.setFont( this._font.copy( {
        size: size
      } ) );
    },
    set fontSize( value ) { this.setFontSize( value ); },

    /**
     * Returns the size of this node's font, see setFontSize() for details.
     * @public
     *
     * NOTE: If a numeric size was passed in, it has been converted to a string with 'px', and a string will be
     * returned here.
     *
     * @returns {string}
     */
    getFontSize: function() {
      return this._font.getSize();
    },
    get fontSize() { return this.getFontSize(); },

    /**
     * Whether this Node itself is painted (displays something itself).
     * @public
     * @override
     *
     * @returns {boolean}
     */
    isPainted: function() {
      // Always true for Text nodes
      return true;
    },

    /**
     * Whether this Node's selfBounds are considered to be valid (always containing the displayed self content
     * of this node). Meant to be overridden in subtypes when this can change (e.g. Text).
     * @public
     * @override
     *
     * If this value would potentially change, please trigger the event 'selfBoundsValid'.
     *
     * @returns {boolean}
     */
    areSelfBoundsValid: function() {
      return this._boundsMethod === 'accurate';
    },

    /**
     * Override for extra information in the debugging output (from Display.getDebugHTML()).
     * @protected (scenery-internal)
     * @override
     *
     * @returns {string}
     */
    getDebugHTMLExtras: function() {
      return ' "' + escapeHTML( this.renderedText ) + '"' + ( this._isHTML ? ' (html)' : '' );
    }
  } );

  // mix in support for fills and strokes
  Paintable.mixin( Text );

  // Unicode embedding marks that we can combine to work around the Edge issue.
  // See https://github.com/phetsims/scenery/issues/520
  var LTR = '\u202a';
  var RTL = '\u202b';
  var POP = '\u202c';

  /**
   * Replaces embedding mark characters with visible strings. Useful for debugging for strings with embedding marks.
   * @public
   *
   * @param {string} string
   * @returns {string} - With embedding marks replaced.
   */
  Text.embeddedDebugString = function( string ) {
    return string.replace( /\u202a/g, '[LTR]' ).replace( /\u202b/g, '[RTL]' ).replace( /\u202c/g, '[POP]' );
  };

  /**
   * Returns a (potentially) modified string where embedding marks have been simplified.
   * @public
   *
   * This simplification wouldn't usually be necessary, but we need to prevent cases like
   * https://github.com/phetsims/scenery/issues/520 where Edge decides to turn [POP][LTR] (after another [LTR]) into
   * a 'box' character, when nothing should be rendered.
   *
   * This will remove redundant nesting:
   *   e.g. [LTR][LTR]boo[POP][POP] => [LTR]boo[POP])
   * and will also combine adjacent directions:
   *   e.g. [LTR]Mail[POP][LTR]Man[POP] => [LTR]MailMan[Pop]
   *
   * Note that it will NOT combine in this way if there was a space between the two LTRs:
   *   e.g. [LTR]Mail[POP] [LTR]Man[Pop])
   * as in the general case, we'll want to preserve the break there between embeddings.
   *
   * TODO: A stack-based implementation that doesn't create a bunch of objects/closures would be nice for performance.
   *
   * @param {string} string
   * @returns {string}
   */
  Text.simplifyEmbeddingMarks = function( string ) {
    // First, we'll convert the string into a tree form, where each node is either a string object OR an object of the
    // node type { dir: {LTR||RTL}, children: {Array.<node>}, parent: {null|node} }. Thus each LTR...POP and RTL...POP
    // become a node with their interiors becoming children.

    // Root node (no direction, so we preserve root LTR/RTLs)
    var root = {
      dir: null,
      children: [],
      parent: null
    };
    var current = root;
    for ( var i = 0; i < string.length; i++ ) {
      var chr = string.charAt( i );

      // Push a direction
      if ( chr === LTR || chr === RTL ) {
        var node = {
          dir: chr,
          children: [],
          parent: current
        };
        current.children.push( node );
        current = node;
      }
      // Pop a direction
      else if ( chr === POP ) {
        assert && assert( current.parent, 'Bad nesting of embedding marks: ' + Text.embeddedDebugString( string ) );
        current = current.parent;
      }
      // Append characters to the current direction
      else {
        current.children.push( chr );
      }
    }
    assert && assert( current === root, 'Bad nesting of embedding marks: ' + Text.embeddedDebugString( string ) );

    // Remove redundant nesting (e.g. [LTR][LTR]...[POP][POP])
    function collapseNesting( node ) {
      for ( var i = node.children.length - 1; i >= 0; i-- ) {
        var child = node.children[ i ];
        if ( node.dir === child.dir ) {
          Array.prototype.splice.apply( node.children, [ i, 1 ].concat( child.children ) );
        }
      }
    }

    // Remove overridden nesting (e.g. [LTR][RTL]...[POP][POP]), since the outer one is not needed
    function collapseUnnecessary( node ) {
      if ( node.children.length === 1 && node.children[ 0 ].dir ) {
        node.dir = node.children[ 0 ].dir;
        node.children = node.children[ 0 ].children;
      }
    }

    // Collapse adjacent matching dirs, e.g. [LTR]...[POP][LTR]...[POP]
    function collapseAdjacent( node ) {
      for ( var i = node.children.length - 1; i >= 1; i-- ) {
        var previousChild = node.children[ i - 1 ];
        var child = node.children[ i ];
        if ( child.dir && previousChild.dir === child.dir ) {
          previousChild.children = previousChild.children.concat( child.children );
          node.children.splice( i, 1 );

          // Now try to collapse adjacent items in the child, since we combined children arrays
          collapseAdjacent( previousChild );
        }
      }
    }

    // Simplifies the tree using the above functions
    function simplify( node ) {
      if ( typeof node === 'string' ) {
        return;
      }

      for ( var i = 0; i < node.children.length; i++ ) {
        simplify( node.children[ i ] );
      }

      collapseUnnecessary( node );
      collapseNesting( node );
      collapseAdjacent( node );

      return node;
    }

    // Turns a tree into a string
    function stringify( node ) {
      if ( typeof node === 'string' ) {
        return node;
      }
      var childString = node.children.map( stringify ).join( '' );
      if ( node.dir ) {
        return node.dir + childString + '\u202c';
      }
      else {
        return childString;
      }
    }

    return stringify( simplify( root ) );
  };

  // Initialize computation of hybrid text
  TextBounds.initializeTextBounds();

  return Text;
} );

// Copyright 2017, University of Colorado Boulder

/**
 * wrapper type for AccordionBox
 * @author John Blanco
 */
define( 'SUN/TAccordionBox',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * Wrapper type for phet/sun's AccordionBox class.
   * @param accordionBox
   * @param phetioID
   * @constructor
   */
  function TAccordionBox( accordionBox, phetioID ) {
    assertInstanceOf( accordionBox, phet.sun.AccordionBox );
    TNode.call( this, accordionBox, phetioID );

    toEventOnEmit(
      accordionBox.startedCallbacksForCollapsedTitleBarDownEmitter,
      accordionBox.endedCallbacksForCollapsedTitleBarDownEmitter,
      'user',
      phetioID,
      this.constructor,
      'collapsed'
    );

    toEventOnEmit(
      accordionBox.startedCallbacksForExpandedTitleBarDownEmitter,
      accordionBox.endedCallbacksForExpandedTitleBarDownEmitter,
      'user',
      phetioID,
      this.constructor,
      'expanded'
    );
  }

  phetioInherit( TNode, 'TAccordionBox', TAccordionBox, {}, {
    documentation: 'A traditional accordionBox',
    events: [ 'expanded', 'collapsed' ]
  } );

  sun.register( 'TAccordionBox', TAccordionBox );

  return TAccordionBox;
} );


// Copyright 2013-2015, University of Colorado Boulder

/**
 * Box that can be expanded/collapsed to show/hide contents.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/AccordionBox',['require','AXON/BooleanProperty','AXON/Emitter','SUN/ExpandCollapseButton','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/nodes/Rectangle','KITE/Shape','SUN/sun','TANDEM/Tandem','SCENERY/nodes/Text','SUN/TAccordionBox'],function( require ) {
  'use strict';

  // modules
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var Emitter = require( 'AXON/Emitter' );
  var ExpandCollapseButton = require( 'SUN/ExpandCollapseButton' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Text = require( 'SCENERY/nodes/Text' );

  // phet-io modules
  var TAccordionBox = require( 'SUN/TAccordionBox' );

  /**
   * @constructor
   *
   * @param {Node} contentNode - Content that will be shown or hidden as the accordion box is expanded/collapsed.
   * @param {Object} [options] - Various key-value pairs that control the appearance and behavior.  Some options are
   *                             specific to this class while some are passed to the superclass.  See the code where
   *                             the options are set in the early portion of the constructor for details.
   */
  function AccordionBox( contentNode, options ) {

    var self = this;

    options = _.extend( {
      // {Tandem}
      tandem: Tandem.tandemRequired(),

      // {Node} - If not provided, a Text node will be supplied. Should have and maintain well-defined bounds if passed
      //          in.
      titleNode: null,

      // {Property.<boolean>} - If not provided, a BooleanProperty will be created, defaulting to true.
      expandedProperty: null,

      // {boolean} - If true, the AccordionBox will resize itself as needed when the title/content resizes.
      //             See https://github.com/phetsims/sun/issues/304
      resize: false,

      // applied to multiple parts of this UI component
      cursor: 'pointer', // {string} default cursor
      lineWidth: 1,
      cornerRadius: 3,

      // box
      stroke: 'black',
      fill: 'rgb( 238, 238, 238 )',
      minWidth: 0,

      titleAlignX: 'center', // {string} horizontal alignment of the title, 'left'|'center'|'right'
      titleAlignY: 'center', // {string} vertical alignment of the title, relative to expand/collapse button 'top'|'center'
      titleXMargin: 10, // horizontal space between title and left|right edge of box
      titleYMargin: 2, // vertical space between title and top of box
      titleXSpacing: 5, // horizontal space between title and expand/collapse button
      showTitleWhenExpanded: true, // true = title is visible when expanded, false = title is hidden when expanded
      titleBarFill: null, // {Color|string} title bar fill
      titleBarStroke: null, // {Color|string} title bar stroke, used only for the expanded title bar
      titleBarExpandCollapse: true, // {boolean} clicking on the title bar expands/collapses the accordion box

      // expand/collapse button
      buttonLength: 16, // button is a square, this is the length of one side
      buttonAlign: 'left',  // {string} button alignment, 'left'|'right'
      buttonXMargin: 4, // horizontal space between button and left|right edge of box
      buttonYMargin: 2, // vertical space between button and top edge of box
      buttonTouchAreaXDilation: 0,
      buttonTouchAreaYDilation: 0,
      buttonMouseAreaXDilation: 0,
      buttonMouseAreaYDilation: 0,

      // content
      contentAlign: 'center', // {string} horizontal alignment of the content, 'left'|'center'|'right'
      contentXMargin: 15, // horizontal space between content and left/right edges of box
      contentYMargin: 8,  // horizontal space between content and bottom edge of box
      contentXSpacing: 5, // horizontal space between content and button, ignored if showTitleWhenExpanded is true
      contentYSpacing: 8, // vertical space between content and title+button, ignored if showTitleWhenExpanded is false

      // phet-io support
      phetioType: TAccordionBox,

      // a11y options
      tagName: 'div',
      accessibleAccordionTitle: 'No Title Given',


    }, options );

    // verify string options
    assert && assert( options.buttonAlign === 'left' || options.buttonAlign === 'right' );
    assert && assert( options.contentAlign === 'left' || options.contentAlign === 'right' || options.contentAlign === 'center' );
    assert && assert( options.titleAlignX === 'left' || options.titleAlignX === 'right' || options.titleAlignX === 'center' );
    assert && assert( options.titleAlignY === 'top' || options.titleAlignY === 'center' );

    // @private
    this._contentAlign = options.contentAlign;
    this._contentNode = contentNode;
    this._cornerRadius = options.cornerRadius;
    this._buttonXMargin = options.buttonXMargin;
    this._buttonYMargin = options.buttonYMargin;
    this._contentXMargin = options.contentXMargin;
    this._contentYMargin = options.contentYMargin;
    this._contentXSpacing = options.contentXSpacing;
    this._contentYSpacing = options.contentYSpacing;
    this._titleAlignX = options.titleAlignX;
    this._titleAlignY = options.titleAlignY;
    this._titleXMargin = options.titleXMargin;
    this._titleYMargin = options.titleYMargin;
    this._titleXSpacing = options.titleXSpacing;
    this._minWidth = options.minWidth;
    this._showTitleWhenExpanded = options.showTitleWhenExpanded;
    this._buttonAlign = options.buttonAlign;

    // emitters for the PhET-iO data stream
    this.startedCallbacksForExpandedTitleBarDownEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForExpandedTitleBarDownEmitter = new Emitter( { indicateCallbacks: false } );
    this.startedCallbacksForCollapsedTitleBarDownEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForCollapsedTitleBarDownEmitter = new Emitter( { indicateCallbacks: false } );

    // @private {Array.<function>} - Actions to take when this AccordionBox is disposed. Will be called with a proper
    //                               'this' reference to the AccordionBox.
    this.disposalActions = [];

    // @private {Node}
    this.titleNode = options.titleNode;

    // If there is no titleNode specified, we'll provide our own, and handle disposal.
    if ( !this.titleNode ) {
      this.titleNode = new Text( '', { tandem: options.tandem.createTandem( 'titleNode' ) } );
      this.disposalActions.push( function() {
        self.titleNode.dispose();
      } );
    }

    // @private {Property.<boolean>}
    this.expandedProperty = options.expandedProperty;

    if ( !this.expandedProperty ) {
      this.expandedProperty = new BooleanProperty( true, {
        tandem: options.tandem.createTandem( 'expandedProperty' )
      } );
      this.disposalActions.push( function() {
        self.expandedProperty.dispose();
      } );
    }

    Node.call( this );

    // @private - expand/collapse button, links to expandedProperty, must be disposed of
    this.expandCollapseButton = new ExpandCollapseButton( this.expandedProperty, {
      sideLength: options.buttonLength,
      cursor: options.cursor,
      tandem: options.tandem.createTandem( 'expandCollapseButton' )
    } );
    this.disposalActions.push( function() {
      self.expandCollapseButton.dispose();
    } );
    this.expandCollapseButton.touchArea = this.expandCollapseButton.localBounds.dilatedXY(
      options.buttonTouchAreaXDilation,
      options.buttonTouchAreaYDilation
    );
    this.expandCollapseButton.mouseArea = this.expandCollapseButton.localBounds.dilatedXY(
      options.buttonMouseAreaXDilation,
      options.buttonMouseAreaYDilation
    );

    // Expanded box
    var boxOptions = { fill: options.fill };

    // @private {Rectangle} - Expanded box
    this.expandedBox = new Rectangle( _.extend( {
      cornerRadius: options.cornerRadius,
      tandem: options.tandem.createTandem( 'expandedBox' ),
      tagName: 'div' // a11y
    }, boxOptions ) );
    this.disposalActions.push( function() {
      self.expandedBox.dispose();
    } );
    this.addChild( this.expandedBox );

    // @private {Rectangle} - Collapsed box
    this.collapsedBox = new Rectangle( _.extend( {
      cornerRadius: options.cornerRadius,
      tandem: options.tandem.createTandem( 'collapsedBox' )
    }, boxOptions ) );
    this.disposalActions.push( function() {
      self.collapsedBox.dispose();
    } );
    this.addChild( this.collapsedBox );

    // @private {Path}
    this.expandedTitleBar = new Path( null, {
      fill: options.titleBarFill,
      stroke: options.titleBarStroke,
      lineWidth: options.lineWidth, // use same lineWidth as box, for consistent look
      cursor: options.cursor,
      tandem: options.tandem.createTandem( 'expandedTitleBar' ),

      // a11y
      tagName: 'button',
      accessibleLabel: options.accessibleAccordionTitle,
      labelTagName: 'p'
    } );
    this.disposalActions.push( function() {
      self.expandedTitleBar.dispose();
    } );
    this.expandedBox.addChild( this.expandedTitleBar );

    // @private {Rectangle} - Collapsed title bar has corners that match the box. Clicking it operates like
    //                        expand/collapse button.
    this.collapsedTitleBar = new Rectangle( {
      cornerRadius: options.cornerRadius,
      fill: options.titleBarFill,
      cursor: options.cursor,
      tandem: options.tandem.createTandem( 'collapsedTitleBar' ),

      // a11y
      tagName: 'button',
      accessibleLabel: options.accessibleAccordionTitle,
      labelTagName: 'p'
    } );
    this.disposalActions.push( function() {
      self.collapsedTitleBar.dispose();
    } );
    this.collapsedBox.addChild( this.collapsedTitleBar );

    if ( options.titleBarExpandCollapse ) {
      this.collapsedTitleBar.addInputListener( {
        down: function() {
          self.startedCallbacksForExpandedTitleBarDownEmitter.emit();
          self.expandedProperty.value = true;
          self.endedCallbacksForExpandedTitleBarDownEmitter.emit();
        }
      } );
    }

    // a11y we always want accessible tab focus on the title, even when titleBarExpandeCollapse === false
    this.collapsedTitleBar.addAccessibleInputListener( {
      click: function() {
        self.startedCallbacksForExpandedTitleBarDownEmitter.emit();
        self.expandedProperty.value = true;
        self.endedCallbacksForExpandedTitleBarDownEmitter.emit();

        // a11y Set focus to expanded title bar
        self.expandedTitleBar.focus();
      }
    } );

    // Set the input listeners for the expandedTitleBar
    // a11y we need to focus on the collapsedTitleBar when the expandedTitleBar is clicked
    if ( options.showTitleWhenExpanded ) {
      if ( options.titleBarExpandCollapse ) {
        this.expandedTitleBar.addInputListener( {
          down: function() {
            self.startedCallbacksForCollapsedTitleBarDownEmitter.emit();
            self.expandedProperty.value = false;
            self.endedCallbacksForCollapsedTitleBarDownEmitter.emit();
          }
        } );
      }

      // a11y we always want accessible tab focus on the title
      this.expandedTitleBar.addAccessibleInputListener( {
        click: function() {
          self.startedCallbacksForCollapsedTitleBarDownEmitter.emit();
          self.expandedProperty.value = false;
          self.endedCallbacksForCollapsedTitleBarDownEmitter.emit();

          // a11y Set focus to expanded title bar
          self.collapsedTitleBar.focus();
        }
      } );
    }

    // TODO: a11y
    this.addChild( this.titleNode );
    this.addChild( this.expandCollapseButton );

    // box outline, on top of everything else
    if ( options.stroke ) {
      var outlineOptions = { stroke: options.stroke, lineWidth: options.lineWidth };

      // @private {Rectangle} - May not be set
      this.expandedBoxOutline = new Rectangle( _.extend( {
        cornerRadius: options.cornerRadius,
        tandem: options.tandem.createTandem( 'expandedBoxOutline' )
      }, outlineOptions ) );
      this.disposalActions.push( function() {
        self.expandedBoxOutline.dispose();
      } );
      this.expandedBox.addChild( this.expandedBoxOutline );

      // @private {Rectangle} - May not be set
      this.collapsedBoxOutline = new Rectangle( _.extend( {
        cornerRadius: options.cornerRadius,
        tandem: options.tandem.createTandem( 'collapsedBoxOutline' )
      }, outlineOptions ) );
      this.collapsedBox.addChild( this.collapsedBoxOutline );
      this.disposalActions.push( function() {
        self.collapsedBoxOutline.dispose();
      } );
    }

    this.expandedBox.addChild( this._contentNode );

    this.layout();

    // Watch future changes for re-layout (don't want to trigger on our first layout and queue useless ones)
    if ( options.resize ) {
      var layoutListener = this.layout.bind( this );
      contentNode.on( 'bounds', layoutListener );
      this.titleNode.on( 'bounds', layoutListener );
      this.disposalActions.push( function() {
        contentNode.off( 'bounds', layoutListener );
        self.titleNode.off( 'bounds', layoutListener );
      } );
    }

    // expand/collapse the box
    var expandedPropertyObserver = function( expanded ) {
      self.expandedBox.visible = expanded;
      self.collapsedBox.visible = !expanded;

      // a11y Toggle the visibility of the buttons in the PDOM
      self.expandedTitleBar.accessibleHidden = !expanded;
      self.collapsedTitleBar.accessibleHidden = expanded;

      self.titleNode.visible = ( expanded && options.showTitleWhenExpanded ) || !expanded;
    };
    this.expandedProperty.link( expandedPropertyObserver );
    this.disposalActions.push( function() {
      self.expandedProperty.unlink( expandedPropertyObserver );
    } );

    if ( this.constructor.name === 'DoubleNumberLineAccordionBox' ) {
      this.inspect();
    }

    this.mutate( _.omit( options, 'cursor' ) );
  }

  sun.register( 'AccordionBox', AccordionBox );

  return inherit( Node, AccordionBox, {
    /**
     * Performs layout that positions everything that can change.
     * @private
     */
    layout: function() {
      var collapsedBoxHeight = this.getCollapsedBoxHeight();
      var boxWidth = this.getBoxWidth();
      var expandedBoxHeight = this.getExpandedBoxHeight();

      this.expandedBox.rectWidth = boxWidth;
      this.expandedBox.rectHeight = expandedBoxHeight;

      var expandedBounds = this.expandedBox.selfBounds;

      this.expandedBoxOutline.rectWidth = boxWidth;
      this.expandedBoxOutline.rectHeight = expandedBoxHeight;

      this.expandedTitleBar.shape = this.getTitleBarShape();

      this.collapsedBox.rectWidth = boxWidth;
      this.collapsedBox.rectHeight = collapsedBoxHeight;

      this.collapsedTitleBar.rectWidth = boxWidth;
      this.collapsedTitleBar.rectHeight = collapsedBoxHeight;

      this.collapsedBoxOutline.rectWidth = boxWidth;
      this.collapsedBoxOutline.rectHeight = collapsedBoxHeight;

      // content layout
      this._contentNode.bottom = expandedBounds.bottom - this._contentYMargin;
      var contentSpanLeft = expandedBounds.left + this._contentXMargin;
      var contentSpanRight = expandedBounds.right - this._contentXMargin;
      if ( !this._showTitleWhenExpanded ) {
        // content will be placed next to button
        if ( this._buttonAlign === 'left' ) {
          contentSpanLeft += this.expandCollapseButton.width + this._contentXSpacing;
        }
        else { // right on right
          contentSpanRight -= this.expandCollapseButton.width + this._contentXSpacing;
        }
      }
      if ( this._contentAlign === 'left' ) {
        this._contentNode.left = contentSpanLeft;
      }
      else if ( this._contentAlign === 'right' ) {
        this._contentNode.right = contentSpanRight;
      }
      else { // center
        this._contentNode.centerX = ( contentSpanLeft + contentSpanRight ) / 2;
      }

      // button horizontal layout
      var titleLeftSpan = expandedBounds.left + this._titleXMargin;
      var titleRightSpan = expandedBounds.right - this._titleXMargin;
      if ( this._buttonAlign === 'left' ) {
        this.expandCollapseButton.left = expandedBounds.left + this._buttonXMargin;
        titleLeftSpan = this.expandCollapseButton.right + this._titleXSpacing;
      }
      else {
        this.expandCollapseButton.right = expandedBounds.right - this._buttonXMargin;
        titleRightSpan = this.expandCollapseButton.left - this._titleXSpacing;
      }

      // title horizontal layout
      if ( this._titleAlignX === 'left' ) {
        this.titleNode.left = titleLeftSpan;
      }
      else if ( this._titleAlignX === 'right' ) {
        this.titleNode.right = titleRightSpan;
      }
      else { // center
        this.titleNode.centerX = expandedBounds.centerX;
      }

      // button & title vertical layout
      if ( this._titleAlignY === 'top' ) {
        this.expandCollapseButton.top = this.collapsedBox.top + Math.max( this._buttonYMargin, this._titleYMargin );
        this.titleNode.top = this.expandCollapseButton.top;
      }
      else { // center
        this.expandCollapseButton.centerY = this.collapsedBox.centerY;
        this.titleNode.centerY = this.expandCollapseButton.centerY;
      }
    },

    /**
     * Returns the Shape of the title bar.
     * @private
     *
     * Expanded title bar has (optional) rounded top corners, square bottom corners. Clicking it operates like
     * expand/collapse button.
     *
     * @returns {Shape}
     */
    getTitleBarShape: function() {
      return Shape.roundedRectangleWithRadii( 0, 0, this.getBoxWidth(), this.getCollapsedBoxHeight(), {
        topLeft: this._cornerRadius,
        topRight: this._cornerRadius
      } );
    },

    /**
     * Returns the computed width of the box (ignoring things like stroke width)
     * @private
     *
     * @returns {number}
     */
    getBoxWidth: function() {
      var width = Math.max( this._minWidth, this.expandCollapseButton.width + this.titleNode.width + this._buttonXMargin + this._titleXMargin + this._titleXSpacing );

      // content is below button+title
      if ( this._showTitleWhenExpanded ) {
        return Math.max( width, this._contentNode.width + ( 2 * this._contentXMargin ) );
      }
      // content is next to button
      else {
        return Math.max( width, this.expandCollapseButton.width + this._contentNode.width + this._buttonXMargin + this._contentXMargin + this._contentXSpacing );
      }
    },

    /**
     * Returns the ideal height of the collapsed box (ignoring things like stroke width)
     * @private
     *
     * @returns {number}
     */
    getCollapsedBoxHeight: function() {
      return Math.max( this.expandCollapseButton.height + ( 2 * this._buttonYMargin ), this.titleNode.height + ( 2 * this._titleYMargin ) );
    },

    /**
     * Returns the ideal height of the expanded box (ignoring things like stroke width)
     * @private
     *
     * @returns {number}
     */
    getExpandedBoxHeight: function() {
      // content is below button+title
      if ( this._showTitleWhenExpanded ) {
        return this.getCollapsedBoxHeight() + this._contentNode.height + this._contentYMargin + this._contentYSpacing;
      }
      // content is next to button
      else {
        return Math.max( this.expandCollapseButton.height + ( 2 * this._buttonYMargin ), this._contentNode.height + ( 2 * this._contentYMargin ) );
      }
    },

    /**
     * Ensures this node is eligible for GC.
     * @public
     */
    dispose: function() {
      while ( this.disposalActions.length ) {
        this.disposalActions.pop().call( this );
      }
      Node.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2016, University of Colorado Boulder

/**
 * A mixin to drawables for Circle that need to store state about what the current display is currently showing,
 * so that updates to the Circle will only be made on attributes that specifically changed (and no change will be
 * necessary for an attribute that changed back to its original/currently-displayed value). Generally, this is used
 * for DOM and SVG drawables.
 *
 * This mixin assumes the PaintableStateful mixin is also mixed (always the case for Circle stateful drawables).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/CircleStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );

  var CircleStatefulDrawable = {
    /**
     * Given the type (constructor) of a drawable, we'll mix in a combination of:
     * - initialization/disposal with the *State suffix
     * - mark* methods to be called on all drawables of nodes of this type, that set specific dirty flags
     * @public (scenery-internal)
     *
     * This will allow drawables that mix in this type to do the following during an update:
     * 1. Check specific dirty flags (e.g. if the fill changed, update the fill of our SVG element).
     * 2. Call setToCleanState() once done, to clear the dirty flags.
     *
     * Also mixes in PaintableStatefulDrawable, as this is needed by all stateful Circle drawables.
     *
     * @param {function} drawableType - The constructor for the drawable type
     */
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      /**
       * Initializes the stateful mixin state, starting its "lifetime" until it is disposed with disposeState().
       * @protected
       *
       * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
       * @param {Instance} instance
       * @returns {CircleStatefulDrawable} - Self reference for chaining
       */
      proto.initializeState = function( renderer, instance ) {
        // @protected {boolean} - Flag marked as true if ANY of the drawable dirty flags are set (basically everything except for transforms, as we
        //                        need to accelerate the transform case.
        this.paintDirty = true;

        // @protected {boolean} - Whether the radius has changed since our last update.
        this.dirtyRadius = true;

        // After adding flags, we'll initialize the mixed-in PaintableStateful state.
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      /**
       * Disposes the stateful mixin state, so it can be put into the pool to be initialized again.
       * @protected
       */
      proto.disposeState = function() {
        this.disposePaintableState();
      };

      /**
       * A "catch-all" dirty method that directly marks the paintDirty flag and triggers propagation of dirty
       * information. This can be used by other mark* methods, or directly itself if the paintDirty flag is checked.
       * @public (scenery-internal)
       *
       * It should be fired (indirectly or directly) for anything besides transforms that needs to make a drawable
       * dirty.
       */
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      /**
       * Called when the radius of the circle changes.
       * @public (scenery-internal)
       */
      proto.markDirtyRadius = function() {
        this.dirtyRadius = true;
        this.markPaintDirty();
      };

      /**
       * Clears all of the dirty flags (after they have been checked), so that future mark* methods will be able to flag them again.
       * @public (scenery-internal)
       */
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyRadius = false;
      };

      PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  scenery.register( 'CircleStatefulDrawable', CircleStatefulDrawable );

  return CircleStatefulDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * DOM drawable for Circle nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/CircleDOMDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Matrix3','SCENERY/util/Features','SCENERY/display/DOMSelfDrawable','SCENERY/display/drawables/CircleStatefulDrawable','SCENERY/display/SelfDrawable','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Features = require( 'SCENERY/util/Features' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var CircleStatefulDrawable = require( 'SCENERY/display/drawables/CircleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  require( 'SCENERY/util/Util' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepDOMCircleElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory

  /**
   * A generated DOMSelfDrawable whose purpose will be drawing our Circle. One of these drawables will be created
   * for each displayed instance of a Circle.
   * @public (scenery-internal)
   * @constructor
   * @extends DOMSelfDrawable
   * @mixes Circle.CircleStatefulDrawable
   * @mixes Paintable.PaintableStatefulDrawable
   * @mixes SelfDrawable.Poolable
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function CircleDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'CircleDOMDrawable', CircleDOMDrawable );

  inherit( DOMSelfDrawable, CircleDOMDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {CircleDOMDrawable} - Self reference for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeDOMSelfDrawable( renderer, instance );

      // Stateful mix-in initialization
      this.initializeState( renderer, instance );

      // @protected {Matrix3} - We need to store an independent matrix, as our CSS transform actually depends on the radius.
      this.matrix = this.matrix || Matrix3.dirtyFromPool();

      // only create elements if we don't already have them (we pool visual states always, and depending on the platform may also pool the actual elements to minimize
      // allocation and performance costs)
      if ( !this.fillElement || !this.strokeElement ) {
        // @protected {HTMLDivElement} - Will contain the fill by manipulating borderRadius
        var fillElement = this.fillElement = document.createElement( 'div' );

        // @protected {HTMLDivElement} - Will contain the stroke by manipulating borderRadius
        var strokeElement = this.strokeElement = document.createElement( 'div' );

        fillElement.style.display = 'block';
        fillElement.style.position = 'absolute';
        fillElement.style.left = '0';
        fillElement.style.top = '0';
        fillElement.style.pointerEvents = 'none';
        strokeElement.style.display = 'block';
        strokeElement.style.position = 'absolute';
        strokeElement.style.left = '0';
        strokeElement.style.top = '0';
        strokeElement.style.pointerEvents = 'none';

        // Nesting allows us to transform only one AND to guarantee that the stroke is on top.
        fillElement.appendChild( strokeElement );
      }

      // @protected {HTMLElement} - Our primary DOM element. This is exposed as part of the DOMSelfDrawable API.
      this.domElement = this.fillElement;

      // Apply CSS needed for future CSS transforms to work properly.
      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    /**
     * Updates our DOM element so that its appearance matches our node's representation.
     * @protected
     *
     * This implements part of the DOMSelfDrawable required API for subtypes.
     */
    updateDOM: function() {
      var node = this.node;
      var fillElement = this.fillElement;
      var strokeElement = this.strokeElement;

      // If paintDirty is false, there are no updates that are needed.
      if ( this.paintDirty ) {
        if ( this.dirtyRadius ) {
          fillElement.style.width = ( 2 * node._radius ) + 'px';
          fillElement.style.height = ( 2 * node._radius ) + 'px';
          fillElement.style[ Features.borderRadius ] = node._radius + 'px';
        }
        if ( this.dirtyFill ) {
          fillElement.style.backgroundColor = node.getCSSFill();
        }

        if ( this.dirtyStroke ) {
          // update stroke presence
          if ( node.hasStroke() ) {
            strokeElement.style.borderStyle = 'solid';
          }
          else {
            strokeElement.style.borderStyle = 'none';
          }
        }

        if ( node.hasStroke() ) {
          // since we only execute these if we have a stroke, we need to redo everything if there was no stroke previously.
          // the other option would be to update stroked information when there is no stroke (major performance loss for fill-only Circles)
          var hadNoStrokeBefore = !this.hadStroke;

          if ( hadNoStrokeBefore || this.dirtyLineWidth || this.dirtyRadius ) {
            strokeElement.style.width = ( 2 * node._radius - node.getLineWidth() ) + 'px';
            strokeElement.style.height = ( 2 * node._radius - node.getLineWidth() ) + 'px';
            strokeElement.style[ Features.borderRadius ] = ( node._radius + node.getLineWidth() / 2 ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyLineWidth ) {
            strokeElement.style.left = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.top = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.borderWidth = node.getLineWidth() + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyStroke ) {
            strokeElement.style.borderColor = node.getSimpleCSSStroke();
          }
        }
      }

      // shift the element vertically, postmultiplied with the entire transform.
      if ( this.transformDirty || this.dirtyRadius ) {
        this.matrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( -node._radius, -node._radius );
        this.matrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( this.matrix, this.fillElement, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToCleanState();
      this.cleanPaintableState();
      this.transformDirty = false;
    },

    /**
     * Disposes the drawable.
     * @public (scenery-internal)
     * @override
     */
    dispose: function() {
      this.disposeState();

      // Release the DOM elements from the poolable visual state so they aren't kept in memory.
      // May not be done on platforms where we have enough memory to pool these
      if ( !keepDOMCircleElements ) {
        // clear the references
        this.fillElement = null;
        this.strokeElement = null;
        this.domElement = null;
      }

      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );

  // Include Circle's stateful mixin (used for dirty flags)
  CircleStatefulDrawable.mixin( CircleDOMDrawable );

  // This sets up CircleDOMDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( CircleDOMDrawable );

  return CircleDOMDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * SVG drawable for Circle nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/CircleSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGSelfDrawable','SCENERY/display/drawables/CircleStatefulDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var CircleStatefulDrawable = require( 'SCENERY/display/drawables/CircleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepSVGCircleElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  /**
   * A generated SVGSelfDrawable whose purpose will be drawing our Circle. One of these drawables will be created
   * for each displayed instance of a Circle.
   * @public (scenery-internal)
   * @constructor
   * @extends SVGSelfDrawable
   * @mixes CircleStatefulDrawable
   * @mixes Paintable.PaintableStatefulDrawable
   * @mixes SelfDrawable.Poolable
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function CircleSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'CircleSVGDrawable', CircleSVGDrawable );

  inherit( SVGSelfDrawable, CircleSVGDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {SVGSelfDrawable} - Self reference for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGCircleElements ); // usesPaint: true

      // @protected {SVGCircleElement} - Sole SVG element for this drawable, implementing API for SVGSelfDrawable
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'circle' );

      return this;
    },

    /**
     * Updates the SVG elements so that they will appear like the current node's representation.
     * @protected
     *
     * Implements the interface for SVGSelfDrawable (and is called from the SVGSelfDrawable's update).
     */
    updateSVGSelf: function() {
      var circle = this.svgElement;

      if ( this.dirtyRadius ) {
        circle.setAttribute( 'r', this.node._radius );
      }

      // Apply any fill/stroke changes to our element.
      this.updateFillStrokeStyle( circle );
    }
  } );

  // Include Circle's stateful mixin (used for dirty flags)
  CircleStatefulDrawable.mixin( CircleSVGDrawable );

  // This sets up CircleSVGDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( CircleSVGDrawable );

  return CircleSVGDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Canvas drawable for Circle nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/CircleCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );

  /**
   * A generated CanvasSelfDrawable whose purpose will be drawing our Circle. One of these drawables will be created
   * for each displayed instance of a Circle.
   * @public (scenery-internal)
   * @constructor
   * @extends CanvasSelfDrawable
   * @mixes PaintableStatelessDrawable
   * @mixes SelfDrawable.Poolable
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function CircleCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'CircleCanvasDrawable', CircleCanvasDrawable );

  inherit( CanvasSelfDrawable, CircleCanvasDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {CircleCanvasDrawable} - Self reference for chaining
     */
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    /**
     * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
     * @public
     *
     * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
     * other required effects (opacity, clipping, etc.) have already been prepared.
     *
     * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
     *
     * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
     * @param {Node} node - Our node that is being drawn
     * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
     */
    paintCanvas: function( wrapper, node, matrix ) {
      var context = wrapper.context;

      context.beginPath();
      context.arc( 0, 0, node._radius, 0, Math.PI * 2, false );
      context.closePath();

      if ( node.hasFill() ) {
        node.beforeCanvasFill( wrapper ); // defined in Paintable
        context.fill();
        node.afterCanvasFill( wrapper ); // defined in Paintable
      }
      if ( node.hasPaintableStroke() ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.stroke();
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },

    /**
     * Called when the radius of the circle changes.
     * @public (scenery-internal)
     */
    markDirtyRadius: function() {
      this.markPaintDirty();
    },

    /**
     * Disposes the drawable.
     * @public (scenery-internal)
     * @override
     */
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );

  // Since we're not using Circle's stateful mixin, we'll need to mix in the Paintable mixin here (of the stateless variety).
  PaintableStatelessDrawable.mixin( CircleCanvasDrawable );

  // This sets up CircleCanvasDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( CircleCanvasDrawable );

  return CircleCanvasDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * A circular node that inherits Path, and allows for optimized drawing and improved parameter handling.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Circle',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','DOT/Bounds2','SCENERY/nodes/Path','KITE/Shape','SCENERY/util/Features','SCENERY/display/Renderer','SCENERY/display/drawables/CircleDOMDrawable','SCENERY/display/drawables/CircleSVGDrawable','SCENERY/display/drawables/CircleCanvasDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Features = require( 'SCENERY/util/Features' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var CircleDOMDrawable = require( 'SCENERY/display/drawables/CircleDOMDrawable' );
  var CircleSVGDrawable = require( 'SCENERY/display/drawables/CircleSVGDrawable' );
  var CircleCanvasDrawable = require( 'SCENERY/display/drawables/CircleCanvasDrawable' );

  var CIRCLE_OPTION_KEYS = [
    'radius' // see setRadius() for more documentation
  ];

  /**
   * @public
   * @constructor
   * @extends Path
   * @mixes Paintable
   *
   * NOTE: There are two ways of invoking the constructor:
   * - new Circle( radius, { ... } )
   * - new Circle( { radius: radius, ... } )
   *
   * This allows the radius to be included in the parameter object for when that is convenient.
   *
   * @param {number} radius - The (non-negative) radius of the circle
   * @param {Object} [options] - Circle-specific options are documented in CIRCLE_OPTION_KEYS above, and can be provided
   *                             along-side options for Node
   */
  function Circle( radius, options ) {
    // @private {number} - The radius of the circle
    this._radius = 0;

    // Handle new Circle( { radius: ... } )
    if ( typeof radius === 'object' ) {
      options = radius;
      assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );
    }
    // Handle new Circle( radius, { ... } )
    else {
      assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );
      options = extendDefined( {
        radius: radius
      }, options );
    }

    Path.call( this, null, options );
  }

  scenery.register( 'Circle', Circle );

  inherit( Path, Circle, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: CIRCLE_OPTION_KEYS.concat( Path.prototype._mutatorKeys ),

    /**
     * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
     *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
     *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
     * @public (scenery-internal)
     * @override
     */
    drawableMarkFlags: Path.prototype.drawableMarkFlags.concat( [ 'radius' ] ).filter( function( flag ) {
      // We don't want the shape flag, as that won't be called for Path subtypes.
      return flag !== 'shape';
    } ),

    /**
     * Determines the default allowed renderers (returned via the Renderer bitmask) that are allowed, given the
     * current stroke options.
     * @public (scenery-internal)
     * @override
     *
     * We can support the DOM renderer if there is a solid-styled stroke (which otherwise wouldn't be supported).
     *
     * @returns {number} - Renderer bitmask, see Renderer for details
     */
    getStrokeRendererBitmask: function() {
      var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
      if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern && this.getLineWidth() <= this.getRadius() ) {
        bitmask |= Renderer.bitmaskDOM;
      }
      return bitmask;
    },

    /**
     * Determines the allowed renderers that are allowed (or excluded) based on the current Path.
     * @public (scenery-internal)
     * @override
     *
     * @returns {number} - Renderer bitmask, see Renderer for details
     */
    getPathRendererBitmask: function() {
      // If we can use CSS borderRadius, we can support the DOM renderer.
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG | ( Features.borderRadius ? Renderer.bitmaskDOM : 0 );
    },

    /**
     * Notifies that the circle has changed (probably the radius), and invalidates path information and our cached
     * shape.
     * @private
     */
    invalidateCircle: function() {
      assert && assert( this._radius >= 0, 'A circle needs a non-negative radius' );

      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;

      // should invalidate the path and ensure a redraw
      this.invalidatePath();
    },

    /**
     * Returns a Shape that is equivalent to our rendered display. Generally used to lazily create a Shape instance
     * when one is needed, without having to do so beforehand.
     * @private
     *
     * @returns {Shape}
     */
    createCircleShape: function() {
      return Shape.circle( 0, 0, this._radius ).makeImmutable();
    },

    /**
     * Returns whether this Circle's selfBounds is intersected by the specified bounds.
     * @public
     *
     * @param {Bounds2} bounds - Bounds to test, assumed to be in the local coordinate frame.
     * @returns {boolean}
     */
    intersectsBoundsSelf: function( bounds ) {
      // TODO: handle intersection with somewhat-infinite bounds!
      var x = Math.abs( bounds.centerX );
      var y = Math.abs( bounds.centerY );
      var halfWidth = bounds.maxX - x;
      var halfHeight = bounds.maxY - y;

      // too far to have a possible intersection
      if ( x > halfWidth + this._radius || y > halfHeight + this._radius ) {
        return false;
      }

      // guaranteed intersection
      if ( x <= halfWidth || y <= halfHeight ) {
        return true;
      }

      // corner case
      x -= halfWidth;
      y -= halfHeight;
      return x * x + y * y <= this._radius * this._radius;
    },

    /**
     * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
     * coordinate frame of this node.
     * @protected
     * @override
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} matrix - The transformation matrix already applied to the context.
     */
    canvasPaintSelf: function( wrapper, matrix ) {
      //TODO: Have a separate method for this, instead of touching the prototype. Can make 'this' references too easily.
      CircleCanvasDrawable.prototype.paintCanvas( wrapper, this, matrix );
    },

    /**
     * Creates a DOM drawable for this Circle.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {DOMSelfDrawable}
     */
    createDOMDrawable: function( renderer, instance ) {
      return CircleDOMDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a SVG drawable for this Circle.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {SVGSelfDrawable}
     */
    createSVGDrawable: function( renderer, instance ) {
      return CircleSVGDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a Canvas drawable for this Circle.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {CanvasSelfDrawable}
     */
    createCanvasDrawable: function( renderer, instance ) {
      return CircleCanvasDrawable.createFromPool( renderer, instance );
    },

    /**
     * Sets the radius of the circle.
     * @public
     *
     * @param {number} radius
     * @returns {Circle} - 'this' reference, for chaining
     */
    setRadius: function( radius ) {
      assert && assert( typeof radius === 'number', 'Circle.radius must be a number' );
      assert && assert( radius >= 0, 'A circle needs a non-negative radius' );
      assert && assert( isFinite( radius ), 'A circle needs a finite radius' );

      if ( this._radius !== radius ) {
        this._radius = radius;
        this.invalidateCircle();

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyRadius();
        }
      }
      return this;
    },
    set radius( value ) { return this.setRadius( value ); },

    /**
     * Returns the radius of the circle.
     * @public
     *
     * @returns {number} - The radius of the circle
     */
    getRadius: function() {
      return this._radius;
    },
    get radius() { return this.getRadius(); },

    /**
     * Computes the bounds of the Circle, including any applied stroke. Overridden for efficiency.
     * @public
     * @override
     *
     * @returns {Bounds2}
     */
    computeShapeBounds: function() {
      var bounds = new Bounds2( -this._radius, -this._radius, this._radius, this._radius );
      if ( this._stroke ) {
        // since we are axis-aligned, any stroke will expand our bounds by a guaranteed set amount
        bounds = bounds.dilated( this.getLineWidth() / 2 );
      }
      return bounds;
    },

    /**
     * Computes whether the provided point is "inside" (contained) in this Circle's self content, or "outside".
     * @protected
     * @override
     *
     * Exists to optimize hit detection, as it's quick to compute for circles.
     *
     * @param {Vector2} point - Considered to be in the local coordinate frame
     * @returns {boolean}
     */
    containsPointSelf: function( point ) {
      var magSq = point.x * point.x + point.y * point.y;
      var result = true;
      var iRadius;
      if ( this._strokePickable ) {
        iRadius = this.getLineWidth() / 2;
        var outerRadius = this._radius + iRadius;
        result = result && magSq <= outerRadius * outerRadius;
      }

      if ( this._fillPickable ) {
        if ( this._strokePickable ) {
          // we were either within the outer radius, or not
          return result;
        }
        else {
          // just testing in the fill range
          return magSq <= this._radius * this._radius;
        }
      }
      else if ( this._strokePickable ) {
        var innerRadius = this._radius - iRadius;
        return result && magSq >= innerRadius * innerRadius;
      }
      else {
        return false; // neither stroke nor fill is pickable
      }
    },

    /**
     * It is impossible to set another shape on this Path subtype, as its effective shape is determined by other
     * parameters.
     * @public
     * @override
     *
     * @param {Shape|null} shape - Throws an error if it is not null.
     */
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Circle to something non-null' );
      }
      else {
        // probably called from the Path constructor
        this.invalidatePath();
      }
    },

    /**
     * Returns an immutable copy of this Path subtype's representation.
     * @public
     * @override
     *
     * NOTE: This is created lazily, so don't call it if you don't have to!
     *
     * @returns {Shape}
     */
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createCircleShape();
      }
      return this._shape;
    },

    /**
     * Returns whether this Path has an associated Shape (instead of no shape, represented by null)
     * @public
     * @override
     *
     * @returns {boolean}
     */
    hasShape: function() {
      // Always true for this Path subtype
      return true;
    }
  } );

  return Circle;
} );

// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/TRadioButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/toEventOnEmit','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * Wrapper type for phet/sun's RadioButton class.
   * @param {RadioButton} radioButton
   * @param {String} phetioID
   * @constructor
   */
  function TRadioButton( radioButton, phetioID ) {

    if ( Tandem.validationEnabled() ) {
      assert && assert( !!radioButton.phetioValueType, 'phetioValueType must be defined' );
    }
    assertInstanceOf( radioButton, phet.sun.RadioButton );
    TNode.call( this, radioButton, phetioID );

    toEventOnEmit(
      radioButton.startedCallbacksForFiredEmitter,
      radioButton.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired',
      function( value ) {
        return { value: radioButton.phetioValueType.toStateObject( value ) };
      } );
  }

  phetioInherit( TNode, 'TRadioButton', TRadioButton, {}, {
    documentation: 'A traditional radio button',
    events: [ 'fired' ]
  } );

  sun.register( 'TRadioButton', TRadioButton );

  return TRadioButton;
} );


// Copyright 2013-2015, University of Colorado Boulder

/**
 * Base class for radio buttons.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/RadioButton',['require','SCENERY/input/ButtonListener','AXON/Emitter','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SUN/sun','TANDEM/Tandem','SUN/TRadioButton'],function( require ) {
  'use strict';

  // modules
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TRadioButton = require( 'SUN/TRadioButton' );

  /**
   * @param {Property} property
   * @param {*} value the value that corresponds to this button, same type as property
   * @param {Node} selectedNode node that will be displayed when the button is selected
   * @param {Node} deselectedNode node that will be displayed when the button is deselected
   * @param {Object} [options]
   * @constructor
   */
  function RadioButton( property, value, selectedNode, deselectedNode, options ) {

    options = _.extend( {
      cursor: 'pointer',
      tandem: Tandem.tandemRequired(),
      phetioType: TRadioButton,
      enabled: true,

      // a11y
      tagName: 'input',
      inputType: 'radio',
      parentContainerTagName: 'li',
      labelTagName: 'label',
      prependLabels: true
    }, options );

    assert && assert( !options.phetioValueType, 'phetioValueType should be specified in the property, not RadioButton options' );

    var self = this;
    Node.call( this );

    // @private
    this._enabled = options.enabled;

    // @public (phet-io)
    this.phetioValueType = property.phetioValueType;

    // Emitters for the PhET-iO data stream
    this.startedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );

    //Add an invisible node to make sure the layout for selected vs deselected is the same
    var background = new Rectangle( selectedNode.bounds.union( deselectedNode.bounds ) );
    selectedNode.pickable = deselectedNode.pickable = false; // the background rectangle suffices

    this.addChild( background );
    this.addChild( selectedNode );
    this.addChild( deselectedNode );

    // sync control with model
    var syncWithModel = function( newValue ) {
      selectedNode.visible = ( newValue === value );
      deselectedNode.visible = !selectedNode.visible;
    };
    property.link( syncWithModel );

    // set property value on fire
    var fire = function() {
      self.startedCallbacksForFiredEmitter.emit1( value );
      property.set( value );
      self.endedCallbacksForFiredEmitter.emit();
    };
    var buttonListener = new ButtonListener( {
      fire: fire
    } );
    this.addInputListener( buttonListener );

    // a11y - input listener so that updates the state of the radio button with keyboard interaction
    var changeListener = this.addAccessibleInputListener( {
      change: function( ) {
        fire();
      }
    } );

    // a11y - Specify the default value for assistive technology. This attribute is needed in addition to 
    // the 'checked' property to mark this element as the default selection since 'checked' may be set before
    // we are finished adding RadioButtons to the containing group, and the browser will remove the boolean
    // 'checked' flag when new buttons are added.
    if ( property.value === value ) {
      this.setAccessibleAttribute( 'checked', 'checked' );
    }

    // a11y - when the property changes, make sure the correct radio button is marked as 'checked' so that this button
    // receives focus on 'tab'
    var accessibleCheckedListener = function( newValue ) {
      self.accessibleChecked = newValue === value;
    };
    property.link( accessibleCheckedListener );

    // @private
    this.disposeRadioButton = function() {
      self.removeInputListener( buttonListener );
      self.removeAccessibleInputListener( changeListener );
      property.unlink( accessibleCheckedListener );
      property.unlink( syncWithModel );
    };

    this.mutate( options );
  }

  sun.register( 'RadioButton', RadioButton );

  return inherit( Node, RadioButton, {

    // @public - Provide dispose() on the prototype for ease of subclassing.
    dispose: function() {
      this.disposeRadioButton();
      Node.prototype.dispose.call( this );
    },

    /**
     * Sets the enabled state
     * @param {boolean} enabled
     * @public
     */
    setEnabled: function( enabled ) {
      this._enabled = enabled;
      this.opacity = enabled ? 1 : 0.3;
      this.pickable = enabled; // NOTE: This is a side-effect. If you set pickable independently, it will be changed when you set enabled.
    },
    set enabled( value ) { this.setEnabled( value ); },

    /**
     * Gets the enabled state
     * @returns {boolean}
     * @public
     */
    getEnabled: function() {
      return this._enabled;
    },
    get enabled() { return this.getEnabled(); }
  } );
} );

// Copyright 2016, University of Colorado Boulder

/**
 * PhET-iO Adapter for sun's AquaRadioButton
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/TAquaRadioButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TBoolean','SUN/sun','SUN/TRadioButton','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var sun = require( 'SUN/sun' );
  var TRadioButton = require( 'SUN/TRadioButton' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * Wrapper type for phet/sun's AquaRadioButton class.
   * @param {AquaRadioButton} radioButton
   * @param {string} phetioID
   * @constructor
   */
  function TAquaRadioButton( radioButton, phetioID ) {

    if ( Tandem.validationEnabled() ) {
      assert && assert( !!radioButton.phetioValueType, 'phetioValueType must be defined' );
    }

    assertInstanceOf( radioButton, phet.sun.AquaRadioButton );
    TRadioButton.call( this, radioButton, phetioID );
  }

  phetioInherit( TRadioButton, 'TAquaRadioButton', TAquaRadioButton, {
    setCircleButtonVisible: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( visible ) {
        this.instance.setCircleButtonVisible( visible );
      },
      documentation: 'Sets whether the circular part of the radio button will be displayed.'
    }
  }, {
    documentation: 'A radio button which looks like the Mac "Aqua" radio buttons'
  } );

  sun.register( 'TAquaRadioButton', TAquaRadioButton );

  return TAquaRadioButton;
} )
;
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Radio button with a pseudo-Aqua (Mac OS) look. See "options" comment for list of options.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/AquaRadioButton',['require','SCENERY/nodes/Circle','PHET_CORE/inherit','SCENERY/nodes/Node','SUN/RadioButton','SUN/sun','TANDEM/Tandem','SUN/TAquaRadioButton'],function( require ) {
  'use strict';

  // modules
  var Circle = require( 'SCENERY/nodes/Circle' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var RadioButton = require( 'SUN/RadioButton' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TAquaRadioButton = require( 'SUN/TAquaRadioButton' );

  /**
   * @param property
   * @param value the value that corresponds to this button, same type as property
   * @param {Node} node that will be vertically centered to the right of the button
   * @param {Object} [options]
   * @constructor
   */
  function AquaRadioButton( property, value, node, options ) {

    options = _.extend( {
      cursor: 'pointer',
      selectedColor: 'rgb( 143, 197, 250 )', // color used to fill the button when it's selected
      deselectedColor: 'white', // color used to fill the button when it's deselected
      centerColor: 'black', // color used to fill the center of teh button when it's selected
      radius: 16, // radius of the button
      xSpacing: 8, // horizontal space between the button and the node
      stroke: 'black', // color used to stroke the outer edge of the button
      tandem: Tandem.tandemRequired(),
      phetioType: TAquaRadioButton
    }, options );

    // @public (phet-io)
    this.phetioValueType = property.phetioValueType;

    // selected node
    var selectedNode = new Node();
    var innerCircle = new Circle( options.radius / 3, { fill: options.centerColor } );
    var outerCircleSelected = new Circle( options.radius, { fill: options.selectedColor, stroke: options.stroke } );

    // @private
    this.selectedCircleButton = new Node( {
      children: [ outerCircleSelected, innerCircle ]
    } );
    selectedNode.addChild( this.selectedCircleButton );
    selectedNode.addChild( node );
    node.left = outerCircleSelected.right + options.xSpacing;
    node.centerY = outerCircleSelected.centerY;

    // deselected node
    var deselectedNode = new Node();

    // @private
    this.deselectedCircleButton = new Circle( options.radius, {
      fill: options.deselectedColor,
      stroke: options.stroke
    } );
    deselectedNode.addChild( this.deselectedCircleButton );
    deselectedNode.addChild( node );
    node.left = this.deselectedCircleButton.right + options.xSpacing;
    node.centerY = this.deselectedCircleButton.centerY;

    RadioButton.call( this, property, value, selectedNode, deselectedNode, options );
  }

  sun.register( 'AquaRadioButton', AquaRadioButton );

  return inherit( RadioButton, AquaRadioButton, {

    /**
     * Sets whether the circular part of the radio button will be displayed.
     * @param {boolean} circleButtonVisible
     * @public
     */
    setCircleButtonVisible: function( circleButtonVisible ) {
      this.deselectedCircleButton.visible = circleButtonVisible;
      this.selectedCircleButton.visible = circleButtonVisible;
    }
  } );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Colors that are reused in many places throughout sun.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/ColorConstants',['require','SCENERY/util/Color','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );

  /**
   *
   * @constructor
   */
  function ColorConstants() {
  }

  sun.register( 'ColorConstants', ColorConstants );

  return inherit( Object, ColorConstants, {}, {

    //The default blue color used in many places, for buttons
    LIGHT_BLUE: new Color( 153, 206, 255 ),

    //Light gray, used as the 'disabled' color in many places.
    LIGHT_GRAY: new Color( 220, 220, 220 )
  } );
} );
// Copyright 2017, University of Colorado Boulder

/**
 * Creates a Property that does synchronization of values with a swappable Property that itself can change.
 * Handles the case where you need a Property that can switch between acting like multiple other Properties.
 *
 * With no other options specified, the value of this Property is:
 * - null, if valuePropertyProperty.value === null
 * - valuePropertyProperty.value.value otherwise
 *
 * The value of this Property (generalized, with the options available) is:
 * - derive( defaultValue ), if valuePropertyProperty.value === null
 * - map( derive( valuePropertyProperty.value ).value ) otherwise
 *
 * Generally, this DynamicProperty uses one-way synchronization (it only listens to the source), but if the
 * 'bidirectional' option is true, it will use two-way synchronization (changes to this Property will change the active
 * source). Thus when this Property changes value (when bidirectional is true), it will set:
 * - derive( valuePropertyProperty.value ).value = inverseMap( this.value ), if valuePropertyProperty.value !== null
 *
 *******************************
 * General example
 *******************************
 *   var firstProperty = new Property( Color.RED );
 *   var secondProperty = new Property( Color.BLUE );
 *   var currentProperty = new Property( firstProperty ); // {Property.<Property.<Color>>}
 *
 *   var backgroundFill = new DynamicProperty( currentProperty ) // Turns into a {Property.<Color>}
 *   backgroundFill.value; // Color.RED, since: currentProperty.value === firstProperty and
 *                                              firstProperty.value === Color.RED
 *   firstProperty.value = Color.YELLOW;
 *   backgroundFill.value; // Color.YELLOW - It's connected to firstProperty right now
 *
 *   currentProperty.value = secondProperty;
 *   backgroundFill.value; // Color.BLUE - It's the secondProperty's value
 *
 *   secondProperty.value = Color.MAGENTA;
 *   backgroundFill.value; // Color.MAGENTA - Yes, it's listening to the other Property now.
 *
 * Also supports falling back to null if our main Property is set to null:
 *   currentProperty.value = null;
 *   backgroundFill.value; // null
 *
 *******************************
 * 'derive' option
 *******************************
 * Additionally, DynamicProperty supports the ability to derive the Property value from our main Property's value.
 * For example, say you have multiple scenes each with the type:
 *   scene: {
 *     backgroundColorProperty: {Property.<Color>}
 *   }
 * and you have a currentSceneProperty: {Property.<Scene>}, you may want to create:
 *   var currentBackgroundColorProperty = new DynamicProperty( currentSceneProperty, {
 *     derive: 'backgroundColorProperty'
 *   } );
 * This would always report the current scene's current background color.
 * What if you sometimes don't have a scene active, e.g. {Property.<Scene|null>}? You can provide a default value:
 *  new DynamicProperty( currentSceneProperty, {
 *    derive: 'backgroundColorProperty',
 *    defaultValue: Color.BLACK
 *  } );
 * So that if the currentSceneProperty's value is null, the value of our DynamicProperty will be Color.BLACK.
 *
 *******************************
 * 'bidirectional' option
 *******************************
 * If you would like for direct changes to this Property to change the original source (bidirectional synchronization),
 * then pass bidirectional:true:
 *   var firstProperty = new Property( 5 );
 *   var secondProperty = new Property( 10 );
 *   var numberPropertyProperty = new Property( firstProperty );
 *   var dynamicProperty = new DynamicProperty( numberPropertyProperty, { bidirectional: true } );
 *   dynamicProperty.value = 2; // allowed now that it is bidrectional, otherwise prohibited
 *   firstProperty.value; // 2
 *   numberPropertyProperty.value = secondProperty; // change which Property is active
 *   dynamicProperty.value; // 10, from the new Property
 *   dynamicProperty.value = 0;
 *   secondProperty.value; // 0, set above.
 *   firstProperty.value; // still 2 from above, since our dynamic Property switched to the other Property
 *
 *******************************
 * 'map' and 'inverseMap' options
 *******************************
 * DynamicProperty also supports mapping values to different types. For example, say we have a
 * numberPropertyProperty {Property.<Property.<number>>}, but want to have a {Property.<string>} as the output. Then:
 *   new DynamicProperty( numberPropertyProperty, {
 *     map: function( number ) { return '' + number; }
 *   } );
 * will do the trick. If this needs to be done with a bidirectional DynamicProperty, also include inverseMap:
 *   new DynamicProperty( numberPropertyProperty, {
 *     bidirectional: true,
 *     map: function( number ) { return '' + number; },
 *     inverseMap: function( string ) { return Number.parseFloat( string ); }
 *   } );
 * so that changes to the dynamic Property will result in a change in the numberPropertyProperty's value.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'AXON/DynamicProperty',['require','AXON/axon','PHET_CORE/inherit','AXON/Property'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );

  /**
   * @constructor
   * @extends {Property}
   *
   * @param {Property.<*|null>} valuePropertyProperty - If the value is null, it is considered disconnected. If the
   *                                                    'derive' option is not used, then this should always have the
   *                                                    type {Property.<Property.<*>|null>}
   * @param {Object} [options] - options
   */
  function DynamicProperty( valuePropertyProperty, options ) {

    options = _.extend( {
      // {boolean} - If set to true then changes to this Property (if valuePropertyProperty.value is non-null at the
      //             time) will also be made to derive( valuePropertyProperty.value ).
      bidirectional: false,

      // {*} - If valuePropertyProperty.value === null, this dynamicProperty will act instead like
      //       derive( valuePropertyProperty.value ) === new Property( defaultValue ). Note that if a custom map
      //       function is provided, it will be applied to this defaultValue to determine our Property's value.
      defaultValue: null,

      // {function|string} - Maps a non-null valuePropertyProperty.value into the Property to be used. See top-level
      //                     documentation for usage. Uses the Lodash path specification (if it's a string).
      derive: _.identity,

      // {function|string} - Maps our input Property value to/from this Property's value. See top-level documentation
      //                     for usage. Uses the Lodash path specification (if it's a string).
      map: _.identity,
      inverseMap: _.identity
    }, options );

    // @public {boolean} - Set to true when this Property's value is changing from an external source.
    this.isExternallyChanging = false;

    // @private {Property.<*|null>}
    this.valuePropertyProperty = valuePropertyProperty;

    // @private {boolean}
    this.bidirectional = options.bidirectional;

    // @private {*}
    this.defaultValue = options.defaultValue;

    // @private {function}
    this.derive = typeof options.derive === 'string' ? _.property( options.derive ) : options.derive;
    this.map = typeof options.map === 'string' ? _.property( options.map ) : options.map;
    this.inverseMap = typeof options.inverseMap === 'string' ? _.property( options.inverseMap ) : options.inverseMap;

    // Use the Property's initial value
    var initialValue;
    if ( this.valuePropertyProperty.value === null ) {
      initialValue = this.map( this.defaultValue );
    }
    else {
      initialValue = this.map( this.derive( this.valuePropertyProperty.value ).value );
    }

    // Super call
    Property.call( this, initialValue, options );

    // @private {function}
    this.propertyPropertyListener = this.onPropertyPropertyChange.bind( this );

    // @private {function}
    this.propertyListener = this.onPropertyChange.bind( this );

    // Rehook our listener to whatever is the active Property.
    valuePropertyProperty.link( this.propertyListener );

    // If we aren't bidirectional, we should never add this listener.
    if ( options.bidirectional ) {
      this.lazyLink( this.onSelfChange.bind( this ) );
    }
  }

  axon.register( 'DynamicProperty', DynamicProperty );

  return inherit( Property, DynamicProperty, {
    /**
     * Listener added to the active inner Property.
     * @private
     *
     * @param {*} value - Should be either our defaultValue (if valuePropertyProperty.value is null), or
     *                    derive( valuePropertyProperty.value ).value otherwise.
     */
    onPropertyPropertyChange: function( value ) {
      // Since we override the setter here, we need to call the version on the prototype
      Property.prototype.set.call( this, this.map( value ) );
    },

    /**
     * Listener added to the outer Property.
     * @private
     *
     * @param {*|null} newPropertyValue - If derive is not provided then it should be a {Property.<*>|null}
     * @param {*|null|undefined} oldPropertyValue - If derive is not provided then it should be a {Property.<*>|null}.
     *                                              We additionally handle the initial link() case where this is
     *                                              undefined.
     */
    onPropertyChange: function( newPropertyValue, oldPropertyValue ) {
      if ( oldPropertyValue ) {
        this.derive( oldPropertyValue ).unlink( this.propertyPropertyListener );
      }
      if ( newPropertyValue ) {
        this.derive( newPropertyValue ).link( this.propertyPropertyListener );
      }
      else {
        // Switch to null when our Property's value is null.
        this.onPropertyPropertyChange( this.defaultValue );
      }
    },

    /**
     * Listener added to ourself when we are bidirectional
     * @private
     *
     * @param {*} value
     */
    onSelfChange: function( value ) {
      if ( this.valuePropertyProperty.value !== null ) {
        this.derive( this.valuePropertyProperty.value ).value = this.inverseMap( value );
      }
    },

    /**
     * Disposes this Property
     * @public
     */
    dispose: function() {
      this.valuePropertyProperty.unlink( this.propertyListener );

      if ( this.valuePropertyProperty.value !== null ) {
        this.derive( this.valuePropertyProperty.value ).unlink( this.propertyPropertyListener );
      }

      Property.prototype.dispose.call( this );
    },

    /**
     * Prevent setting this Property manually
     * @public
     * @override
     *
     * TODO: DerivedProperty should only need to do this, not all of the other methods it's also doing
     *
     * @param {*} value
     */
    set: function( value ) {
      assert && assert( this.bidirectional, 'Cannot set values directly to a DynamicProperty, tried to set: ' + value );

      this.isExternallyChanging = true;

      Property.prototype.set.call( this, value );

      this.isExternallyChanging = false;
    }
  } );
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * An arrow shape, either single or double headed.
 * ArrowShape has an optimization that allows you to reuse an array of Vector2.
 * The array will have 0 points if the tail and tip are the same point.
 *
 * @author John Blanco
 * @author Chris Malley
 * @author Aaron Davis
 * @author Sam Reid
 */
define( 'SCENERY_PHET/ArrowShape',['require','PHET_CORE/inherit','KITE/Shape','DOT/Vector2','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var Vector2 = require( 'DOT/Vector2' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   *
   * @param {number} tailX
   * @param {number} tailY
   * @param {number} tipX
   * @param {number} tipY
   * @param {Object} [options]
   * @constructor
   */
  function ArrowShape( tailX, tailY, tipX, tipY, options ) {

    options = _.extend( {
      tailWidth: 5,
      headWidth: 10,
      headHeight: 10,
      doubleHead: false,
      isHeadDynamic: false,
      scaleTailToo: false,
      fractionalHeadHeight: 0.5 // head will be scaled when head size is less than fractionalHeadHeight * arrow length
    }, options );

    Tandem.disallowTandem( options );

    var self = this;
    Shape.call( this );

    if ( tipX !== tailX || tipY !== tailY ) {

      var points = ArrowShape.getArrowShapePoints( tailX, tailY, tipX, tipY, [], options );

      // Describe the shape
      this.moveTo( points[ 0 ].x, points[ 0 ].y );
      var tail = _.tail( points );
      _.each( tail, function( element ) {
        self.lineTo( element.x, element.y );
      } );
      this.close();
    }
  }

  sceneryPhet.register( 'ArrowShape', ArrowShape );

  return inherit( Shape, ArrowShape, {}, {

    /**
     * This method is static so it can be used in ArrowShape as well as in ArrowNode.
     * @param {number} tailX
     * @param {number} tailY
     * @param {number} tipX
     * @param {number} tipY
     * @param {Vector2[]} shapePoints - if provided, values will be overwritten. This is to achieve
     *                                  high performance and is used by ArrowNode to avoid re-creating shapes.
     *                                  Tested this implementation vs the old one by creating hundreds of arrows and
     *                                  saw significant performance gains.
     * @param {Object} [options]
     * @returns {Array}
     * @static
     * @public
     */
    getArrowShapePoints: function( tailX, tailY, tipX, tipY, shapePoints, options ) {

      // default shapePoints to empty array if it isn't passed in
      if ( !shapePoints ) {
        shapePoints = [];
      }

      // if arrow has no length, it should have no points so that we don't attempt to draw anything
      if ( tipX === tailX && tipY === tailY ) {
        shapePoints.length = 0;
      }
      else {

        // The shape of the arrow will populate the shapePoints array
        var vector = new Vector2( tipX - tailX, tipY - tailY );
        var xHatUnit = vector.normalized();
        var yHatUnit = xHatUnit.rotated( Math.PI / 2 );
        var length = vector.magnitude();

        // scale down the head if head is dynamic.
        var headWidth = options.headWidth;
        var headHeight = options.headHeight;
        var tailWidth = options.tailWidth;
        if ( options.isHeadDynamic ) {
          if ( length < options.headHeight / options.fractionalHeadHeight ) {
            headHeight = length * options.fractionalHeadHeight;
            if ( options.scaleTailToo ) {
              tailWidth = options.tailWidth * headHeight / options.headHeight;
              headWidth = options.headWidth * headHeight / options.headHeight;
            }
          }
          else {
            // nothing to do; headHeight is already large enough, and previously computed values will be correct.
          }
        }

        // otherwise, just make sure that head height is less than arrow length
        else {
          headHeight = Math.min( options.headHeight, options.doubleHead ? 0.35 * length : 0.99 * length );
        }

        var index = 0;

        // Set up a coordinate frame that goes from the tail of the arrow to the tip.
        var addPoint = function( xHat, yHat ) {
          var x = xHatUnit.x * xHat + yHatUnit.x * yHat + tailX;
          var y = xHatUnit.y * xHat + yHatUnit.y * yHat + tailY;
          if ( shapePoints[ index ] ) {
            shapePoints[ index ].x = x;
            shapePoints[ index ].y = y;
          }
          else {
            shapePoints.push( new Vector2( x, y ) );
          }
          index++;
        };

        // Compute points for single- or double-headed arrow
        if ( options.doubleHead ) {
          addPoint( 0, 0 );
          addPoint( headHeight, headWidth / 2 );
          addPoint( headHeight, tailWidth / 2 );
        }
        else {
          addPoint( 0, tailWidth / 2 );
        }
        addPoint( length - headHeight, tailWidth / 2 );
        addPoint( length - headHeight, headWidth / 2 );
        addPoint( length, 0 );
        addPoint( length - headHeight, -headWidth / 2 );
        addPoint( length - headHeight, -tailWidth / 2 );
        if ( options.doubleHead ) {
          addPoint( headHeight, -tailWidth / 2 );
          addPoint( headHeight, -headWidth / 2 );
        }
        else {
          addPoint( 0, -tailWidth / 2 );
        }

        if ( index < shapePoints.length ) {
          shapePoints.length = index;
        }
      }
      return shapePoints;
    }
  } );
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * A single- or double-headed arrow. This is a convenience class, most of the work is done in ArrowShape.
 *
 * @author John Blanco
 * @author Chris Malley
 * @author Aaron Davis
 * @author Sam Reid
 */
define( 'SCENERY_PHET/ArrowNode',['require','SCENERY_PHET/ArrowShape','PHET_CORE/inherit','SCENERY/nodes/Path','SCENERY_PHET/sceneryPhet','KITE/Shape','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var ArrowShape = require( 'SCENERY_PHET/ArrowShape' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Shape = require( 'KITE/Shape' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {number} tailX
   * @param {number} tailY
   * @param {number} tipX
   * @param {number} tipY
   * @param {Object} [options]
   * @constructor
   */
  function ArrowNode( tailX, tailY, tipX, tipY, options ) {

    // default options
    options = _.extend( {
      headHeight: 10,
      headWidth: 10,
      tailWidth: 5,
      isHeadDynamic: false,
      scaleTailToo: false,
      fractionalHeadHeight: 0.5, // head will be scaled when head size is less than fractionalHeadHeight * arrow length
      doubleHead: false, // true puts heads on both ends of the arrow, false puts a head at the tip
      fill: 'black',
      stroke: 'black',
      lineWidth: 1,
      tandem: Tandem.tandemRequired()
    }, options );
    this.options = options; // @private

    Path.call( this, null );
    this.shapePoints = [];
    this.setTailAndTip( tailX, tailY, tipX, tipY );

    // things you're likely to mess up, add more as needed
    assert && assert( options.headWidth > options.tailWidth );

    this.mutate( options );
  }

  sceneryPhet.register( 'ArrowNode', ArrowNode );

  return inherit( Path, ArrowNode, {

    /**
     * Update the internal shapePoints array which is used to populate the points in the Shape instance.
     *
     * @private
     * @returns {boolean} true if the number of points in the array has changed, which would require building a new
     *                    shape instance.
     */
    updateShapePoints: function() {
      var numberOfPoints = this.shapePoints.length;
      this.shapePoints = ArrowShape.getArrowShapePoints( this.tailX, this.tailY, this.tipX, this.tipY, this.shapePoints, this.options );
      return this.shapePoints.length !== numberOfPoints;
    },

    /**
     * Initialize or update the shape. Only called if the number of points in the shape changes.
     * @private
     */
    updateShape: function() {

      var shape = new Shape();

      if ( this.shapePoints.length > 1 ) {
        shape.moveToPoint( this.shapePoints[ 0 ] );
        for ( var i = 1; i < this.shapePoints.length; i++ ) {
          shape.lineToPoint( this.shapePoints[ i ] );
        }
        shape.close();
      }

      this.shape = shape;
    },

    /**
     * Set the tail and tip locations to update the arrow shape
     * @public
     */
    setTailAndTip: function( tailX, tailY, tipX, tipY ) {

      // assert && assert( !(tailX === tipX && tailY === tipY), 'arrow should have different tail and tip' );

      this.tailX = tailX; // @public {read-only}
      this.tailY = tailY; // @public {read-only}
      this.tipX = tipX; // @public {read-only}
      this.tipY = tipY; // @public {read-only}

      var numberOfPointsChanged = this.updateShapePoints();

      // This bit of logic is to improve performance for the case where the Shape instance can be reused (if the number
      // of points in the array is the same)
      if ( !this.shape || numberOfPointsChanged ) {
        this.updateShape();
      }
      else {

        // This is the higher-performance case where the Shape instance can be reused
        this.shape.invalidatePoints();
      }
    },

    /**
     * @public
     * @param {number} tailWidth
     */
    setTailWidth: function( tailWidth ) {
      this.options.tailWidth = tailWidth;
      this.updateShapePoints();
      this.updateShape();
    },

    /**
     * @public - set whether the arrow has one triangle or two
     * @param {number} doubleHead
     */
    setDoubleHead: function( doubleHead ) {
      this.options.doubleHead = doubleHead;
      this.updateShapePoints();
      this.updateShape();
    }
  } );
} );

// Copyright 2014-2017, University of Colorado Boulder

/**
 * A single- or double-headed curved arrow.
 * Arrow heads are not curved, their tips are perpendicular to the ends of the arrow tail.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/CurvedArrowShape',['require','PHET_CORE/inherit','KITE/Shape','DOT/Vector2','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var Vector2 = require( 'DOT/Vector2' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * This is a general algorithm, used herein to compute the point for an arrow's tip.
   * Given 2 points that define a line segment (the arrow's base), compute the point (the tip) that
   * is a specified distance away from a perpendicular line that runs through the center point
   * of the line segment.
   *
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   * @param distance
   * @returns {Vector2}
   */
  var computePerpendicularPoint = function( x1, y1, x2, y2, distance ) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    var r = Math.sqrt( dx * dx + dy * dy );
    // midpoint + distance * unitVector
    var x = ( x1 + x2 ) / 2 + ( distance * dy / r );
    var y = ( y1 + y2 ) / 2 - ( distance * dx / r );
    return new Vector2( x, y );
  };

  /**
   * @param {number} radius radius at the center of the arrow's tail
   * @param {number} startAngle starting angle, in radians (at tail, or optional 2nd head)
   * @param {number} endAngle end angle, in radians (at head of arrow)
   * @param {Object} [options]
   * @constructor
   */
  function CurvedArrowShape( radius, startAngle, endAngle, options ) {
    options = _.extend( {
      doubleHead: false, // false = single head at endAngle, true = heads at startAngle and endAngle
      headWidth: 10,
      headHeight: 10,
      tailWidth: 5
    }, options );

    Shape.call( this );

    // Points that define the base of an arrow head. 'inner' is closer to the center of the circle, 'outer' is farther away.
    var baseInnerX;
    var baseInnerY;
    var baseOuterX;
    var baseOuterY;

    // optional head at startAngle
    if ( options.doubleHead ) {

      // base of the arrow head at startAngle
      baseInnerX = Math.cos( startAngle ) * ( radius - options.headWidth / 2 );
      baseInnerY = Math.sin( startAngle ) * ( radius - options.headWidth / 2 );
      baseOuterX = Math.cos( startAngle ) * ( radius + options.headWidth / 2 );
      baseOuterY = Math.sin( startAngle ) * ( radius + options.headWidth / 2 );

      // tip of the arrow head at startAngle
      var startTip = computePerpendicularPoint( baseOuterX, baseOuterY, baseInnerX, baseInnerY, options.headHeight );

      // head at startAngle
      this.moveTo( baseInnerX, baseInnerY )
        .lineTo( startTip.x, startTip.y )
        .lineTo( baseOuterX, baseOuterY );
    }

    // outer arc from startAngle to endAngle
    this.arc( 0, 0, radius + options.tailWidth / 2, startAngle, endAngle, options.anticlockwise );

    // base of the arrow head at endAngle
    baseInnerX = Math.cos( endAngle ) * ( radius - options.headWidth / 2 );
    baseInnerY = Math.sin( endAngle ) * ( radius - options.headWidth / 2 );
    baseOuterX = Math.cos( endAngle ) * ( radius + options.headWidth / 2 );
    baseOuterY = Math.sin( endAngle ) * ( radius + options.headWidth / 2 );

    // tip of the arrow head at endAngle
    var endTip = computePerpendicularPoint( baseInnerX, baseInnerY, baseOuterX, baseOuterY, options.headHeight );

    // arrow head at endAngle
    this.lineTo( baseOuterX, baseOuterY )
      .lineTo( endTip.x, endTip.y )
      .lineTo( baseInnerX, baseInnerY );

    // inner arc from endAngle to startAngle
    this.arc( 0, 0, radius - options.tailWidth / 2, endAngle, startAngle, !options.anticlockwise );

    // Workaround for https://github.com/phetsims/scenery/issues/214 (Firefox-specific path rendering issue)
    this.lineTo( Math.cos( startAngle ) * radius, Math.sin( startAngle ) * radius + 0.00001 );

    this.close();
  }

  sceneryPhet.register( 'CurvedArrowShape', CurvedArrowShape );

  return inherit( Shape, CurvedArrowShape );
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Provides access to Font Awesome glyphs as scenery nodes.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/FontAwesomeNode',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/nodes/Path','KITE/Shape','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );

  /*
   * This data structure contains SVG descriptions of Font Awesome icons used in PhET simulations.
   * This entire data structure is included in sims that use FontAwesomeNode, so only icons that are
   * actually used should be included.
   *
   * Keys are based on Font Awesome icon names, values are {string} SVG data.
   *
   * To add a new icon:
   * (1) Find the icon at http://fontawesome.io/icons/
   * (2) Note the icon's name and Unicode value.
   *     E.g. http://fontawesome.io/icon/level-down/ is 'fa-level-down' and 'f149'
   * (3) Navigate to sherpa/lib/font-awesome-*\/fonts/fontawesome-webfont.svg
   * (4) Locate the Unicode value in fontawesome-webfont.svg.
   *     If it's not there, you'll likely need to download a more recent version of fontawesome-webfont.svg.
   * (5) Locate the SVG data from the corresponding d="..." field.
   * (6) Create a new field name in the ICONS hash below. The field name should be based on the icon's name.
   *     Remove the 'fa-' prefix and replace '-' with '_'.
   *     E.g. 'fa-level-down' -> level_down.
   * (7) Copy the SVG data to the new field in ICONS.
   */
  var ICONS = {
    camera: 'M960 864q119 0 203.5 -84.5t84.5 -203.5t-84.5 -203.5t-203.5 -84.5t-203.5 84.5t-84.5 203.5t84.5 203.5t203.5 84.5zM1664 1280q106 0 181 -75t75 -181v-896q0 -106 -75 -181t-181 -75h-1408q-106 0 -181 75t-75 181v896q0 106 75 181t181 75h224l51 136 q19 49 69.5 84.5t103.5 35.5h512q53 0 103.5 -35.5t69.5 -84.5l51 -136h224zM960 128q185 0 316.5 131.5t131.5 316.5t-131.5 316.5t-316.5 131.5t-316.5 -131.5t-131.5 -316.5t131.5 -316.5t316.5 -131.5z',
    check: 'M1671 970q0 -40 -28 -68l-724 -724l-136 -136q-28 -28 -68 -28t-68 28l-136 136l-362 362q-28 28 -28 68t28 68l136 136q28 28 68 28t68 -28l294 -295l656 657q28 28 68 28t68 -28l136 -136q28 -28 28 -68z',
    check_empty: 'M1120 1280h-832q-66 0 -113 -47t-47 -113v-832q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v832q0 66 -47 113t-113 47zM1408 1120v-832q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832 q119 0 203.5 -84.5t84.5 -203.5z',
    check_square_o: 'M1408 606v-318q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832q63 0 117 -25q15 -7 18 -23q3 -17 -9 -29l-49 -49q-10 -10 -23 -10q-3 0 -9 2q-23 6 -45 6h-832q-66 0 -113 -47t-47 -113v-832 q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v254q0 13 9 22l64 64q10 10 23 10q6 0 12 -3q20 -8 20 -29zM1639 1095l-814 -814q-24 -24 -57 -24t-57 24l-430 430q-24 24 -24 57t24 57l110 110q24 24 57 24t57 -24l263 -263l647 647q24 24 57 24t57 -24l110 -110 q24 -24 24 -57t-24 -57z',
    cut: 'M960 640q26 0 45 -19t19 -45t-19 -45t-45 -19t-45 19t-19 45t19 45t45 19zM1260 576l507 -398q28 -20 25 -56q-5 -35 -35 -51l-128 -64q-13 -7 -29 -7q-17 0 -31 8l-690 387l-110 -66q-8 -4 -12 -5q14 -49 10 -97q-7 -77 -56 -147.5t-132 -123.5q-132 -84 -277 -84 q-136 0 -222 78q-90 84 -79 207q7 76 56 147t131 124q132 84 278 84q83 0 151 -31q9 13 22 22l122 73l-122 73q-13 9 -22 22q-68 -31 -151 -31q-146 0 -278 84q-82 53 -131 124t-56 147q-5 59 15.5 113t63.5 93q85 79 222 79q145 0 277 -84q83 -52 132 -123t56 -148 q4 -48 -10 -97q4 -1 12 -5l110 -66l690 387q14 8 31 8q16 0 29 -7l128 -64q30 -16 35 -51q3 -36 -25 -56zM579 836q46 42 21 108t-106 117q-92 59 -192 59q-74 0 -113 -36q-46 -42 -21 -108t106 -117q92 -59 192 -59q74 0 113 36zM494 91q81 51 106 117t-21 108 q-39 36 -113 36q-100 0 -192 -59q-81 -51 -106 -117t21 -108q39 -36 113 -36q100 0 192 59zM672 704l96 -58v11q0 36 33 56l14 8l-79 47l-26 -26q-3 -3 -10 -11t-12 -12q-2 -2 -4 -3.5t-3 -2.5zM896 480l96 -32l736 576l-128 64l-768 -431v-113l-160 -96l9 -8q2 -2 7 -6 q4 -4 11 -12t11 -12l26 -26zM1600 64l128 64l-520 408l-177 -138q-2 -3 -13 -7z',
    eye_close: 'M555 201l78 141q-87 63 -136 159t-49 203q0 121 61 225q-229 -117 -381 -353q167 -258 427 -375zM944 960q0 20 -14 34t-34 14q-125 0 -214.5 -89.5t-89.5 -214.5q0 -20 14 -34t34 -14t34 14t14 34q0 86 61 147t147 61q20 0 34 14t14 34zM1307 1151q0 -7 -1 -9 q-105 -188 -315 -566t-316 -567l-49 -89q-10 -16 -28 -16q-12 0 -134 70q-16 10 -16 28q0 12 44 87q-143 65 -263.5 173t-208.5 245q-20 31 -20 69t20 69q153 235 380 371t496 136q89 0 180 -17l54 97q10 16 28 16q5 0 18 -6t31 -15.5t33 -18.5t31.5 -18.5t19.5 -11.5 q16 -10 16 -27zM1344 704q0 -139 -79 -253.5t-209 -164.5l280 502q8 -45 8 -84zM1792 576q0 -35 -20 -69q-39 -64 -109 -145q-150 -172 -347.5 -267t-419.5 -95l74 132q212 18 392.5 137t301.5 307q-115 179 -282 294l63 112q95 -64 182.5 -153t144.5 -184q20 -34 20 -69z',
    eye_open: 'M1664 576q-152 236 -381 353q61 -104 61 -225q0 -185 -131.5 -316.5t-316.5 -131.5t-316.5 131.5t-131.5 316.5q0 121 61 225q-229 -117 -381 -353q133 -205 333.5 -326.5t434.5 -121.5t434.5 121.5t333.5 326.5zM944 960q0 20 -14 34t-34 14q-125 0 -214.5 -89.5 t-89.5 -214.5q0 -20 14 -34t34 -14t34 14t14 34q0 86 61 147t147 61q20 0 34 14t14 34zM1792 576q0 -34 -20 -69q-140 -230 -376.5 -368.5t-499.5 -138.5t-499.5 139t-376.5 368q-20 35 -20 69t20 69q140 229 376.5 368t499.5 139t499.5 -139t376.5 -368q20 -35 20 -69z',
    exchange: 'M1792 352v-192q0 -13 -9.5 -22.5t-22.5 -9.5h-1376v-192q0 -13 -9.5 -22.5t-22.5 -9.5q-12 0 -24 10l-319 320q-9 9 -9 22q0 14 9 23l320 320q9 9 23 9q13 0 22.5 -9.5t9.5 -22.5v-192h1376q13 0 22.5 -9.5t9.5 -22.5zM1792 896q0 -14 -9 -23l-320 -320q-9 -9 -23 -9 q-13 0 -22.5 9.5t-9.5 22.5v192h-1376q-13 0 -22.5 9.5t-9.5 22.5v192q0 13 9.5 22.5t22.5 9.5h1376v192q0 14 9 23t23 9q12 0 24 -10l319 -319q9 -9 9 -23z',
    home: 'M1408 544v-480q0 -26 -19 -45t-45 -19h-384v384h-256v-384h-384q-26 0 -45 19t-19 45v480q0 1 0.5 3t0.5 3l575 474l575 -474q1 -2 1 -6zM1631 613l-62 -74q-8 -9 -21 -11h-3q-13 0 -21 7l-692 577l-692 -577q-12 -8 -24 -7q-13 2 -21 11l-62 74q-8 10 -7 23.5t11 21.5 l719 599q32 26 76 26t76 -26l244 -204v195q0 14 9 23t23 9h192q14 0 23 -9t9 -23v-408l219 -182q10 -8 11 -21.5t-7 -23.5z',
    info_circle: 'M1024 160v160q0 14 -9 23t-23 9h-96v512q0 14 -9 23t-23 9h-320q-14 0 -23 -9t-9 -23v-160q0 -14 9 -23t23 -9h96v-320h-96q-14 0 -23 -9t-9 -23v-160q0 -14 9 -23t23 -9h448q14 0 23 9t9 23zM896 1056v160q0 14 -9 23t-23 9h-192q-14 0 -23 -9t-9 -23v-160q0 -14 9 -23 t23 -9h192q14 0 23 9t9 23zM1536 640q0 -209 -103 -385.5t-279.5 -279.5t-385.5 -103t-385.5 103t-279.5 279.5t-103 385.5t103 385.5t279.5 279.5t385.5 103t385.5 -103t279.5 -279.5t103 -385.5z',
    level_down: 'M32 1280h704q13 0 22.5 -9.5t9.5 -23.5v-863h192q40 0 58 -37t-9 -69l-320 -384q-18 -22 -49 -22t-49 22l-320 384q-26 31 -9 69q18 37 58 37h192v640h-320q-14 0 -25 11l-160 192q-13 14 -4 34q9 19 29 19z',
    pencil_square_o: 'M888 352l116 116l-152 152l-116 -116v-56h96v-96h56zM1328 1072q-16 16 -33 -1l-350 -350q-17 -17 -1 -33t33 1l350 350q17 17 1 33zM1408 478v-190q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832 q63 0 117 -25q15 -7 18 -23q3 -17 -9 -29l-49 -49q-14 -14 -32 -8q-23 6 -45 6h-832q-66 0 -113 -47t-47 -113v-832q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v126q0 13 9 22l64 64q15 15 35 7t20 -29zM1312 1216l288 -288l-672 -672h-288v288zM1756 1084l-92 -92 l-288 288l92 92q28 28 68 28t68 -28l152 -152q28 -28 28 -68t-28 -68z',
    refresh: 'M1511 480q0 -5 -1 -7q-64 -268 -268 -434.5t-478 -166.5q-146 0 -282.5 55t-243.5 157l-129 -129q-19 -19 -45 -19t-45 19t-19 45v448q0 26 19 45t45 19h448q26 0 45 -19t19 -45t-19 -45l-137 -137q71 -66 161 -102t187 -36q134 0 250 65t186 179q11 17 53 117 q8 23 30 23h192q13 0 22.5 -9.5t9.5 -22.5zM1536 1280v-448q0 -26 -19 -45t-45 -19h-448q-26 0 -45 19t-19 45t19 45l138 138q-148 137 -349 137q-134 0 -250 -65t-186 -179q-11 -17 -53 -117q-8 -23 -30 -23h-199q-13 0 -22.5 9.5t-9.5 22.5v7q65 268 270 434.5t480 166.5 q146 0 284 -55.5t245 -156.5l130 129q19 19 45 19t45 -19t19 -45z',
    reply: 'M1792 416q0 -166 -127 -451q-3 -7 -10.5 -24t-13.5 -30t-13 -22q-12 -17 -28 -17q-15 0 -23.5 10t-8.5 25q0 9 2.5 26.5t2.5 23.5q5 68 5 123q0 101 -17.5 181t-48.5 138.5t-80 101t-105.5 69.5t-133 42.5t-154 21.5t-175.5 6h-224v-256q0 -26 -19 -45t-45 -19t-45 19 l-512 512q-19 19 -19 45t19 45l512 512q19 19 45 19t45 -19t19 -45v-256h224q713 0 875 -403q53 -134 53 -333z',
    times: 'M1298 214q0 -40 -28 -68l-136 -136q-28 -28 -68 -28t-68 28l-294 294l-294 -294q-28 -28 -68 -28t-68 28l-136 136q-28 28 -28 68t28 68l294 294l-294 294q-28 28 -28 68t28 68l136 136q28 28 68 28t68 -28l294 -294l294 294q28 28 68 28t68 -28l136 -136q28 -28 28 -68 t-28 -68l-294 -294l294 -294q28 -28 28 -68z',
    times_circle: 'M1149 414q0 26 -19 45l-181 181l181 181q19 19 19 45q0 27 -19 46l-90 90q-19 19 -46 19q-26 0 -45 -19l-181 -181l-181 181q-19 19 -45 19q-27 0 -46 -19l-90 -90q-19 -19 -19 -46q0 -26 19 -45l181 -181l-181 -181q-19 -19 -19 -45q0 -27 19 -46l90 -90q19 -19 46 -19 q26 0 45 19l181 181l181 -181q19 -19 45 -19q27 0 46 19l90 90q19 19 19 46zM1536 640q0 -209 -103 -385.5t-279.5 -279.5t-385.5 -103t-385.5 103t-279.5 279.5t-103 385.5t103 385.5t279.5 279.5t385.5 103t385.5 -103t279.5 -279.5t103 -385.5z',
    trash: 'M512 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM768 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM1024 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576 q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM1152 76v948h-896v-948q0 -22 7 -40.5t14.5 -27t10.5 -8.5h832q3 0 10.5 8.5t14.5 27t7 40.5zM480 1152h448l-48 117q-7 9 -17 11h-317q-10 -2 -17 -11zM1408 1120v-64q0 -14 -9 -23t-23 -9h-96v-948q0 -83 -47 -143.5t-113 -60.5h-832 q-66 0 -113 58.5t-47 141.5v952h-96q-14 0 -23 9t-9 23v64q0 14 9 23t23 9h309l70 167q15 37 54 63t79 26h320q40 0 79 -26t54 -63l70 -167h309q14 0 23 -9t9 -23z',
    undo: 'M1536 640q0 -156 -61 -298t-164 -245t-245 -164t-298 -61q-179 0 -336.5 76t-266 213t-147.5 312q-3 14 7 27q9 12 25 12h199q23 0 30 -23q50 -162 185 -261.5t304 -99.5q104 0 198.5 40.5t163.5 109.5t109.5 163.5t40.5 198.5t-40.5 198.5t-109.5 163.5t-163.5 109.5 t-198.5 40.5q-98 0 -188 -35.5t-160 -101.5l137 -138q31 -30 14 -69q-17 -40 -59 -40h-448q-26 0 -45 19t-19 45v448q0 42 40 59q39 17 69 -14l130 -129q107 101 244.5 156.5t284.5 55.5q156 0 298 -61t245 -164t164 -245t61 -298z',
    volume_off: 'M768 1184v-1088q0 -26 -19 -45t-45 -19t-45 19l-333 333h-262q-26 0 -45 19t-19 45v384q0 26 19 45t45 19h262l333 333q19 19 45 19t45 -19t19 -45z',
    volume_up: 'M768 1184v-1088q0 -26 -19 -45t-45 -19t-45 19l-333 333h-262q-26 0 -45 19t-19 45v384q0 26 19 45t45 19h262l333 333q19 19 45 19t45 -19t19 -45zM1152 640q0 -76 -42.5 -141.5t-112.5 -93.5q-10 -5 -25 -5q-26 0 -45 18.5t-19 45.5q0 21 12 35.5t29 25t34 23t29 35.5 t12 57t-12 57t-29 35.5t-34 23t-29 25t-12 35.5q0 27 19 45.5t45 18.5q15 0 25 -5q70 -27 112.5 -93t42.5 -142zM1408 640q0 -153 -85 -282.5t-225 -188.5q-13 -5 -25 -5q-27 0 -46 19t-19 45q0 39 39 59q56 29 76 44q74 54 115.5 135.5t41.5 173.5t-41.5 173.5 t-115.5 135.5q-20 15 -76 44q-39 20 -39 59q0 26 19 45t45 19q13 0 26 -5q140 -59 225 -188.5t85 -282.5zM1664 640q0 -230 -127 -422.5t-338 -283.5q-13 -5 -26 -5q-26 0 -45 19t-19 45q0 36 39 59q7 4 22.5 10.5t22.5 10.5q46 25 82 51q123 91 192 227t69 289t-69 289 t-192 227q-36 26 -82 51q-7 4 -22.5 10.5t-22.5 10.5q-39 23 -39 59q0 26 19 45t45 19q13 0 26 -5q211 -91 338 -283.5t127 -422.5z',
    warning_sign: 'M1024 161v190q0 14 -9.5 23.5t-22.5 9.5h-192q-13 0 -22.5 -9.5t-9.5 -23.5v-190q0 -14 9.5 -23.5t22.5 -9.5h192q13 0 22.5 9.5t9.5 23.5zM1022 535l18 459q0 12 -10 19q-13 11 -24 11h-220q-11 0 -24 -11q-10 -7 -10 -21l17 -457q0 -10 10 -16.5t24 -6.5h185 q14 0 23.5 6.5t10.5 16.5zM1008 1469l768 -1408q35 -63 -2 -126q-17 -29 -46.5 -46t-63.5 -17h-1536q-34 0 -63.5 17t-46.5 46q-37 63 -2 126l768 1408q17 31 47 49t65 18t65 -18t47 -49z'
  };

  // constants
  var SHAPE_MATRIX = Matrix3.createFromPool( 0.025, 0, 0, 0, -0.025, 0, 0, 0, 1 ); // to create a unity-scale icon

  // keys are fontawesome icon names, values are Shape instances.
  // Shapes are immutable so that Path doesn't add a listener, which creates a memory leak.
  var shapeCache = {};

  /**
   * @param {string} iconName - the fontawesome icon name
   * @param {Object} [options]
   * @constructor
   */
  function FontAwesomeNode( iconName, options ) {

    // default values
    options = _.extend( {
      fill: '#000',

      // Font awesome nodes are expensive to pick (and have a lot of holes in them which you may wish to pick anyways,
      // such as the door of the 'home' icon, so don't pick by default.
      pickable: false,

      // {boolean} use Shape caching for this instance? Note that there is no way to remove an entry from the cache
      // so only cache a shape if it will persist for the lifetime of the simulation.
      enableCache: true
    }, options );

    var shape;
    if ( options.enableCache ) {

      // cache the shape
      if ( !shapeCache[ iconName ] ) {
        shapeCache[ iconName ] = FontAwesomeNode.createShape( iconName );
      }

      // get the shape from the cache
      shape = shapeCache[ iconName ];
    }
    else {

      // don't use the cache
      shape = FontAwesomeNode.createShape( iconName );
    }

    Path.call( this, shape, options );
  }

  sun.register( 'FontAwesomeNode', FontAwesomeNode );

  return inherit( Path, FontAwesomeNode, {}, {

    /**
     * Creates an immutable Shape for a specified fontawesome icon.
     *
     * @param {string} iconName - the fontawesome icon name
     * @returns {Shape}
     */
    createShape: function( iconName ) {
      assert && assert( ICONS[ iconName ], 'unsupported iconName: ' + iconName );
      return new Shape( ICONS[ iconName ] ).transformed( SHAPE_MATRIX ).makeImmutable();
    }
  } );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * The ButtonListener is a scenery Input Listener that translates input events (down, up, enter, exit) into states in a
 * button model.  Duck typing is used for the buttonModel, it can be anything with "down" and "over" boolean properties,
 * such as a PushButtonModel or a StickyToggleButtonModel.
 *
 * One assumption of this ButtonListener is that only one pointer can interact with the button at a time, and the other
 * pointers are effectively "locked out" while another pointer is using the button.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/buttons/ButtonListener',['require','SCENERY/input/DownUpListener','SCENERY/input/Input','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var DownUpListener = require( 'SCENERY/input/DownUpListener' );
  var Input = require( 'SCENERY/input/Input' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {*} buttonModel any object with 'downProperty' and 'overProperty' boolean attributes
   * @constructor
   */
  function ButtonListener( buttonModel ) {

    this.buttonModel = buttonModel; // @private
    var self = this;

    // Track the pointer that is currently interacting with this button, ignore others.
    this.overPointer = null; // @private
    this.downPointer = null; // @private

    DownUpListener.call( this, {
      down: function( event, trail ) {
        if ( self.downPointer === null ) {
          self.downPointer = event.pointer;
        }
        if ( event.pointer === self.downPointer ) {
          buttonModel.downProperty.set( true );
        }
      },

      up: function( event, trail ) {
        if ( event.pointer === self.downPointer ) {
          self.downPointer = null;
          buttonModel.downProperty.set( false );
        }
      }
    } );
  }

  sun.register( 'ButtonListener', ButtonListener );

  return inherit( DownUpListener, ButtonListener, {

    /**
     * When this Button has focus, pressing a key down presses the button.  This is part of the accessibility feature
     * set. This API is subject to change (if we make a more specific ENTER/SPACE callback).
     * @param {Event} event
     * @param {Trail} trail
     * @public
     */
    keydown: function( event, trail ) {
      if ( event.domEvent.keyCode === Input.KEY_ENTER || event.domEvent.keyCode === Input.KEY_SPACE ) {
        this.enter( event, trail );
        this.buttonModel.downProperty.set( true );
      }
    },

    /**
     * When this Button has focus, pressing a key up releases the button.  This is part of the accessibility feature
     * set. This API is subject to change (if we make a more specific ENTER/SPACE callback
     * @param {Event} event
     * @param {Trail} trail
     * @public
     */
    keyup: function( event, trail ) {
      if ( event.domEvent.keyCode === Input.KEY_ENTER || event.domEvent.keyCode === Input.KEY_SPACE ) {
        this.buttonModel.downProperty.set( false );
        this.exit( event, trail );
      }
    },

    // @public
    enter: function( event, trail ) {
      if ( this.overPointer === null ) {
        this.overPointer = event.pointer;
        this.buttonModel.overProperty.set( true );
      }
    },

    // @public
    exit: function( event, trail ) {
      if ( event.pointer === this.overPointer ) {
        this.overPointer = null;
        this.buttonModel.overProperty.set( false );
      }
    }
  } );
} );
// Copyright 2017, University of Colorado Boulder

/**
 * Handles creation of an SVG stop element, and handles keeping it updated based on property/color changes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGGradientStop',['require','SCENERY/util/Color','PHET_CORE/inherit','PHET_CORE/Poolable','AXON/Property','SCENERY/scenery'],function( require ) {
  'use strict';

  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Property = require( 'AXON/Property' );
  var scenery = require( 'SCENERY/scenery' );

  var scratchColor = new Color( 'transparent' );

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param {SVGGradient} svgGradient
   * @param {number} ratio
   * @param {Color|string|Property.<Color|string|null>|null} color
   */
  function SVGGradientStop( svgGradient, ratio, color ) {
    this.initialize( svgGradient, ratio, color );
  }

  scenery.register( 'SVGGradientStop', SVGGradientStop );

  inherit( Object, SVGGradientStop, {
    /**
     * Poolable initializer.
     * @private
     *
     * @param {SVGGradient} svgGradient
     * @param {number} ratio
     * @param {Color|string|Property.<Color|string|null>|null} color
     */
    initialize: function( svgGradient, ratio, color ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] initialize: ' + svgGradient.gradient.id + ' : ' + ratio );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      // @private {SVGGradient} - transient
      this.svgGradient = svgGradient;

      // @private {Color|string|Property.<Color|string|null>|null} - transient
      this.color = color;

      // @private {number}
      this.ratio = ratio;

      // @public {SVGStopElement} - persistent
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'stop' );

      this.svgElement.setAttribute( 'offset', ratio );

      // @private {boolean}
      this.dirty = true; // true here so our update() actually properly initializes

      this.update();

      // @private {function} - persistent
      this.propertyListener = this.propertyListener || this.onPropertyChange.bind( this );
      this.colorListener = this.colorListener || this.markDirty.bind( this );

      if ( color instanceof Property ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] adding Property listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        color.lazyLink( this.propertyListener );
        if ( color.value instanceof Color ) {
          sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] adding Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
          color.value.addChangeListener( this.colorListener );
        }
      }
      else if ( color instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] adding Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        color.addChangeListener( this.colorListener );
      }

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();

      return this;
    },

    /**
     * Called when our color is a Property and it changes.
     * @private
     *
     * @param {Color|string|null} newValue
     * @param {Color|string|null} oldValue
     */
    onPropertyChange: function( newValue, oldValue ) {
      if ( oldValue instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] removing Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        oldValue.removeChangeListener( this.colorListener );
      }
      if ( newValue instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] adding Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        newValue.addChangeListener( this.colorListener );
      }

      this.markDirty();
    },

    /**
     * Should be called when the color stop's value may have changed.
     * @private
     */
    markDirty: function() {
      this.dirty = true;
      this.svgGradient.markDirty();
    },

    /**
     * Updates the color stop to whatever the current color should be.
     * @public
     */
    update: function() {
      if ( !this.dirty ) {
        return;
      }
      this.dirty = false;

      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] update: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      // {Color|string|Property.<Color|string|null>|null}
      var color = this.color;

      // to {Color|string|null}
      if ( color instanceof Property ) {
        color = color.value;
      }

      // to {Color|string}
      if ( color === null ) {
        color = 'transparent';
      }

      // to {Color}, in our scratchColor
      if ( typeof color === 'string' ) {
        scratchColor.setCSS( color );
      }
      else {
        scratchColor.set( color );
      }

      // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
      // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
      // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
      // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
      var stopOpacityRule = 'stop-opacity: ' + scratchColor.a.toFixed( 20 ) + ';';

      // For GC, mutate the color so it is just RGB and output that CSS also
      scratchColor.alpha = 1;
      var stopColorRule = 'stop-color: ' + scratchColor.toCSS() + ';';

      this.svgElement.setAttribute( 'style', stopColorRule + ' ' + stopOpacityRule );

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Disposes, so that it can be reused from the pool.
     * @public
     */
    dispose: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] dispose: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      var color = this.color;

      if ( color instanceof Property ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] removing Property listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        color.unlink( this.propertyListener );
        if ( color.value instanceof Color ) {
          sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] removing Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
          color.value.removeChangeListener( this.colorListener );
        }
      }
      else if ( color instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] removing Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        color.removeChangeListener( this.colorListener );
      }

      this.color = null; // clear the reference
      this.svgGradient = null; // clear the reference

      this.freeToPool();

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    }
  } );

  Poolable.mixin( SVGGradientStop, {
    constructorDuplicateFactory: function( pool ) {
      return function( svgGradient, ratio, color ) {
        if ( pool.length ) {
          return pool.pop().initialize( svgGradient, ratio, color );
        }
        else {
          return new SVGGradientStop( svgGradient, ratio, color );
        }
      };
    }
  } );

  return SVGGradientStop;
} );

// Copyright 2017, University of Colorado Boulder

/**
 * Base type for controllers that create and keep an SVG gradient element up-to-date with a Scenery gradient.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGGradient',['require','PHET_CORE/cleanArray','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGGradientStop'],function( require ) {
  'use strict';

  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGGradientStop = require( 'SCENERY/display/SVGGradientStop' );

  /**
   * @constructor
   *
   * @param {SVGBlock} svgBlock
   * @param {Gradient} gradient
   */
  function SVGGradient( svgBlock, gradient ) {
    this.initialize( svgBlock, gradient );
  }

  scenery.register( 'SVGGradient', SVGGradient );

  inherit( Object, SVGGradient, {
    /**
     * Poolable initializer.
     * @private
     *
     * @param {SVGBlock} svgBlock
     * @param {Gradient} gradient
     */
    initialize: function( svgBlock, gradient ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradient] initialize ' + gradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      // @private {SVGBlock} - transient
      this.svgBlock = svgBlock;

      // @private {Gradient} - transient
      this.gradient = gradient;

      var hasPreviousDefinition = this.definition !== undefined;

      // @public {SVGGradientElement} - persistent
      this.definition = this.definition || this.createDefinition();

      if ( !hasPreviousDefinition ) {
        // so we don't depend on the bounds of the object being drawn with the gradient
        this.definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' );
      }

      if ( gradient.transformMatrix ) {
        this.definition.setAttribute( 'gradientTransform', gradient.transformMatrix.getSVGTransform() );
      }
      else {
        this.definition.removeAttribute( 'gradientTransform' );
      }

      // We need to make a function call, as stops need to be rescaled/reversed in some radial gradient cases.
      var gradientStops = gradient.getSVGStops();

      // @private {Array.<SVGGradientStop>} - transient
      this.stops = cleanArray( this.stops );
      for ( var i = 0; i < gradientStops.length; i++ ) {
        var stop = new SVGGradientStop( this, gradientStops[ i ].ratio, gradientStops[ i ].color );
        this.stops.push( stop );
        this.definition.appendChild( stop.svgElement );
      }

      // @private {boolean}
      this.dirty = false;

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Creates the gradient-type-specific definition.
     * @protected
     * @abstract
     *
     * @returns {SVGGradientElement}
     */
    createDefinition: function() {
      throw new Error( 'abstract method' );
    },

    /**
     * Called from SVGGradientStop when a stop needs to change the actual color.
     * @public
     */
    markDirty: function() {
      if ( !this.dirty ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradient] switched to dirty: ' + this.gradient.id );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();

        this.dirty = true;

        this.svgBlock.markDirtyGradient( this );

        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
    },

    /**
     * Called from SVGBlock when we need to update our color stops.
     * @public
     */
    update: function() {
      if ( !this.dirty ) {
        return;
      }
      this.dirty = false;

      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradient] update: ' + this.gradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      for ( var i = 0; i < this.stops.length; i++ ) {
        this.stops[ i ].update();
      }

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },

    /**
     * Disposes, so that it can be reused from the pool.
     * @public
     */
    dispose: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradient] dispose ' + this.gradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      // Dispose and clean up stops
      for ( var i = 0; i < this.stops.length; i++ ) {
        var stop = this.stops[ i ]; // SVGGradientStop
        this.definition.removeChild( stop.svgElement );
        stop.dispose();
      }
      cleanArray( this.stops );

      this.svgBlock = null;
      this.gradient = null;

      this.freeToPool();

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    }
  } );

  return SVGGradient;
} );

// Copyright 2017, University of Colorado Boulder

/**
 * Controller that creates and keeps an SVG linear gradient up-to-date with a Scenery LinearGradient
 *
 * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGLinearGradient',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/SVGGradient'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGGradient = require( 'SCENERY/display/SVGGradient' );

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param {SVGBlock} svgBlock
   * @param {LinearGradient} linearGradient
   */
  function SVGLinearGradient( svgBlock, linearGradient ) {
    this.initialize( svgBlock, linearGradient );
  }

  scenery.register( 'SVGLinearGradient', SVGLinearGradient );

  inherit( SVGGradient, SVGLinearGradient, {
    /**
     * Poolable initializer.
     * @private
     *
     * @param {SVGBlock} svgBlock
     * @param {LinearGradient} linearGradient
     */
    initialize: function( svgBlock, linearGradient ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGLinearGradient] initialize ' + linearGradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      SVGGradient.prototype.initialize.call( this, svgBlock, linearGradient );

      // seems we need the defs: http://stackoverflow.com/questions/7614209/linear-gradients-in-svg-without-defs
      // SVG: spreadMethod 'pad' 'reflect' 'repeat' - find Canvas usage

      /* Approximate example of what we are creating:
       <linearGradient id="grad2" x1="0" y1="0" x2="100" y2="0" gradientUnits="userSpaceOnUse">
       <stop offset="0" style="stop-color:rgb(255,255,0);stop-opacity:1" />
       <stop offset="0.5" style="stop-color:rgba(255,255,0,0);stop-opacity:0" />
       <stop offset="1" style="stop-color:rgb(255,0,0);stop-opacity:1" />
       </linearGradient>
       */

      // Linear-specific setup
      this.definition.setAttribute( 'x1', linearGradient.start.x );
      this.definition.setAttribute( 'y1', linearGradient.start.y );
      this.definition.setAttribute( 'x2', linearGradient.end.x );
      this.definition.setAttribute( 'y2', linearGradient.end.y );

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();

      return this;
    },

    /**
     * Creates the gradient-type-specific definition.
     * @protected
     * @override
     *
     * @returns {SVGLinearGradientElement}
     */
    createDefinition: function() {
      return document.createElementNS( scenery.svgns, 'linearGradient' );
    }
  } );

  Poolable.mixin( SVGLinearGradient, {
    constructorDuplicateFactory: function( pool ) {
      return function( svgBlock, linearGradient ) {
        if ( pool.length ) {
          return pool.pop().initialize( svgBlock, linearGradient );
        }
        else {
          return new SVGLinearGradient( svgBlock, linearGradient );
        }
      };
    }
  } );

  return SVGLinearGradient;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * A linear gradient that can be passed into the 'fill' or 'stroke' parameters.
 *
 * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/LinearGradient',['require','SCENERY/util/Gradient','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGLinearGradient','DOT/Vector2'],function( require ) {
  'use strict';

  var Gradient = require( 'SCENERY/util/Gradient' );
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGLinearGradient = require( 'SCENERY/display/SVGLinearGradient' );
  var Vector2 = require( 'DOT/Vector2' );

  /**
   * @constructor
   * @extends Gradient
   *
   * TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
   *
   * @param {number} x0 - X coordinate of the start point (ratio 0) in the local coordinate frame
   * @param {number} y0 - Y coordinate of the start point (ratio 0) in the local coordinate frame
   * @param {number} x1 - X coordinate of the end point (ratio 1) in the local coordinate frame
   * @param {number} y1 - Y coordinate of the end point (ratio 1) in the local coordinate frame
   */
  function LinearGradient( x0, y0, x1, y1 ) {
    assert && assert( isFinite( x0 ) && isFinite( y0 ) && isFinite( x1 ) && isFinite( y1 ) );

    // TODO: are we using this alternative format?
    var usesVectors = y1 === undefined;
    if ( usesVectors ) {
      assert && assert( ( x0 instanceof Vector2 ) && ( y0 instanceof Vector2 ), 'If less than 4 parameters are given, the first two parameters must be Vector2' );
    }

    this.start = usesVectors ? x0 : new Vector2( x0, y0 );
    this.end = usesVectors ? y0 : new Vector2( x1, y1 );

    Gradient.call( this );
  }

  scenery.register( 'LinearGradient', LinearGradient );

  inherit( Gradient, LinearGradient, {

    isLinearGradient: true,

    /**
     * Returns a fresh gradient given the starting parameters
     * @protected
     * @override
     *
     * @returns {CanvasGradient}
     */
    createCanvasGradient: function() {
      // use the global scratch canvas instead of creating a new Canvas
      return scenery.scratchContext.createLinearGradient( this.start.x, this.start.y, this.end.x, this.end.y );
    },

    /**
     * Creates an SVG paint object for creating/updating the SVG equivalent definition.
     * @public
     *
     * @param {SVGBlock} svgBlock
     * @returns {SVGGradient|SVGPattern}
     */
    createSVGPaint: function( svgBlock ) {
      return SVGLinearGradient.createFromPool( svgBlock, this );
    },

    toString: function() {
      var result = 'new scenery.LinearGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.end.x + ', ' + this.end.y + ' )';

      _.each( this.stops, function( stop ) {
        result += '.addColorStop( ' + stop.ratio + ', \'' + ( stop.color.toCSS ? stop.color.toCSS() : stop.color.toString() ) + '\' )';
      } );

      return result;
    }
  } );

  return LinearGradient;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Visual representation of a rectangular button.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RectangularButtonView',['require','SCENERY/nodes/AlignBox','DOT/Bounds2','SUN/buttons/ButtonListener','SCENERY/util/Color','SUN/ColorConstants','PHET_CORE/inherit','SCENERY/util/LinearGradient','SCENERY/nodes/Node','SCENERY/nodes/Path','AXON/Property','KITE/Shape','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var ButtonListener = require( 'SUN/buttons/ButtonListener' );
  var Color = require( 'SCENERY/util/Color' );
  var ColorConstants = require( 'SUN/ColorConstants' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Property = require( 'AXON/Property' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );

  // constants
  var VERTICAL_HIGHLIGHT_GRADIENT_LENGTH = 7; // In screen coords, which are roughly pixels.
  var HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH = 7; // In screen coords, which are roughly pixels.
  var SHADE_GRADIENT_LENGTH = 3; // In screen coords, which are roughly pixels.
  var DEFAULT_COLOR = ColorConstants.LIGHT_BLUE;
  var X_ALIGN_VALUES = [ 'center', 'left', 'right' ];
  var Y_ALIGN_VALUES = [ 'center', 'top', 'bottom' ];

  // convenience function for creating the shape of the button, done to avoid code duplication
  function createButtonShape( width, height, options ) {
    return Shape.roundedRectangleWithRadii( 0, 0, width, height, {
      topLeft: typeof( options.leftTopCornerRadius ) === 'number' ? options.leftTopCornerRadius : options.cornerRadius,
      topRight: typeof( options.rightTopCornerRadius ) === 'number' ? options.rightTopCornerRadius : options.cornerRadius,
      bottomLeft: typeof( options.leftBottomCornerRadius ) === 'number' ? options.leftBottomCornerRadius : options.cornerRadius,
      bottomRight: typeof( options.rightBottomCornerRadius ) === 'number' ? options.rightBottomCornerRadius : options.cornerRadius
    } );
  }

  /**
   * @param {ButtonModel} buttonModel - Model that defines the button's behavior.
   * @param {Property} interactionStateProperty - A property that is used to drive the visual appearance of the button.
   * @param {Object} [options]
   * @constructor
   */
  function RectangularButtonView( buttonModel, interactionStateProperty, options ) {
    this.buttonModel = buttonModel; // @protected

    options = _.extend( {
      // Default values.
      content: null,
      minWidth: HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH,
      minHeight: VERTICAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH,
      cursor: 'pointer',
      cornerRadius: 4,
      baseColor: DEFAULT_COLOR,
      disabledBaseColor: ColorConstants.LIGHT_GRAY,
      xMargin: 8, // should be visibly greater than yMargin, see issue #109
      yMargin: 5,
      fireOnDown: false,
      touchAreaXDilation: 0,
      touchAreaYDilation: 0,
      stroke: undefined, // undefined by default, which will cause a stroke to be derived from the base color
      lineWidth: 0.5, // Only meaningful if stroke is non-null
      xAlign: 'center', // {string} see X_ALIGN_VALUES
      yAlign: 'center', // {string} see Y_ALIGN_VALUES

      // Strategy for controlling the button's appearance, excluding any
      // content.  This can be a stock strategy from this file or custom.  To
      // create a custom one, model it off of the stock strategies defined in
      // this file.
      buttonAppearanceStrategy: RectangularButtonView.ThreeDAppearanceStrategy,

      // Strategy for controlling the appearance of the button's content based
      // on the button's state.  This can be a stock strategy from this file,
      // or custom.  To create a custom one, model it off of the stock
      // version(s) defined in this file.
      contentAppearanceStrategy: RectangularButtonView.FadeContentWhenDisabled,

      // a11y
      tagName: 'button'
    }, options );

    // validate options
    assert && assert( _.includes( X_ALIGN_VALUES, options.xAlign ), 'invalid xAlign: ' + options.xAlign );
    assert && assert( _.includes( Y_ALIGN_VALUES, options.yAlign ), 'invalid yAlign: ' + options.yAlign );

    Node.call( this );

    var content = options.content; // convenience variable

    // Hook up the input listener
    this.addInputListener( new ButtonListener( buttonModel ) );

    // @private - make the base color into a property so that the appearance strategy can update itself if changes occur.
    this.baseColorProperty = new Property( Color.toColor( options.baseColor ) ); // @private

    // Figure out the size of the button.
    var buttonWidth = Math.max( content ? content.width + options.xMargin * 2 : 0, options.minWidth );
    var buttonHeight = Math.max( content ? content.height + options.yMargin * 2 : 0, options.minHeight );

    // create and add the button node
    var button = new Path( createButtonShape( buttonWidth, buttonHeight, options ), {
      fill: options.baseColor,
      lineWidth: options.lineWidth
    } );
    this.addChild( button );

    // Add the content to the button.
    if ( content ) {

      // For performance reasons, the content should be unpickable.
      if ( content ) {
        content.pickable = false;
      }

      this.addChild( new AlignBox( content, {
        alignBounds: new Bounds2(
          options.xMargin,
          options.yMargin,
          button.width - options.xMargin,
          buttonHeight - options.yMargin
        ),
        xAlign: options.xAlign,
        yAlign: options.yAlign
      } ) );
    }

    // Hook up the strategy that will control the basic button appearance.
    var buttonAppearanceStrategy = new options.buttonAppearanceStrategy(
      button,
      interactionStateProperty,
      this.baseColorProperty,
      options
    );

    // Hook up the strategy that will control the content appearance.
    var contentAppearanceStrategy = new options.contentAppearanceStrategy( content, interactionStateProperty, options );

    // Control the pointer state based on the interaction state.
    // Control the pointer state based on the interaction state.
    var self = this;

    function handleInteractionStateChanged( state ) {
      self.cursor = state === 'disabled' || state === 'disabled-pressed' ? null : 'pointer';
    }

    interactionStateProperty.link( handleInteractionStateChanged );

    // Add explicit mouse and touch areas so that the child nodes can all be non-pickable.
    this.mouseArea = Shape.rectangle( 0, 0, buttonWidth, buttonHeight );
    this.touchArea = Shape.rectangle(
      -options.touchAreaXDilation,
      -options.touchAreaYDilation,
      buttonWidth + options.touchAreaXDilation * 2,
      buttonHeight + options.touchAreaYDilation * 2
    );

    // Mutate with the options after the layout is complete so that width-
    // dependent fields like centerX will work.
    this.mutate( options );

    // define a dispose function
    this.disposeRectangularButtonView = function() {
      buttonAppearanceStrategy.dispose();
      contentAppearanceStrategy.dispose();
      interactionStateProperty.unlink( handleInteractionStateChanged );
    };
  }

  sun.register( 'RectangularButtonView', RectangularButtonView );

  /**
   * Strategy for making a button look 3D-ish by using gradients that create the appearance of highlighted and shaded
   * edges.  The gradients are set up to make the light source appear to be in the upper left.
   * @param {Node} button
   * @param {Property.<Boolean>} interactionStateProperty
   * @param {Property.<Color>} baseColorProperty
   * @param {Object} [options]
   * @constructor
   * @public
   */
  RectangularButtonView.ThreeDAppearanceStrategy = function( button, interactionStateProperty, baseColorProperty, options ) {

    var buttonWidth = button.width;
    var buttonHeight = button.height;

    // compute color stops for gradient, see issue #148
    assert && assert( buttonWidth >= HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH );
    assert && assert( buttonHeight >= VERTICAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH );
    var verticalHighlightStop = Math.min( VERTICAL_HIGHLIGHT_GRADIENT_LENGTH / buttonHeight, 1 );
    var verticalShadowStop = Math.max( 1 - SHADE_GRADIENT_LENGTH / buttonHeight, 0 );
    var horizontalHighlightStop = Math.min( HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH / buttonWidth, 1 );
    var horizontalShadowStop = Math.max( 1 - SHADE_GRADIENT_LENGTH / buttonWidth, 0 );

    var disabledBaseColor = Color.toColor( options.disabledBaseColor );
    var transparentDisabledBaseColor = new Color( disabledBaseColor.getRed(), disabledBaseColor.getGreen(), disabledBaseColor.getBlue(), 0 );
    var transparentWhite = new Color( 256, 256, 256, 0.7 );

    // Create the overlay that is used to add shading to left and right edges of the button.
    var overlayForHorizGradient = new Path( createButtonShape( buttonWidth, buttonHeight, options ), {
      lineWidth: options.lineWidth,
      pickable: false
    } );
    button.addChild( overlayForHorizGradient );

    // Various fills used in the button's appearance, updated below.
    var upFillVertical;
    var upFillHorizontal;
    var overFillVertical;
    var overFillHorizontal;
    var downFillVertical;
    var disabledFillVertical;
    var disabledFillHorizontal;
    var disabledPressedFillVertical;
    var enabledStroke;
    var disabledStroke;

    // Function for updating the button's appearance based on the current interaction state.
    function updateAppearance( interactionState ) {

      switch( interactionState ) {

        case 'idle':
          button.fill = upFillVertical;
          overlayForHorizGradient.stroke = enabledStroke;
          overlayForHorizGradient.fill = upFillHorizontal;
          break;

        case 'over':
          button.fill = overFillVertical;
          overlayForHorizGradient.stroke = enabledStroke;
          overlayForHorizGradient.fill = overFillHorizontal;
          break;

        case 'pressed':
          button.fill = downFillVertical;
          overlayForHorizGradient.stroke = enabledStroke;
          overlayForHorizGradient.fill = overFillHorizontal;
          break;

        case 'disabled':
          button.fill = disabledFillVertical;
          button.stroke = disabledStroke;
          overlayForHorizGradient.stroke = disabledStroke;
          overlayForHorizGradient.fill = disabledFillHorizontal;
          break;

        case 'disabled-pressed':
          button.fill = disabledPressedFillVertical;
          button.stroke = disabledStroke;
          overlayForHorizGradient.stroke = disabledStroke;
          overlayForHorizGradient.fill = disabledFillHorizontal;
          break;

        default:
          throw new Error( 'unsupported interactionState: ' + interactionState );
      }
    }

    // Function for creating the fills and strokes used to control the button's appearance.
    function updateFillsAndStrokes( baseColor ) {

      var transparentBaseColor = new Color( baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), 0 );

      // Create the gradient fills used for various button states
      upFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop, baseColor )
        .addColorStop( verticalShadowStop, baseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );

      upFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
        .addColorStop( 0, transparentWhite )
        .addColorStop( horizontalHighlightStop, transparentBaseColor )
        .addColorStop( horizontalShadowStop, transparentBaseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );

      overFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop, baseColor.colorUtilsBrighter( 0.5 ) )
        .addColorStop( verticalShadowStop, baseColor.colorUtilsBrighter( 0.5 ) )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );

      overFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
        .addColorStop( 0, transparentWhite )
        .addColorStop( horizontalHighlightStop / 2, new Color( 256, 256, 256, 0 ) )
        .addColorStop( horizontalShadowStop, transparentBaseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.3 ) );

      downFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop * 0.67, baseColor.colorUtilsDarker( 0.3 ) )
        .addColorStop( verticalShadowStop, baseColor.colorUtilsBrighter( 0.2 ) )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );

      disabledFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop, disabledBaseColor.colorUtilsBrighter( 0.5 ) )
        .addColorStop( verticalShadowStop, disabledBaseColor.colorUtilsBrighter( 0.5 ) )
        .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );

      disabledFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
        .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( horizontalHighlightStop, transparentDisabledBaseColor )
        .addColorStop( horizontalShadowStop, transparentDisabledBaseColor )
        .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );

      disabledPressedFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop * 0.67, disabledBaseColor.colorUtilsDarker( 0.3 ) )
        .addColorStop( verticalShadowStop, disabledBaseColor.colorUtilsBrighter( 0.2 ) )
        .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );

      if ( options.stroke === null ) {
        // The stroke was explicitly set to null, so the button should have no stroke.
        enabledStroke = null;
        disabledStroke = null;
      }
      else if ( typeof( options.stroke ) === 'undefined' ) {
        // No stroke was defined, but it wasn't set to null, so default to a stroke based on the base color of the
        // button.  This behavior is a bit unconventional for Scenery nodes, but it makes the buttons look much better.
        enabledStroke = baseColor.colorUtilsDarker( 0.4 );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      else {
        enabledStroke = Color.toColor( options.stroke );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }

      button.cachedPaints = [
        upFillVertical, overFillVertical, downFillVertical, disabledFillVertical, disabledPressedFillVertical,
        disabledStroke
      ];

      overlayForHorizGradient.cachedPaints = [
        upFillHorizontal, overFillHorizontal, disabledFillHorizontal, enabledStroke, disabledStroke
      ];

      updateAppearance( interactionStateProperty.value );
    }

    // Do the initial update explicitly, then lazy link to the properties.  This keeps the number of initial updates to
    // a minimum and allows us to update some optimization flags the first time the base color is actually changed.
    updateFillsAndStrokes( baseColorProperty.value );
    updateAppearance( interactionStateProperty.value );

    baseColorProperty.lazyLink( updateFillsAndStrokes );

    interactionStateProperty.lazyLink( updateAppearance );

    this.dispose = function() {
      baseColorProperty.unlink( updateFillsAndStrokes );
      interactionStateProperty.unlink( updateAppearance );
    };
  };

  /**
   * Strategy for buttons that look flat, i.e. no shading or highlighting, but that change color on mouseover, press,
   * etc.
   *
   * @param {Node} button
   * @param {Property.<boolean>} interactionStateProperty
   * @param {Property.<Color>} baseColorProperty
   * @param {Object} [options]
   * @constructor
   * @public
   */
  RectangularButtonView.FlatAppearanceStrategy = function( button, interactionStateProperty, baseColorProperty, options ) {

    // Set up variables needed to create the various gradient fills
    var disabledBaseColor = Color.toColor( options.disabledBaseColor );

    // fills used for various button states
    var upFill;
    var overFill;
    var downFill;
    var disabledFill;
    var disabledPressedFillVertical;
    var enabledStroke;
    var disabledStroke;

    function updateAppearance( interactionState ) {
      switch( interactionState ) {

        case 'idle':
          button.fill = upFill;
          button.stroke = enabledStroke;
          break;

        case 'over':
          button.fill = overFill;
          button.stroke = enabledStroke;
          break;

        case 'pressed':
          button.fill = downFill;
          button.stroke = enabledStroke;
          break;

        case 'disabled':
          button.fill = disabledFill;
          button.stroke = disabledStroke;
          break;

        case 'disabled-pressed':
          button.fill = disabledPressedFillVertical;
          button.stroke = disabledStroke;
          break;

        default:
          throw new Error( 'upsupported interactionState: ' + interactionState );
      }
    }

    function updateFillsAndStrokes( baseColor ) {
      upFill = baseColor;
      overFill = baseColor.colorUtilsBrighter( 0.4 );
      downFill = baseColor.colorUtilsDarker( 0.4 );
      disabledFill = disabledBaseColor;
      disabledPressedFillVertical = disabledFill;
      if ( options.stroke === null ) {
        // The stroke was explicitly set to null, so the button should have no stroke.
        enabledStroke = null;
        disabledStroke = null;
      }
      else if ( typeof( options.stroke ) === 'undefined' ) {
        // No stroke was defined, but it wasn't set to null, so default to a stroke based on the base color of the
        // button.  This behavior is a bit unconventional for Scenery nodes, but it makes the buttons look much better.
        enabledStroke = baseColor.colorUtilsDarker( 0.4 );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      else {
        enabledStroke = Color.toColor( options.stroke );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }

      button.cachedPaints = [
        upFill, overFill, downFill, disabledFill, disabledPressedFillVertical,
        enabledStroke, disabledStroke
      ];
      updateAppearance( interactionStateProperty.value );
    }

    baseColorProperty.link( updateFillsAndStrokes );

    // Lazy link to interaction state to avoid two updates at init.
    interactionStateProperty.lazyLink( updateAppearance );

    this.dispose = function() {
      baseColorProperty.unlink( updateFillsAndStrokes );
      interactionStateProperty.unlink( updateAppearance );
    };
  };

  /**
   * Basic strategy for controlling content appearance, fades the content by making it transparent when disabled.
   *
   * @param {Node} content
   * @param {Property} interactionStateProperty
   * @constructor
   * @public
   */
  RectangularButtonView.FadeContentWhenDisabled = function( content, interactionStateProperty ) {

    // update the opacity when the state changes
    function updateOpacity( state ) {
      if ( content ) {
        content.opacity = state === 'disabled' || state === 'disabled-pressed' ? 0.3 : 1;
      }
    }

    interactionStateProperty.link( updateOpacity );

    // add dispose function to unlink listener
    this.dispose = function() {
      interactionStateProperty.unlink( updateOpacity );
    };
  };

  return inherit( Node, RectangularButtonView, {

    /**
     * Sets the enabled state.
     * @param {boolean} value
     * @public
     */
    setEnabled: function( value ) {
      assert && assert( typeof value === 'boolean', 'RectangularButtonView.enabled must be a boolean value' );
      this.buttonModel.enabledProperty.set( value );
    },
    set enabled( value ) { this.setEnabled( value ); },

    /**
     * Gets the enabled state.
     * @returns {boolean}
     * @public
     */
    getEnabled: function() { return this.buttonModel.enabledProperty.get(); },
    get enabled() { return this.getEnabled(); },

    /**
     * Sets the base color, which is the main background fill color used for the button.
     * @param {Color|String} baseColor
     * @public
     */
    setBaseColor: function( baseColor ) { this.baseColorProperty.value = Color.toColor( baseColor ); },
    set baseColor( baseColor ) { this.setBaseColor( baseColor ); },

    /**
     * Gets the base color for this button.
     * @returns {Color}
     * @public
     */
    getBaseColor: function() { return this.baseColorProperty.value; },
    get baseColor() { return this.getBaseColor(); },

    /**
     * dispose function
     * @public
     */
    dispose: function() {
      this.disposeRectangularButtonView();
      Node.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2016, University of Colorado Boulder

/**
 * PhET-iO wrapper type for phet's DerivedProperty type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'AXON/TDerivedProperty',['require','AXON/axon','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TVoid','AXON/TProperty'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TProperty = require( 'AXON/TProperty' );

  /**
   * Parametric wrapper type constructor.  Given an value type, this function returns an appropriate DerivedProperty wrapper type.
   *
   * @param {function} phetioValueType - phet-io type wrapper like TString, TNumber, etc. If loaded by phet (not phet-io)
   *                                    it will be the function returned by the 'ifphetio!' plugin.
   * @constructor
   */
  function TDerivedProperty( phetioValueType ) {

    // The parent type is also parameterized, so we have to instantiate it before we can extend it.
    var TPropertyImpl = new TProperty( phetioValueType );

    /**
     * This type constructor is parameterized based on the phetioValueType.
     *
     * @param {DerivedProperty} property
     * @param {string} phetioID - the full unique tandem name for the instance
     * @constructor
     */
    var TDerivedPropertyImpl = function TDerivedPropertyImpl( property, phetioID ) {
      assert && assert( !!phetioValueType, 'TDerivedProperty needs phetioValueType' );

      TPropertyImpl.call( this, property, phetioID );
      assertInstanceOf( property, phet.axon.DerivedProperty );
    };
    return phetioInherit( TPropertyImpl, 'TDerivedProperty', TDerivedPropertyImpl, {

      setValue: {
        returnType: TVoid,
        parameterTypes: [ phetioValueType ],
        implementation: function( value ) {
          return this.instance.set( value );
        },
        documentation: 'Errors out when you try to set a derived property.'
      }
    }, {
      documentation: 'Like TProperty, but not settable.  Instead it is derived from other TDerivedProperty or TProperty ' +
                     'instances',
      valueType: phetioValueType,

      /**
       * Decodes a state into a DerivedProperty.
       * @param {Object} stateObject
       * @returns {Object}
       */
      fromStateObject: function( stateObject ) {
        return phetioValueType.fromStateObject( stateObject );
      },


      /**
       * Encodes a DerivedProperty instance to a state.
       * @param {Object} instance
       * @returns {Object}
       */
      toStateObject: function( instance ) {
        return phetioValueType.toStateObject( instance.value );
      }
    } );
  }

  axon.register( 'TDerivedProperty', TDerivedProperty );

  return TDerivedProperty;
} );


// Copyright 2013-2016, University of Colorado Boulder

/**
 * A DerivedProperty is computed based on other properties.  This implementation inherits from Property to (a) simplify
 * implementation and (b) ensure it remains consistent. Note that the setters should not be called directly, so the
 * setters (set, reset and es5 setter) throw an error if used directly.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

define( 'AXON/DerivedProperty',['require','AXON/Property','AXON/axon','PHET_CORE/inherit','AXON/TDerivedProperty','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var TDerivedProperty = require( 'AXON/TDerivedProperty' );
  var Tandem = require( 'TANDEM/Tandem' );

  function equalsFunction( a, b ) {
    return a === b;
  }

  function conjunctionWithProperty( value, property ) {
    return value && property.value;
  }

  function disjunctionWithProperty( value, property ) {
    return value || property.value;
  }

  /**
   * @param {Property[]} dependencies - properties that this property's value is derived from
   * @param {function} derivation - function that derives this property's value, expects args in the same order as dependencies
   * @param {Object} [options] - see Property
   * @constructor
   */
  function DerivedProperty( dependencies, derivation, options ) {

    options = _.extend( {
      tandem: Tandem.tandemOptional()
    }, options );

    this.dependencies = dependencies; // @private

    // @private Keep track of each dependency and only update the changed value, for speed
    this.dependencyValues = dependencies.map( function( property ) {return property.get();} );

    var initialValue = derivation.apply( null, this.dependencyValues );

    // We must pass supertype tandem to parent class so addInstance is called only once in the subclassiest constructor.
    Property.call( this, initialValue, _.extend( {}, options, {
      tandem: options.tandem && options.tandem.createSupertypeTandem()
    } ) );

    var self = this;

    // @private Keep track of listeners so they can be detached
    this.dependencyListeners = [];

    for ( var i = 0; i < dependencies.length; i++ ) {
      var dependency = dependencies[ i ];
      (function( dependency, i ) {
        var listener = function( newValue ) {
          self.dependencyValues[ i ] = newValue;
          Property.prototype.set.call( self, derivation.apply( null, self.dependencyValues ) );
        };
        self.dependencyListeners.push( listener );
        dependency.lazyLink( listener );
      })( dependency, i );
    }

    // If running as phet-io and a tandem is supplied, register with tandem.
    options.tandem.supplied && options.tandem.addInstance( this, TDerivedProperty( options.phetioValueType ) );

    this.disposeDerivedProperty = function() {
      options.tandem && options.tandem.removeInstance( self );
    };
  }

  axon.register( 'DerivedProperty', DerivedProperty );

  return inherit( Property, DerivedProperty, {

    // @public
    dispose: function() {

      Property.prototype.dispose.call( this );
      this.disposeDerivedProperty();

      // TODO: Move this code to disposeDerivedProperty
      // Unlink from dependent properties
      for ( var i = 0; i < this.dependencies.length; i++ ) {
        var dependency = this.dependencies[ i ];
        dependency.unlink( this.dependencyListeners[ i ] );
      }
      this.dependencies = null;
      this.dependencyListeners = null;
      this.dependencyValues = null;
    },

    /**
     * Override the mutators to provide an error message.  These should not be called directly,
     * the value should only be modified when the dependencies change.
     * @param value
     * @override
     * @public
     */
    set: function( value ) { throw new Error( 'Cannot set values directly to a derived property, tried to set: ' + value ); },

    /**
     * Override the mutators to provide an error message.  These should not be called directly, the value should only be modified
     * when the dependencies change. Keep the newValue output in the string so the argument won't be stripped by minifier
     * (which would cause crashes like https://github.com/phetsims/axon/issues/15)
     * @param newValue
     * @override
     * @public
     */
    set value( newValue ) { throw new Error( 'Cannot es5-set values directly to a derived property, tried to set: ' + newValue ); },

    /**
     * Override get value as well to satisfy the linter which wants get/set pairs (even though it just uses the same code as the superclass).
     * @returns {*}
     * @override
     * @public
     */
    get value() {return Property.prototype.get.call( this );},

    /**
     * Override the mutators to provide an error message.  These should not be called directly,
     * the value should only be modified when the dependencies change.
     * @override
     * @public
     */
    reset: function() { throw new Error( 'Cannot reset a derived property directly' ); }
  }, {

    /**
     * Creates a derived boolean property whose value is true iff firstProperty's value is equal to secondProperty's
     * value.
     * @public
     *
     * @param {Property.<*>} firstProperty
     * @param {Property.<*>} secondProperty
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {DerivedProperty.<boolean>}
     */
    valueEquals: function( firstProperty, secondProperty, options ) {
      return new DerivedProperty( [ firstProperty, secondProperty ], equalsFunction, options );
    },

    /**
     * Creates a derived boolean property whose value is true iff every input property value is true.
     * @public
     *
     * @param {Array.<Property.<boolean>>} properties
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {DerivedProperty.<boolean>}
     */
    and: function( properties, options ) {
      return new DerivedProperty( properties, _.reduce.bind( null, properties, conjunctionWithProperty, true ), options ); // TODO: fix
    },

    /**
     * Creates a derived boolean property whose value is true iff any input property value is true.
     * @public
     *
     * @param {Array.<Property.<boolean>>} properties
     * @param {Object} [options] - Forwarded to the DerivedProperty
     * @returns {DerivedProperty.<boolean>}
     */
    or: function( properties, options ) {
      return new DerivedProperty( properties, _.reduce.bind( null, properties, disjunctionWithProperty, false ), options );
    }
  } );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * A derived property that maps push button model states to the values needed by the button view.
 */
define( 'SUN/buttons/PushButtonInteractionStateProperty',['require','PHET_CORE/inherit','AXON/DerivedProperty','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {ButtonModel} buttonModel
   * @param {Object} [options]
   * @constructor
   */
  function PushButtonInteractionStateProperty( buttonModel, options ) {

    DerivedProperty.call(
      this,
      [ buttonModel.overProperty, buttonModel.downProperty, buttonModel.enabledProperty ],
      function( over, down, enabled ) {
        return !enabled ? 'disabled' :
               over && !down ? 'over' :
               over && down ? 'pressed' :
               'idle';
      }, options );
  }

  sun.register( 'PushButtonInteractionStateProperty', PushButtonInteractionStateProperty );

  return inherit( DerivedProperty, PushButtonInteractionStateProperty );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Base class for button models, which describe the behavior of buttons when users interact with them.  Property values
 * are set by an associated listener, see ButtonListener for details.
 */
define( 'SUN/buttons/ButtonModel',['require','PHET_CORE/inherit','AXON/Property','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function ButtonModel( options ) {

    options = _.extend( {
      // {function} called on pointer down
      startCallback: function() {},
      // {function} called on pointer up, @param {boolean} over - indicates whether the pointer was released over the button
      endCallback: function( over ) {},
      // {boolean} is the button enabled?
      enabled: true
    }, options );

    var self = this;

    // model properties
    this.overProperty = new Property( false ); // @public - Is the pointer over the button?
    this.downProperty = new Property( false ); // @public - Is the pointer down?
    this.enabledProperty = new Property( options.enabled ); // @public - Is the button enabled?

    // startCallback on pointer down, endCallback on pointer up. lazyLink so they aren't called immediately.
    this.downProperty.lazyLink( function( down ) {
      if ( down ) {
        options.startCallback();
      }
      else {
        options.endCallback( self.overProperty.get() );
      }
    } );
  }

  sun.register( 'ButtonModel', ButtonModel );

  return inherit( Object, ButtonModel, {

    // @public
    dispose: function() {
      //TODO because this is called by subtypes, see https://github.com/phetsims/sun/issues/274#issuecomment-263750638
    }
  } );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Timer so that other modules can run timing related code through the simulation's requestAnimationFrame.
 * Note: this is not specific to the running screen, it is global across all screens.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'PHET_CORE/Timer',['require','PHET_CORE/cleanArray','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  // modules
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var phetCore = require( 'PHET_CORE/phetCore' );

  var listeners = [];
  var listenersDefensiveCopy = []; // separated out to prevent garbage collection issues

  var Timer = {

    // @public (joist-internal) - Trigger a step event, called by Sim.js in the animation loop
    step: function( dt ) {
      var length = listeners.length;
      var i;

      // to safely allow listeners to remove themselves while being called (as is explicitly done in setTimeout), we make a copy of the array.
      // we don't use slice(), since that would cause garbage collection issues.
      for ( i = 0; i < length; i++ ) {
        listenersDefensiveCopy[ i ] = listeners[ i ];
      }
      for ( i = 0; i < length; i++ ) {
        listenersDefensiveCopy[ i ]( dt );
      }
      cleanArray( listenersDefensiveCopy );
    },

    // @public - Add a listener to be called back once after the specified time (in milliseconds)
    setTimeout: function( listener, timeout ) {
      var elapsed = 0;
      var self = this;
      var callback = function( dt ) {
        elapsed += dt;

        //Convert seconds to ms and see if item has timed out
        if ( elapsed * 1000 >= timeout ) {
          listener();
          self.removeStepListener( callback );
        }
      };
      this.addStepListener( callback );

      //Return the callback so it can be removed with removeStepListener
      return callback;
    },

    // @public - Clear a scheduled timeout. If there was no timeout, nothing is done.
    clearTimeout: function( timeoutID ) {
      if ( this.hasStepListener( timeoutID ) ) {
        this.removeStepListener( timeoutID );
      }
    },

    // @public - Add a listener to be called at specified intervals (in milliseconds)
    setInterval: function( listener, interval ) {
      var elapsed = 0;
      var callback = function( dt ) {
        elapsed += dt;

        //Convert seconds to ms and see if item has timed out
        while ( elapsed * 1000 >= interval && listeners.indexOf( callback ) !== -1 ) {
          listener();
          elapsed = elapsed - interval / 1000.0; //Save the leftover time so it won't accumulate
        }
      };
      this.addStepListener( callback );

      //Return the callback so it can be removed with removeStepListener
      return callback;
    },

    // @public - Clear a scheduled interval. If there was no interval, nothing is done.
    clearInterval: function( intervalID ) {
      if ( this.hasStepListener( intervalID ) ) {
        this.removeStepListener( intervalID );
      }
    },

    // @public - Add a listener to be called back on every animationFrame with a dt value
    addStepListener: function( listener ) {
      listeners.push( listener );
    },

    // @public - Remove a step listener from being called back
    removeStepListener: function( listener ) {
      var index = listeners.indexOf( listener );
      assert && assert( index !== -1, 'An attempt was made to remove a non-existent step listener' );
      if ( index !== -1 ) {
        listeners.splice( index, 1 );
      }
    },

    // @public
    hasStepListener: function( listener ) {
      return listeners.indexOf( listener ) >= 0;
    }
  };

  phetCore.register( 'Timer', Timer );

  return Timer;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Timer that calls a set of registered callbacks.
 * Utilizes joist.Timer, but provides a higher level of abstraction, hiding the details of managing the timer.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/CallbackTimer',['require','PHET_CORE/inherit','PHET_CORE/Timer','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Timer = require( 'PHET_CORE/Timer' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function CallbackTimer( options ) {

    options = _.extend( {
      callback: null, // {function} convenience for adding 1 callback
      delay: 400, // {number} start to fire continuously after pressing for this long (milliseconds)
      interval: 100 // {number} fire continuously at this interval (milliseconds)
    }, options );

    // validate options
    assert && assert( options.delay >= 0, 'bad value for delay: ' + options.delay );
    assert && assert( options.interval > 0, 'bad value for interval: ' + options.interval );

    this.delay = options.delay; // @private
    this.interval = options.interval; // @private

    this.callbacks = []; // @private
    if ( options.callback ) { this.callbacks.push( options.callback ); }

    this.delayID = null; // @private identifier for timer associated with the initial delay
    this.intervalID = null; // @private identifier for timer associates with the continuous interval
    this.fired = false;  // @private has the timer fired since it was started?
  }

  sun.register( 'CallbackTimer', CallbackTimer );

  return inherit( Object, CallbackTimer, {

    // @public Is the timer running?
    isRunning: function() {
      return ( this.delayID !== null || this.intervalID !== null );
    },

    // @public Starts the timer.
    start: function() {
      var self = this;
      if ( !self.isRunning() ) {
        self.fired = false;
        self.delayID = Timer.setTimeout( function() {

          self.delayID = null;

          self.intervalID = Timer.setInterval( function() {
            self.fire();
          }, self.interval );

          // fire after scheduling the intervalID, so that isRunning will be true for callbacks, see sun#216
          self.fire();

        }, self.delay );
      }
    },

    /**
     * Stops the timer.
     * @param {boolean} fire - should we fire if we haven't fired already?
     * @public
     */
    stop: function( fire ) {
      if ( this.isRunning() ) {
        if ( this.delayID ) {
          Timer.clearTimeout( this.delayID );
          this.delayID = null;
        }
        if ( this.intervalID ) {
          Timer.clearInterval( this.intervalID );
          this.intervalID = null;
        }
        if ( fire && !this.fired ) {
          this.fire();
        }
      }
    },

    // @public Adds a {function} callback.
    addCallback: function( callback ) {
      if ( this.callbacks.indexOf( callback ) === -1 ) {
        this.callbacks.push( callback );
      }
    },

    // @public Removes a {function} callback.
    removeCallback: function( callback ) {
      var index = this.callbacks.indexOf( callback );
      if ( index !== -1 ) {
        this.callbacks.splice( index, 1 );
      }
    },

    /**
     * Calls all callbacks.
     * Clients are free to call this when the timer is not running.
     * @public
     */
    fire: function() {
      var callbacksCopy = this.callbacks.slice( 0 );
      for ( var i = 0; i < callbacksCopy.length; i++ ) {
        callbacksCopy[ i ]();
      }
      this.fired = true;
    },

    dispose: function() {
      this.stop();
      this.callbacks.length = 0;
    }
  } );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Basic model for a push button, including over/down/enabled properties.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author John Blanco (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/buttons/PushButtonModel',['require','SUN/buttons/ButtonModel','SUN/CallbackTimer','PHET_CORE/inherit','SUN/sun','AXON/Emitter','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var ButtonModel = require( 'SUN/buttons/ButtonModel' );
  var CallbackTimer = require( 'SUN/CallbackTimer' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  var Emitter = require( 'AXON/Emitter' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function PushButtonModel( options ) {

    options = _.extend( {

      fireOnDown: false, // true: fire on pointer down; false: fire on pointer up if pointer is over button
      listener: null, // {function} convenience for adding 1 listener, no args

      // fire-on-hold feature
      fireOnHold: false, // is the fire-on-hold feature enabled?
      fireOnHoldDelay: 400, // start to fire continuously after pressing for this long (milliseconds)
      fireOnHoldInterval: 100, // fire continuously at this interval (milliseconds),
      tandem: Tandem.tandemOptional()
    }, options );

    var self = this;

    ButtonModel.call( this, options );

    // @public (phet-io) support for the phet-io data stream
    this.startedCallbacksForFiredEmitter = new Emitter( {
      indicateCallbacks: false,
      tandem: options.tandem.createTandem( 'startedCallbacksForFiredEmitter' ),
      phetioEmitData: false
    } );
    this.endedCallbacksForFiredEmitter = new Emitter( {
      indicateCallbacks: false,
      tandem: options.tandem.createTandem( 'endedCallbacksForFiredEmitter' ),
      phetioEmitData: false
    } );

    this.listeners = []; // @private
    if ( options.listener !== null ) {
      this.listeners.push( options.listener );
    }

    // Create a timer to handle the optional fire-on-hold feature.
    // When that feature is enabled, calling this.fire is delegated to the timer.
    if ( options.fireOnHold ) {
      this.timer = new CallbackTimer( {
        callback: this.fire.bind( this ),
        delay: options.fireOnHoldDelay,
        interval: options.fireOnHoldInterval
      } );
    }

    // Point down
    this.downProperty.link( function( down ) {
      if ( down ) {
        if ( self.enabledProperty.get() ) {
          if ( options.fireOnDown ) {
            self.fire();
          }
          if ( self.timer ) {
            self.timer.start();
          }
        }
      }
      else {
        var fire = ( !options.fireOnDown && self.overProperty.get() && self.enabledProperty.get() ); // should the button fire?
        if ( self.timer ) {
          self.timer.stop( fire );
        }
        else if ( fire ) {
          self.fire();
        }
      }
    } );

    // Stop the timer when the button is disabled.
    this.enabledProperty.link( function( enabled ) {
      if ( !enabled && self.timer ) {
        self.timer.stop( false ); // Stop the timer, don't fire if we haven't already
      }
    } );


    this.disposePushButtonModel = function() {
      this.listeners.length = 0;
      if ( this.timer ) {
        this.timer.dispose();
        this.timer = null;
      }

      this.startedCallbacksForFiredEmitter.dispose();
      this.endedCallbacksForFiredEmitter.dispose();
    };
  }

  sun.register( 'PushButtonModel', PushButtonModel );

  return inherit( ButtonModel, PushButtonModel, {

    // @public
    dispose: function() {
      this.disposePushButtonModel();
      ButtonModel.prototype.dispose.call( this );
    },

    /**
     * Adds a listener. If already a listener, this is a no-op.
     * @param {function} listener - function called when the button is pressed, no args
     * @public
     */
    addListener: function( listener ) {
      if ( this.listeners.indexOf( listener ) === -1 ) {
        this.listeners.push( listener );
      }
    },

    /**
     * Removes a listener. If not a listener, this is a no-op.
     * @param {function} listener
     * @public
     */
    removeListener: function( listener ) {
      var i = this.listeners.indexOf( listener );
      if ( i !== -1 ) {
        this.listeners.splice( i, 1 );
      }
    },

    /**
     * Fires all listeners.
     * @public (phet-io, a11y)
     */
    fire: function() {
      this.startedCallbacksForFiredEmitter.emit();
      var copy = this.listeners.slice( 0 );
      copy.forEach( function( listener ) {
        listener();
      } );
      this.endedCallbacksForFiredEmitter.emit();
    }
  } );
} );

define("PHET_IO/assertions/assertInstanceOfTypes", function(){return function(){ return function(){}; };});
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/buttons/TPushButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOfTypes','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/toEventOnEmit','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOfTypes = require( 'ifphetio!PHET_IO/assertions/assertInstanceOfTypes' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );

  /**
   * Wrapper type for phet/sun's PushButton class.
   * @param button
   * @param phetioID
   * @constructor
   */
  function TPushButton( button, phetioID ) {
    TNode.call( this, button, phetioID );

    assertInstanceOfTypes( button, [
      phet.sun.RoundPushButton,
      phet.sun.RectangularPushButton
    ] );

    assert && assert( button.buttonModel.startedCallbacksForFiredEmitter, 'button models should use emitters' );
    toEventOnEmit(
      button.buttonModel.startedCallbacksForFiredEmitter,
      button.buttonModel.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired'
    );
  }

  phetioInherit( TNode, 'TPushButton', TPushButton, {
    addListener: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [] ) ],
      implementation: function( listener ) {
        this.instance.addListener( listener );
      },
      documentation: 'Adds a listener that is called back when the button is pressed.'
    },
    fire: {
      returnType: TVoid,
      parameterTypes: [],
      implementation: function() {
        this.instance.buttonModel.fire();
      },
      documentation: 'Performs the action associated with the button'
    }
  }, {
    documentation: 'A pressable button in the simulation',
    events: [ 'fired' ]
  } );

  sun.register( 'TPushButton', TPushButton );

  return TPushButton;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * A rectangular push button.  This is the file in which the appearance and behavior are brought together.
 *
 * This class inherits from RectangularButtonView, which contains all of the code that defines the button's appearance,
 * and adds the button's behavior by hooking up a button model.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RectangularPushButton',['require','PHET_CORE/inherit','SUN/buttons/PushButtonInteractionStateProperty','SUN/buttons/PushButtonModel','SUN/buttons/RectangularButtonView','SUN/sun','TANDEM/Tandem','SUN/buttons/TPushButton'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var PushButtonInteractionStateProperty = require( 'SUN/buttons/PushButtonInteractionStateProperty' );
  var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
  var RectangularButtonView = require( 'SUN/buttons/RectangularButtonView' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TPushButton = require( 'SUN/buttons/TPushButton' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function RectangularPushButton( options ) {
    var self = this;

    options = _.extend( {
      tandem: Tandem.tandemRequired(), // {Tandem|null}
      phetioType: TPushButton,

      // a11y - listener that will only be called when using the keyboard to interact with the push button
      accessibleFire: function() {}
    }, options );

    // If a listener was passed in, save it and add it after creating the button model.  This is done so that
    // the same code path is always used for adding listener, thus guaranteeing a consistent code path if addListener is
    // overridden, see https://github.com/phetsims/sun/issues/284.
    var listener = options.listener;
    options = _.omit( options, [ 'listener' ] );

    // Safe to pass through options to the PushButtonModel like "fireOnDown".  Other scenery options will be safely ignored.
    this.buttonModel = new PushButtonModel( options ); // @public, listen only

    // add the listener that was potentially saved above
    listener && this.addListener( listener );

    // Call the parent type
    RectangularButtonView.call( this, this.buttonModel, new PushButtonInteractionStateProperty( this.buttonModel ), options );

    // a11y - press the button when 'enter' or 'spacebar' are pressed
    this.clickListener = this.addAccessibleInputListener( {
      click: function() {
        self.buttonModel.fire();
        options.accessibleFire();
      }
    } );

    this.disposeRectangularPushButton = function() {
      this.buttonModel.dispose(); //TODO this fails when assertions are enabled, see sun#212
      this.removeAccessibleInputListener( this.clickListener );
      options.tandem.removeInstance( this );
    };
  }

  sun.register( 'RectangularPushButton', RectangularPushButton );

  return inherit( RectangularButtonView, RectangularPushButton, {

      // @public
      dispose: function() {
        this.disposeRectangularPushButton();
        RectangularButtonView.prototype.dispose.call( this );
      },

      // @public
      addListener: function( listener ) {
        this.buttonModel.addListener( listener );
      },

      // @public
      removeListener: function( listener ) {
        this.buttonModel.removeListener( listener );
      }
    }
  );
} );
// Copyright 2017, University of Colorado Boulder

/**
 * A button meant for conditionally being able to clear thermal energy from a system. Has a trash can with an arrow,
 * and appears disabled if there is no thermal energy.
 *
 * @author Sam Reid
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'SCENERY_PHET/ClearThermalButton',['require','SCENERY/util/Color','SCENERY_PHET/CurvedArrowShape','SUN/FontAwesomeNode','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','SUN/buttons/RectangularButtonView','SUN/buttons/RectangularPushButton','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var CurvedArrowShape = require( 'SCENERY_PHET/CurvedArrowShape' );
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var RectangularButtonView = require( 'SUN/buttons/RectangularButtonView' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @constructor
   *
   * @param {Object} [options]
   */
  function ClearThermalButton( options ) {
    options = _.extend( {
      baseColor: new Color( 230, 230, 240 ),
      disabledBaseColor: 'white',
      cornerRadius: 6,
      buttonAppearanceStrategy: RectangularButtonView.FlatAppearanceStrategy,
      contentAppearanceStrategy: function( content, interactionStateProperty ) {
        function updateEnabled( state ) {
          if ( content ) {
            var enabled = state !== 'disabled' && state !== 'disabled-pressed';

            arrowPath.fill = enabled ? '#f05a28' : 'rgba(0,0,0,0.3)';
            trashPath.fill = enabled ? 'black' : 'rgba(0,0,0,0.3)';
          }
        }
        interactionStateProperty.link( updateEnabled );
        this.dispose = function() {
          interactionStateProperty.unlink( updateEnabled );
        };
      },
      xMargin: 7,
      yMargin: 3,
      tandem: Tandem.tandemRequired()
    }, options );

    var arrowShape = new CurvedArrowShape( 10, -0.9 * Math.PI, -0.2 * Math.PI, {
      tandem: options.tandem.createTandem( 'arrowShape' ),
      headWidth: 12,
      tailWidth: 4
      // TODO
    } );

    // @private {Path}
    var trashPath = new FontAwesomeNode( 'trash', { tandem: options.tandem.createTandem( 'trashPath' ) } );
    var arrowPath = new Path( arrowShape, {
      tandem: options.tandem.createTandem( 'arrowPath' ),
      bottom: trashPath.top,
      right: trashPath.left + trashPath.width * 0.75
    } );

    options.content = new Node( {
      children: [ trashPath, arrowPath ],
      scale: 0.4
    } );

    RectangularPushButton.call( this, options );
  }

  sceneryPhet.register( 'ClearThermalButton', ClearThermalButton );

  return inherit( RectangularPushButton, ClearThermalButton );
} );
// Copyright 2016, University of Colorado Boulder

/**
 * Canvas drawable for Line nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/LineCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );
  // TODO: use LineStatelessDrawable instead of the custom stuff going on
  // var LineStatelessDrawable = require( 'SCENERY/display/drawables/LineStatelessDrawable' );

  /**
   * A generated CanvasSelfDrawable whose purpose will be drawing our Line. One of these drawables will be created
   * for each displayed instance of a Line.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function LineCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'LineCanvasDrawable', LineCanvasDrawable );

  inherit( CanvasSelfDrawable, LineCanvasDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {LineCanvasDrawable} - Self reference for chaining
     */
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },

    /**
     * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
     * @public
     *
     * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
     * other required effects (opacity, clipping, etc.) have already been prepared.
     *
     * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
     *
     * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
     * @param {Node} node - Our node that is being drawn
     * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
     */
    paintCanvas: function( wrapper, node, matrix ) {
      var context = wrapper.context;

      context.beginPath();
      context.moveTo( node._x1, node._y1 );
      context.lineTo( node._x2, node._y2 );

      if ( node.hasPaintableStroke() ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.stroke();
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },

    // stateless dirty methods:
    markDirtyLine: function() { this.markPaintDirty(); },
    markDirtyP1: function() { this.markPaintDirty(); },
    markDirtyP2: function() { this.markPaintDirty(); },
    markDirtyX1: function() { this.markPaintDirty(); },
    markDirtyY1: function() { this.markPaintDirty(); },
    markDirtyX2: function() { this.markPaintDirty(); },
    markDirtyY2: function() { this.markPaintDirty(); },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );

  PaintableStatelessDrawable.mixin( LineCanvasDrawable );

  // This sets up LineCanvasDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( LineCanvasDrawable );

  return LineCanvasDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * A mixin to drawables for Line that need to store state about what the current display is currently showing,
 * so that updates to the Line will only be made on attributes that specifically changed (and no change will be
 * necessary for an attribute that changed back to its original/currently-displayed value). Generally, this is used
 * for DOM and SVG drawables.
 *
 * This mixin assumes the PaintableStateful mixin is also mixed (always the case for Line stateful drawables).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/LineStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );

  var LineStatefulDrawable = {
    /**
     * Given the type (constructor) of a drawable, we'll mix in a combination of:
     * - initialization/disposal with the *State suffix
     * - mark* methods to be called on all drawables of nodes of this type, that set specific dirty flags
     *
     * This will allow drawables that mix in this type to do the following during an update:
     * 1. Check specific dirty flags (e.g. if the fill changed, update the fill of our SVG element).
     * 2. Call setToCleanState() once done, to clear the dirty flags.
     *
     * @param {function} drawableType - The constructor for the drawable type
     */
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      /**
       * Initializes the stateful mixin state, starting its "lifetime" until it is disposed with disposeState().
       * @protected
       *
       * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
       * @param {Instance} instance
       * @returns {LineStatefulDrawable} - Self reference for chaining
       */
      proto.initializeState = function( renderer, instance ) {
        // @protected {boolean} - Flag marked as true if ANY of the drawable dirty flags are set (basically everything except for transforms, as we
        //                        need to accelerate the transform case.
        this.paintDirty = true;
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.dirtyX2 = true;
        this.dirtyY2 = true;

        // After adding flags, we'll initialize the mixed-in PaintableStateful state.
        this.initializePaintableState( renderer, instance );

        return this; // allow for chaining
      };

      /**
       * Disposes the stateful mixin state, so it can be put into the pool to be initialized again.
       * @protected
       */
      proto.disposeState = function() {
        this.disposePaintableState();
      };

      /**
       * A "catch-all" dirty method that directly marks the paintDirty flag and triggers propagation of dirty
       * information. This can be used by other mark* methods, or directly itself if the paintDirty flag is checked.
       * @public (scenery-internal)
       *
       * It should be fired (indirectly or directly) for anything besides transforms that needs to make a drawable
       * dirty.
       */
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyLine = function() {
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.dirtyX2 = true;
        this.dirtyY2 = true;
        this.markPaintDirty();
      };

      proto.markDirtyP1 = function() {
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.markPaintDirty();
      };

      proto.markDirtyP2 = function() {
        this.dirtyX2 = true;
        this.dirtyY2 = true;
        this.markPaintDirty();
      };

      proto.markDirtyX1 = function() {
        this.dirtyX1 = true;
        this.markPaintDirty();
      };

      proto.markDirtyY1 = function() {
        this.dirtyY1 = true;
        this.markPaintDirty();
      };

      proto.markDirtyX2 = function() {
        this.dirtyX2 = true;
        this.markPaintDirty();
      };

      proto.markDirtyY2 = function() {
        this.dirtyY2 = true;
        this.markPaintDirty();
      };

      /**
       * Clears all of the dirty flags (after they have been checked), so that future mark* methods will be able to flag them again.
       * @public (scenery-internal)
       */
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyX1 = false;
        this.dirtyY1 = false;
        this.dirtyX2 = false;
        this.dirtyY2 = false;
      };

      PaintableStatefulDrawable.mixin( drawableType );
    }
  };

  scenery.register( 'LineStatefulDrawable', LineStatefulDrawable );

  return LineStatefulDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * SVG drawable for Line nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/LineSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/LineStatefulDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var LineStatefulDrawable = require( 'SCENERY/display/drawables/LineStatefulDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepSVGLineElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  /*---------------------------------------------------------------------------*
   * SVG Rendering
   *----------------------------------------------------------------------------*/

  /**
   * A generated SVGSelfDrawable whose purpose will be drawing our Line. One of these drawables will be created
   * for each displayed instance of a Line.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function LineSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'LineSVGDrawable', LineSVGDrawable );

  inherit( SVGSelfDrawable, LineSVGDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {LineSVGDrawable} - Self reference for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGLineElements ); // usesPaint: true

      // @protected {SVGLineElement} - Sole SVG element for this drawable, implementing API for SVGSelfDrawable
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'line' );

      return this;
    },

    /**
     * Updates the SVG elements so that they will appear like the current node's representation.
     * @protected
     *
     * Implements the interface for SVGSelfDrawable (and is called from the SVGSelfDrawable's update).
     */
    updateSVGSelf: function() {
      var line = this.svgElement;

      if ( this.dirtyX1 ) {
        line.setAttribute( 'x1', this.node._x1 );
      }
      if ( this.dirtyY1 ) {
        line.setAttribute( 'y1', this.node._y1 );
      }
      if ( this.dirtyX2 ) {
        line.setAttribute( 'x2', this.node._x2 );
      }
      if ( this.dirtyY2 ) {
        line.setAttribute( 'y2', this.node._y2 );
      }

      // Apply any fill/stroke changes to our element.
      this.updateFillStrokeStyle( line );
    }
  } );
  LineStatefulDrawable.mixin( LineSVGDrawable );
  // This sets up LineSVGDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( LineSVGDrawable );

  return LineSVGDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Displays a (stroked) line. Inherits Path, and allows for optimized drawing and improved parameter handling.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Line',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','KITE/segments/Line','SCENERY/nodes/Path','KITE/Shape','DOT/Bounds2','DOT/Vector2','SCENERY/display/Renderer','SCENERY/display/drawables/LineCanvasDrawable','SCENERY/display/drawables/LineSVGDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var KiteLine = require( 'KITE/segments/Line' ); // eslint-disable-line require-statement-match
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var LineCanvasDrawable = require( 'SCENERY/display/drawables/LineCanvasDrawable' );
  var LineSVGDrawable = require( 'SCENERY/display/drawables/LineSVGDrawable' );

  var LINE_OPTION_KEYS = [
    'p1', // {Vector2} - Start position
    'p2', // {Vector2} - End position
    'x1', // {number} - Start x position
    'y1', // {number} - Start y position
    'x2', // {number} - End x position
    'y2' // {number} - End y position
  ];

  /**
   * @public
   * @constructor
   * @extends Path
   *
   * Currently, all numerical parameters should be finite.
   * x1: {number} - x-position of the start
   * y1: {number} - y-position of the start
   * x2: {number} - x-position of the end
   * y2: {number} - y-position of the end
   * p1: {Vector2} - position of the start
   * p2: {Vector2} - position of the end
   *
   * Available constructors (with "..." denoting options parameters):
   * - new Line( x1, y1, x2, y2, { ... } )
   * - new Line( p1, p2, { ... } )
   * - A combination of options that sets all of the x's and y's, e.g.:
   *   - new Line( { p1: p1, p2: p2, ... } )
   *   - new Line( { p1: p1, x2: x2, y2: y2, ... } )
   *   - new Line( { x1: x1, y1: y1, x2: x2, y2: y2, ... } )
   *
   * @param {number} x1
   * @param {number} y1
   * @param {number} x2
   * @param {number} y2
   * @param {Object} [options] - Line-specific options are documented in LINE_OPTION_KEYS above, and can be provided
   *                             along-side options for Node
   */
  function Line( x1, y1, x2, y2, options ) {
    // @private {number} - The x coordinate of the start point (point 1)
    this._x1 = 0;

    // @private {number} - The y coordinate of the start point (point 1)
    this._y1 = 0;

    // @private {number} - The x coordinate of the start point (point 2)
    this._x2 = 0;

    // @private {number} - The y coordinate of the start point (point 2)
    this._y2 = 0;

    // Remap constructor parameters to options
    if ( typeof x1 === 'object' ) {
      if ( x1 instanceof Vector2 ) {
        // assumes Line( Vector2, Vector2, options ), where x2 is our options
        assert && assert( y1 instanceof Vector2 );
        assert && assert( x2 === undefined || typeof x2 === 'object' );
        assert && assert( x2 === undefined || Object.getPrototypeOf( x2 ) === Object.prototype,
          'Extra prototype on Node options object is a code smell' );

        options = extendDefined( {
          // First Vector2 is under the x1 name
          x1: x1.x,
          y1: x1.y,
          // Second Vector2 is under the y1 name
          x2: y1.x,
          y2: y1.y
        }, x2 ); // Options object (if available) is under the x2 name
      }
      else {
        // assumes Line( { ... } ), init to zero for now
        assert && assert( y1 === undefined );

        // Options object is under the x1 name
        options = x1;

        assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
          'Extra prototype on Node options object is a code smell' );
      }
    }
    else {
      // new Line( x1, y1, x2, y2, [options] )
      assert && assert( typeof x1 === 'number' &&
                        typeof y1 === 'number' &&
                        typeof x2 === 'number' &&
                        typeof y2 === 'number' );
      assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );

      options = extendDefined( {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      }, options );
    }

    Path.call( this, null, options );
  }

  scenery.register( 'Line', Line );

  inherit( Path, Line, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: LINE_OPTION_KEYS.concat( Path.prototype._mutatorKeys ),

    /**
     * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
     *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
     *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
     * @public (scenery-internal)
     * @override
     */
    drawableMarkFlags: Path.prototype.drawableMarkFlags.concat( [ 'line', 'p1', 'p2', 'x1', 'x2', 'y1', 'y2' ] ).filter( function( flag ) {
      // We don't want the shape flag, as that won't be called for Path subtypes.
      return flag !== 'shape';
    } ),

    /**
     * Set all of the line's x and y values.
     * @public
     *
     * @param {number} x1 - the start x coordinate
     * @param {number} y1 - the start y coordinate
     * @param {number} x2 - the end x coordinate
     * @param {number} y2 - the end y coordinate
     * @returns {Line} - For chaining
     */
    setLine: function( x1, y1, x2, y2 ) {
      assert && assert( x1 !== undefined &&
                        y1 !== undefined &&
                        x2 !== undefined &&
                        y2 !== undefined, 'parameters need to be defined' );

      this._x1 = x1;
      this._y1 = y1;
      this._x2 = x2;
      this._y2 = y2;

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyLine();
      }

      this.invalidateLine();

      return this;
    },

    /**
     * Set the line's first point's x and y values
     * @public
     *
     * Numeric parameters:
     * p1 {Vector2} - The first point
     * x1 {number} - The x coordinate of the first point
     * y1 {number} - THe y coordinate of the first point
     *
     * Available type signatures to call:
     * - setPoint1( x1, y1 )
     * - setPoint1( p1 )
     *
     * @param {number} x1 - the start x coordinate
     * @param {number} y1 - the start y coordinate
     * @returns {Line} - For chaining
     */
    setPoint1: function( x1, y1 ) {
      if ( typeof x1 === 'number' ) {
        // setPoint1( x1, y1 );
        assert && assert( x1 !== undefined && y1 !== undefined, 'parameters need to be defined' );
        this._x1 = x1;
        this._y1 = y1;
      }
      else {
        // setPoint1( Vector2 )
        assert && assert( x1.x !== undefined && x1.y !== undefined, 'parameters need to be defined' );
        this._x1 = x1.x;
        this._y1 = x1.y;
      }
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyP1();
      }
      this.invalidateLine();

      return this;
    },
    set p1( point ) { this.setPoint1( point ); },
    get p1() { return new Vector2( this._x1, this._y1 ); },

    /**
     * Set the line's second point's x and y values
     * @public
     *
     * Numeric parameters:
     * p2 {Vector2} - The second point
     * x2 {number} - The x coordinate of the second point
     * y2 {number} - THe y coordinate of the second point
     *
     * Available type signatures to call:
     * - setPoint2( x2, y2 )
     * - setPoint2( p2 )
     *
     * @param {number} x2 - the start x coordinate
     * @param {number} y2 - the start y coordinate
     * @returns {Line} - For chaining
     */
    setPoint2: function( x2, y2 ) {
      if ( typeof x2 === 'number' ) {
        // setPoint2( x2, y2 );
        assert && assert( x2 !== undefined && y2 !== undefined, 'parameters need to be defined' );
        this._x2 = x2;
        this._y2 = y2;
      }
      else {
        // setPoint2( Vector2 )
        assert && assert( x2.x !== undefined && x2.y !== undefined, 'parameters need to be defined' );
        this._x2 = x2.x;
        this._y2 = x2.y;
      }
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyP2();
      }
      this.invalidateLine();

      return this;
    },
    set p2( point ) { this.setPoint2( point ); },
    get p2() { return new Vector2( this._x2, this._y2 ); },

    /**
     * Sets the x coordinate of the first point of the line.
     * @public
     *
     * @param {number} x1
     * @returns {Line} - For chaining.
     */
    setX1: function( x1 ) {
      if ( this._x1 !== x1 ) {
        this._x1 = x1;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyX1();
        }

        this.invalidateLine();
      }
      return this;
    },
    set x1( value ) { this.setX1( value ); },

    /**
     * Returns the x coordinate of the first point of the line.
     * @public
     *
     * @returns {number}
     */
    getX1: function() {
      return this._x1;
    },
    get x1() { return this.getX1(); },

    /**
     * Sets the y coordinate of the first point of the line.
     * @public
     *
     * @param {number} y1
     * @returns {Line} - For chaining.
     */
    setY1: function( y1 ) {
      if ( this._y1 !== y1 ) {
        this._y1 = y1;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyY1();
        }

        this.invalidateLine();
      }
      return this;
    },
    set y1( value ) { this.setY1( value ); },

    /**
     * Returns the y coordinate of the first point of the line.
     * @public
     *
     * @returns {number}
     */
    getY1: function() {
      return this._y1;
    },
    get y1() { return this.getY1(); },

    /**
     * Sets the x coordinate of the second point of the line.
     * @public
     *
     * @param {number} x2
     * @returns {Line} - For chaining.
     */
    setX2: function( x2 ) {
      if ( this._x2 !== x2 ) {
        this._x2 = x2;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyX2();
        }

        this.invalidateLine();
      }
      return this;
    },
    set x2( value ) { this.setX2( value ); },

    /**
     * Returns the x coordinate of the second point of the line.
     * @public
     *
     * @returns {number}
     */
    getX2: function() {
      return this._x2;
    },
    get x2() { return this.getX2(); },

    /**
     * Sets the y coordinate of the second point of the line.
     * @public
     *
     * @param {number} y2
     * @returns {Line} - For chaining.
     */
    setY2: function( y2 ) {
      if ( this._y2 !== y2 ) {
        this._y2 = y2;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyY2();
        }

        this.invalidateLine();
      }
      return this;
    },
    set y2( value ) { this.setY2( value ); },

    /**
     * Returns the y coordinate of the second point of the line.
     * @public
     *
     * @returns {number}
     */
    getY2: function() {
      return this._y2;
    },
    get y2() { return this.getY2(); },

    /**
     * Returns a Shape that is equivalent to our rendered display. Generally used to lazily create a Shape instance
     * when one is needed, without having to do so beforehand.
     * @private
     *
     * @returns {Shape}
     */
    createLineShape: function() {
      return Shape.lineSegment( this._x1, this._y1, this._x2, this._y2 ).makeImmutable();
    },

    /**
     * Notifies that the line has changed and invalidates path information and our cached shape.
     * @private
     */
    invalidateLine: function() {
      assert && assert( isFinite( this._x1 ), 'A rectangle needs to have a finite x1 (' + this._x1 + ')' );
      assert && assert( isFinite( this._y1 ), 'A rectangle needs to have a finite y1 (' + this._y1 + ')' );
      assert && assert( isFinite( this._x2 ), 'A rectangle needs to have a finite x2 (' + this._x2 + ')' );
      assert && assert( isFinite( this._y2 ), 'A rectangle needs to have a finite y2 (' + this._y2 + ')' );

      // sets our 'cache' to null, so we don't always have to recompute our shape
      this._shape = null;

      // should invalidate the path and ensure a redraw
      this.invalidatePath();
    },

    /**
     * Computes whether the provided point is "inside" (contained) in this Line's self content, or "outside".
     * @protected
     * @override
     *
     * Since an unstroked Line contains no area, we can quickly shortcut this operation.
     *
     * @param {Vector2} point - Considered to be in the local coordinate frame
     * @returns {boolean}
     */
    containsPointSelf: function( point ) {
      if ( this._strokePickable ) {
        return Path.prototype.containsPointSelf.call( this, point );
      }
      else {
        return false; // nothing is in a line! (although maybe we should handle edge points properly?)
      }
    },

    /**
     * Returns whether this Line's selfBounds is intersected by the specified bounds.
     * @public
     *
     * @param {Bounds2} bounds - Bounds to test, assumed to be in the local coordinate frame.
     * @returns {boolean}
     */
    intersectsBoundsSelf: function( bounds ) {
      // TODO: optimization
      return new KiteLine( this.p1, this.p2 ).intersectsBounds( bounds );
    },

    /**
     * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
     * coordinate frame of this node.
     * @protected
     * @override
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} matrix - The transformation matrix already applied to the context.
     */
    canvasPaintSelf: function( wrapper, matrix ) {
      //TODO: Have a separate method for this, instead of touching the prototype. Can make 'this' references too easily.
      LineCanvasDrawable.prototype.paintCanvas( wrapper, this, matrix );
    },

    /**
     * Computes the bounds of the Line, including any applied stroke. Overridden for efficiency.
     * @public
     * @override
     *
     * @returns {Bounds2}
     */
    computeShapeBounds: function() {
      // optimized form for a single line segment (no joins, just two caps)
      if ( this._stroke ) {
        var lineCap = this.getLineCap();
        var halfLineWidth = this.getLineWidth() / 2;
        if ( lineCap === 'round' ) {
          // we can simply dilate by half the line width
          return new Bounds2(
            Math.min( this._x1, this._x2 ) - halfLineWidth, Math.min( this._y1, this._y2 ) - halfLineWidth,
            Math.max( this._x1, this._x2 ) + halfLineWidth, Math.max( this._y1, this._y2 ) + halfLineWidth );
        }
        else {
          // (dx,dy) is a vector p2-p1
          var dx = this._x2 - this._x1;
          var dy = this._y2 - this._y1;
          var magnitude = Math.sqrt( dx * dx + dy * dy );
          if ( magnitude === 0 ) {
            // if our line is a point, just dilate by halfLineWidth
            return new Bounds2( this._x1 - halfLineWidth, this._y1 - halfLineWidth, this._x2 + halfLineWidth, this._y2 + halfLineWidth );
          }
          // (sx,sy) is a vector with a magnitude of halfLineWidth pointed in the direction of (dx,dy)
          var sx = halfLineWidth * dx / magnitude;
          var sy = halfLineWidth * dy / magnitude;
          var bounds = Bounds2.NOTHING.copy();

          if ( lineCap === 'butt' ) {
            // four points just using the perpendicular stroked offsets (sy,-sx) and (-sy,sx)
            bounds.addCoordinates( this._x1 - sy, this._y1 + sx );
            bounds.addCoordinates( this._x1 + sy, this._y1 - sx );
            bounds.addCoordinates( this._x2 - sy, this._y2 + sx );
            bounds.addCoordinates( this._x2 + sy, this._y2 - sx );
          }
          else {
            assert && assert( lineCap === 'square' );

            // four points just using the perpendicular stroked offsets (sy,-sx) and (-sy,sx) and parallel stroked offsets
            bounds.addCoordinates( this._x1 - sx - sy, this._y1 - sy + sx );
            bounds.addCoordinates( this._x1 - sx + sy, this._y1 - sy - sx );
            bounds.addCoordinates( this._x2 + sx - sy, this._y2 + sy + sx );
            bounds.addCoordinates( this._x2 + sx + sy, this._y2 + sy - sx );
          }
          return bounds;
        }
      }
      else {
        // It might have a fill? Just include the fill bounds for now.
        var fillBounds = Bounds2.NOTHING.copy();
        fillBounds.addCoordinates( this._x1, this._y1 );
        fillBounds.addCoordinates( this._x2, this._y2 );
        return fillBounds;
      }
    },

    /**
     * Creates a SVG drawable for this Line.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {SVGSelfDrawable}
     */
    createSVGDrawable: function( renderer, instance ) {
      return LineSVGDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a Canvas drawable for this Line.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {CanvasSelfDrawable}
     */
    createCanvasDrawable: function( renderer, instance ) {
      return LineCanvasDrawable.createFromPool( renderer, instance );
    },

    /**
     * It is impossible to set another shape on this Path subtype, as its effective shape is determined by other
     * parameters.
     * @public
     * @override
     *
     * @param {Shape|null} Shape - Throws an error if it is not null.
     */
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Line to something non-null' );
      }
      else {
        // probably called from the Path constructor
        this.invalidatePath();
      }
    },

    /**
     * Returns an immutable copy of this Path subtype's representation.
     * @public
     * @override
     *
     * NOTE: This is created lazily, so don't call it if you don't have to!
     *
     * @returns {Shape}
     */
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createLineShape();
      }
      return this._shape;
    },

    /**
     * Returns whether this Path has an associated Shape (instead of no shape, represented by null)
     * @public
     * @override
     *
     * @returns {boolean}
     */
    hasShape: function() {
      return true;
    },

    /**
     * Returns available fill renderers.
     * @public (scenery-internal)
     * @override
     *
     * Since our line can't be filled, we support all fill renderers.
     *
     * @returns {number} - See Renderer for more information on the bitmasks
     */
    getFillRendererBitmask: function() {
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG | Renderer.bitmaskDOM | Renderer.bitmaskWebGL;
    }
  } );

  return Line;
} );

// Copyright 2016-2017, University of Colorado Boulder

/**
 * Wrapper type for scenery phet's RichText node.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */
define( 'SCENERY/nodes/TRichText',['require','SCENERY/scenery','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );

  /**
   * Wrapper type for scenery's Text node.
   * @param {Text} text
   * @param {string} phetioID
   * @constructor
   */
  function TRichText( text, phetioID ) {
    TNode.call( this, text, phetioID );
    assertInstanceOf( text, scenery.RichText );
  }

  phetioInherit( TNode, 'TRichText', TRichText, {

    setText: {
      returnType: TVoid,
      parameterTypes: [ TString ],
      implementation: function( text ) {
        this.instance.text = text;
      },
      documentation: 'Set the text content'
    },

    getText: {
      returnType: TString,
      parameterTypes: [],
      implementation: function() {
        return this.instance.text;
      },
      documentation: 'Get the text content'
    }
  }, {
    documentation: 'The tandem wrapper type for the scenery RichText node'
  } );

  scenery.register( 'TRichText', TRichText );

  return TRichText;
} );
// Copyright 2015-2016, University of Colorado Boulder

/**
 * A mixin for subtypes of Node, used to prevent children being added/removed to that subtype of Node.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Leaf',['require','SCENERY/scenery'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var Leaf = {
    /**
     * Removes the capability to insert children when this is mixed into a type.
     * @public
     * @mixin
     *
     * @param {function} type - The type (constructor) whose prototype we'll modify so that it can't have children.
     */
    mixin: function( type ) {
      var proto = type.prototype;

      /**
       * @override
       */
      proto.insertChild = function( index, node ) {
        throw new Error( 'Attempt to insert child into Leaf' );
      };

      /**
       * @override
       */
      proto.removeChildWithIndex = function( node, indexOfChild ) {
        throw new Error( 'Attempt to remove child from Leaf' );
      };
    }
  };
  scenery.register( 'Leaf', Leaf );

  return scenery.Leaf;
} );

// Copyright 2015-2016, University of Colorado Boulder

/**
 * A Node meant to just take up certain bounds. It is never displayed, and cannot have children.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Spacer',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Bounds2','SCENERY/nodes/Node','SCENERY/nodes/Leaf'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Leaf = require( 'SCENERY/nodes/Leaf' );

  /**
   * Creates a spacer taking up a rectangular area from x: [0,width] and y: [0,height]. Use x/y in options to control
   * its position.
   * @public
   * @constructor
   * @extends Node
   *
   * @param {number} width - The width of the spacer
   * @param {number} height - The height of the spacer
   * @param {Object} [options] - Passed to Node
   */
  function Spacer( width, height, options ) {
    assert && assert( typeof width === 'number' && isFinite( width ), 'width should be a finite number' );
    assert && assert( typeof height === 'number' && isFinite( height ), 'height should be a finite number' );

    Node.call( this );

    // override the local bounds to our area
    this.localBounds = new Bounds2( 0, 0, width, height );

    this.mutate( options );
  }

  scenery.register( 'Spacer', Spacer );

  inherit( Node, Spacer );
  Leaf.mixin( Spacer ); // prevent children from being added, since we're overriding local bounds

  return Spacer;
} );

// Copyright 2015-2016, University of Colorado Boulder

/**
 * A Node meant to just take up vertical space (usually for layout purposes).
 * It is never displayed, and cannot have children.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/VStrut',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Spacer'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Spacer = require( 'SCENERY/nodes/Spacer' );

  /**
   * Creates a strut with x=0 and y in the range [0,height].
   * @public
   * @constructor
   * @extends Spacer
   *
   * @param {number} height - Height of the strut
   * @param {Object} [options] - Passed to Spacer/Node
   */
  function VStrut( height, options ) {
    Spacer.call( this, 0, height, options );
  }

  scenery.register( 'VStrut', VStrut );

  return inherit( Spacer, VStrut );
} );

// Copyright 2017, University of Colorado Boulder

/**
 * Displays rich text by interpreting the input text as HTML, supporting a limited set of tags that prevent any
 * security vulnerabilities. It does this by parsing the input HTML and splitting it into multiple Text children
 * recursively.
 *
 * NOTE: Encoding HTML entities is required, and malformed HTML is not accepted.
 *
 * NOTE: Currently it can line-wrap at the start and end of tags. This will probably be fixed in the future to only
 *       potentially break on whitespace.
 *
 * It supports the following markup and features in the string content (in addition to other options as listed in
 * RICH_TEXT_OPTIONKEYS):
 * - <a href="{{placeholder}}"> for links (pass in { links: { placeholder: ACTUAL_HREF } })
 * - <b> and <strong> for bold text
 * - <i> and <em> for italic text
 * - <sub> and <sup> for subscripts / superscripts
 * - <u> for underlined text
 * - <s> for strikethrough text
 * - <font> tags with attributes color="cssString", face="familyString", size="cssSize"
 * - <span> tags with a dir="ltr" / dir="rtl" attribute
 * - <br> for explicit line breaks
 * - Unicode bidirectional marks (present in PhET strings) for full RTL support
 *
 * Examples from the scenery-phet demo:
 *
 * new RichText( 'RichText can have <b>bold</b> and <i>italic</i> text.' ),
 * new RichText( 'Can do H<sub>2</sub>O (A<sub>sub</sub> and A<sup>sup</sup>), or nesting: x<sup>2<sup>2</sup></sup>' ),
 * new RichText( 'Additionally: <font color="blue">color</font>, <font size="30px">sizes</font>, <font face="serif">faces</font>, <s>strikethrough</s>, and <u>underline</u>' ),
 * new RichText( 'These <b><em>can</em> <u><font color="red">be</font> mixed<sup>1</sup></u></b>.' ),
 * new RichText( '\u202aHandles bidirectional text: \u202b<font color="#0a0">مقابض</font> النص ثنائي <b>الاتجاه</b><sub>2</sub>\u202c\u202c' ),
 * new RichText( '\u202b\u062a\u0633\u062a (\u0632\u0628\u0627\u0646)\u202c' ),
 * new RichText( 'HTML entities need to be escaped, like &amp; and &lt;.' ),
 * new RichText( 'Supports <a href="{{phetWebsite}}"><em>links</em> with <b>markup</b></a>, and <a href="{{callback}}">links that call functions</a>.', {
 *   links: {
 *     phetWebsite: 'https://phet.colorado.edu',
 *     callback: function() {
 *       console.log( 'Link was clicked' );
 *     }
 *   }
 * } ),
 * new RichText( 'Or also <a href="https://phet.colorado.edu">links directly in the string</a>.', {
 *   links: true
 * } ),
 * new RichText( 'Links not found <a href="{{bogus}}">are ignored</a> for security.' ),
 * new HBox( {
 *   spacing: 30,
 *   children: [
 *     new RichText( 'Multi-line text with the<br>separator &lt;br&gt; and <a href="https://phet.colorado.edu">handles<br>links</a> and other <b>tags<br>across lines</b>', {
 *       links: true
 *     } ),
 *     new RichText( 'Supposedly RichText supports line wrapping. Here is a lineWrap of 300, which should probably wrap multiple times here', { lineWrap: 300 })
 *   ]
 * } )
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'SCENERY/nodes/RichText',['require','SCENERY/input/ButtonListener','SCENERY/util/Color','PHET_CORE/extendDefined','SCENERY/util/Font','PHET_CORE/inherit','SCENERY/nodes/Line','SCENERY/nodes/Node','SCENERY/scenery','SCENERY/nodes/Text','TANDEM/Tandem','SCENERY/nodes/TRichText','SCENERY/nodes/VStrut'],function( require ) {
  'use strict';

  // modules
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Color = require( 'SCENERY/util/Color' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var Font = require( 'SCENERY/util/Font' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'SCENERY/nodes/Line' );
  var Node = require( 'SCENERY/nodes/Node' );
  var scenery = require( 'SCENERY/scenery' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TRichText = require( 'SCENERY/nodes/TRichText' );
  var VStrut = require( 'SCENERY/nodes/VStrut' );

  // Options that can be used in the constructor, with mutate(), or directly as setters/getters
  var RICH_TEXT_OPTION_KEYS = [
    'font',
    'fill',
    'stroke',
    'subScale',
    'subXSpacing',
    'subYOffset',
    'supScale',
    'supXSpacing',
    'supYOffset',
    'capHeightScale',
    'underlineLineWidth',
    'underlineHeightScale',
    'strikethroughLineWidth',
    'strikethroughHeightScale',
    'linkFill',
    'linkEventsHandled',
    'links',
    'align',
    'leading',
    'lineWrap',
    'text'
  ];

  var DEFAULT_FONT = new Font( {
    size: 20
  } );

  // Tags that should be included in accessibleLabel, see https://github.com/phetsims/joist/issues/430
  var ACCESSIBLE_TAGS = [
    'b', 'strong', 'i', 'em', 'sub', 'sup', 'u', 's'
  ];

  // What type of line-break situations we can be in during our recursive process
  var LineBreakState = {
    // There was a line break, but it was at the end of the element (or was a <br>). The relevant element can be fully
    // removed from the tree.
    COMPLETE: 'COMPLETE',

    // There was a line break, but there is some content left in this element after the line break. DO NOT remove it.
    INCOMPLETE: 'INCOMPLETE',

    // There was NO line break
    NONE: 'NONE'
  };

  // We need to do some font-size tests, so we have a Text for that.
  var scratchText = new scenery.Text( '' );

  /**
   * @public
   * @constructor
   * @extends Node
   *
   * @param {string|number} text
   * @param {Object} [options] - RichText-specific options are documented in RICH_TEXT_OPTION_KEYS above, and can be
   *                             provided along-side options for Node.
   */
  function RichText( text, options ) {

    // @private {string} - Set by mutator
    this._text = '';

    // @private {Font}
    this._font = DEFAULT_FONT;

    // @private {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern}
    this._fill = '#000000';
    this._stroke = null;

    // @private {number}
    this._subScale = 0.75;
    this._subXSpacing = 0;
    this._subYOffset = 0;

    // @private {number}
    this._supScale = 0.75;
    this._supXSpacing = 0;
    this._supYOffset = 0;

    // @private {number}
    this._capHeightScale = 0.75;

    // @private {number}
    this._underlineLineWidth = 1;
    this._underlineHeightScale = 0.15;

    // @private {number}
    this._strikethroughLineWidth = 1;
    this._strikethroughHeightScale = 0.3;

    // @private {paint}
    this._linkFill = 'rgb(27,0,241)';

    // @private {boolean}
    this._linkEventsHandled = false;

    // @private {Object|boolean} - If an object, values are either {string} or {function}
    this._links = {};

    // @private {string}
    this._align = 'left'; // 'left', 'center', or 'right'

    // @private {number}
    this._leading = 0;

    // @private {number|null}
    this._lineWrap = null;

    // @private {Array.<{ element: {*}, node: {Node}, href: {string} }>} - We need to consolidate links (that could be
    // split across multiple lines) under one "link" node, so we track created link fragments here so they can get
    // pieced together later.
    this._linkItems = [];

    // @private {boolean} - Whether something has been added to this line yet. We don't want to infinite-loop out if
    // something is longer than our lineWrap, so we'll place one item on its own on an otherwise empty line.
    this._hasAddedLeafToLine = false;

    Node.call( this );

    // @private {Node} - Normal layout container of lines (separate, so we can clear it easily)
    this.lineContainer = new Node( {} );
    this.addChild( this.lineContainer );

    options = extendDefined( {
      fill: '#000000',
      text: text,
      tandem: Tandem.tandemOptional(),
      phetioType: TRichText
    }, options );

    this.mutate( options );
  }

  scenery.register( 'RichText', RichText );

  inherit( Node, RichText, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: RICH_TEXT_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),

    /**
     * When called, will rebuild the node structure for this RichText
     * @private
     */
    rebuildRichText: function() {
      var self = this;

      // Clear any existing lines or link fragments
      this.lineContainer.removeAllChildren();

      // Bail early, particularly if we are being constructed.
      if ( this._text === '' ) {
        return;
      }

      sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'RichText#' + this.id + ' rebuild' );
      sceneryLog && sceneryLog.RichText && sceneryLog.push();

      // Turn bidirectional marks into explicit elements, so that the nesting is applied correctly.
      var mappedText = this._text.replace( /\u202a/g, '<span dir="ltr">' )
        .replace( /\u202b/g, '<span dir="rtl">' )
        .replace( /\u202c/g, '</span>' );

      var rootElements;

      // Start appending all top-level elements
      try {
        rootElements = himalaya.parse( mappedText );
      }
      catch( e ) {
        // If we error out, don't kill the sim. Instead, replace the string with something that looks obviously like an
        // error. See https://github.com/phetsims/chipper/issues/1361 (we don't want translations to error out our
        // build process).

        rootElements = himalaya.parse( 'INVALID TRANSLATION' );
      }

      // Clear out link items, as we'll need to reconstruct them later
      this._linkItems.length = 0;

      var widthAvailable = this._lineWrap === null ? Number.POSITIVE_INFINITY : this._lineWrap;
      var isRootLTR = true;

      var currentLine = new RichTextElement( isRootLTR );
      this._hasAddedLeafToLine = false; // notify that if nothing has been added, the first leaf always gets added.

      // Himalaya can give us multiple top-level items, so we need to iterate over those
      while ( rootElements.length ) {
        var element = rootElements[ 0 ];

        // How long our current line is already
        var currentLineWidth = currentLine.bounds.isValid() ? currentLine.width : 0;

        // Add the element in
        var lineBreakState = this.appendElement( currentLine, element, this._font, this._fill, isRootLTR, widthAvailable - currentLineWidth );
        sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'lineBreakState: ' + lineBreakState );

        // If there was a line break (we'll need to swap to a new line node)
        if ( lineBreakState !== LineBreakState.NONE ) {
          // Add the line if it works
          if ( currentLine.bounds.isValid() ) {
            sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'Adding line due to lineBreak' );
            this.appendLine( currentLine );
          }
          // Otherwise if it's a blank line, add in a strut (<br><br> should result in a blank line)
          else {
            this.appendLine( new VStrut( scratchText.setText( 'X' ).setFont( this._font ).height ) );
          }

          // Set up a new line
          currentLine = new RichTextElement( isRootLTR );
          this._hasAddedLeafToLine = false;
        }

        // If it's COMPLETE or NONE, then we fully processed the line
        if ( lineBreakState !== LineBreakState.INCOMPLETE ) {
          sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'Finished root element' );
          rootElements.splice( 0, 1 );
        }
      }

      // Only add the final line if it's valid (we don't want to add unnecessary padding at the bottom)
      if ( currentLine.bounds.isValid() ) {
        sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'Adding final line' );
        this.appendLine( currentLine );
      }

      // All lines are constructed, so we can align them now
      this.alignLines();

      // Handle regrouping of links (so that all fragments of a link across multiple lines are contained under a single
      // ancestor that has listeners and a11y)
      while ( this._linkItems.length ) {
        // Close over the href and other references
        (function(){
          var linkElement = self._linkItems[ 0 ].element;
          var href = self._linkItems[ 0 ].href;
          var i;

          // Find all nodes that are for the same link
          var nodes = [];
          for ( i = self._linkItems.length - 1; i >= 0; i-- ) {
            var item = self._linkItems[ i ];
            if ( item.element === linkElement ) {
              nodes.push( item.node );
              self._linkItems.splice( i, 1 );
            }
          }

          // a11y - open the link in the new tab when activated with a keyboard.
          // also see https://github.com/phetsims/joist/issues/430
          var rootNode = new Node( {
            cursor: 'pointer',
            tagName: 'a',
            accessibleLabelAsHTML: linkElement.accessibleLabel
          } );

          // If our href is a function, it should be called when the user clicks on the link
          if ( typeof href === 'function' ) {
            rootNode.addInputListener( new ButtonListener( {
              fire: href
            } ) );
            rootNode.setAccessibleAttribute( 'href', '#' ); // Required so that the click listener will get called.
            rootNode.addAccessibleInputListener( {
              click: function( event ) {
                event.preventDefault();

                href();
              }
            } );
          }
          // Otherwise our href is a {string}, and we should open a window pointing to it (assuming it's a URL)
          else {
            rootNode.addInputListener( new ButtonListener( {
              fire: function( event ) {
                self._linkEventsHandled && event.handle();
                if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
                  var newWindow = window.open( href, '_blank' ); // open in a new window/tab
                  newWindow.focus();
                }
              }
            } ) );
            rootNode.setAccessibleAttribute( 'href', href );
            rootNode.setAccessibleAttribute( 'target', '_blank' );
          }

          self.lineContainer.addChild( rootNode );

          // Detach the node from its location, adjust its transform, and reattach under the link. This should keep each
          // fragment in the same place, but changes its parent.
          for ( i = 0; i < nodes.length; i++ ) {
            var node = nodes[ i ];
            var matrix = node.getUniqueTrailTo( self.lineContainer ).getMatrix();
            node.detach();
            node.matrix = matrix;
            rootNode.addChild( node );
          }
        })();
      }

      // Clear them out afterwards, for memory purposes
      this._linkItems.length = 0;

      sceneryLog && sceneryLog.RichText && sceneryLog.pop();
    },

    /**
     * Appends a finished line, applying any necessary leading.
     * @private
     *
     * @param {RichTextElement} lineNode
     */
    appendLine: function( lineNode ) {
      // Apply leading
      if ( this.lineContainer.bounds.isValid() ) {
        lineNode.top = this.lineContainer.bottom + this._leading;

        // This ensures RTL lines will still be laid out properly with the main origin (handled by alignLines later)
        lineNode.left = 0;
      }

      this.lineContainer.addChild( lineNode );
    },

    /**
     * Aligns all lines attached to the lineContainer.
     * @private
     */
    alignLines: function() {
      // All nodes will either share a 'left', 'centerX' or 'right'.
      var coordinateName = this._align === 'center' ? 'centerX' : this._align;

      var ideal = this.lineContainer[ coordinateName ];
      for ( var i = 0; i < this.lineContainer.getChildrenCount(); i++ ) {
        this.lineContainer.getChildAt( i )[ coordinateName ] = ideal;
      }
    },

    /**
     * Main recursive function for constructing the RichText Node tree.
     * @private
     *
     * We'll add any relevant content to the containerNode. The element will be mutated as things are added, so that
     * whenever content is added to the Node tree it will be removed from the element tree. This means we can pause
     * whenever (e.g. when a line-break is encountered) and the rest will be ready for parsing the next line.
     *
     * @param {RichTextElement} containerNode - The node where child elements should be placed
     * @param {*} element - See Himalaya's element specification
     *                      (https://github.com/andrejewski/himalaya/blob/master/text/ast-spec-v0.md)
     * @param {Font|string} font - The font to apply at this level
     * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} fill - Fill to apply
     * @param {boolean} isLTR - True if LTR, false if RTL (handles RTL text properly)
     * @param {number} widthAvailable - How much width we have available before forcing a line break (for lineWrap)
     * @returns {LineBreakState} - Whether a line break was reached
     */
    appendElement: function( containerNode, element, font, fill, isLTR, widthAvailable ) {
      var lineBreakState = LineBreakState.NONE;

      // {Node|Text} - The main Node for the element that we are adding
      var node;

      // If we're a leaf
      if ( element.type === 'Text' ) {
        sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'appending leaf: ' + element.content );
        sceneryLog && sceneryLog.RichText && sceneryLog.push();

        node = new RichTextLeaf( element.content, isLTR, font, fill, this._stroke );

        // If this content gets added, it will need to be pushed over by this amount
        var containerSpacing = isLTR ? containerNode.rightSpacing : containerNode.leftSpacing;

        // Handle wrapping if required. Container spacing cuts into our available width
        if ( !node.fitsIn( widthAvailable - containerSpacing, this._hasAddedLeafToLine, isLTR ) ) {
          // Didn't fit, lets break into words to see what we can fit
          var words = element.content.split( ' ' );

          sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'Overflow leafAdded:' + this._hasAddedLeafToLine + ', words: ' + words.length );

          // If we need to add something (and there is only a single word), then add it
          if ( this._hasAddedLeafToLine || words.length > 1 ) {
            sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'Skipping words' );

            var skippedWords = [];
            var success = false;
            skippedWords.unshift( words.pop() ); // We didn't fit with the last one!

            // Keep shortening by removing words until it fits (or if we NEED to fit it) or it doesn't fit.
            while ( words.length ) {
              node = new RichTextLeaf( words.join( ' ' ), isLTR, font, fill, this._stroke );

              // If we haven't added anything to the line and we are down to the first word, we need to just add it.
              if ( !node.fitsIn( widthAvailable - containerSpacing, this._hasAddedLeafToLine, isLTR ) &&
                   ( this._hasAddedLeafToLine || words.length > 1 ) ) {
                sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'Skipping word ' + words[ words.length - 1 ] );
                skippedWords.unshift( words.pop() );
              }
              else {
                sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'Success with ' + words.join( ' ' ) );
                success = true;
                break;
              }
            }

            // If we haven't added anything yet to this line, we'll permit the overflow
            if ( success ) {
              lineBreakState = LineBreakState.INCOMPLETE;
              element.content = skippedWords.join( ' ' );
              sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'Remaining content: ' + element.content );
            }
            else {
              return LineBreakState.INCOMPLETE;
            }
          }
        }

        this._hasAddedLeafToLine = true;

        sceneryLog && sceneryLog.RichText && sceneryLog.pop();
      }
      // Otherwise presumably an element with content
      else if ( element.type === 'Element' ) {
        // Bail out quickly for a line break
        if ( element.tagName === 'br' ) {
          sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'manual line break' );
          return LineBreakState.COMPLETE;
        }
        // Span (dir attribute) -- we need the LTR/RTL knowledge before most other operations
        else if ( element.tagName === 'span' ) {
          if ( element.attributes.dir ) {
            assert && assert( element.attributes.dir === 'ltr' || element.attributes.dir === 'rtl',
              'Span dir attributes should be ltr or rtl.' );
            isLTR = element.attributes.dir === 'ltr';
          }
        }

        node = new RichTextElement( isLTR );

        sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'appending element' );
        sceneryLog && sceneryLog.RichText && sceneryLog.push();

        // Achor (link)
        if ( element.tagName === 'a' ) {
          var href = element.attributes.href;

          // Try extracting the href from the links object
          if ( this._links !== true ) {
            if ( href.indexOf( '{{' ) === 0 && href.indexOf( '}}' ) === href.length - 2 ) {
              href = this._links[ href.slice( 2, -2 ) ];
            }
            else {
              href = null;
            }
          }

          // Ignore things if there is no matching href
          if ( href ) {
            if ( this._linkFill !== null ) {
              fill = this._linkFill; // Link color
            }
            // Don't overwrite only accessibleLabels once things have been "torn down"
            if ( !element.accessibleLabel ) {
              element.accessibleLabel = RichText.himalayaElementToAccessibleString( element, isLTR );
            }

            // Store information about it for the "regroup links" step
            this._linkItems.push( {
              element: element,
              node: node,
              href: href
            } );
          }
        }
        // Bold
        else if ( element.tagName === 'b' || element.tagName === 'strong' ) {
          font = font.copy( {
            weight: 'bold'
          } );
        }
        // Italic
        else if ( element.tagName === 'i' || element.tagName === 'em' ) {
          font = font.copy( {
            style: 'italic'
          } );
        }
        // Subscript
        else if ( element.tagName === 'sub' ) {
          node.scale( this._subScale );
          node.addExtraBeforeSpacing( this._subXSpacing );
          node.y += this._subYOffset;
        }
        // Superscript
        else if ( element.tagName === 'sup' ) {
          node.scale( this._supScale );
          node.addExtraBeforeSpacing( this._supXSpacing );
          node.y += this._supYOffset;
        }
        // Font (color/face/size attributes)
        else if ( element.tagName === 'font' ) {
          if ( element.attributes.color ) {
            fill = new Color( element.attributes.color );
          }
          if ( element.attributes.face ) {
            font = font.copy( {
              family: element.attributes.face
            } );
          }
          if ( element.attributes.size ) {
            font = font.copy( {
              size: element.attributes.size
            } );
          }
        }

        // If we've added extra spacing, we'll need to subtract it off of our available width
        var scale = node.getScaleVector().x;

        // Process children
        while ( lineBreakState === LineBreakState.NONE && element.children.length ) {
          var widthBefore = node.bounds.isValid() ? node.width : 0;

          var childElement = element.children[ 0 ];
          lineBreakState = this.appendElement( node, childElement, font, fill, isLTR, widthAvailable / scale );

          // for COMPLETE or NONE, we'll want to remove the childElement from the tree (we fully processed it)
          if ( lineBreakState !== LineBreakState.INCOMPLETE ) {
            element.children.splice( 0, 1 );
          }

          var widthAfter = node.bounds.isValid() ? node.width : 0;

          // Remove the amount of width taken up by the child
          widthAvailable += widthBefore - widthAfter;
        }
        // If there is a line break and there are still more things to process, we are incomplete
        if ( lineBreakState === LineBreakState.COMPLETE && element.children.length ) {
          lineBreakState = LineBreakState.INCOMPLETE;
        }

        // Subscript positioning
        if ( element.tagName === 'sub' ) {
          if ( isFinite( node.height ) ) {
            node.centerY = 0;
          }
        }
        // Superscript positioning
        else if ( element.tagName === 'sup' ) {
          if ( isFinite( node.height ) ) {
            node.centerY = scratchText.setText( 'X' ).setFont( font ).top * this._capHeightScale;
          }
        }
        // Underline
        else if ( element.tagName === 'u' ) {
          var underlineY = -node.top * this._underlineHeightScale;
          if ( isFinite( node.top ) ) {
            node.addChild( new Line( node.localBounds.left, underlineY, node.localBounds.right, underlineY, {
              stroke: fill,
              lineWidth: this._underlineLineWidth
            } ) );
          }
        }
        // Strikethrough
        else if ( element.tagName === 's' ) {
          var strikethroughY = node.top * this._strikethroughHeightScale;
          if ( isFinite( node.top ) ) {
            node.addChild( new Line( node.localBounds.left, strikethroughY, node.localBounds.right, strikethroughY, {
              stroke: fill,
              lineWidth: this._strikethroughLineWidth
            } ) );
          }
        }
        sceneryLog && sceneryLog.RichText && sceneryLog.pop();
      }

      containerNode.addElement( node );

      return lineBreakState;
    },

    /**
     * Sets the text displayed by our node.
     * @public
     *
     * NOTE: Encoding HTML entities is required, and malformed HTML is not accepted.
     *
     * @param {string|number} text - The text to display. If it's a number, it will be cast to a string
     * @returns {RichText} - For chaining
     */
    setText: function( text ) {
      assert && assert( text !== null && text !== undefined, 'Text should be defined and non-null. Use the empty string if needed.' );
      assert && assert( typeof text === 'number' || typeof text === 'string', 'text should be a string or number' );

      // cast it to a string (for numbers, etc., and do it before the change guard so we don't accidentally trigger on non-changed text)
      text = '' + text;

      if ( text !== this._text ) {
        this._text = text;
        this.rebuildRichText();
      }
      return this;
    },
    set text( value ) { this.setText( value ); },

    /**
     * Returns the text displayed by our node.
     * @public
     *
     * @returns {string}
     */
    getText: function() {
      return this._text;
    },
    get text() { return this.getText(); },

    /**
     * Sets the font of our node.
     * @public
     *
     * @param {Font|string} font
     * @returns {RichText} - For chaining.
     */
    setFont: function( font ) {
      assert && assert( font instanceof Font || typeof font === 'string',
        'Fonts provided to setFont should be a Font object or a string in the CSS3 font shortcut format' );

      if ( this._font !== font ) {
        this._font = font;
        this.rebuildRichText();
      }
      return this;
    },
    set font( value ) { this.setFont( value ); },

    /**
     * Returns the current Font
     * @public
     *
     * @returns {Font|string}
     */
    getFont: function() {
      return this._font;
    },
    get font() { return this.getFont(); },

    /**
     * Sets the fill of our text.
     * @public
     *
     * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} fill
     * @returns {RichText} - For chaining.
     */
    setFill: function( fill ) {
      if ( this._fill !== fill ) {
        this._fill = fill;
        this.rebuildRichText();
      }
      return this;
    },
    set fill( value ) { this.setFill( value ); },

    /**
     * Returns the current fill.
     * @public
     *
     * @returns {Font|string}
     */
    getFill: function() {
      return this._fill;
    },
    get fill() { return this.getFill(); },

    /**
     * Sets the stroke of our text.
     * @public
     *
     * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} stroke
     * @returns {RichText} - For chaining.
     */
    setStroke: function( stroke ) {
      if ( this._stroke !== stroke ) {
        this._stroke = stroke;
        this.rebuildRichText();
      }
      return this;
    },
    set stroke( value ) { this.setStroke( value ); },

    /**
     * Returns the current stroke.
     * @public
     *
     * @returns {Font|string}
     */
    getStroke: function() {
      return this._stroke;
    },
    get stroke() { return this.getStroke(); },

    /**
     * Sets the scale (relative to 1) of any text under subscript (<sub>) elements.
     * @public
     *
     * @param {number} subScale
     * @returs {RichText} - For chaining
     */
    setSubScale: function( subScale ) {
      assert && assert( typeof subScale === 'number' && isFinite( subScale ) && subScale > 0 );

      if ( this._subScale !== subScale ) {
        this._subScale = subScale;
        this.rebuildRichText();
      }
      return this;
    },
    set subScale( value ) { this.setSubScale( value ); },

    /**
     * Returns the scale (relative to 1) of any text under subscript (<sub>) elements.
     * @public
     *
     * @returns {number}
     */
    getSubScale: function() {
      return this._subScale;
    },
    get subScale() { return this.getSubScale(); },

    /**
     * Sets the horizontal spacing before any subscript (<sub>) elements.
     * @public
     *
     * @param {number} subXSpacing
     * @returs {RichText} - For chaining
     */
    setSubXSpacing: function( subXSpacing ) {
      assert && assert( typeof subXSpacing === 'number' && isFinite( subXSpacing ) );

      if ( this._subXSpacing !== subXSpacing ) {
        this._subXSpacing = subXSpacing;
        this.rebuildRichText();
      }
      return this;
    },
    set subXSpacing( value ) { this.setSubXSpacing( value ); },

    /**
     * Returns the horizontal spacing before any subscript (<sub>) elements.
     * @public
     *
     * @returns {number}
     */
    getSubXSpacing: function() {
      return this._subXSpacing;
    },
    get subXSpacing() { return this.getSubXSpacing(); },

    /**
     * Sets the adjustment offset to the vertical placement of any subscript (<sub>) elements.
     * @public
     *
     * @param {number} subYOffset
     * @returs {RichText} - For chaining
     */
    setSubYOffset: function( subYOffset ) {
      assert && assert( typeof subYOffset === 'number' && isFinite( subYOffset ) );

      if ( this._subYOffset !== subYOffset ) {
        this._subYOffset = subYOffset;
        this.rebuildRichText();
      }
      return this;
    },
    set subYOffset( value ) { this.setSubYOffset( value ); },

    /**
     * Returns the adjustment offset to the vertical placement of any subscript (<sub>) elements.
     * @public
     *
     * @returns {number}
     */
    getSubYOffset: function() {
      return this._subYOffset;
    },
    get subYOffset() { return this.getSubYOffset(); },

    /**
     * Sets the scale (relative to 1) of any text under superscript (<sup>) elements.
     * @public
     *
     * @param {number} supScale
     * @returs {RichText} - For chaining
     */
    setSupScale: function( supScale ) {
      assert && assert( typeof supScale === 'number' && isFinite( supScale ) && supScale > 0 );

      if ( this._supScale !== supScale ) {
        this._supScale = supScale;
        this.rebuildRichText();
      }
      return this;
    },
    set supScale( value ) { this.setSupScale( value ); },

    /**
     * Returns the scale (relative to 1) of any text under superscript (<sup>) elements.
     * @public
     *
     * @returns {number}
     */
    getSupScale: function() {
      return this._supScale;
    },
    get supScale() { return this.getSupScale(); },

    /**
     * Sets the horizontal spacing before any superscript (<sup>) elements.
     * @public
     *
     * @param {number} supXSpacing
     * @returs {RichText} - For chaining
     */
    setSupXSpacing: function( supXSpacing ) {
      assert && assert( typeof supXSpacing === 'number' && isFinite( supXSpacing ) );

      if ( this._supXSpacing !== supXSpacing ) {
        this._supXSpacing = supXSpacing;
        this.rebuildRichText();
      }
      return this;
    },
    set supXSpacing( value ) { this.setSupXSpacing( value ); },

    /**
     * Returns the horizontal spacing before any superscript (<sup>) elements.
     * @public
     *
     * @returns {number}
     */
    getSupXSpacing: function() {
      return this._supXSpacing;
    },
    get supXSpacing() { return this.getSupXSpacing(); },

    /**
     * Sets the adjustment offset to the vertical placement of any superscript (<sup>) elements.
     * @public
     *
     * @param {number} supYOffset
     * @returs {RichText} - For chaining
     */
    setSupYOffset: function( supYOffset ) {
      assert && assert( typeof supYOffset === 'number' && isFinite( supYOffset ) );

      if ( this._supYOffset !== supYOffset ) {
        this._supYOffset = supYOffset;
        this.rebuildRichText();
      }
      return this;
    },
    set supYOffset( value ) { this.setSupYOffset( value ); },

    /**
     * Returns the adjustment offset to the vertical placement of any superscript (<sup>) elements.
     * @public
     *
     * @returns {number}
     */
    getSupYOffset: function() {
      return this._supYOffset;
    },
    get supYOffset() { return this.getSupYOffset(); },

    /**
     * Sets the expected cap height (baseline to top of capital letters) as a scale of the detected distance from the
     * baseline to the top of the text bounds.
     * @public
     *
     * @param {number} capHeightScale
     * @returs {RichText} - For chaining
     */
    setCapHeightScale: function( capHeightScale ) {
      assert && assert( typeof capHeightScale === 'number' && isFinite( capHeightScale ) && capHeightScale > 0 );

      if ( this._capHeightScale !== capHeightScale ) {
        this._capHeightScale = capHeightScale;
        this.rebuildRichText();
      }
      return this;
    },
    set capHeightScale( value ) { this.setCapHeightScale( value ); },

    /**
     * Returns the expected cap height (baseline to top of capital letters) as a scale of the detected distance from the
     * baseline to the top of the text bounds.
     * @public
     *
     * @returns {number}
     */
    getCapHeightScale: function() {
      return this._capHeightScale;
    },
    get capHeightScale() { return this.getCapHeightScale(); },

    /**
     * Sets the lineWidth of underline lines.
     * @public
     *
     * @param {number} underlineLineWidth
     * @returs {RichText} - For chaining
     */
    setUnderlineLineWidth: function( underlineLineWidth ) {
      assert && assert( typeof underlineLineWidth === 'number' && isFinite( underlineLineWidth ) && underlineLineWidth > 0 );

      if ( this._underlineLineWidth !== underlineLineWidth ) {
        this._underlineLineWidth = underlineLineWidth;
        this.rebuildRichText();
      }
      return this;
    },
    set underlineLineWidth( value ) { this.setUnderlineLineWidth( value ); },

    /**
     * Returns the lineWidth of underline lines.
     * @public
     *
     * @returns {number}
     */
    getUnderlineLineWidth: function() {
      return this._underlineLineWidth;
    },
    get underlineLineWidth() { return this.getUnderlineLineWidth(); },

    /**
     * Sets the underline height adjustment as a proportion of the detected distance from the baseline to the top of the
     * text bounds.
     * @public
     *
     * @param {number} underlineHeightScale
     * @returs {RichText} - For chaining
     */
    setUnderlineHeightScale: function( underlineHeightScale ) {
      assert && assert( typeof underlineHeightScale === 'number' && isFinite( underlineHeightScale ) && underlineHeightScale > 0 );

      if ( this._underlineHeightScale !== underlineHeightScale ) {
        this._underlineHeightScale = underlineHeightScale;
        this.rebuildRichText();
      }
      return this;
    },
    set underlineHeightScale( value ) { this.setUnderlineHeightScale( value ); },

    /**
     * Returns the underline height adjustment as a proportion of the detected distance from the baseline to the top of the
     * text bounds.
     * @public
     *
     * @returns {number}
     */
    getUnderlineHeightScale: function() {
      return this._underlineHeightScale;
    },
    get underlineHeightScale() { return this.getUnderlineHeightScale(); },

    /**
     * Sets the lineWidth of strikethrough lines.
     * @public
     *
     * @param {number} strikethroughLineWidth
     * @returs {RichText} - For chaining
     */
    setStrikethroughLineWidth: function( strikethroughLineWidth ) {
      assert && assert( typeof strikethroughLineWidth === 'number' && isFinite( strikethroughLineWidth ) && strikethroughLineWidth > 0 );

      if ( this._strikethroughLineWidth !== strikethroughLineWidth ) {
        this._strikethroughLineWidth = strikethroughLineWidth;
        this.rebuildRichText();
      }
      return this;
    },
    set strikethroughLineWidth( value ) { this.setStrikethroughLineWidth( value ); },

    /**
     * Returns the lineWidth of strikethrough lines.
     * @public
     *
     * @returns {number}
     */
    getStrikethroughLineWidth: function() {
      return this._strikethroughLineWidth;
    },
    get strikethroughLineWidth() { return this.getStrikethroughLineWidth(); },

    /**
     * Sets the strikethrough height adjustment as a proportion of the detected distance from the baseline to the top of the
     * text bounds.
     * @public
     *
     * @param {number} strikethroughHeightScale
     * @returs {RichText} - For chaining
     */
    setStrikethroughHeightScale: function( strikethroughHeightScale ) {
      assert && assert( typeof strikethroughHeightScale === 'number' && isFinite( strikethroughHeightScale ) && strikethroughHeightScale > 0 );

      if ( this._strikethroughHeightScale !== strikethroughHeightScale ) {
        this._strikethroughHeightScale = strikethroughHeightScale;
        this.rebuildRichText();
      }
      return this;
    },
    set strikethroughHeightScale( value ) { this.setStrikethroughHeightScale( value ); },

    /**
     * Returns the strikethrough height adjustment as a proportion of the detected distance from the baseline to the top of the
     * text bounds.
     * @public
     *
     * @returns {number}
     */
    getStrikethroughHeightScale: function() {
      return this._strikethroughHeightScale;
    },
    get strikethroughHeightScale() { return this.getStrikethroughHeightScale(); },

    /**
     * Sets the color of links. If null, no fill will be overridden.
     * @public
     *
     * @param {paint} linkFill
     * @returs {RichText} - For chaining
     */
    setLinkFill: function( linkFill ) {
      if ( this._linkFill !== linkFill ) {
        this._linkFill = linkFill;
        this.rebuildRichText();
      }
      return this;
    },
    set linkFill( value ) { this.setLinkFill( value ); },

    /**
     * Returns the color of links.
     * @public
     *
     * @returns {paint}
     */
    getLinkFill: function() {
      return this._linkFill;
    },
    get linkFill() { return this.getLinkFill(); },

    /**
     * Sets whether link clicks will call event.handle().
     * @public
     *
     * @param {boolean} linkEventsHandled
     * @returs {RichText} - For chaining
     */
    setLinkEventsHandled: function( linkEventsHandled ) {
      assert && assert( typeof linkEventsHandled === 'boolean' );

      if ( this._linkEventsHandled !== linkEventsHandled ) {
        this._linkEventsHandled = linkEventsHandled;
        this.rebuildRichText();
      }
      return this;
    },
    set linkEventsHandled( value ) { this.setLinkEventsHandled( value ); },

    /**
     * Returns whether link events will be handled.
     * @public
     *
     * @returns {boolean}
     */
    getLinkEventsHandled: function() {
      return this._linkEventsHandled;
    },
    get linkEventsHandled() { return this.getLinkEventsHandled(); },

    /**
     * Sets the map of href placeholder => actual href/callback used for links. However if set to true ({boolean}) as a
     * full object, links in the string will not be mapped, but will be directly added.
     * @public
     *
     * For instance, the default is to map hrefs for security purposes:
     *
     * new RichText( '<a href="{{alink}}">content</a>', {
     *   links: {
     *     alink: 'https://phet.colorado.edu'
     *   }
     * } );
     *
     * But links with an href not matching will be ignored. This can be avoided by passing links: true to directly
     * embed links:
     *
     * new RichText( '<a href="https://phet.colorado.edu">content</a>', { links: true } );
     *
     * Callbacks (instead of a URL) are also supported, e.g.:
     *
     * new RichText( '<a href="{{acallback}}">content</a>', {
     *   links: {
     *     acallback: function() { console.log( 'clicked' ) }
     *   }
     * } );
     *
     * See https://github.com/phetsims/scenery-phet/issues/316 for more information.
     *
     * @param {Object|boolean} links
     * @returs {RichText} - For chaining
     */
    setLinks: function( links ) {
      assert && assert( links !== false || Object.getPrototypeOf( links ) === Object.prototype );

      if ( this._links !== links ) {
        this._links = links;
        this.rebuildRichText();
      }
      return this;
    },
    set links( value ) { this.setLinks( value ); },

    /**
     * Returns whether link events will be handled.
     * @public
     *
     * @returns {Object}
     */
    getLinks: function() {
      return this._links;
    },
    get links() { return this.getLinks(); },

    /**
     * Sets the alignment of text (only relevant if there are multiple lines).
     * @public
     *
     * @param {string} align
     * @returns {RichText} - For chaining
     */
    setAlign: function( align ) {
      assert && assert( align === 'left' || align === 'center' || align === 'right' );

      if ( this._align !== align ) {
        this._align = align;
        this.rebuildRichText();
      }
      return this;
    },
    set align( value ) { this.setAlign( value ); },

    /**
     * Returns the current alignment of the text (only relevant if there are multiple lines).
     * @public
     *
     * @returns {string}
     */
    getAlign: function() {
      return this._align;
    },
    get align() { return this.getAlign(); },

    /**
     * Sets the leading (spacing between lines)
     * @public
     *
     * @param {number} leading
     * @returns {RichText} - For chaining
     */
    setLeading: function( leading ) {
      assert && assert( typeof leading === 'number' && isFinite( leading ) );

      if ( this._leading !== leading ) {
        this._leading = leading;
        this.rebuildRichText();
      }
      return this;
    },
    set leading( value ) { this.setLeading( value ); },

    /**
     * Returns the leading (spacing between lines)
     * @public
     *
     * @returns {number}
     */
    getLeading: function() {
      return this._leading;
    },
    get leading() { return this.getLeading(); },

    /**
     * Sets the line wrap width for the text (or null if none is desired). Lines longer than this length will wrap
     * automatically to the next line.
     * @public
     *
     * @param {number|null} lineWrap - If it's a number, it should be greater than 0.
     * @returns {RichText} - For chaining
     */
    setLineWrap: function( lineWrap ) {
      assert && assert( lineWrap === null || ( typeof lineWrap === 'number' && isFinite( lineWrap ) && lineWrap > 0 ) );

      if ( this._lineWrap !== lineWrap ) {
        this._lineWrap = lineWrap;
        this.rebuildRichText();
      }
      return this;
    },
    set lineWrap( value ) { this.setLineWrap( value ); },

    /**
     * Returns the line wrap width.
     * @public
     *
     * @returns {number|null}
     */
    getLineWrap: function() {
      return this._lineWrap;
    },
    get lineWrap() { return this.getLineWrap(); }
  }, {
    /**
     * Stringifies an HTML subtree defined by the given element.
     * @public
     *
     * @param {*} element - See himalaya
     * @param {boolean} isLTR
     * @returns {string}
     */
    himalayaElementToString: function( element, isLTR ) {
      if ( element.type === 'Text' ) {
        return RichText.contentToString( element.content, isLTR );
      }
      else if ( element.type === 'Element' ) {
        if ( element.tagName === 'span' && element.attributes.dir ) {
          isLTR = element.attributes.dir === 'ltr';
        }

        // Process children
        return element.children.map( function( child ) {
          return RichText.himalayaElementToString( child, isLTR );
        } ).join( '' );
      }
      else {
        return '';
      }
    },

    /**
     * Stringifies an HTML subtree defined by the given element, but removing certain tags that we don't need for
     * accessibility (like <a>, <font>, <span>, etc.), and adding in tags we do want (see ACCESSIBLE_TAGS).
     * @public
     *
     * @param {*} element - See himalaya
     * @param {boolean} isLTR
     * @returns {string}
     */
    himalayaElementToAccessibleString: function( element, isLTR ) {
      if ( element.type === 'Text' ) {
        return RichText.contentToString( element.content, isLTR );
      }
      else if ( element.type === 'Element' ) {
        if ( element.tagName === 'span' && element.attributes.dir ) {
          isLTR = element.attributes.dir === 'ltr';
        }

        // Process children
        var content = element.children.map( function( child ) {
          return RichText.himalayaElementToAccessibleString( child, isLTR );
        } ).join( '' );

        if ( _.includes( ACCESSIBLE_TAGS, element.tagName ) ) {
          return '<' + element.tagName + '>' + content + '</' + element.tagName + '>';
        }
        else {
          return content;
        }
      }
      else {
        return '';
      }
    },

    /**
     * Takes the element.content from himalaya, unescapes HTML entities, and applies the proper directional tags.
     * @private
     *
     * See https://github.com/phetsims/scenery-phet/issues/315
     *
     * @param {string} content
     * @param {boolean} isLTR
     * @returns {string}
     */
    contentToString: function( content, isLTR ) {
      var unescapedContent = _.unescape( content );
      return isLTR ? ( '\u202a' + unescapedContent + '\u202c' ) : ( '\u202b' + unescapedContent + '\u202c' );
    }
  } );

  /**
   * A container of other RichText elements and leaves.
   * @constructor
   * @private
   *
   * @param {boolean} isLTR - Whether this container will lay out elements in the left-to-right order (if false, will be
   *                          right-to-left).
   */
  function RichTextElement( isLTR ) {
    Node.call( this );

    // @private {boolean}
    this.isLTR = isLTR;

    // @protected {number} - The amount of local-coordinate spacing to apply on each side
    this.leftSpacing = 0;
    this.rightSpacing = 0;
  }

  inherit( Node, RichTextElement, {
    /**
     * Adds a child element.
     * @private
     *
     * @param {RichTextElement|RichTextLeaf} element
     */
    addElement: function( element ) {

      var hadChild = this.children.length > 0;
      var hasElement = element.width > 0;

      // May be at a different scale, which we need to handle
      var elementScale = element.getScaleVector().x;
      var leftElementSpacing = element.leftSpacing * elementScale;
      var rightElementSpacing = element.rightSpacing * elementScale;

      // If there is nothing, than no spacing should be handled
      if ( !hadChild && !hasElement ) {
        sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'No child or element, ignoring' );
        return;
      }
      else if ( !hadChild ) {
        sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'First child, ltr:' + this.isLTR + ', spacing: ' + ( this.isLTR ? rightElementSpacing : leftElementSpacing ) );
        if ( this.isLTR ) {
          element.left = 0;
          this.rightSpacing = rightElementSpacing;
        }
        else {
          element.right = 0;
          this.leftSpacing = leftElementSpacing;
        }
        this.addChild( element );
      }
      else if ( !hasElement ) {
        sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'No element, adding spacing, ltr:' + this.isLTR + ', spacing: ' + ( leftElementSpacing + rightElementSpacing ) );
        if ( this.isLTR ) {
          this.rightSpacing += leftElementSpacing + rightElementSpacing;
        }
        else {
          this.leftSpacing += leftElementSpacing + rightElementSpacing;
        }
      }
      else {
        if ( this.isLTR ) {
          sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'LTR add ' + this.rightSpacing + ' + ' + leftElementSpacing );
          element.left = this.localBounds.right + this.rightSpacing + leftElementSpacing;
          this.rightSpacing = rightElementSpacing;
        }
        else {
          sceneryLog && sceneryLog.RichText && sceneryLog.RichText( 'RTL add ' + this.leftSpacing + ' + ' + rightElementSpacing );
          element.right = this.localBounds.left - this.leftSpacing - rightElementSpacing;
          this.leftSpacing = leftElementSpacing;
        }
        this.addChild( element );
      }
    },

    /**
     * Adds an amount of spacing to the "before" side.
     * @private
     *
     * @param {number} amount
     */
    addExtraBeforeSpacing: function( amount ) {
      if ( this.isLTR ) {
        this.leftSpacing += amount;
      }
      else {
        this.rightSpacing += amount;
      }
    }
  } );

  /**
   * A leaf (text) node.
   * @constructor
   *
   * @param {string} content
   * @param {boolean} isLTR
   * @param {Font|string} font
   * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} fill
   * @param {null|string|Color|Property.<string|Color>|LinearGradient|RadialGradient|Pattern} stroke
   */
  function RichTextLeaf( content, isLTR, font, fill, stroke ) {

    // Grab all spaces at the (logical) start
    var whitespaceBefore = '';
    while ( content[ 0 ] === ' ' ) {
      whitespaceBefore += ' ';
      content = content.slice( 1 );
    }

    // Grab all spaces at the (logical) end
    var whitespaceAfter = '';
    while ( content[ content.length - 1 ] === ' ' ) {
      whitespaceAfter = ' ';
      content = content.slice( 0, content.length - 1 );
    }

    Text.call( this, RichText.contentToString( content, isLTR ), {
      font: font,
      fill: fill,
      stroke: stroke
    } );

    var spacingBefore = whitespaceBefore.length ? scratchText.setText( whitespaceBefore ).setFont( font ).width : 0;
    var spacingAfter = whitespaceAfter.length ? scratchText.setText( whitespaceAfter ).setFont( font ).width : 0;

    // Turn logical spacing into directional
    // @protected {number}
    this.leftSpacing = isLTR ? spacingBefore : spacingAfter;
    this.rightSpacing = isLTR ? spacingAfter : spacingBefore;
  }

  inherit( Text, RichTextLeaf, {
    /**
     * Whether this leaf will fit in the specified amount of space (including, if required, the amount of spacing on
     * the side).
     * @private
     *
     * @param {number} widthAvailable
     * @param {boolean} hasAddedLeafToLine
     * @param {boolean} isContainerLTR
     */
    fitsIn: function( widthAvailable, hasAddedLeafToLine, isContainerLTR ) {
      return this.width + ( hasAddedLeafToLine ? ( isContainerLTR ? this.leftSpacing : this.rightSpacing ) : 0 ) <= widthAvailable;
    }
  } );

  return RichText;
} );


define("string!PENDULUM_LAB/legend.kineticEnergyAbbreviation",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/legend.kineticEnergyAbbreviation");});


define("string!PENDULUM_LAB/legend.potentialEnergyAbbreviation",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/legend.potentialEnergyAbbreviation");});


define("string!PENDULUM_LAB/legend.thermalEnergyAbbreviation",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/legend.thermalEnergyAbbreviation");});


define("string!PENDULUM_LAB/legend.totalEnergyAbbreviation",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/legend.totalEnergyAbbreviation");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Single graph node in 'Pendulum Lab' simulation.
 * Contains graphs for Kinetic, Potential, Thermal and Total energy for one pendulum.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/energy/view/EnergyBarChartNode',['require','SCENERY_PHET/ArrowNode','SCENERY_PHET/ClearThermalButton','PHET_CORE/inherit','SCENERY/nodes/Line','DOT/Matrix3','SCENERY/nodes/Node','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY/nodes/Rectangle','SCENERY/nodes/RichText','string!PENDULUM_LAB/legend.kineticEnergyAbbreviation','string!PENDULUM_LAB/legend.potentialEnergyAbbreviation','string!PENDULUM_LAB/legend.thermalEnergyAbbreviation','string!PENDULUM_LAB/legend.totalEnergyAbbreviation'],function( require ) {
  'use strict';

  // modules
  var ArrowNode = require( 'SCENERY_PHET/ArrowNode' );
  var ClearThermalButton = require( 'SCENERY_PHET/ClearThermalButton' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'SCENERY/nodes/Line' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Node = require( 'SCENERY/nodes/Node' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var RichText = require( 'SCENERY/nodes/RichText' );

  // strings
  var legendKineticEnergyAbbreviationString = require( 'string!PENDULUM_LAB/legend.kineticEnergyAbbreviation' );
  var legendPotentialEnergyAbbreviationString = require( 'string!PENDULUM_LAB/legend.potentialEnergyAbbreviation' );
  var legendThermalEnergyAbbreviationString = require( 'string!PENDULUM_LAB/legend.thermalEnergyAbbreviation' );
  var legendTotalEnergyAbbreviationString = require( 'string!PENDULUM_LAB/legend.totalEnergyAbbreviation' );

  // constants
  var BAR_WIDTH = 14;
  var BAR_OFFSET = 14;
  var SPACING = 4;
  var GRAPH_WIDTH = 122;

  /**
   * @constructor
   *
   * @param {Property.<number>} kineticEnergyProperty
   * @param {Property.<number>} potentialEnergyProperty
   * @param {Property.<number>} thermalEnergyProperty
   * @param {Property.<number>} zoomProperty
   * @param {Property.<boolean>} isEnergyBoxExpandedProperty - Property which track expansion of graph.
   * @param {Property.<number>} chartHeightProperty
   */
  function EnergyBarChartNode( kineticEnergyProperty, potentialEnergyProperty, thermalEnergyProperty, zoomProperty, isEnergyBoxExpandedProperty, chartHeightProperty ) {

    // @private {Property.<number>}
    this.kineticEnergyProperty = kineticEnergyProperty;
    this.potentialEnergyProperty = potentialEnergyProperty;
    this.thermalEnergyProperty = thermalEnergyProperty;
    this.zoomProperty = zoomProperty;
    this.chartHeightProperty = chartHeightProperty;

    // @private {Property.<boolean>}
    this.isEnergyBoxExpandedProperty = isEnergyBoxExpandedProperty;

    var BAR_SPACING = ( GRAPH_WIDTH - BAR_OFFSET ) / 4 - BAR_WIDTH; // amount of space between bars (half on each side of each bar)

    // position of the bars of the energy bar graph
    var kineticCenterX = BAR_OFFSET + 0.5 * BAR_SPACING + 0 * BAR_WIDTH;
    var potentialCenterX = BAR_OFFSET + 1.5 * BAR_SPACING + 1 * BAR_WIDTH;
    var thermalCenterX = BAR_OFFSET + 2.5 * BAR_SPACING + 2 * BAR_WIDTH;
    var totalCenterX = BAR_OFFSET + 3.5 * BAR_SPACING + 3 * BAR_WIDTH;

    // labels for bars
    var barLabelOptions = {
      font: PendulumLabConstants.ENERGY_BAR_FONT,
      rotation: -Math.PI / 2,
      top: SPACING,
      maxWidth: 90
    };
    var kineticLabel = new RichText( legendKineticEnergyAbbreviationString, _.extend( { fill: PendulumLabConstants.KINETIC_ENERGY_COLOR, centerX: kineticCenterX }, barLabelOptions ) );
    var potentialLabel = new RichText( legendPotentialEnergyAbbreviationString, _.extend( { fill: PendulumLabConstants.POTENTIAL_ENERGY_COLOR, centerX: potentialCenterX }, barLabelOptions ) );
    var thermalLabel = new RichText( legendThermalEnergyAbbreviationString, _.extend( { fill: PendulumLabConstants.THERMAL_ENERGY_COLOR, centerX: thermalCenterX }, barLabelOptions ) );
    var totalLabel = new RichText( legendTotalEnergyAbbreviationString, _.extend( { fill: PendulumLabConstants.TOTAL_ENERGY_COLOR, centerX: totalCenterX }, barLabelOptions ) );

    // create 'x' and 'y' axis
    var axisX = new Line( 0, 0, GRAPH_WIDTH, 0, { stroke: 'black' } );
    var axisY = new ArrowNode( 0, 0, 0, chartHeightProperty.value, {
      tailWidth: 2,
      headHeight: 7,
      headWidth: 6
    } );
    chartHeightProperty.link( function( height ) {
      axisY.setTailAndTip( 0, 0, 0, height );
    } );

    // @private {Rectangle} - Individual energy bars
    this.kineticEnergyBar = new Rectangle( 0, 0, BAR_WIDTH, 0, {
      fill: PendulumLabConstants.KINETIC_ENERGY_COLOR,
      centerX: kineticCenterX,
      stroke: 'black'
    } );
    this.potentialEnergyBar = new Rectangle( 0, 0, BAR_WIDTH, 0, {
      fill: PendulumLabConstants.POTENTIAL_ENERGY_COLOR,
      centerX: potentialCenterX,
      stroke: 'black'
    } );
    this.thermalEnergyBar = new Rectangle( 0, 0, BAR_WIDTH, 0, {
      fill: PendulumLabConstants.THERMAL_ENERGY_COLOR,
      centerX: thermalCenterX,
      stroke: 'black'
    } );

    // @private {Rectangle} - For the combined total bar
    this.totalKineticEnergyBar = new Rectangle( 0, 0, BAR_WIDTH, 0, {
      fill: PendulumLabConstants.KINETIC_ENERGY_COLOR,
      centerX: totalCenterX
    } );
    this.totalPotentialEnergyBar = new Rectangle( 0, 0, BAR_WIDTH, 0, {
      fill: PendulumLabConstants.POTENTIAL_ENERGY_COLOR,
      centerX: totalCenterX
    } );
    this.totalThermalEnergyBar = new Rectangle( 0, 0, BAR_WIDTH, 0, {
      fill: PendulumLabConstants.THERMAL_ENERGY_COLOR,
      centerX: totalCenterX
    } );
    this.totalHighlightBar = new Rectangle( 0, 0, BAR_WIDTH, 0, {
      stroke: 'black',
      centerX: totalCenterX
    } );

    function createArrow( fill, centerX ) {
      return new ArrowNode( 0, 0, 0, 18, {
        fill: fill,
        stroke: 'black',
        headHeight: 7,
        headWidth: 16,
        tailWidth: 10,
        centerX: centerX
      } );
    }

    // @private {ArrowNode}
    this.kineticEnergyArrow = createArrow( PendulumLabConstants.KINETIC_ENERGY_COLOR, kineticCenterX );
    this.potentialEnergyArrow = createArrow( PendulumLabConstants.POTENTIAL_ENERGY_COLOR, potentialCenterX );
    this.thermalEnergyArrow = createArrow( PendulumLabConstants.THERMAL_ENERGY_COLOR, thermalCenterX );
    this.totalEnergyArrow = createArrow( '#bbb', totalCenterX );

    var clearThermalButton = new ClearThermalButton( {
      listener: thermalEnergyProperty.reset.bind( thermalEnergyProperty ),
      centerX: thermalCenterX,
      top: thermalLabel.bottom + 5,
      scale: 0.72
    } );
    thermalEnergyProperty.link( function( thermalEnergy ) {
      clearThermalButton.enabled = thermalEnergy !== 0;
    } );

    Node.call( this, {
      preventFit: true,
      children: [
        kineticLabel, potentialLabel, thermalLabel, totalLabel, clearThermalButton,
        new Node( {
          // flip the coordinate frame for easier positioning
          matrix: Matrix3.scale( 1, -1 ),
          children: [
            this.kineticEnergyBar, this.potentialEnergyBar, this.thermalEnergyBar,
            this.totalKineticEnergyBar, this.totalPotentialEnergyBar, this.totalThermalEnergyBar,
            this.totalHighlightBar,
            this.kineticEnergyArrow, this.potentialEnergyArrow, this.thermalEnergyArrow, this.totalEnergyArrow,
            axisX, axisY
          ]
        } )
      ]
    } );

    var updateListener = this.update.bind( this );
    kineticEnergyProperty.lazyLink( updateListener );
    potentialEnergyProperty.lazyLink( updateListener );
    thermalEnergyProperty.lazyLink( updateListener );
    zoomProperty.lazyLink( updateListener );
    chartHeightProperty.lazyLink( updateListener );
    isEnergyBoxExpandedProperty.lazyLink( updateListener );
    this.update();
  }

  pendulumLab.register( 'EnergyBarChartNode', EnergyBarChartNode );

  return inherit( Node, EnergyBarChartNode, {
    /**
     * Hide the bar graph
     * @public
     */
    hide: function() {
      this.visible = false;
    },

    /**
     * Show the bar graph and update its status
     * @public
     */
    show: function() {
      this.visible = true;
      this.update();
    },

    /**
     * Update the heights of the bar graph
     * @private
     */
    update: function() {
      if ( this.isEnergyBoxExpandedProperty.value && this.visible ) {
        var energyMultiplier = 40 * this.zoomProperty.value;
        var maxHeight = this.chartHeightProperty.value;

        var arrowPadding = 5;
        maxHeight -= arrowPadding + this.kineticEnergyArrow.height;

        var kineticEnergy = this.kineticEnergyProperty.value * energyMultiplier;
        var potentialEnergy = this.potentialEnergyProperty.value * energyMultiplier;
        var thermalEnergy = this.thermalEnergyProperty.value * energyMultiplier;

        // individual bars
        this.kineticEnergyBar.rectHeight = Math.min( maxHeight, kineticEnergy );
        this.potentialEnergyBar.rectHeight = Math.min( maxHeight, potentialEnergy );
        this.thermalEnergyBar.rectHeight = Math.min( maxHeight, thermalEnergy );

        // combined bar, thermal on bottom, then potential, then kinetic
        var thermalHeight = Math.min( maxHeight, thermalEnergy );
        var potentialAndThermalHeight = Math.min( maxHeight, thermalEnergy + potentialEnergy );
        var totalHeight = Math.min( maxHeight, potentialAndThermalHeight + kineticEnergy );
        this.totalThermalEnergyBar.rectHeight = thermalHeight;
        this.totalPotentialEnergyBar.rectY = thermalHeight;
        this.totalPotentialEnergyBar.rectHeight = potentialAndThermalHeight - thermalHeight;
        this.totalKineticEnergyBar.rectY = potentialAndThermalHeight;
        this.totalKineticEnergyBar.rectHeight = totalHeight - potentialAndThermalHeight;
        this.totalHighlightBar.rectHeight = totalHeight;

        if ( kineticEnergy >= maxHeight ) {
          this.kineticEnergyArrow.visible = true;
          this.kineticEnergyArrow.bottom = this.chartHeightProperty.value;
        }
        else {
          this.kineticEnergyArrow.visible = false;
        }

        if ( potentialEnergy >= maxHeight ) {
          this.potentialEnergyArrow.visible = true;
          this.potentialEnergyArrow.bottom = this.chartHeightProperty.value;
        }
        else {
          this.potentialEnergyArrow.visible = false;
        }

        if ( thermalEnergy >= maxHeight ) {
          this.thermalEnergyArrow.visible = true;
          this.thermalEnergyArrow.bottom = this.chartHeightProperty.value;
        }
        else {
          this.thermalEnergyArrow.visible = false;
        }

        if ( kineticEnergy + potentialEnergy + thermalEnergy >= maxHeight ) {
          this.totalEnergyArrow.visible = true;
          this.totalEnergyArrow.bottom = this.chartHeightProperty.value;
        }
        else {
          this.totalEnergyArrow.visible = false;
        }
      }
    }
  } );
} );

// Copyright 2014-2016, University of Colorado Boulder

/**
 * A specialized drawable for a layer of drawables with the same renderer (basically, it's a Canvas element, SVG
 * element, or some type of DOM container). Doesn't strictly have to have its DOM element used directly (Canvas block
 * used for caches).  This type is abstract, and meant to be subclassed.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Block',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  function Block( display, renderer ) {
    throw new Error( 'Should never be called' );
  }

  scenery.register( 'Block', Block );

  inherit( Drawable, Block, {

    /**
     * @param {Display} display
     * @param {number} renderer
     * @returns {Block} - Returns 'this' reference, for chaining
     */
    initializeBlock: function( display, renderer ) {
      this.initializeDrawable( renderer );
      this.display = display;
      this.drawableCount = 0;
      this.used = true; // flag handled in the stitch

      this.firstDrawable = null;
      this.lastDrawable = null;
      this.pendingFirstDrawable = null;
      this.pendingLastDrawable = null;

      // linked-list handling for blocks
      this.previousBlock = null;
      this.nextBlock = null;

      // last set z-index, valid if > 0.
      this.zIndex = 0;

      if ( assertSlow ) {
        this.drawableList = cleanArray( this.drawableList );
      }

      return this;
    },

    dispose: function() {
      assert && assert( this.drawableCount === 0, 'There should be no drawables on a block when it is disposed' );

      // clear references
      this.display = null;
      this.firstDrawable = null;
      this.lastDrawable = null;
      this.pendingFirstDrawable = null;
      this.pendingLastDrawable = null;

      this.previousBlock = null;
      this.nextBlock = null;

      if ( assertSlow ) {
        cleanArray( this.drawableList );
      }

      Drawable.prototype.dispose.call( this );
    },

    addDrawable: function( drawable ) {
      this.drawableCount++;
      this.markDirtyDrawable( drawable );

      if ( assertSlow ) {
        var idx = _.indexOf( this.drawableList, drawable );
        assertSlow && assertSlow( idx === -1, 'Drawable should not be added when it has not been removed' );
        this.drawableList.push( drawable );

        assertSlow && assertSlow( this.drawableCount === this.drawableList.length, 'Count sanity check, to make sure our assertions are not buggy' );
      }
    },

    removeDrawable: function( drawable ) {
      this.drawableCount--;
      this.markDirty();

      if ( assertSlow ) {
        var idx = _.indexOf( this.drawableList, drawable );
        assertSlow && assertSlow( idx !== -1, 'Drawable should be already added when it is removed' );
        this.drawableList.splice( idx, 1 );

        assertSlow && assertSlow( this.drawableCount === this.drawableList.length, 'Count sanity check, to make sure our assertions are not buggy' );
      }
    },

    // @protected
    onIntervalChange: function( firstDrawable, lastDrawable ) {
      // stub, should be filled in with behavior in blocks
    },

    updateInterval: function() {
      if ( this.pendingFirstDrawable !== this.firstDrawable ||
           this.pendingLastDrawable !== this.lastDrawable ) {
        this.onIntervalChange( this.pendingFirstDrawable, this.pendingLastDrawable );

        this.firstDrawable = this.pendingFirstDrawable;
        this.lastDrawable = this.pendingLastDrawable;
      }
    },

    notifyInterval: function( firstDrawable, lastDrawable ) {
      this.pendingFirstDrawable = firstDrawable;
      this.pendingLastDrawable = lastDrawable;

      this.updateInterval();
    },

    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        Drawable.prototype.audit.call( this, allowPendingBlock, allowPendingList, allowDirty );

        var count = 0;

        if ( !allowPendingList ) {

          // audit children, and get a count
          for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
            drawable.audit( allowPendingBlock, allowPendingList, allowDirty );
            count++;
            if ( drawable === this.lastDrawable ) { break; }
          }

          if ( !allowPendingBlock ) {
            assertSlow && assertSlow( count === this.drawableCount, 'drawableCount should match' );

            assertSlow && assertSlow( this.firstDrawable === this.pendingFirstDrawable, 'No pending first drawable' );
            assertSlow && assertSlow( this.lastDrawable === this.pendingLastDrawable, 'No pending last drawable' );

            // scan through to make sure our drawable lists are identical
            for ( var d = this.firstDrawable; d !== null; d = d.nextDrawable ) {
              assertSlow && assertSlow( d.renderer === this.renderer, 'Renderers should match' );
              assertSlow && assertSlow( d.parentDrawable === this, 'This block should be this drawable\'s parent' );
              assertSlow && assertSlow( _.indexOf( this.drawableList, d ) >= 0 );
              if ( d === this.lastDrawable ) { break; }
            }
          }
        }
      }
    }
  } );

  return Block;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * A Block that needs to be fitted to either the screen bounds or other local bounds. This potentially reduces memory
 * usage and can make graphical operations in the browser faster, yet if the fit is rapidly changing could cause
 * performance degradation.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/FittedBlock',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','SCENERY/scenery','SCENERY/display/Block'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var scenery = require( 'SCENERY/scenery' );
  var Block = require( 'SCENERY/display/Block' );

  var scratchBounds2 = Bounds2.NOTHING.copy();

  function FittedBlock( display, renderer, transformRootInstance ) {
    this.initialize( display, renderer, transformRootInstance );
  }

  scenery.register( 'FittedBlock', FittedBlock );

  inherit( Block, FittedBlock, {
    initializeFittedBlock: function( display, renderer, transformRootInstance, preferredFit ) {
      this.initializeBlock( display, renderer );

      this.transformRootInstance = transformRootInstance;

      assert && assert( typeof transformRootInstance.isDisplayRoot === 'boolean' );
      this.canBeFullDisplay = transformRootInstance.isDisplayRoot;

      assert && assert( preferredFit === FittedBlock.FULL_DISPLAY || preferredFit === FittedBlock.COMMON_ANCESTOR );

      // @private {FittedBlock.Fit} - Our preferred fit IF we can be fitted. Our fit can fall back if something's unfittable.
      this.preferredFit = preferredFit;

      // @protected {FittedBlock.Fit} - Our current fitting method.
      this.fit = preferredFit;

      this.dirtyFit = true;
      this.dirtyFitListener = this.dirtyFitListener || this.markDirtyFit.bind( this );
      this.commonFitInstance = null; // filled in if COMMON_ANCESTOR
      this.fitBounds = Bounds2.NOTHING.copy(); // tracks the "tight" bounds for fitting, not the actually-displayed bounds
      this.oldFitBounds = Bounds2.NOTHING.copy(); // copy for storage
      this.fitOffset = new Vector2();

      // {number} - Number of child drawables that are marked as unfittable.
      this.unfittableDrawableCount = 0;

      this.fittableListener = this.onFittabilityChange.bind( this );

      // TODO: improve how we handle graphical acceleration with transforms
      this.forceAcceleration = false;

      // now we always add a listener to the display size to invalidate our fit
      this.display.onStatic( 'displaySize', this.dirtyFitListener );

      // TODO: add count of boundsless objects?
      return this;
    },

    /**
     * Changes the current fit, if it's currently different from the argument.
     * @private
     *
     * @param {FittedBlock.Fit} fit
     */
    setFit: function( fit ) {
      // We can't allow full-display fits sometimes
      if ( !this.canBeFullDisplay && fit === FittedBlock.FULL_DISPLAY ) {
        fit = FittedBlock.COMMON_ANCESTOR;
      }

      if ( this.fit !== fit ) {
        this.fit = fit;

        // updateFit() needs to be called in the repaint phase
        this.markDirtyFit();

        // Reset the oldFitBounds so that any updates that check bounds changes will update it.
        // TODO: remove duplication here with updateFit()
        this.oldFitBounds.set( Bounds2.NOTHING );

        // If we switched to the common-ancestor fit, we need to compute the common-ancestor instance.
        if ( fit === FittedBlock.COMMON_ANCESTOR ) {
          this.removeCommonFitInstance();
        }
      }
    },

    markDirtyFit: function() {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyFit on FittedBlock#' + this.id );
      this.dirtyFit = true;

      // Make sure we are visited in the repaint phase
      this.markDirty();
    },

    /*
     * Should be called from update() whenever this block is dirty
     */
    updateFit: function() {
      assert && assert( this.fit === FittedBlock.FULL_DISPLAY || this.fit === FittedBlock.COMMON_ANCESTOR,
        'Unsupported fit' );

      // check to see if we don't need to re-fit
      if ( !this.dirtyFit && this.fit === FittedBlock.FULL_DISPLAY ) {
        return;
      }

      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( 'updateFit #' + this.id );

      this.dirtyFit = false;

      if ( this.fit === FittedBlock.COMMON_ANCESTOR && this.commonFitInstance === null ) {
        this.addCommonFitInstance( this.computeCommonAncestorInstance() );
      }

      // If our fit WAS common-ancestor and our common fit instance's subtree as something unfittable, switch to
      // full-display fit.
      if ( this.fit === FittedBlock.COMMON_ANCESTOR &&
           this.commonFitInstance.fittability.subtreeUnfittableCount > 0 &&
           this.canBeFullDisplay ) {
        // Reset the oldFitBounds so that any updates that check bounds changes will update it.
        this.oldFitBounds.set( Bounds2.NOTHING );

        this.fit = FittedBlock.FULL_DISPLAY;
      }

      if ( this.fit === FittedBlock.FULL_DISPLAY ) {
        this.setSizeFullDisplay();
      }
      else if ( this.fit === FittedBlock.COMMON_ANCESTOR ) {
        assert && assert( this.commonFitInstance.trail.length >= this.transformRootInstance.trail.length );

        // will trigger bounds validation (for now) until we have a better way of handling this
        this.fitBounds.set( this.commonFitInstance.node.getLocalBounds() );

        // walk it up, transforming so it is relative to our transform root
        var instance = this.commonFitInstance;
        while ( instance !== this.transformRootInstance ) {
          // shouldn't infinite loop, we'll null-pointer beforehand unless something is seriously wrong
          this.fitBounds.transform( instance.node.getMatrix() );
          instance = instance.parent;
        }

        this.fitBounds.roundOut();
        this.fitBounds.dilate( 4 ); // for safety, modify in the future

        // ensure that our fitted bounds don't go outside of our display's bounds (see https://github.com/phetsims/scenery/issues/390)
        if ( this.transformRootInstance.isDisplayRoot ) {
          // Only apply this effect if our transform root is the display root. Otherwise we might be transformed, and
          // this could cause buggy situations. See https://github.com/phetsims/scenery/issues/454
          scratchBounds2.setMinMax( 0, 0, this.display.width, this.display.height );
          this.fitBounds.constrainBounds( scratchBounds2 );
        }

        if ( !this.fitBounds.isValid() ) {
          this.fitBounds.setMinMax( 0, 0, 0, 0 );
        }

        if ( !this.fitBounds.equals( this.oldFitBounds ) ) {
          // store our copy for future checks (and do it before we modify this.fitBounds)
          this.oldFitBounds.set( this.fitBounds );

          this.setSizeFitBounds();
        }
      }
      else {
        throw new Error( 'unknown fit' );
      }
    },

    setSizeFullDisplay: function() {
      // override in subtypes, use this.display.getSize()
    },

    setSizeFitBounds: function() {
      // override in subtypes, use this.fitBounds
    },

    addCommonFitInstance: function( instance ) {
      assert && assert( this.commonFitInstance === null );

      if ( instance ) {
        this.commonFitInstance = instance;
        this.commonFitInstance.fittability.subtreeFittabilityChange.addListener( this.dirtyFitListener );
      }
    },

    removeCommonFitInstance: function() {
      if ( this.commonFitInstance ) {
        this.commonFitInstance.fittability.subtreeFittabilityChange.removeListener( this.dirtyFitListener );
        this.commonFitInstance = null;
      }
    },

    dispose: function() {
      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( 'dispose #' + this.id );

      this.display.offStatic( 'displaySize', this.dirtyFitListener );

      this.removeCommonFitInstance();

      // clear references
      this.transformRootInstance = null;

      Block.prototype.dispose.call( this );
    },

    /**
     * @override
     * Track the fittability of the added drawable.
     *
     * @param {Drawable} drawable
     */
    addDrawable: function( drawable ) {
      Block.prototype.addDrawable.call( this, drawable );

      drawable.onStatic( 'fittability', this.fittableListener );

      if ( !drawable.fittable ) {
        this.incrementUnfittable();
      }
    },

    /**
     * @override
     * Stop tracking the fittability of the removed drawable.
     *
     * @param {Drawable} drawable
     */
    removeDrawable: function( drawable ) {
      Block.prototype.removeDrawable.call( this, drawable );

      drawable.offStatic( 'fittability', this.fittableListener );

      if ( !drawable.fittable ) {
        this.decrementUnfittable();
      }
    },

    /**
     * Called from the fittability listener attached to child drawables when their fittability changes.
     * @private
     *
     * @param {Drawable} drawable
     */
    onFittabilityChange: function( drawable ) {
      assert && assert( drawable.parentDrawable === this );

      if ( drawable.isFittable() ) {
        this.decrementUnfittable();
      }
      else {
        this.incrementUnfittable();
      }
    },

    /**
     * The number of unfittable child drawables was increased by 1.
     * @private
     */
    incrementUnfittable: function() {
      this.unfittableDrawableCount++;

      if ( this.unfittableDrawableCount === 1 ) {
        this.checkFitConstraints();
      }
    },

    /**
     * The number of unfittable child drawables was decreased by 1.
     * @private
     */
    decrementUnfittable: function() {
      this.unfittableDrawableCount--;

      if ( this.unfittableDrawableCount === 0 ) {
        this.checkFitConstraints();
      }
    },

    /**
     * Check to make sure we are using the correct current fit.
     * @private
     */
    checkFitConstraints: function() {
      // If we have ANY unfittable drawables, take up the full display.
      if ( this.unfittableDrawableCount > 0 && this.canBeFullDisplay ) {
        this.setFit( FittedBlock.FULL_DISPLAY );
      }
      // Otherwise fall back to our "default"
      else {
        this.setFit( this.preferredFit );
      }
    },

    computeCommonAncestorInstance: function() {
      assert && assert( this.firstDrawable.instance && this.lastDrawable.instance,
        'For common-ancestor fits, we need the first and last drawables to have direct instance references' );

      var firstInstance = this.firstDrawable.instance;
      var lastInstance = this.lastDrawable.instance;

      // walk down the longest one until they are a common length
      var minLength = Math.min( firstInstance.trail.length, lastInstance.trail.length );
      while ( firstInstance.trail.length > minLength ) {
        firstInstance = firstInstance.parent;
      }
      while ( lastInstance.trail.length > minLength ) {
        lastInstance = lastInstance.parent;
      }

      // step down until they match
      while ( firstInstance !== lastInstance ) {
        firstInstance = firstInstance.parent;
        lastInstance = lastInstance.parent;
      }

      var commonFitInstance = firstInstance;

      assert && assert( commonFitInstance.trail.length >= this.transformRootInstance.trail.length );

      return commonFitInstance;
    },

    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );

      Block.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );

      // if we use a common ancestor fit, find the common ancestor instance
      if ( this.fit === FittedBlock.COMMON_ANCESTOR ) {
        this.removeCommonFitInstance();
        this.markDirtyFit();
      }
    }
  } );

  // Defines the FittedBlock.Fit enumeration type.
  FittedBlock.FULL_DISPLAY = 1;
  FittedBlock.COMMON_ANCESTOR = 2;

  FittedBlock.fitString = {
    1: 'fullDisplay',
    2: 'commonAncestor'
  };

  return FittedBlock;
} );

// Copyright 2013-2016, University of Colorado Boulder


/**
 * Handles a visual Canvas layer of drawables.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/CanvasBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','DOT/Vector2','DOT/Matrix3','SCENERY/scenery','SCENERY/display/FittedBlock','SCENERY/util/CanvasContextWrapper','SCENERY/display/Renderer','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var scenery = require( 'SCENERY/scenery' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var CanvasContextWrapper = require( 'SCENERY/util/CanvasContextWrapper' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Util = require( 'SCENERY/util/Util' );

  var scratchMatrix = new Matrix3();
  var scratchMatrix2 = new Matrix3();

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param display
   * @param renderer
   * @param transformRootInstance
   * @param filterRootInstance
   */
  function CanvasBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }

  scenery.register( 'CanvasBlock', CanvasBlock );

  inherit( FittedBlock, CanvasBlock, {
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.COMMON_ANCESTOR );

      this.filterRootInstance = filterRootInstance;

      this.dirtyDrawables = cleanArray( this.dirtyDrawables );

      if ( !this.domElement ) {
        //OHTWO TODO: support tiled Canvas handling (will need to wrap then in a div, or something)
        this.canvas = document.createElement( 'canvas' );
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = '0';
        this.canvas.style.top = '0';
        this.canvas.style.pointerEvents = 'none';

        // unique ID so that we can support rasterization with Display.foreignObjectRasterization
        this.canvasId = this.canvas.id = 'scenery-canvas' + this.id;

        this.context = this.canvas.getContext( '2d' );
        this.context.save(); // We always immediately save every Canvas so we can restore/save for clipping

        // workaround for Chrome (WebKit) miterLimit bug: https://bugs.webkit.org/show_bug.cgi?id=108763
        this.context.miterLimit = 20;
        this.context.miterLimit = 10;

        // Tracks intermediate Canvas context state, so we don't have to send unnecessary Canvas commands
        this.wrapper = new CanvasContextWrapper( this.canvas, this.context );

        this.domElement = this.canvas;

        // {Array.<CanvasContextWrapper>} as multiple Canvases are needed to properly render opacity within the block.
        this.wrapperStack = [ this.wrapper ];
      }
      // {number} - The index into the wrapperStack array where our current Canvas (that we are drawing to) is.
      this.wrapperStackIndex = 0;

      // Maps node ID => count of how many listeners we WOULD have attached to it. We only attach at most one listener
      // to each node. We need to listen to all ancestors up to our filter root, so that we can pick up opacity changes.
      this.opacityListenerCountMap = this.opacityListenerCountMap || {};

      // reset any fit transforms that were applied
      Util.prepareForTransform( this.canvas, this.forceAcceleration ); // Apply CSS needed for future CSS transforms to work properly.
      Util.unsetTransform( this.canvas ); // clear out any transforms that could have been previously applied

      this.canvasDrawOffset = new Vector2();

      this.currentDrawable = null;
      this.clipDirty = true; // Whether we need to re-apply clipping to our current Canvas
      this.clipCount = 0; // How many clips should be applied

      // store our backing scale so we don't have to look it up while fitting
      this.backingScale = ( renderer & Renderer.bitmaskCanvasLowResolution ) ? 1 : scenery.Util.backingScale( this.context );

      this.clipDirtyListener = this.markDirty.bind( this );
      this.opacityDirtyListener = this.markDirty.bind( this );
      this.filterRootNode = this.filterRootInstance.node;
      this.filterRootNode.onStatic( 'clip', this.clipDirtyListener );

      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'initialized #' + this.id );
      // TODO: dirty list of nodes (each should go dirty only once, easier than scanning all?)

      return this;
    },

    setSizeFullDisplay: function() {
      var size = this.display.getSize();
      this.canvas.width = size.width * this.backingScale;
      this.canvas.height = size.height * this.backingScale;
      this.canvas.style.width = size.width + 'px';
      this.canvas.style.height = size.height + 'px';
      this.wrapper.resetStyles();
      this.canvasDrawOffset.setXY( 0, 0 );
      Util.unsetTransform( this.canvas );
    },

    setSizeFitBounds: function() {
      var x = this.fitBounds.minX;
      var y = this.fitBounds.minY;
      this.canvasDrawOffset.setXY( -x, -y ); // subtract off so we have a tight fit
      //OHTWO TODO PERFORMANCE: see if we can get a speedup by putting the backing scale in our transform instead of with CSS?
      Util.setTransform( 'matrix(1,0,0,1,' + x + ',' + y + ')', this.canvas, this.forceAcceleration ); // reapply the translation as a CSS transform
      this.canvas.width = this.fitBounds.width * this.backingScale;
      this.canvas.height = this.fitBounds.height * this.backingScale;
      this.canvas.style.width = this.fitBounds.width + 'px';
      this.canvas.style.height = this.fitBounds.height + 'px';
      this.wrapper.resetStyles();
    },

    update: function() {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'update #' + this.id );
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.push();

      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }

        // udpate the fit BEFORE drawing, since it may change our offset
        this.updateFit();

        // for now, clear everything!
        this.context.restore(); // just in case we were clipping/etc.
        this.context.setTransform( 1, 0, 0, 1, 0, 0 ); // identity
        this.context.clearRect( 0, 0, this.canvas.width, this.canvas.height ); // clear everything
        this.context.save();
        this.wrapper.resetStyles();

        //OHTWO TODO: PERFORMANCE: create an array for faster drawable iteration (this is probably a hellish memory access pattern)
        //OHTWO TODO: why is "drawable !== null" check needed
        this.currentDrawable = null; // we haven't rendered a drawable this frame yet
        for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
          this.renderDrawable( drawable );
          if ( drawable === this.lastDrawable ) { break; }
        }
        if ( this.currentDrawable ) {
          this.walkDown( this.currentDrawable.instance.trail, 0 );
        }
      }

      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.pop();
    },

    /**
     * Reapplies clips to the current context. It's necessary to fully apply every clipping area for every ancestor,
     * due to how Canvas is set up. Should ideally be called when the clip is dirty.
     *
     * @param {CanvasSelfDrawable} Drawable
     */
    applyClip: function( drawable ) {
      this.clipDirty = false;
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Apply clip ' + drawable.instance.trail.toString() + ' ' + drawable.instance.trail.subtrailTo( node ).toPathString() );

      var wrapper = this.wrapperStack[ this.wrapperStackIndex ];
      var context = wrapper.context;

      // Re-set (even if no clip is needed, so we get rid of the old clip)
      context.restore();
      context.save();
      wrapper.resetStyles();

      // If 0, no clip is needed
      if ( this.clipCount ) {
        var instance = drawable.instance;
        var trail = instance.trail;

        // Inverse of what we'll be applying to the scene, to get back to the root coordinate transform
        scratchMatrix.rowMajor( this.backingScale, 0, this.canvasDrawOffset.x * this.backingScale,
                                0, this.backingScale, this.canvasDrawOffset.y * this.backingScale,
                                0, 0, 1 );
        scratchMatrix2.set( this.transformRootInstance.trail.getMatrix() ).invert();
        scratchMatrix2.multiplyMatrix( scratchMatrix ).canvasSetTransform( context );

        // Recursively apply clips and transforms
        for ( var i = 0; i < trail.length; i++ ) {
          var node = trail.nodes[ i ];
          node.getMatrix().canvasAppendTransform( context );
          if ( node.hasClipArea() ) {
            context.beginPath();
            node.clipArea.writeToContext( context );
            // TODO: add the ability to show clipping highlights inline?
                // context.save();
                // context.strokeStyle = 'red';
                // context.lineWidth = 2;
                // context.stroke();
                // context.restore();
            context.clip();
          }
        }
      }
    },

    /**
     * Walk down towards the root, popping any clip/opacity effects that were needed.
     *
     * @param {Trail} trail
     * @param {number} branchIndex - The first index where our before and after trails have diverged.
     */
    walkDown: function( trail, branchIndex ) {
      var filterRootIndex = this.filterRootInstance.trail.length - 1;

      for ( var i = trail.length - 1; i >= branchIndex; i-- ) {
        var node = trail.nodes[ i ];

        if ( node.hasClipArea() ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Pop clip ' + trail.subtrailTo( node ).toString() + ' ' + trail.subtrailTo( node ).toPathString() );
          // Pop clip
          this.clipCount--;
          this.clipDirty = true;
        }
        // We should not apply opacity at or below the filter root
        if ( i > filterRootIndex && node.getOpacity() !== 1 ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Pop opacity ' + trail.subtrailTo( node ).toString() + ' ' + trail.subtrailTo( node ).toPathString() );
          // Pop opacity
          var topWrapper = this.wrapperStack[ this.wrapperStackIndex ];
          var bottomWrapper = this.wrapperStack[ this.wrapperStackIndex - 1 ];
          this.wrapperStackIndex--;

          // Draw the transparent content into the next-level Canvas.
          bottomWrapper.context.setTransform( 1, 0, 0, 1, 0, 0 );
          bottomWrapper.context.globalAlpha = node.getOpacity();
          bottomWrapper.context.drawImage( topWrapper.canvas, 0, 0 );
          bottomWrapper.context.globalAlpha = 1;
        }
      }
    },

    /**
     * Walk up towards the next leaf, pushing any clip/opacity effects that are needed.
     *
     * @param {Trail} trail
     * @param {number} branchIndex - The first index where our before and after trails have diverged.
     */
    walkUp: function( trail, branchIndex ) {
      var filterRootIndex = this.filterRootInstance.trail.length - 1;

      for ( var i = branchIndex; i < trail.length; i++ ) {
        var node = trail.nodes[ i ];

        // We should not apply opacity at or below the filter root
        if ( i > filterRootIndex && node.getOpacity() !== 1 ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Push opacity ' + trail.subtrailTo( node ).toString() + ' ' + trail.subtrailTo( node ).toPathString() );
          // Push opacity
          this.wrapperStackIndex++;
          // If we need to push an entirely new Canvas to the stack
          if ( this.wrapperStackIndex === this.wrapperStack.length ) {
            var newCanvas = document.createElement( 'canvas' );
            var newContext = newCanvas.getContext( '2d' );
            newContext.save();
            this.wrapperStack.push( new CanvasContextWrapper( newCanvas, newContext ) );
          }
          var wrapper = this.wrapperStack[ this.wrapperStackIndex ];
          var context = wrapper.context;

          // Size and clear our context
          wrapper.setDimensions( this.canvas.width, this.canvas.height );
          context.setTransform( 1, 0, 0, 1, 0, 0 ); // identity
          context.clearRect( 0, 0, this.canvas.width, this.canvas.height ); // clear everything

        }

        if ( node.hasClipArea() ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Push clip ' + trail.subtrailTo( node ).toString() + ' ' + trail.subtrailTo( node ).toPathString() );
          // Push clip
          this.clipCount++;
          this.clipDirty = true;
        }
      }
    },

    renderDrawable: function( drawable ) {
      // do not paint invisible drawables
      if ( !drawable.visible ) {
        return;
      }

      // For opacity/clip, walk up/down as necessary (Can only walk down if we are not the first drawable)
      var branchIndex = this.currentDrawable ? drawable.instance.getBranchIndexTo( this.currentDrawable.instance ) : 0;
      if ( this.currentDrawable ) {
        this.walkDown( this.currentDrawable.instance.trail, branchIndex );
      }
      this.walkUp( drawable.instance.trail, branchIndex );

      var wrapper = this.wrapperStack[ this.wrapperStackIndex ];
      var context = wrapper.context;

      // Re-apply the clip if necessary
      if ( this.clipDirty ) {
        this.applyClip( drawable );
      }

      // we're directly accessing the relative transform below, so we need to ensure that it is up-to-date
      assert && assert( drawable.instance.relativeTransform.isValidationNotNeeded() );

      var matrix = drawable.instance.relativeTransform.matrix;

      // set the correct (relative to the transform root) transform up, instead of walking the hierarchy (for now)
      //OHTWO TODO: should we start premultiplying these matrices to remove this bottleneck?
      context.setTransform( this.backingScale, 0, 0, this.backingScale, this.canvasDrawOffset.x * this.backingScale, this.canvasDrawOffset.y * this.backingScale );
      if ( drawable.instance !== this.transformRootInstance ) {
        matrix.canvasAppendTransform( context );
      }

      // paint using its local coordinate frame
      drawable.paintCanvas( wrapper, drawable.instance.node, drawable.instance.relativeTransform.matrix );

      this.currentDrawable = drawable;
    },

    dispose: function() {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'dispose #' + this.id );

      this.filterRootNode.offStatic( 'clip', this.clipDirtyListener );
      this.filterRootNode = null;

      // clear references
      this.transformRootInstance = null;
      cleanArray( this.dirtyDrawables );

      // minimize memory exposure of the backing raster
      this.canvas.width = 0;
      this.canvas.height = 0;

      FittedBlock.prototype.dispose.call( this );
    },

    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on CanvasBlock#' + this.id + ' with ' + drawable.toString() );

      assert && assert( drawable );

      if ( assert ) {
        // Catch infinite loops
        this.display.ensureNotPainting();
      }

      // TODO: instance check to see if it is a canvas cache (usually we don't need to call update on our drawables)
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },

    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );

      FittedBlock.prototype.addDrawable.call( this, drawable );

      // Add opacity listeners (from this node up to the filter root)
      for ( var instance = drawable.instance; instance && instance !== this.filterRootInstance; instance = instance.parent ) {
        var node = instance.node;

        // Only add the listener if we don't already have one
        if ( this.opacityListenerCountMap[ node.id ] ) {
          this.opacityListenerCountMap[ node.id ]++;
        }
        else {
          this.opacityListenerCountMap[ node.id ] = 1;

          node.onStatic( 'opacity', this.opacityDirtyListener );
        }
      }
    },

    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );

      // Remove opacity listeners (from this node up to the filter root)
      for ( var instance = drawable.instance; instance && instance !== this.filterRootInstance; instance = instance.parent ) {
        var node = instance.node;
        assert && assert( this.opacityListenerCountMap[ node.id ] > 0 );
        this.opacityListenerCountMap[ node.id ]--;
        if ( this.opacityListenerCountMap[ node.id ] === 0 ) {
          delete this.opacityListenerCountMap[ node.id ];
          node.offStatic( 'opacity', this.opacityDirtyListener );
        }
      }

      FittedBlock.prototype.removeDrawable.call( this, drawable );
    },

    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );

      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );

      // If we have an interval change, we'll need to ensure we repaint (even if we're full-display). This was a missed
      // case for https://github.com/phetsims/scenery/issues/512, where it would only clear if it was a common-ancestor
      // fitted block.
      this.markDirty();
    },

    onPotentiallyMovedDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.onPotentiallyMovedDrawable ' + drawable.toString() );
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.push();

      assert && assert( drawable.parentDrawable === this );

      // For now, mark it as dirty so that we redraw anything containing it. In the future, we could have more advanced
      // behavior that figures out the intersection-region for what was moved and what it was moved past, but that's
      // a harder problem.
      drawable.markDirty();

      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.pop();
    },

    toString: function() {
      return 'CanvasBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );

  Poolable.mixin( CanvasBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'new from constructor' );
          return new CanvasBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );

  return CanvasBlock;
} );

// Copyright 2014-2016, University of Colorado Boulder

/**
 * PoolableMixin wrapper for SVG <group> elements. We store state and add listeners directly to the corresponding Node, so that we can set dirty flags and
 * smartly update only things that have changed. This takes a load off of SVGBlock.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGGroup',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','PHET_CORE/platform','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param block
   * @param instance
   * @param parent
   */
  function SVGGroup( block, instance, parent ) {
    this.initialize( block, instance, parent );
  }

  scenery.register( 'SVGGroup', SVGGroup );

  inherit( Object, SVGGroup, {
    initialize: function( block, instance, parent ) {
      //OHTWO TODO: add collapsing groups! they can't have self drawables, transforms, filters, etc., and we probably shouldn't de-collapse groups

      this.block = block;
      this.instance = instance;
      this.node = instance.trail.lastNode();
      this.parent = parent;
      this.children = cleanArray( this.children );
      this.hasSelfDrawable = false;
      this.selfDrawable = null; // reference to a self drawable

      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'initializing ' + this.toString() );

      // general dirty flag (triggered on any other dirty event)
      this.dirty = true;

      // we won't listen for transform changes (or even want to set a transform) if our node is beneath a transform root
      this.willApplyTransforms = this.block.transformRootInstance.trail.nodes.length < this.instance.trail.nodes.length;

      // we won't listen for filter changes (or set filters, like opacity or visibility) if our node is beneath a filter root
      this.willApplyFilters = this.block.filterRootInstance.trail.nodes.length < this.instance.trail.nodes.length;

      // transform handling
      this.transformDirty = true;
      this.hasTransform = this.hasTransform !== undefined ? this.hasTransform : false; // persists across disposal
      this.transformDirtyListener = this.transformDirtyListener || this.markTransformDirty.bind( this );
      if ( this.willApplyTransforms ) {
        this.node.onStatic( 'transform', this.transformDirtyListener );
      }

      // filter handling
      this.opacityDirty = true;
      this.visibilityDirty = true;
      this.clipDirty = true;
      this.hasOpacity = this.hasOpacity !== undefined ? this.hasOpacity : false; // persists across disposal
      this.clipDefinition = this.clipDefinition !== undefined ? this.clipDefinition : null; // persists across disposal
      this.clipPath = this.clipPath !== undefined ? this.clipPath : null; // persists across disposal
      this.opacityDirtyListener = this.opacityDirtyListener || this.markOpacityDirty.bind( this );
      this.visibilityDirtyListener = this.visibilityDirtyListener || this.markVisibilityDirty.bind( this );
      this.clipDirtyListener = this.clipDirtyListener || this.markClipDirty.bind( this );
      this.node.onStatic( 'visibility', this.visibilityDirtyListener );
      if ( this.willApplyFilters ) {
        this.node.onStatic( 'opacity', this.opacityDirtyListener );
      }
      //OHTWO TODO: remove clip workaround
      this.node.onStatic( 'clip', this.clipDirtyListener );

      // for tracking the order of child groups, we use a flag and update (reorder) once per updateDisplay if necessary.
      this.orderDirty = true;
      this.orderDirtyListener = this.orderDirtyListener || this.markOrderDirty.bind( this );
      this.node.onStatic( 'childInserted', this.orderDirtyListener );
      this.node.onStatic( 'childRemoved', this.orderDirtyListener );

      if ( !this.svgGroup ) {
        this.svgGroup = document.createElementNS( scenery.svgns, 'g' );
      }

      this.instance.addSVGGroup( this );

      this.block.markDirtyGroup( this ); // so we are marked and updated properly

      return this;
    },

    addSelfDrawable: function( drawable ) {
      this.selfDrawable = drawable;
      this.svgGroup.insertBefore( drawable.svgElement, this.children.length ? this.children[ 0 ].svgGroup : null );
      this.hasSelfDrawable = true;
    },

    removeSelfDrawable: function( drawable ) {
      this.hasSelfDrawable = false;
      this.svgGroup.removeChild( drawable.svgElement );
      this.selfDrawable = null;
    },

    addChildGroup: function( group ) {
      this.markOrderDirty();

      group.parent = this;
      this.children.push( group );
      this.svgGroup.appendChild( group.svgGroup );
    },

    removeChildGroup: function( group ) {
      this.markOrderDirty();

      group.parent = null;
      this.children.splice( _.indexOf( this.children, group ), 1 );
      this.svgGroup.removeChild( group.svgGroup );
    },

    markDirty: function() {
      if ( !this.dirty ) {
        this.dirty = true;

        this.block.markDirtyGroup( this );
      }
    },

    /*---------------------------------------------------------------------------*
     * TODO: reduce filesize by creating these methods programatically. not done yet since I want to ensure correctness and make refactoring easier right now.
     *----------------------------------------------------------------------------*/

    markOrderDirty: function() {
      if ( !this.orderDirty ) {
        this.orderDirty = true;
        this.markDirty();
      }
    },

    markTransformDirty: function() {
      if ( !this.transformDirty ) {
        this.transformDirty = true;
        this.markDirty();
      }
    },

    markOpacityDirty: function() {
      if ( !this.opacityDirty ) {
        this.opacityDirty = true;
        this.markDirty();
      }
    },

    markVisibilityDirty: function() {
      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },

    markClipDirty: function() {
      if ( !this.clipDirty ) {
        this.clipDirty = true;
        this.markDirty();
      }
    },

    update: function() {
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'update: ' + this.toString() );

      // we may have been disposed since being marked dirty on our block. we won't have a reference if we are disposed
      if ( !this.block ) {
        return;
      }

      sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();

      var svgGroup = this.svgGroup;

      this.dirty = false;

      if ( this.transformDirty ) {
        this.transformDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'transform update: ' + this.toString() );

        if ( this.willApplyTransforms ) {

          var isIdentity = this.node.transform.isIdentity();

          if ( !isIdentity ) {
            this.hasTransform = true;
            svgGroup.setAttribute( 'transform', this.node.transform.getMatrix().getSVGTransform() );
          }
          else if ( this.hasTransform ) {
            this.hasTransform = false;
            // IE guard needed since removeAttribute fails, see https://github.com/phetsims/scenery/issues/395
            ( platform.ie9 || platform.ie10 ) ? svgGroup.setAttribute( 'transform', '' ) : svgGroup.removeAttribute( 'transform' );
          }
        }
        else {
          // we want no transforms if we won't be applying transforms
          if ( this.hasTransform ) {
            this.hasTransform = false;
            // IE guard needed since removeAttribute fails, see https://github.com/phetsims/scenery/issues/395
            ( platform.ie9 || platform.ie10 ) ? svgGroup.setAttribute( 'transform', '' ) : svgGroup.removeAttribute( 'transform' );
          }
        }
      }

      if ( this.visibilityDirty ) {
        this.visibilityDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'visibility update: ' + this.toString() );

        svgGroup.style.display = this.node.isVisible() ? '' : 'none';
      }


      if ( this.opacityDirty ) {
        this.opacityDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'opacity update: ' + this.toString() );

        if ( this.willApplyFilters && this.node.opacity !== 1 ) {
          this.hasOpacity = true;
          svgGroup.setAttribute( 'opacity', this.node.opacity );
        }
        else if ( this.hasOpacity ) {
          this.hasOpacity = false;
          svgGroup.removeAttribute( 'opacity' );
        }
      }

      if ( this.clipDirty ) {
        this.clipDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'clip update: ' + this.toString() );

        //OHTWO TODO: remove clip workaround (use this.willApplyFilters)
        if ( this.node.clipArea ) {
          if ( !this.clipDefinition ) {
            var clipId = 'clip' + this.node.getId();

            this.clipDefinition = document.createElementNS( scenery.svgns, 'clipPath' );
            this.clipDefinition.setAttribute( 'id', clipId );
            this.clipDefinition.setAttribute( 'clipPathUnits', 'userSpaceOnUse' );
            this.block.defs.appendChild( this.clipDefinition ); // TODO: method? evaluate with future usage of defs (not done yet)

            this.clipPath = document.createElementNS( scenery.svgns, 'path' );
            this.clipDefinition.appendChild( this.clipPath );

            svgGroup.setAttribute( 'clip-path', 'url(#' + clipId + ')' );
          }

          this.clipPath.setAttribute( 'd', this.node.clipArea.getSVGPath() );
        }
        else if ( this.clipDefinition ) {
          svgGroup.removeAttribute( 'clip-path' );
          this.block.defs.removeChild( this.clipDefinition ); // TODO: method? evaluate with future usage of defs (not done yet)

          // TODO: consider pooling these?
          this.clipDefinition = null;
          this.clipPath = null;
        }
      }

      if ( this.orderDirty ) {
        this.orderDirty = false;

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'order update: ' + this.toString() );
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();

        // our instance should have the proper order of children. we check that way.
        var idx = this.children.length - 1;
        var instanceChildren = this.instance.children;
        // iterate backwards, since DOM's insertBefore makes forward iteration more complicated (no insertAfter)
        for ( var i = instanceChildren.length - 1; i >= 0; i-- ) {
          var group = instanceChildren[ i ].lookupSVGGroup( this.block );
          if ( group ) {
            // ensure that the spot in our array (and in the DOM) at [idx] is correct
            if ( this.children[ idx ] !== group ) {
              // out of order, rearrange
              sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'group out of order: ' + idx + ' for ' + group.toString() );

              // in the DOM first (since we reference the children array to know what to insertBefore)
              // see http://stackoverflow.com/questions/9732624/how-to-swap-dom-child-nodes-in-javascript
              svgGroup.insertBefore( group.svgGroup, idx + 1 >= this.children.length ? null : this.children[ idx + 1 ].svgGroup );

              // then in our children array
              var oldIndex = _.indexOf( this.children, group );
              assert && assert( oldIndex < idx, 'The item we are moving backwards to location [idx] should not have an index greater than that' );
              this.children.splice( oldIndex, 1 );
              this.children.splice( idx, 0, group );
            }
            else {
              sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'group in place: ' + idx + ' for ' + group.toString() );
            }

            // if there was a group for that instance, we move on to the next spot
            idx--;
          }
        }

        sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
      }

      sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
    },

    isReleasable: function() {
      // if we have no parent, we are the rootGroup (the block is responsible for disposing that one)
      return !this.hasSelfDrawable && !this.children.length && this.parent;
    },

    dispose: function() {
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();

      assert && assert( this.children.length === 0, 'Should be empty by now' );

      if ( this.willApplyTransforms ) {
        this.node.offStatic( 'transform', this.transformDirtyListener );
      }
      this.node.offStatic( 'visibility', this.visibilityDirtyListener );
      if ( this.willApplyFilters ) {
        this.node.offStatic( 'opacity', this.opacityDirtyListener );
      }
      //OHTWO TODO: remove clip workaround
      this.node.offStatic( 'clip', this.clipDirtyListener );

      this.node.offStatic( 'childInserted', this.orderDirtyListener );
      this.node.offStatic( 'childRemoved', this.orderDirtyListener );

      // if our Instance has been disposed, it has already had the reference removed
      if ( this.instance.active ) {
        this.instance.removeSVGGroup( this );
      }

      // remove clipping, since it is defs-based (and we want to keep our defs block clean - could be another layer!)
      if ( this.clipDefinition ) {
        this.svgGroup.removeAttribute( 'clip-path' );
        this.block.defs.removeChild( this.clipDefinition );
        this.clipDefinition = null;
        this.clipPath = null;
      }

      // clear references
      this.parent = null;
      this.block = null;
      this.instance = null;
      this.node = null;
      cleanArray( this.children );
      this.selfDrawable = null;

      // for now
      this.freeToPool();

      sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
    },

    toString: function() {
      return 'SVGGroup:' + this.block.toString() + '_' + this.instance.toString();
    }
  } );

  // @public
  SVGGroup.addDrawable = function( block, drawable ) {
    assert && assert( drawable.instance, 'Instance is required for a drawable to be grouped correctly in SVG' );

    var group = SVGGroup.ensureGroupsToInstance( block, drawable.instance );
    group.addSelfDrawable( drawable );
  };

  // @public
  SVGGroup.removeDrawable = function( block, drawable ) {
    drawable.instance.lookupSVGGroup( block ).removeSelfDrawable( drawable );

    SVGGroup.releaseGroupsToInstance( block, drawable.instance );
  };

  // @private
  SVGGroup.ensureGroupsToInstance = function( block, instance ) {
    // TODO: assertions here

    var group = instance.lookupSVGGroup( block );

    if ( !group ) {
      assert && assert( instance !== block.rootGroup.instance, 'Making sure we do not walk past our rootGroup' );

      var parentGroup = SVGGroup.ensureGroupsToInstance( block, instance.parent );

      group = SVGGroup.createFromPool( block, instance, parentGroup );
      parentGroup.addChildGroup( group );
    }

    return group;
  };

  // @private
  SVGGroup.releaseGroupsToInstance = function( block, instance ) {
    var group = instance.lookupSVGGroup( block );

    if ( group.isReleasable() ) {
      var parentGroup = group.parent;
      parentGroup.removeChildGroup( group );

      SVGGroup.releaseGroupsToInstance( block, parentGroup.instance );

      group.dispose();
    }
  };

  Poolable.mixin( SVGGroup, {
    constructorDuplicateFactory: function( pool ) {
      return function( block, instance, parent ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'new from pool' );
          return pool.pop().initialize( block, instance, parent );
        }
        else {
          sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'new from constructor' );
          return new SVGGroup( block, instance, parent );
        }
      };
    }
  } );

  return SVGGroup;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Handles a visual SVG layer of drawables.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/FittedBlock','SCENERY/display/SVGGroup','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var SVGGroup = require( 'SCENERY/display/SVGGroup' );
  var Util = require( 'SCENERY/util/Util' );

  /**
   * @constructor
   * @extends FittedBlock
   * @mixes Poolable
   *
   * @param {Display} display - the scenery Display this SVGBlock will appear in
   * @param {number} renderer - the bitmask for the renderer, see Renderer.js
   * @param {Instance} transformRootInstance - TODO: Documentation
   * @param {Instance} filterRootInstance - TODO: Documentation
   * @constructor
   */
  function SVGBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }

  scenery.register( 'SVGBlock', SVGBlock );

  inherit( FittedBlock, SVGBlock, {

    /**
     * Initialize function, which is required since SVGBlock instances are pooled by scenery.
     *
     * @param {Display} display - the scenery Display this SVGBlock will appear in
     * @param {number} renderer - the bitmask for the renderer, see Renderer.js
     * @param {Instance} transformRootInstance - TODO: Documentation
     * @param {Instance} filterRootInstance - TODO: Documentation
     * @returns {FittedBlock}
     */
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.COMMON_ANCESTOR );

      this.filterRootInstance = filterRootInstance;

      this.dirtyGradients = cleanArray( this.dirtyGradients );
      this.dirtyGroups = cleanArray( this.dirtyGroups );
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );

      // Keep track of how many times each Paint is used in this SVGBlock so that when all usages have been eliminated
      // we can remove the SVG def from our SVG tree to prevent memory leaks, etc.
      // maps {string} paint.id => { count: {number}, paint: {Paint}, def: {SVGElement} }
      // @private
      this.paintMap = {};

      if ( !this.domElement ) {

        // main SVG element
        this.svg = document.createElementNS( scenery.svgns, 'svg' );
        this.svg.style.position = 'absolute';
        this.svg.style.left = '0';
        this.svg.style.top = '0';

        // a11y - make sure the element is not focusable (it is focusable by default in IE11 full screen mode)
        this.svg.setAttribute( 'focusable', false );

        //OHTWO TODO: why would we clip the individual layers also? Seems like a potentially useless performance loss
        // this.svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
        this.svg.style[ 'pointer-events' ] = 'none';

        // the <defs> block that we will be stuffing gradients and patterns into
        this.defs = document.createElementNS( scenery.svgns, 'defs' );
        this.svg.appendChild( this.defs );

        this.baseTransformGroup = document.createElementNS( scenery.svgns, 'g' );
        this.svg.appendChild( this.baseTransformGroup );

        this.domElement = this.svg;
      }

      // reset what layer fitting can do (this.forceAcceleration set in fitted block initialization)
      Util.prepareForTransform( this.svg, this.forceAcceleration ); // Apply CSS needed for future CSS transforms to work properly.

      Util.unsetTransform( this.svg ); // clear out any transforms that could have been previously applied
      this.baseTransformGroup.setAttribute( 'transform', '' ); // no base transform

      var instanceClosestToRoot = transformRootInstance.trail.nodes.length > filterRootInstance.trail.nodes.length ?
                                  filterRootInstance : transformRootInstance;

      this.rootGroup = SVGGroup.createFromPool( this, instanceClosestToRoot, null );
      this.baseTransformGroup.appendChild( this.rootGroup.svgGroup );

      // TODO: dirty list of nodes (each should go dirty only once, easier than scanning all?)

      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'initialized #' + this.id );

      return this;
    },

    /*
     * Increases our reference count for the specified {Paint}. If it didn't exist before, we'll add the SVG def to the
     * paint can be referenced by SVG id.
     *
     * @param {Paint} paint
     */
    incrementPaint: function( paint ) {
      assert && assert( paint.isPaint );

      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'incrementPaint ' + this.toString() + ' ' + paint.id );

      if ( this.paintMap.hasOwnProperty( paint.id ) ) {
        this.paintMap[ paint.id ].count++;
      }
      else {
        var svgPaint = paint.createSVGPaint( this );
        svgPaint.definition.setAttribute( 'id', paint.id + '-' + this.id );

        // TODO: reduce allocations? (pool these)
        this.paintMap[ paint.id ] = {
          count: 1,
          paint: paint,
          svgPaint: svgPaint
        };

        this.defs.appendChild( svgPaint.definition );
      }
    },

    /*
     * Decreases our reference count for the specified {Paint}. If this was the last reference, we'll remove the SVG def
     * from our SVG tree to prevent memory leaks, etc.
     *
     * @param {Paint} paint
     */
    decrementPaint: function( paint ) {
      assert && assert( paint.isPaint );

      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'decrementPaint ' + this.toString() + ' ' + paint.id );

      // since the block may have been disposed (yikes!), we have a defensive set-up here
      if ( this.paintMap.hasOwnProperty( paint.id ) ) {
        var entry = this.paintMap[ paint.id ];
        assert && assert( entry.count >= 1 );

        if ( entry.count === 1 ) {
          this.defs.removeChild( entry.svgPaint.definition );
          entry.svgPaint.dispose();
          delete this.paintMap[ paint.id ]; // delete, so we don't memory leak if we run through MANY paints
        }
        else {
          entry.count--;
        }
      }
    },

    markDirtyGradient: function( gradient ) {
      this.dirtyGradients.push( gradient );
      this.markDirty();
    },

    markDirtyGroup: function( block ) {
      this.dirtyGroups.push( block );
      this.markDirty();
    },

    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on SVGBlock#' + this.id + ' with ' + drawable.toString() );
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },

    setSizeFullDisplay: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'setSizeFullDisplay #' + this.id );

      var size = this.display.getSize();
      this.svg.setAttribute( 'width', size.width );
      this.svg.setAttribute( 'height', size.height );
    },

    setSizeFitBounds: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'setSizeFitBounds #' + this.id + ' with ' + this.fitBounds.toString() );

      var x = this.fitBounds.minX;
      var y = this.fitBounds.minY;

      assert && assert( isFinite( x ) && isFinite( y ), 'Invalid SVG transform for SVGBlock' );
      assert && assert( this.fitBounds.isValid(), 'Invalid fitBounds' );

      this.baseTransformGroup.setAttribute( 'transform', 'translate(' + (-x) + ',' + (-y) + ')' ); // subtract off so we have a tight fit
      Util.setTransform( 'matrix(1,0,0,1,' + x + ',' + y + ')', this.svg, this.forceAcceleration ); // reapply the translation as a CSS transform
      this.svg.setAttribute( 'width', this.fitBounds.width );
      this.svg.setAttribute( 'height', this.fitBounds.height );
    },

    /**
     * Update the SVGBlock as part of a render step.  Called from Display.updateDisplay => BackboneDrawable.updateDisplay
     */
    update: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'update #' + this.id );

      // TODO: Shouldn't calling update on a disposed SVGBlock be an assertion error?
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        //OHTWO TODO: call here!
        // TODO: What does the above TODO mean?
        while ( this.dirtyGroups.length ) {
          var group = this.dirtyGroups.pop();

          // if this group has been disposed or moved to another block, don't mess with it
          if ( group.block === this ) {
            group.update();
          }
        }
        while ( this.dirtyGradients.length ) {
          this.dirtyGradients.pop().update();
        }
        while ( this.dirtyDrawables.length ) {
          var drawable = this.dirtyDrawables.pop();

          // if this drawable has been disposed or moved to another block, don't mess with it
          // TODO: If it was moved to another block, why might it still appear in our list?  Shouldn't that be an assertion check?
          if ( drawable.parentDrawable === this ) {
            drawable.update();
          }
        }

        // checks will be done in updateFit() to see whether it is needed
        this.updateFit();
      }
    },

    dispose: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'dispose #' + this.id );

      // make it take up zero area, so that we don't use up excess memory
      this.svg.setAttribute( 'width', 0 );
      this.svg.setAttribute( 'height', 0 );

      // clear references
      this.filterRootInstance = null;
      cleanArray( this.dirtyGradients );
      cleanArray( this.dirtyGroups );
      cleanArray( this.dirtyDrawables );
      this.paintMap = {};

      this.baseTransformGroup.removeChild( this.rootGroup.svgGroup );
      this.rootGroup.dispose();
      this.rootGroup = null;

      // since we may not properly remove all defs yet
      while ( this.defs.childNodes.length ) {
        this.defs.removeChild( this.defs.childNodes[ 0 ] );
      }

      FittedBlock.prototype.dispose.call( this );
    },

    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );

      FittedBlock.prototype.addDrawable.call( this, drawable );

      SVGGroup.addDrawable( this, drawable );
      drawable.updateSVGBlock( this );
    },

    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );

      SVGGroup.removeDrawable( this, drawable );

      FittedBlock.prototype.removeDrawable.call( this, drawable );

      // NOTE: we don't unset the drawable's defs here, since it will either be disposed (will clear it)
      // or will be added to another SVGBlock (which will overwrite it)
    },

    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );

      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );
    },

    toString: function() {
      return 'SVGBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );

  Poolable.mixin( SVGBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'new from constructor' );
          return new SVGBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );

  return SVGBlock;
} );

// Copyright 2014-2016, University of Colorado Boulder


/**
 * DOM Drawable wrapper for another DOM Drawable. Used so that we can have our own independent siblings, generally as part
 * of a Backbone's layers/blocks.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/DOMBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Block'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Block = require( 'SCENERY/display/Block' );

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param display
   * @param domDrawable
   */
  function DOMBlock( display, domDrawable ) {
    this.initialize( display, domDrawable );
  }

  scenery.register( 'DOMBlock', DOMBlock );

  inherit( Block, DOMBlock, {
    initialize: function( display, domDrawable ) {
      // TODO: is it bad to pass the acceleration flags along?
      this.initializeBlock( display, domDrawable.renderer );

      this.domDrawable = domDrawable;
      this.domElement = domDrawable.domElement;

      return this;
    },

    dispose: function() {
      this.domDrawable = null;
      this.domElement = null;

      // super call
      Block.prototype.dispose.call( this );
    },

    update: function() {
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        this.domDrawable.update();
      }
    },

    markDirtyDrawable: function( drawable ) {
      this.markDirty();
    },

    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.DOMBlock && sceneryLog.DOMBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );
      assert && assert( this.domDrawable === drawable, 'DOMBlock should only be used with one drawable for now (the one it was initialized with)' );

      Block.prototype.addDrawable.call( this, drawable );
    },

    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.DOMBlock && sceneryLog.DOMBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );
      assert && assert( this.domDrawable === drawable, 'DOMBlock should only be used with one drawable for now (the one it was initialized with)' );

      Block.prototype.removeDrawable.call( this, drawable );
    }
  } );

  Poolable.mixin( DOMBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, domDrawable ) {
        if ( pool.length ) {
          return pool.pop().initialize( display, domDrawable );
        }
        else {
          return new DOMBlock( display, domDrawable );
        }
      };
    }
  } );

  return DOMBlock;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Abstraction over the shader program
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/ShaderProgram',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Util = require( 'SCENERY/util/Util' );

  function ShaderProgram( gl, vertexSource, fragmentSource, options ) {
    options = _.extend( {
      attributes: [], // {Array.<string>} (vertex) attribute names in the shader source
      uniforms: [] // {Array.<string>} uniform names in the shader source
    }, options );

    // store parameters so that we can recreate the shader program on context loss
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
    this.attributeNames = options.attributes;
    this.uniformNames = options.uniforms;

    this.initialize( gl );
  }

  scenery.register( 'ShaderProgram', ShaderProgram );

  return inherit( Object, ShaderProgram, {
    // initializes (or reinitializes) the WebGL state and uniform/attribute references.
    initialize: function( gl ) {
      var self = this;
      this.gl = gl; // TODO: create them with separate contexts

      this.used = false;

      this.program = this.gl.createProgram();

      this.vertexShader = Util.createShader( this.gl, this.vertexSource, this.gl.VERTEX_SHADER );
      this.fragmentShader = Util.createShader( this.gl, this.fragmentSource, this.gl.FRAGMENT_SHADER );

      this.gl.attachShader( this.program, this.vertexShader );
      this.gl.attachShader( this.program, this.fragmentShader );

      this.gl.linkProgram( this.program );

      if ( !this.gl.getProgramParameter( this.program, this.gl.LINK_STATUS ) ) {
        console.log( 'GLSL link error:' );
        console.log( this.gl.getProgramInfoLog( this.program ) );
        console.log( 'for vertex shader' );
        console.log( this.vertexSource );
        console.log( 'for fragment shader' );
        console.log( this.fragmentSource );

        // Normally it would be best to throw an exception here, but a context loss could cause the shader parameter check
        // to fail, and we must handle context loss gracefully between any adjacent pair of gl calls.
        // Therefore, we simply report the errors to the console.  See #279
      }

      // clean these up, they aren't needed after the link
      this.gl.deleteShader( this.vertexShader );
      this.gl.deleteShader( this.fragmentShader );

      this.uniformLocations = {}; // map name => uniform location for program
      this.attributeLocations = {}; // map name => attribute location for program
      this.activeAttributes = {}; // map name => boolean (enabled)

      _.each( this.attributeNames, function( attributeName ) {
        self.attributeLocations[ attributeName ] = self.gl.getAttribLocation( self.program, attributeName );
        self.activeAttributes[ attributeName ] = true; // default to enabled
      } );
      _.each( this.uniformNames, function( uniformName ) {
        self.uniformLocations[ uniformName ] = self.gl.getUniformLocation( self.program, uniformName );
      } );

      this.isInitialized = true;
    },

    use: function() {
      if ( this.used ) { return; }

      var self = this;

      this.used = true;

      this.gl.useProgram( this.program );

      // enable the active attributes
      _.each( this.attributeNames, function( attributeName ) {
        if ( self.activeAttributes[ attributeName ] ) {
          self.enableVertexAttribArray( attributeName );
        }
      } );
    },

    activateAttribute: function( attributeName ) {
      // guarded so we don't enable twice
      if ( !this.activeAttributes[ attributeName ] ) {
        this.activeAttributes[ attributeName ] = true;

        if ( this.used ) {
          this.enableVertexAttribArray( attributeName );
        }
      }
    },

    enableVertexAttribArray: function( attributeName ) {
      this.gl.enableVertexAttribArray( this.attributeLocations[ attributeName ] );
    },

    unuse: function() {
      if ( !this.used ) { return; }

      var self = this;

      this.used = false;

      _.each( this.attributeNames, function( attributeName ) {
        if ( self.activeAttributes[ attributeName ] ) {
          self.disableVertexAttribArray( attributeName );
        }
      } );
    },

    disableVertexAttribArray: function( attributeName ) {
      this.gl.disableVertexAttribArray( this.attributeLocations[ attributeName ] );
    },

    deactivateAttribute: function( attributeName ) {
      // guarded so we don't disable twice
      if ( this.activeAttributes[ attributeName ] ) {
        this.activeAttributes[ attributeName ] = false;

        if ( this.used ) {
          this.disableVertexAttribArray( attributeName );
        }
      }
    },

    dispose: function() {
      this.gl.deleteProgram( this.program );
    }
  } );
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Given a rectangular containing area, takes care of allocating and deallocating smaller rectangular "bins" that fit
 * together inside the area and do not overlap. Optimized more for runtime CPU usage than space currently.
 *
 * For example:
 * #begin canvasExample binPacker 256x256
 * #on
 * var binPacker = new dot.BinPacker( new dot.Bounds2( 0, 0, 256, 256 ) );
 * var bins = [];
 * for ( var i = 0; i < 100; i++ ) {
 *   var bin = binPacker.allocate( Math.random() * 64, Math.random() * 64 );
 *   if ( bin ) {
 *     bins.push( bin );
 *   }
 * }
 * #off
 *
 * context.strokeStyle = '#000';
 * bins.forEach( function( bin ) {
 *   var bounds = bin.bounds;
 *   context.strokeRect( bounds.x, bounds.y, bounds.width, bounds.height );
 * } );
 * #end canvasExample
 *
 * @author Sharfudeen Ashraf
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'DOT/BinPacker',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
  'use strict';

  // modules
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );

  /**
   * Creates a BinPacker with the specified containing bounds.
   * @public
   * @constructor
   *
   * @param {Bounds2} bounds - The available bounds to pack bins inside.
   */
  function BinPacker( bounds ) {
    this.rootBin = new dot.BinPacker.Bin( bounds, null );
  }

  dot.register( 'BinPacker', BinPacker );

  inherit( Object, BinPacker, {
    /**
     * Allocates a bin with the specified width and height if possible (returning a {Bin}), otherwise returns null.
     * @public
     *
     * @param {number} width
     * @param {number} height
     * @returns {Bin|null}
     */
    allocate: function( width, height ) {
      // find a leaf bin that has available room (or null)
      var bin = this.rootBin.findAvailableBin( width, height );

      if ( bin ) {
        // split it into a sized sub-bin for our purpose that we will use, and other bins for future allocations
        var sizedBin = bin.split( width, height );

        // mark our bin as used
        sizedBin.use();

        return sizedBin;
      }
      else {
        return null;
      }
    },

    /**
     * Deallocates a bin, so that its area can be reused by future allocations.
     * @public
     *
     * @param {Bin} bin - The bin that was returned from allocate().
     */
    deallocate: function( bin ) {
      bin.unuse();
    },

    /**
     * @private, for debugging purposes
     * @returns {string}
     */
    toString: function() {
      var result = '';

      var padding = '';

      function binTree( bin ) {
        result += padding + bin.toString() + '\n';
        padding = padding + '  ';
        _.each( bin.children, binTree );
        padding = padding.substring( 2 );
      }

      binTree( this.rootBin );

      return result;
    }
  } );

  /**
   * A rectangular bin that can be used itself or split into sub-bins.
   * @public
   * @constructor
   *
   * @param {Bounds2} bounds
   * @param {Bin|null} parent
   */
  BinPacker.Bin = function Bin( bounds, parent ) {
    // @public {Bounds2} - Our containing bounds
    this.bounds = bounds;

    // @private {Bin|null} - Parent bin, if applicable
    this.parent = parent;

    // @private {boolean} - Whether our children are responsible for our area
    this.isSplit = false;

    // @private {boolean} - Whether we are marked as a bin that is used
    this.isUsed = false;

    // @private {Array.<Bin>}
    this.children = [];
  };
  inherit( Object, BinPacker.Bin, {

    /**
     * Finds an unused bin with open area that is at least width-x-height in size.
     * @private
     *
     * @param {number} width
     * @param {number} height
     * @returns {Bin|null}
     */
    findAvailableBin: function( width, height ) {
      assert && assert( width > 0 && height > 0, 'Empty bin requested?' );

      // If we are marked as used ourself, we can't be used
      if ( this.isUsed ) {
        return null;
      }
      // If our bounds can't fit it, skip this entire sub-tree
      else if ( this.bounds.width < width || this.bounds.height < height ) {
        return null;
      }
      // If we have been split, check our children
      else if ( this.isSplit ) {
        for ( var i = 0; i < this.children.length; i++ ) {
          var result = this.children[ i ].findAvailableBin( width, height );
          if ( result ) {
            return result;
          }
        }
        // No child can fit the area
        return null;
      }
      // Otherwise we are free and our dimensions are compatible (checked above)
      else {
        return this;
      }
    },

    /**
     * Splits this bin into multiple child bins, and returns the child with the dimensions (width,height).
     * @private
     *
     * @param {number} width
     * @param {number} height
     */
    split: function( width, height ) {
      assert && assert( this.bounds.width >= width && this.bounds.height >= height,
        'Bin does not have space' );
      assert && assert( !this.isSplit, 'Bin should not be re-split' );
      assert && assert( !this.isUsed, 'Bin should not be split when used' );
      assert && assert( width > 0 && height > 0, 'Empty bin requested?' );

      // if our dimensions match exactly, don't split (return ourself)
      if ( width === this.bounds.width && height === this.bounds.height ) {
        return this;
      }

      // mark as split
      this.isSplit = true;

      // locations of the split
      var splitX = this.bounds.minX + width;
      var splitY = this.bounds.minY + height;

      /*
       * How an area is split (for now). In the future, splitting more after determining what we need to fit next would
       * potentially be better, but this preserves the width better (which many times we need).
       *
       *   ************************************
       *   *                  *               *
       *   *                  *               *
       *   *       main       *     right     *
       *   * (width x height) *               *
       *   *                  *               *
       *   ************************************
       *   *                                  *
       *   *              bottom              *
       *   *                                  *
       *   ************************************
       */
      var mainBounds = new Bounds2( this.bounds.minX, this.bounds.minY, splitX, splitY );
      var rightBounds = new Bounds2( splitX, this.bounds.minY, this.bounds.maxX, splitY );
      var bottomBounds = new Bounds2( this.bounds.minX, splitY, this.bounds.maxX, this.bounds.maxY );

      var mainBin = new dot.BinPacker.Bin( mainBounds, this );
      this.children.push( mainBin );

      // only add right/bottom if they take up area
      if ( rightBounds.hasNonzeroArea() ) {
        this.children.push( new dot.BinPacker.Bin( rightBounds, this ) );
      }
      if ( bottomBounds.hasNonzeroArea() ) {
        this.children.push( new dot.BinPacker.Bin( bottomBounds, this ) );
      }

      return mainBin;
    },

    /**
     * Mark this bin as used.
     * @private
     */
    use: function() {
      assert && assert( !this.isSplit, 'Should not mark a split bin as used' );
      assert && assert( !this.isUsed, 'Should not mark a used bin as used' );

      this.isUsed = true;
    },

    /**
     * Mark this bin as not used, and attempt to collapse split parents if all children are unused.
     * @private
     */
    unuse: function() {
      assert && assert( this.isUsed, 'Can only unuse a used instance' );

      this.isUsed = false;

      this.parent && this.parent.attemptToCollapse();
    },

    /**
     * If our bin can be collapsed (it is split and has children that are not used AND not split), then we will become
     * not split, and will remove our children. If successful, it will also call this on our parent, fully attempting
     * to clean up unused data structures.
     * @private
     */
    attemptToCollapse: function() {
      assert && assert( this.isSplit, 'Should only attempt to collapse split bins' );

      // Bail out if a single child isn't able to be collapsed. If it is not split or used, it won't have any children
      // or needs.
      for ( var i = 0; i < this.children.length; i++ ) {
        var child = this.children[ i ];

        if ( child.isSplit || child.isUsed ) {
          return;
        }
      }

      // We can now collapse ourselves neatly
      this.children = [];
      this.isSplit = false;

      // And attempt to collapse our parent
      this.parent && this.parent.attemptToCollapse();
    },

    /**
     * @private, for debugging purposes
     * @returns {string}
     */
    toString: function() {
      return this.bounds.toString() + ( this.isUsed ? ' used' : '' );
    }
  } );

  return BinPacker;
} );

// Copyright 2015-2016, University of Colorado Boulder

/**
 * A single Canvas/texture with multiple different images (sprites) drawn internally. During rendering, this texture
 * can be used in one draw call to render multiple different images by providing UV coordinates to each quad for each
 * image to be drawn.
 *
 * Note that the WebGL texture part is not required to be run - the Canvas-only part can be used functionally without
 * any WebGL dependencies.
 *
 * TODO: How to use custom mipmap levels?
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SCENERY/util/SpriteSheet',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/BinPacker','DOT/Bounds2','DOT/Dimension2'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );
  var inherit = require( 'PHET_CORE/inherit' );
  var BinPacker = require( 'DOT/BinPacker' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Dimension2 = require( 'DOT/Dimension2' );

  // constants
  // The max SpriteSheet size was selected to minimize memory overhead while still accommodating many large images
  // See https://github.com/phetsims/scenery/issues/539
  var MAX_DIMENSION = new Dimension2( 1024, 1024 );

  // Amount of space along the edge of each image that is filled with the closest adjacent pixel value. This helps
  // get rid of alpha fading, see https://github.com/phetsims/scenery/issues/637.
  var GUTTER_SIZE = 1;

  // Amount of blank space along the bottom and right of each image that is left transparent, to avoid graphical
  // artifacts due to texture filtering blending the adjacent image in.
  // See https://github.com/phetsims/scenery/issues/637.
  var PADDING = 1;

  /**
   * @constructor
   *
   * @param {boolean} useMipmaps - Whether built-in WebGL mipmapping should be used. Higher quality, but may be slower
   *                               to add images (since mipmaps need to be updated).
   */
  function SpriteSheet( useMipmaps ) {
    // @private {boolean}
    this.useMipmaps = useMipmaps;

    // @private {WebGLRenderingContext|null} - Will be passed in with initializeContext
    this.gl = null;

    // @public {WebGLTexture|null} - Will be set later, once we have a context
    this.texture = null;

    // @private {Bounds2} - The top-level bounding box for texture content. All sprites will have coordinate bounding
    // boxes that are included in these bounds.
    // TODO: potentially support larger texture sizes based on reported capabilities (could cause fewer draw calls?)
    this.bounds = new Bounds2( 0, 0, MAX_DIMENSION.width, MAX_DIMENSION.height );
    assert && assert( this.bounds.minX === 0 && this.bounds.minY === 0, 'Assumed constraint later on for transforms' );

    // @private {number}
    this.width = this.bounds.width;
    this.height = this.bounds.height;

    // @private {HTMLCanvasElement}
    this.canvas = document.createElement( 'canvas' );
    this.canvas.width = this.width;
    this.canvas.height = this.height;

    // @private {CanvasRenderingContext2D}
    this.context = this.canvas.getContext( '2d' );

    // @private {BinPacker} - Handles how our available area is partitioned into sprites.
    this.binPacker = new BinPacker( this.bounds );

    // @private {boolean} - Whether this spritesheet needs updates.
    this.dirty = true;

    // @private {Array.<SpriteSheet.Sprite>}
    this.usedSprites = [];
    this.unusedSprites = []; // works as a LRU cache for removing items when we need to allocate new space
  }

  scenery.register( 'SpriteSheet', SpriteSheet );

  inherit( Object, SpriteSheet, {
    /**
     * Initialize (or reinitialize) ourself with a new GL context. Should be called at least once before updateTexture()
     * @public
     *
     * NOTE: Should be safe to call with a different context (will recreate a different texture) should this be needed
     *       for things like context loss.
     *
     * @param {WebGLRenderingContext} gl
     */
    initializeContext: function( gl ) {
      this.gl = gl;

      this.createTexture();
    },

    /**
     * Allocates and creates a GL texture, configures it, and initializes it with our current Canvas.
     * @private
     */
    createTexture: function() {
      var gl = this.gl;

      this.texture = gl.createTexture();
      gl.bindTexture( gl.TEXTURE_2D, this.texture );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.useMipmaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR );
      gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
      gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas );
      if ( this.useMipmaps ) {
        gl.hint( gl.GENERATE_MIPMAP_HINT, gl.NICEST );
        gl.generateMipmap( gl.TEXTURE_2D );
      }
      gl.bindTexture( gl.TEXTURE_2D, null );

      this.dirty = false;
    },

    /**
     * Updates a pre-existing texture with our current Canvas.
     * @public
     */
    updateTexture: function() {
      assert && assert( this.gl, 'SpriteSheet needs context to updateTexture()' );

      if ( this.dirty ) {
        this.dirty = false;

        var gl = this.gl;

        gl.bindTexture( gl.TEXTURE_2D, this.texture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas );
        if ( this.useMipmaps ) {
          gl.generateMipmap( gl.TEXTURE_2D );
        }
        gl.bindTexture( gl.TEXTURE_2D, null );
      }
    },

    /**
     * Adds an image (if possible) to our sprite sheet. If successful, will return a {Sprite}, otherwise null.
     * @public
     *
     * @param {HTMLCanvasElement|HTMLImageElement} image
     * @param {number} width - Passed in, since it may not be fully loaded yet?
     * @param {number} height - Passed in, since it may not be fully loaded yet?
     * @returns {Sprite|null}
     */
    addImage: function( image, width, height ) {
      var i;

      // check used cache
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        var usedSprite = this.usedSprites[ i ];
        if ( usedSprite.image === image ) {
          usedSprite.count++;
          return usedSprite;
        }
      }

      // check unused cache
      for ( i = 0; i < this.unusedSprites.length; i++ ) {
        var unusedSprite = this.unusedSprites[ i ];
        if ( unusedSprite.image === image ) {
          unusedSprite.count++;
          assert && assert( unusedSprite.count === 1, 'Count should be exactly 1 after coming back from being unused' );
          this.unusedSprites.splice( i, 1 ); // remove it from the unused array
          this.usedSprites.push( unusedSprite ); // add it to the used array
          return unusedSprite;
        }
      }

      // Not in any caches, let's try to find space. If we can't find space at first, we start removing unused sprites
      // one-by-one.
      var bin;
      // Enters 'while' loop only if allocate() returns null and we have unused sprites (i.e. conditions where we will
      // want to deallocate the least recently used (LRU) unused sprite and then check for allocation again).
      while ( !( bin = this.binPacker.allocate( width + 2 * GUTTER_SIZE + PADDING, height + 2 * GUTTER_SIZE + PADDING ) ) && this.unusedSprites.length ) {
        var ejectedSprite = this.unusedSprites.shift(); // LRU policy by taking first item

        // clear its space in the Canvas
        this.dirty = true;
        var ejectedBounds = ejectedSprite.bin.bounds;
        this.context.clearRect( ejectedBounds.x, ejectedBounds.y, ejectedBounds.width, ejectedBounds.height );

        // deallocate its area in the bin packer
        this.binPacker.deallocate( ejectedSprite.bin );
      }

      if ( bin ) {
        // WebGL will want UV coordinates in the [0,1] range
        // We need to chop off the gutters (on all sides), and the padding (on the bottom and right)
        var uvBounds = new Bounds2(
          ( bin.bounds.minX + GUTTER_SIZE ) / this.width,
          ( bin.bounds.minY + GUTTER_SIZE ) / this.height,
          ( bin.bounds.maxX - GUTTER_SIZE - PADDING ) / this.width,
          ( bin.bounds.maxY - GUTTER_SIZE - PADDING ) / this.height );
        var sprite = new SpriteSheet.Sprite( this, bin, uvBounds, image, 1 );

        this.copyImageWithGutter( image, width, height, bin.bounds.x, bin.bounds.y );

        this.dirty = true;
        this.usedSprites.push( sprite );
        return sprite;
      }
      // no space, even after clearing out our unused sprites
      else {
        return null;
      }
    },

    /**
     * Removes an image from our spritesheet. (Removes one from the amount it is used, and if it is 0, gets actually
     * removed).
     * @public
     *
     * @param {HTMLCanvasElement|HTMLImageElement} image
     */
    removeImage: function( image ) {
      // find the used sprite (and its index)
      var usedSprite;
      var i;
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        if ( this.usedSprites[ i ].image === image ) {
          usedSprite = this.usedSprites[ i ];
          break;
        }
      }
      assert && assert( usedSprite, 'Sprite not found for removeImage' );

      // if we have no more references to the image/sprite
      if ( --usedSprite.count <= 0 ) {
        this.usedSprites.splice( i, 1 ); // remove it from the used list
        this.unusedSprites.push( usedSprite ); // add it to the unused list
      }

      // NOTE: no modification to the Canvas/texture is made, since we can leave it drawn there and unreferenced.
      // If addImage( image ) is called for the same image, we can 'resurrect' it without any further Canvas/texture
      // changes being made.
    },

    /**
     * Whether the sprite for the specified image is handled by this spritesheet. It can be either used or unused, but
     * addImage() calls with the specified image should be extremely fast (no need to modify the Canvas or texture).
     * @public
     *
     * @returns {boolean}
     */
    containsImage: function( image ) {
      var i;

      // check used cache
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        if ( this.usedSprites[ i ].image === image ) {
          return true;
        }
      }

      // check unused cache
      for ( i = 0; i < this.unusedSprites.length; i++ ) {
        if ( this.unusedSprites[ i ].image === image ) {
          return true;
        }
      }

      return false;
    },

    /**
     * Copes the image (width x height) centered into a bin (width+2 x height+2) at (binX,binY), where the padding
     * along the edges is filled with the next closest pixel in the actual image.
     * @private
     *
     * @param {HTMLCanvasElement|HTMLImageElement} image
     * @param {number} width
     * @param {number} height
     * @param {number} binX
     * @param {number} binY
     */
    copyImageWithGutter: function( image, width, height, binX, binY ) {
      assert && assert( GUTTER_SIZE === 1 );

      // Corners, all 1x1
      this.copyImageRegion( image, 1, 1, 0, 0, binX, binY );
      this.copyImageRegion( image, 1, 1, width - 1, 0, binX + 1 + width, binY );
      this.copyImageRegion( image, 1, 1, width - 1, height - 1, binX + 1 + width, binY + 1 + height );
      this.copyImageRegion( image, 1, 1, 0, height - 1, binX, binY + 1 + height );

      // Edges
      this.copyImageRegion( image, width, 1, 0, 0, binX + 1, binY );
      this.copyImageRegion( image, width, 1, 0, height - 1, binX + 1, binY + 1 + height );
      this.copyImageRegion( image, 1, height, 0, 0, binX, binY + 1 );
      this.copyImageRegion( image, 1, height, width - 1, 0, binX + 1 + width, binY + 1 );

      this.context.drawImage( image, binX + 1, binY + 1 );
    },

    /**
     * Helper for drawing gutters.
     * @private
     *
     * @param {HTMLCanvasElement|HTMLImageElement} image
     * @param {number} width
     * @param {number} height
     * @param {number} sourceX
     * @param {number} sourceY
     * @param {number} destinationX
     * @param {number} destinationY
     */
    copyImageRegion: function( image, width, height, sourceX, sourceY, destinationX, destinationY ) {
      this.context.drawImage( image, sourceX, sourceY, width, height, destinationX, destinationY, width, height );
    }
  } );

  /**
   * A reference to a specific part of the texture that can be used.
   *
   * @constructor
   */
  SpriteSheet.Sprite = function( spriteSheet, bin, uvBounds, image, initialCount ) {
    // @public [read-only] {SpriteSheet} - The containing SpriteSheet
    this.spriteSheet = spriteSheet;

    // @private [read-only] {BinPacker.Bin} - Contains the actual image bounds in our Canvas (plus padding), and is
    //                                        used to deallocate (need to clear that area).
    this.bin = bin;

    // @public [read-only] {Bounds2} - Normalized bounds between [0,1] for the full texture (for GLSL texture lookups).
    this.uvBounds = uvBounds;

    // @private [read-only] {HTMLCanvasElement | HTMLImageElement} - Image element used.
    this.image = image;

    // @private [read-write] {number} - Reference count for number of addChild() calls minus removeChild() calls. If
    // the count is 0, it should be in the 'unusedSprites' array, otherwise it should be in the 'usedSprites' array.
    this.count = initialCount;
  };

  // @public (read-only) the size of a sprite sheet
  SpriteSheet.MAX_DIMENSION = MAX_DIMENSION;

  return SpriteSheet;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * Renders a visual layer of WebGL drawables.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Sharfudeen Ashraf (For Ghent University)
 */
define( 'SCENERY/display/WebGLBlock',['require','PHET_CORE/cleanArray','AXON/Emitter','SCENERY/display/FittedBlock','PHET_CORE/inherit','DOT/Matrix3','PHET_CORE/Poolable','SCENERY/display/Renderer','SCENERY/scenery','SCENERY/util/ShaderProgram','SCENERY/util/SpriteSheet','SCENERY/util/Util'],function( require ) {
  'use strict';

  // modules
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Emitter = require( 'AXON/Emitter' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var scenery = require( 'SCENERY/scenery' );
  var ShaderProgram = require( 'SCENERY/util/ShaderProgram' );
  var SpriteSheet = require( 'SCENERY/util/SpriteSheet' );
  var Util = require( 'SCENERY/util/Util' );

  /**
   * @constructor
   * @extends FittedBlock
   * @mixes Poolable
   *
   * @param display
   * @param renderer
   * @param transformRootInstance
   * @param filterRootInstance
   */
  function WebGLBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }

  scenery.register( 'WebGLBlock', WebGLBlock );

  inherit( FittedBlock, WebGLBlock, {
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'initialize #' + this.id );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

      // WebGLBlocks are hard-coded to take the full display size (as opposed to svg and canvas)
      // Since we saw some jitter on iPad, see #318 and generally expect WebGL layers to span the entire display
      // In the future, it would be good to understand what was causing the problem and make webgl consistent
      // with svg and canvas again.
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.FULL_DISPLAY );

      this.filterRootInstance = filterRootInstance;

      // {boolean} - Whether we pass this flag to the WebGL Context. It will store the contents displayed on the screen,
      // so that canvas.toDataURL() will work. It also requires clearing the context manually ever frame. Both incur
      // performance costs, so it should be false by default.
      // TODO: This block can be shared across displays, so we need to handle preserveDrawingBuffer separately?
      this.preserveDrawingBuffer = display.options.preserveDrawingBuffer;

      // list of {Drawable}s that need to be updated before we update
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );

      // {Array.<SpriteSheet>}, permanent list of spritesheets for this block
      this.spriteSheets = this.spriteSheets || [];

      // Projection {Matrix3} that maps from Scenery's global coordinate frame to normalized device coordinates,
      // where x,y are both in the range [-1,1] from one side of the Canvas to the other.
      this.projectionMatrix = this.projectionMatrix || new Matrix3().setTo32Bit();

      // @private {Float32Array} - Column-major 3x3 array specifying our projection matrix for 2D points
      // (homogenized to (x,y,1))
      this.projectionMatrixArray = this.projectionMatrix.entries;

      // processor for custom WebGL drawables (e.g. WebGLNode)
      this.customProcessor = this.customProcessor || new WebGLBlock.CustomProcessor();

      // processor for drawing vertex-colored triangles (e.g. Path types)
      this.vertexColorPolygonsProcessor = this.vertexColorPolygonsProcessor || new WebGLBlock.VertexColorPolygons( this.projectionMatrixArray );

      // processor for drawing textured triangles (e.g. Image)
      this.texturedTrianglesProcessor = this.texturedTrianglesProcessor || new WebGLBlock.TexturedTrianglesProcessor( this.projectionMatrixArray );

      // @public {Emitter} - Called when the WebGL context changes to a new context.
      this.glChangedEmitter = new Emitter();

      // @private {boolean}
      this.isContextLost = false;

      // @private {function}
      this.contextLostListener = this.onContextLoss.bind( this );
      this.contextRestoreListener = this.onContextRestoration.bind( this );

      if ( !this.domElement ) {
        // @public (scenery-internal) {HTMLCanvasElement} - Div wrapper used so we can switch out Canvases if necessary.
        this.domElement = document.createElement( 'div' );
        this.domElement.className = 'webgl-container';
        this.domElement.style.position = 'absolute';
        this.domElement.style.left = '0';
        this.domElement.style.top = '0';

        this.rebuildCanvas();
      }

      // clear buffers when we are reinitialized
      this.gl.clear( this.gl.COLOR_BUFFER_BIT );

      // reset any fit transforms that were applied
      Util.prepareForTransform( this.canvas, false ); // Apply CSS needed for future CSS transforms to work properly.
      Util.unsetTransform( this.canvas ); // clear out any transforms that could have been previously applied

      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();

      return this;
    },

    /**
     * Forces a rebuild of the Canvas and its context (as long as a context can be obtained).
     * @private
     *
     * This can be necessary when the browser won't restore our context that was lost (and we need to create another
     * canvas to get a valid context).
     */
    rebuildCanvas: function() {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'rebuildCanvas #' + this.id );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

      var canvas = document.createElement( 'canvas' );
      var gl = this.getContextFromCanvas( canvas );

      // Don't assert-failure out if this is not our first attempt (we're testing to see if we can recreate)
      assert && assert( gl || this.canvas, 'We should have a WebGL context by now' );

      // If we're aggressively trying to rebuild, we need to ignore context creation failure.
      if ( gl ) {
        if ( this.canvas ) {
          this.domElement.removeChild( this.canvas );
          this.canvas.removeEventListener( 'webglcontextlost', this.contextLostListener, false );
          this.canvas.removeEventListener( 'webglcontextrestored', this.contextRestoreListener, false );
        }

        // @private {HTMLCanvasElement}
        this.canvas = canvas;
        this.canvas.style.pointerEvents = 'none';

        // unique ID so that we can support rasterization with Display.foreignObjectRasterization
        this.canvasId = this.canvas.id = 'scenery-webgl' + this.id;

        this.canvas.addEventListener( 'webglcontextlost', this.contextLostListener, false );
        this.canvas.addEventListener( 'webglcontextrestored', this.contextRestoreListener, false );

        this.domElement.appendChild( this.canvas );

        this.setupContext( gl );
      }

      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
    },

    /**
     * Takes a fresh WebGL context switches the WebGL block over to use it.
     * @private
     *
     * @param {WebGLRenderingContext} gl
     */
    setupContext: function( gl ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'setupContext #' + this.id );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

      assert && assert( gl, 'Should have an actual context if this is called' );

      this.isContextLost = false;

      // @private {WebGLRenderingContext}
      this.gl = gl;

      // @private {number} - How much larger our Canvas will be compared to the CSS pixel dimensions, so that our
      // Canvas maps one of its pixels to a physical pixel (for Retina devices, etc.).
      this.backingScale = Util.backingScale( this.gl );

      // Double the backing scale size if we detect no built-in antialiasing.
      // See https://github.com/phetsims/circuit-construction-kit-dc/issues/139
      if ( gl.getParameter( gl.SAMPLES ) === 0 ) {
        this.backingScale *= 2;
      }

      // @private {number}
      this.originalBackingScale = this.backingScale;

      Util.applyWebGLContextDefaults( this.gl ); // blending defaults, etc.

      // When the context changes, we need to force certain refreshes
      this.markDirty();
      this.dirtyFit = true; // Force re-fitting

      // Update the context references on the processors
      this.customProcessor.initializeContext( this.gl );
      this.vertexColorPolygonsProcessor.initializeContext( this.gl );
      this.texturedTrianglesProcessor.initializeContext( this.gl );

      // Notify spritesheets of the new context
      for ( var i = 0; i < this.spriteSheets.length; i++ ) {
        this.spriteSheets[ i ].initializeContext( this.gl );
      }

      // Notify (e.g. WebGLNode painters need to be recreated)
      this.glChangedEmitter.emit();

      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
    },

    /**
     * Attempts to force a Canvas rebuild to get a new Canvas/context pair.
     * @private
     */
    delayedRebuildCanvas: function() {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'Delaying rebuilding of Canvas #' + this.id );
      var self = this;

      // TODO: Can we move this to before the update() step? Could happen same-frame in that case.
      window.setTimeout( function() {
        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'Executing delayed rebuilding #' + this.id );
        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();
        self.rebuildCanvas();
        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
      } );
    },

    /**
     * Callback for whenever our WebGL context is lost.
     * @private
     *
     * @param {WebGLContextEvent} domEvent
     */
    onContextLoss: function( domEvent ) {
      if ( !this.isContextLost ) {
        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'Context lost #' + this.id );
        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

        this.isContextLost = true;

        // Preventing default is super-important, otherwise it never attempts to restore the context
        domEvent.preventDefault();

        this.canvas.style.display = 'none';

        this.markDirty();

        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
      }
    },

    /**
     * Callback for whenever our WebGL context is restored.
     * @private
     *
     * @param {WebGLContextEvent} domEvent
     */
    onContextRestoration: function( domEvent ) {
      if ( this.isContextLost ) {
        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'Context restored #' + this.id );
        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

        var gl = this.getContextFromCanvas( this.canvas );
        assert && assert( gl, 'We were told the context was restored, so this should work' );

        this.setupContext( gl );

        this.canvas.style.display = '';

        sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
      }
    },

    /**
     * Attempts to get a WebGL context from a Canvas.
     * @private
     *
     * @param {HTMLCanvasElement}
     * @returns {WebGLRenderingContext|*} - If falsy, it did not succeed.
     */
    getContextFromCanvas: function( canvas ) {
      var contextOptions = {
        antialias: true,
        preserveDrawingBuffer: this.preserveDrawingBuffer
      };

      // we've already committed to using a WebGLBlock, so no use in a try-catch around our context attempt
      return canvas.getContext( 'webgl', contextOptions ) || canvas.getContext( 'experimental-webgl', contextOptions );
    },

    setSizeFullDisplay: function() {
      var size = this.display.getSize();
      this.canvas.width = Math.ceil( size.width * this.backingScale );
      this.canvas.height = Math.ceil( size.height * this.backingScale );
      this.canvas.style.width = size.width + 'px';
      this.canvas.style.height = size.height + 'px';
    },

    setSizeFitBounds: function() {
      throw new Error( 'setSizeFitBounds unimplemented for WebGLBlock' );
    },

    update: function() {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'update #' + this.id );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

      var gl = this.gl;

      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        if ( this.isContextLost && this.display._aggressiveContextRecreation ) {
          this.delayedRebuildCanvas();
        }

        // update drawables, so that they have vertex arrays up to date, etc.
        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }

        // ensure sprite sheet textures are up-to-date
        var numSpriteSheets = this.spriteSheets.length;
        for ( var i = 0; i < numSpriteSheets; i++ ) {
          this.spriteSheets[ i ].updateTexture();
        }

        // temporary hack for supporting webglScale
        if ( this.firstDrawable &&
             this.firstDrawable === this.lastDrawable &&
             this.firstDrawable.node &&
             this.firstDrawable.node._hints.webglScale !== null &&
             this.backingScale !== this.originalBackingScale * this.firstDrawable.node._hints.webglScale ) {
          this.backingScale = this.originalBackingScale * this.firstDrawable.node._hints.webglScale;
          this.dirtyFit = true;
        }

        // udpate the fit BEFORE drawing, since it may change our offset
        this.updateFit();

        // finalX = 2 * x / display.width - 1
        // finalY = 1 - 2 * y / display.height
        // result = matrix * ( x, y, 1 )
        this.projectionMatrix.rowMajor(
          2 / this.display.width, 0, -1,
          0, -2 / this.display.height, 1,
          0, 0, 1 );

        // if we created the context with preserveDrawingBuffer, we need to clear before rendering
        if ( this.preserveDrawingBuffer ) {
          gl.clear( gl.COLOR_BUFFER_BIT );
        }

        gl.viewport( 0.0, 0.0, this.canvas.width, this.canvas.height );

        // We switch between processors for drawables based on each drawable's webglRenderer property. Each processor
        // will be activated, will process a certain number of adjacent drawables with that processor's webglRenderer,
        // and then will be deactivated. This allows us to switch back-and-forth between different shader programs,
        // and allows us to trigger draw calls for each grouping of drawables in an efficient way.
        var currentProcessor = null;
        // How many draw calls have been executed. If no draw calls are executed while updating, it means nothing should
        // be drawn, and we'll have to manually clear the Canvas if we are not preserving the drawing buffer.
        var cumulativeDrawCount = 0;
        // Iterate through all of our drawables (linked list)
        //OHTWO TODO: PERFORMANCE: create an array for faster drawable iteration (this is probably a hellish memory access pattern)
        for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
          // ignore invisible drawables
          if ( drawable.visible ) {
            // select our desired processor
            var desiredProcessor = null;
            if ( drawable.webglRenderer === Renderer.webglTexturedTriangles ) {
              desiredProcessor = this.texturedTrianglesProcessor;
            }
            else if ( drawable.webglRenderer === Renderer.webglCustom ) {
              desiredProcessor = this.customProcessor;
            }
            else if ( drawable.webglRenderer === Renderer.webglVertexColorPolygons ) {
              desiredProcessor = this.vertexColorPolygonsProcessor;
            }
            assert && assert( desiredProcessor );

            // swap processors if necessary
            if ( desiredProcessor !== currentProcessor ) {
              // deactivate any old processors
              if ( currentProcessor ) {
                cumulativeDrawCount += currentProcessor.deactivate();
              }
              // activate the new processor
              currentProcessor = desiredProcessor;
              currentProcessor.activate();
            }

            // process our current drawable with the current processor
            currentProcessor.processDrawable( drawable );
          }

          // exit loop end case
          if ( drawable === this.lastDrawable ) { break; }
        }
        // deactivate any processor that still has drawables that need to be handled
        if ( currentProcessor ) {
          cumulativeDrawCount += currentProcessor.deactivate();
        }

        // If we executed no draw calls AND we aren't preserving the drawing buffer, we'll need to manually clear the
        // drawing buffer ourself.
        if ( cumulativeDrawCount === 0 && !this.preserveDrawingBuffer ) {
          gl.clear( gl.COLOR_BUFFER_BIT );
        }

        gl.flush();
      }

      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
    },

    dispose: function() {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'dispose #' + this.id );

      // TODO: many things to dispose!?

      // clear references
      cleanArray( this.dirtyDrawables );

      FittedBlock.prototype.dispose.call( this );
    },

    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on WebGLBlock#' + this.id + ' with ' + drawable.toString() );

      assert && assert( drawable );
      assert && assert( !drawable.disposed );

      // TODO: instance check to see if it is a canvas cache (usually we don't need to call update on our drawables)
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },

    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );

      FittedBlock.prototype.addDrawable.call( this, drawable );

      // will trigger changes to the spritesheets for images, or initialization for others
      drawable.onAddToBlock( this );
    },

    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );

      // Ensure a removed drawable is not present in the dirtyDrawables array afterwards. Don't want to update it.
      // See https://github.com/phetsims/scenery/issues/635
      var index = 0;
      while ( ( index = this.dirtyDrawables.indexOf( drawable, index ) ) >= 0 ) {
        this.dirtyDrawables.splice( index, 1 );
      }

      // wil trigger removal from spritesheets
      drawable.onRemoveFromBlock( this );

      FittedBlock.prototype.removeDrawable.call( this, drawable );
    },

    /**
     * Ensures we have an allocated part of a SpriteSheet for this image. If a SpriteSheet already contains this image,
     * we'll just increase the reference count. Otherwise, we'll attempt to add it into one of our SpriteSheets. If
     * it doesn't fit, we'll add a new SpriteSheet and add the image to it.
     *
     * @param {HTMLImageElement | HTMLCanvasElement} image
     * @param {number} width
     * @param {number} height
     *
     * @returns {Sprite} - Throws an error if we can't accommodate the image
     */
    addSpriteSheetImage: function( image, width, height ) {
      var sprite = null;
      var numSpriteSheets = this.spriteSheets.length;
      // TODO: check for SpriteSheet containment first?
      for ( var i = 0; i < numSpriteSheets; i++ ) {
        var spriteSheet = this.spriteSheets[ i ];
        sprite = spriteSheet.addImage( image, width, height );
        if ( sprite ) {
          break;
        }
      }
      if ( !sprite ) {
        var newSpriteSheet = new SpriteSheet( true ); // use mipmaps for now?
        sprite = newSpriteSheet.addImage( image, width, height );
        newSpriteSheet.initializeContext( this.gl );
        this.spriteSheets.push( newSpriteSheet );
        if ( !sprite ) {
          // TODO: renderer flags should change for very large images
          throw new Error( 'Attempt to load image that is too large for sprite sheets' );
        }
      }
      return sprite;
    },

    /**
     * Removes the reference to the sprite in our spritesheets.
     *
     * @param {Sprite} sprite
     */
    removeSpriteSheetImage: function( sprite ) {
      sprite.spriteSheet.removeImage( sprite.image );
    },

    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );

      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );

      this.markDirty();
    },

    onPotentiallyMovedDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.onPotentiallyMovedDrawable ' + drawable.toString() );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();

      assert && assert( drawable.parentDrawable === this );

      this.markDirty();

      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
    },

    toString: function() {
      return 'WebGLBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );

  /*---------------------------------------------------------------------------*
   * Processors rely on the following lifecycle:
   * 1. activate()
   * 2. processDrawable() - 0 or more times
   * 3. deactivate()
   * Once deactivated, they should have executed all of the draw calls they need to make.
   *---------------------------------------------------------------------------*/

  // TODO: Processor super-type?

  /**
   * @constructor
   */
  WebGLBlock.CustomProcessor = function() {
    this.drawable = null;
  };
  inherit( Object, WebGLBlock.CustomProcessor, {
    /**
     * Sets the WebGL context that this processor should use.
     * @public
     *
     * NOTE: This can be called multiple times on a single processor, in the case where the previous context was lost.
     *       We should not need to dispose anything from that.
     *
     * @param {WebGLRenderingContext} gl
     */
    initializeContext: function( gl ) {

    },

    activate: function() {
      this.drawCount = 0;
    },

    processDrawable: function( drawable ) {
      assert && assert( drawable.webglRenderer === Renderer.webglCustom );

      this.drawable = drawable;
      this.draw();
    },

    deactivate: function() {
      return this.drawCount;
    },

    // @private
    draw: function() {
      if ( this.drawable ) {
        var count = this.drawable.draw();
        assert && assert( typeof count === 'number' );
        this.drawCount += count;
        this.drawable = null;
      }
    }
  } );

  /**
   * @constructor
   *
   * @param {Float32Array} projectionMatrixArray - Projection matrix entries
   */
  WebGLBlock.VertexColorPolygons = function( projectionMatrixArray ) {
    assert && assert( projectionMatrixArray instanceof Float32Array );

    // @private {Float32Array}
    this.projectionMatrixArray = projectionMatrixArray;

    // @private {number} - Initial length of the vertex buffer. May increase as needed.
    this.lastArrayLength = 128;

    // @private {Float32Array}
    this.vertexArray = new Float32Array( this.lastArrayLength );
  };
  inherit( Object, WebGLBlock.VertexColorPolygons, {
    /**
     * Sets the WebGL context that this processor should use.
     * @public
     *
     * NOTE: This can be called multiple times on a single processor, in the case where the previous context was lost.
     *       We should not need to dispose anything from that.
     *
     * @param {WebGLRenderingContext} gl
     */
    initializeContext: function( gl ) {
      assert && assert( gl, 'Should be an actual context' );

      // @private {WebGLRenderingContext}
      this.gl = gl;

      // @private {ShaderProgram}
      this.shaderProgram = new ShaderProgram( gl, [
        // vertex shader
        'attribute vec2 aVertex;',
        'attribute vec4 aColor;',
        'varying vec4 vColor;',
        'uniform mat3 uProjectionMatrix;',

        'void main() {',
        '  vColor = aColor;',
        '  vec3 ndc = uProjectionMatrix * vec3( aVertex, 1.0 );', // homogeneous map to to normalized device coordinates
        '  gl_Position = vec4( ndc.xy, 0.0, 1.0 );',
        '}'
      ].join( '\n' ), [
        // fragment shader
        'precision mediump float;',
        'varying vec4 vColor;',

        'void main() {',
        // '  gl_FragColor = vec4( 0.0, 1.0, 0.0, 1.0 );',
        '  gl_FragColor = vColor;',
        '}'
      ].join( '\n' ), {
        attributes: [ 'aVertex', 'aColor' ],
        uniforms: [ 'uProjectionMatrix' ]
      } );

      // @private {WebGLBuffer}
      this.vertexBuffer = gl.createBuffer();

      gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
      gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
    },

    activate: function() {
      this.shaderProgram.use();

      this.vertexArrayIndex = 0;
      this.drawCount = 0;
    },

    processDrawable: function( drawable ) {
      if ( drawable.includeVertices ) {
        var vertexData = drawable.vertexArray;

        // if our vertex data won't fit, keep doubling the size until it fits
        while ( vertexData.length + this.vertexArrayIndex > this.vertexArray.length ) {
          var newVertexArray = new Float32Array( this.vertexArray.length * 2 );
          newVertexArray.set( this.vertexArray );
          this.vertexArray = newVertexArray;
        }

        // copy our vertex data into the main array
        this.vertexArray.set( vertexData, this.vertexArrayIndex );
        this.vertexArrayIndex += vertexData.length;

        this.drawCount++;
      }
    },

    deactivate: function() {
      if ( this.drawCount ) {
        this.draw();
      }

      this.shaderProgram.unuse();

      return this.drawCount;
    },

    // @private
    draw: function() {
      var gl = this.gl;

      // (uniform) projection transform into normalized device coordinates
      gl.uniformMatrix3fv( this.shaderProgram.uniformLocations.uProjectionMatrix, false, this.projectionMatrixArray );

      gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
      // if we increased in length, we need to do a full bufferData to resize it on the GPU side
      if ( this.vertexArray.length > this.lastArrayLength ) {
        gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
      }
      // otherwise do a more efficient update that only sends part of the array over
      else {
        gl.bufferSubData( gl.ARRAY_BUFFER, 0, this.vertexArray.subarray( 0, this.vertexArrayIndex ) );
      }
      var sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;
      var stride = 6 * sizeOfFloat;
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aVertex, 2, gl.FLOAT, false, stride, 0 * sizeOfFloat );
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aColor, 4, gl.FLOAT, false, stride, 2 * sizeOfFloat );

      gl.drawArrays( gl.TRIANGLES, 0, this.vertexArrayIndex / 6 );

      this.vertexArrayIndex = 0;
    }
  } );

  /**
   * @constructor
   *
   * @param {Float32Array} projectionMatrixArray - Projection matrix entries
   */
  WebGLBlock.TexturedTrianglesProcessor = function( projectionMatrixArray ) {
    assert && assert( projectionMatrixArray instanceof Float32Array );

    // @private {Float32Array}
    this.projectionMatrixArray = projectionMatrixArray;

    // @private {number} - Initial length of the vertex buffer. May increase as needed.
    this.lastArrayLength = 128;

    // @private {Float32Array}
    this.vertexArray = new Float32Array( this.lastArrayLength );
  };
  inherit( Object, WebGLBlock.TexturedTrianglesProcessor, {
    /**
     * Sets the WebGL context that this processor should use.
     * @public
     *
     * NOTE: This can be called multiple times on a single processor, in the case where the previous context was lost.
     *       We should not need to dispose anything from that.
     *
     * @param {WebGLRenderingContext} gl
     */
    initializeContext: function( gl ) {
      assert && assert( gl, 'Should be an actual context' );

      // @private {WebGLRenderingContext}
      this.gl = gl;

      // @private {ShaderProgram}
      this.shaderProgram = new ShaderProgram( gl, [
        // vertex shader
        'attribute vec2 aVertex;',
        'attribute vec2 aTextureCoord;',
        'attribute float aAlpha;',
        'varying vec2 vTextureCoord;',
        'varying float vAlpha;',
        'uniform mat3 uProjectionMatrix;',

        'void main() {',
        '  vTextureCoord = aTextureCoord;',
        '  vAlpha = aAlpha;',
        '  vec3 ndc = uProjectionMatrix * vec3( aVertex, 1.0 );', // homogeneous map to to normalized device coordinates
        '  gl_Position = vec4( ndc.xy, 0.0, 1.0 );',
        '}'
      ].join( '\n' ), [
        // fragment shader
        'precision mediump float;',
        'varying vec2 vTextureCoord;',
        'varying float vAlpha;',
        'uniform sampler2D uTexture;',

        'void main() {',
        '  vec4 color = texture2D( uTexture, vTextureCoord, -0.7 );', // mipmap LOD bias of -0.7 (for now)
        '  color.a *= vAlpha;',
        '  gl_FragColor = color;',
        '}'
      ].join( '\n' ), {
        // attributes: [ 'aVertex', 'aTextureCoord' ],
        attributes: [ 'aVertex', 'aTextureCoord', 'aAlpha' ],
        uniforms: [ 'uTexture', 'uProjectionMatrix' ]
      } );

      // @private {WebGLBuffer}
      this.vertexBuffer = gl.createBuffer();

      gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
      gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
    },

    activate: function() {
      this.shaderProgram.use();

      this.currentSpriteSheet = null;
      this.vertexArrayIndex = 0;
      this.drawCount = 0;
    },

    processDrawable: function( drawable ) {
      // skip unloaded images or sprites
      if ( !drawable.sprite ) {
        return;
      }

      assert && assert( drawable.webglRenderer === Renderer.webglTexturedTriangles );
      if ( this.currentSpriteSheet && drawable.sprite.spriteSheet !== this.currentSpriteSheet ) {
        this.draw();
      }
      this.currentSpriteSheet = drawable.sprite.spriteSheet;

      var vertexData = drawable.vertexArray;

      // if our vertex data won't fit, keep doubling the size until it fits
      while ( vertexData.length + this.vertexArrayIndex > this.vertexArray.length ) {
        var newVertexArray = new Float32Array( this.vertexArray.length * 2 );
        newVertexArray.set( this.vertexArray );
        this.vertexArray = newVertexArray;
      }

      // copy our vertex data into the main array
      this.vertexArray.set( vertexData, this.vertexArrayIndex );
      this.vertexArrayIndex += vertexData.length;
    },

    deactivate: function() {
      if ( this.currentSpriteSheet ) {
        this.draw();
      }

      this.shaderProgram.unuse();

      return this.drawCount;
    },

    // @private
    draw: function() {
      assert && assert( this.currentSpriteSheet );
      var gl = this.gl;

      // (uniform) projection transform into normalized device coordinates
      gl.uniformMatrix3fv( this.shaderProgram.uniformLocations.uProjectionMatrix, false, this.projectionMatrixArray );

      gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
      // if we increased in length, we need to do a full bufferData to resize it on the GPU side
      if ( this.vertexArray.length > this.lastArrayLength ) {
        gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
      }
      // otherwise do a more efficient update that only sends part of the array over
      else {
        gl.bufferSubData( gl.ARRAY_BUFFER, 0, this.vertexArray.subarray( 0, this.vertexArrayIndex ) );
      }

      var numComponents = 5;
      var sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;
      var stride = numComponents * sizeOfFloat;
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aVertex, 2, gl.FLOAT, false, stride, 0 * sizeOfFloat );
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * sizeOfFloat );
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aAlpha, 1, gl.FLOAT, false, stride, 4 * sizeOfFloat );

      gl.activeTexture( gl.TEXTURE0 );
      gl.bindTexture( gl.TEXTURE_2D, this.currentSpriteSheet.texture );
      gl.uniform1i( this.shaderProgram.uniformLocations.uTexture, 0 );

      gl.drawArrays( gl.TRIANGLES, 0, this.vertexArrayIndex / numComponents );

      gl.bindTexture( gl.TEXTURE_2D, null );

      this.drawCount++;

      this.currentSpriteSheet = null;
      this.vertexArrayIndex = 0;
    }
  } );

  Poolable.mixin( WebGLBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'new from constructor' );
          return new WebGLBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );

  return WebGLBlock;
} );

// Copyright 2014-2016, University of Colorado Boulder


/**
 * Abstract base type (and API) for stitching implementations. Stitching is:
 * A method of updating the blocks for a backbone (the changes from the previous frame to the current frame), and
 * setting up the drawables to be attached/detached from blocks. At a high level:
 *   - We have an ordered list of blocks displayed in the last frame.
 *   - We have an ordered list of drawables displayed in the last frame (and what block they are part of).
 *   - We have an ordered list of drawables that will be displayed in the next frame (and whether they were part of our
 *     backbone, and if so what block they were in).
 *   - We need to efficiently create/dispose required blocks, add/remove drawables from blocks, notify blocks of their
 *     drawable range, and ensure blocks are displayed back-to-front.
 *
 * Since stitching usually only involves one or a few small changes (except for on sim initialization), the stitch
 * method is provided with a list of intervals that were (potentially) changed. This consists of a linked-list of
 * intervals (it is constructed during recursion through a tree that skips known-unchanged subtrees). The intervals
 * are completely disjoint (don't overlap, and aren't adjacent - there is at least one drawable that is unchanged
 * in-between change intervals).
 *
 * Assumes the same object instance will be reused multiple times, possibly for different backbones.
 *
 * Any stitcher implementations should always call initialize() first and clean() at the end, so that we can set up
 * and then clean up any object references (allowing them to be garbage-collected or pooled more safely).
 *
 * Stitcher responsibilities:
 *   1. Blocks used in the previous frame but not used in the current frame (no drawables, not attached) should be
 *      marked for disposal.
 *   2. Blocks should be created as necessary.
 *   3. If a changed drawable is removed from a block, it should have notePendingRemoval called on it.
 *   4. If a changed drawable is added to a block, it should have notePendingAddition called on it.
 *   5. If an unchanged drawable is to have a block change, it should have notePendingMove called on it.
 *   6. New blocks should be added to the DOM (appendChild presumably)
 *   7. Removed blocks should be removed from the DOM (removeChild)
 *      NOTE: check for child-parent relationship, since DOM blocks (wrappers) may have been
 *      added to the DOM elsewhere in another backbone's stitch already (which in the DOM
 *      automatically removes it from our backbone's div)
 *   8. If a block's first or last drawable changes, it should have notifyInterval called on it.
 *   9. At the end of the stitch, the backbone should have a way of iterating over its blocks in order (preferably an
 *      Array for fast repaint iteration)
 *   10. New blocks should have setBlockBackbone( backbone ) called on them
 *   11. Blocks with any drawable change should have backbone.markDirtyDrawable( block ) called so it can be visited
 *       in the repaint phase.
 *   12. Blocks should have z-indices set in the proper stacking order (back to front), using backbone.reindexBlocks()
 *       or equivalent (it tries to change as few z-indices as possible).
 *
 * Stitcher desired behavior and optimizations:
 *   1. Reuse blocks of the same renderer type, instead of removing one and creating another.
 *   2. Minimize (as much as is possible) how many drawables are added and removed from blocks (try not to remove 1000
 *      drawables from A and add them to B if we could instead just add/remove 5 drawables from C to D)
 *   3. No more DOM manipulation than necessary
 *   4. Optimize first for "one or a few small change intervals" that only cause local changes (no blocks created,
 *      removed or reordered). It would be ideal to do this very quickly, so it could be done every frame in
 *      simulations.
 *
 * Current constraints:
 *   1. DOM drawables should be paired with exactly one block (basically a wrapper, they are inserted directly into the
 *      DOM, and a DOM block should only ever be given the same drawable.
 *   2. Otherwise, consecutive drawables with the same renderer should be part of the same block. In the future we will
 *      want to allow "gaps" to form between (if something with a different renderer gets added and removed a lot
 *      in-between), but we'll need to figure out performance-sensitive flags to indicate when this needs to not be
 *      done (opacity and types of blending require no gaps between same-renderer drawables).
 *
 * Gluing: consequences of "no gaps"
 * There are two (important) implications:
 * Gluing
 *   If we have the following blocks:
 *     … A (SVG), B (Canvas), C (SVG) ...
 *   and all drawables for for B are removed, the following would be invalid ("has a gap"):
 *     … A (SVG), C (SVG) …
 *   so we need to glue them together, usually either resulting in:
 *     … A (SVG) …
 *   or
 *     … C (SVG) …
 *   with A or C including all of the drawables that were in A and C.
 *   More generally:
 *     If a change interval used to have its before/after (unchanged) drawables on two
 *     different blocks and for the current frame there will be no blocks in-between,
 *     we will need to "glue".
 *   Additionally, note the case:
 *     … A (SVG), B (Canvas), C (DOM), D (SVG), E (Canvas), F (SVG).
 *   If B,C,E are all removed, the results of A,D,F will have to all be combined into one layer
 * Un-gluing
 *   If we have the following drawables, all part of one block:
 *     … a (svg), b (svg) …
 *   and we insert a drawable with a different renderer:
 *     … a (svg), c (canvas), b (svg) ...
 *   we will need to split them into to SVG blocks
 *   More generally:
 *     If a change interval used to have its before/after (unchanged) drawables included
 *     in the same block, and the current frame requires a block to be inserted
 *     in-between, we will need to "un-glue".
 * These consequences mean that "unchanged" drawables (outside of change intervals) may need to have their block changed
 * (with notePendingMove). For performance, please consider which "end" should keep its drawables (the other end's
 * drawables will ALL have to be added/removed, which can be a major performance loss if we choose the wrong one).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Stitcher',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable','SCENERY/display/Renderer','SCENERY/display/CanvasBlock','SCENERY/display/SVGBlock','SCENERY/display/DOMBlock','SCENERY/display/WebGLBlock'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var CanvasBlock = require( 'SCENERY/display/CanvasBlock' );
  var SVGBlock = require( 'SCENERY/display/SVGBlock' );
  var DOMBlock = require( 'SCENERY/display/DOMBlock' );
  var WebGLBlock = require( 'SCENERY/display/WebGLBlock' );

  function Stitcher( display, renderer ) {
    throw new Error( 'We are too abstract for that!' );
  }

  scenery.register( 'Stitcher', Stitcher );

  inherit( Object, Stitcher, {
    // Main stitch entry point, called directly from the backbone or cache. We are modifying our backbone's blocks and
    // their attached drawables.
    // @param {Drawable | null} firstStitchDrawable: What our backbone's first drawable will be after this stitch
    // @param {Drawable | null} lastStitchDrawable: What our backbone's last drawable will be after this stitch
    // @param {Drawable | null} oldFirstStitchDrawable: What our backbone's first drawable was before this stitch
    // @param {Drawable | null} oldLastStitchDrawable: What our backbone's last drawable was before this stitch
    // @param {ChangeInterval} firstChangeInterval: The first change interval of our interval linked-list
    // @param {ChangeInterval} lastChangeInterval: The last change interval of our interval linked-list
    // The change-interval pair denotes a linked-list of change intervals that we will need to stitch across (they
    // contain drawables that need to be removed and added, and it may affect how we lay out blocks in the stacking
    // order).
    initialize: function( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval ) {
      assert && assert( firstChangeInterval && lastChangeInterval, 'We are guaranteed at least one change interval' );
      assert && assert( !firstDrawable || firstDrawable.previousDrawable === null,
        'End boundary of drawable linked list should link to null' );
      assert && assert( !lastDrawable || lastDrawable.nextDrawable === null,
        'End boundary of drawable linked list should link to null' );

      if ( sceneryLog && sceneryLog.Stitch ) {
        sceneryLog.Stitch( 'stitch ' + backbone.toString() +
                           ' first:' + ( firstDrawable ? firstDrawable.toString() : 'null' ) +
                           ' last:' + ( lastDrawable ? lastDrawable.toString() : 'null' ) +
                           ' oldFirst:' + ( oldFirstDrawable ? oldFirstDrawable.toString() : 'null' ) +
                           ' oldLast:' + ( oldLastDrawable ? oldLastDrawable.toString() : 'null' ) );
        sceneryLog.push();
      }
      if ( sceneryLog && sceneryLog.StitchDrawables ) {
        sceneryLog.StitchDrawables( 'Before:' );
        sceneryLog.push();
        Stitcher.debugDrawables( oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval, false );
        sceneryLog.pop();

        sceneryLog.StitchDrawables( 'After:' );
        sceneryLog.push();
        Stitcher.debugDrawables( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval, true );
        sceneryLog.pop();
      }

      this.backbone = backbone;
      this.firstDrawable = firstDrawable;
      this.lastDrawable = lastDrawable;

      // list of blocks that have their pendingFirstDrawable or pendingLastDrawable set, and need updateInterval() called
      this.touchedBlocks = cleanArray( this.touchedBlocks );

      if ( assertSlow ) {
        assertSlow( !this.initialized, 'We should not be already initialized (clean should be called)' );
        this.initialized = true;
        this.reindexed = false;

        this.pendingAdditions = [];
        this.pendingRemovals = [];
        this.pendingMoves = [];
        this.createdBlocks = [];
        this.disposedBlocks = [];
        this.intervalsNotified = [];
        this.boundariesRecorded = false;

        this.previousBlocks = backbone.blocks.slice( 0 ); // copy of previous blocks
      }
    },

    // Removes object references
    clean: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'clean' );
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( '-----------------------------------' );

      if ( assertSlow ) {
        this.auditStitch();

        this.initialized = false;
      }

      this.backbone = null;
      this.firstDrawable = null;
      this.lastDrawable = null;

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Writes the first/last drawables for the entire backbone into its memory. We want to wait to do this until we have
    // read from its previous values.
    recordBackboneBoundaries: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'recording backbone boundaries: ' +
                                                            ( this.firstDrawable ? this.firstDrawable.toString() : 'null' ) +
                                                            ' to ' +
                                                            ( this.lastDrawable ? this.lastDrawable.toString() : 'null' ) );
      this.backbone.previousFirstDrawable = this.firstDrawable;
      this.backbone.previousLastDrawable = this.lastDrawable;

      if ( assertSlow ) {
        this.boundariesRecorded = true;
      }
    },

    // Records that this {Drawable} drawable should be added/moved to the {Block} at a later time
    notePendingAddition: function( drawable, block ) {
      assert && assert( drawable.renderer === block.renderer );

      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending add: ' + drawable.toString() + ' to ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      drawable.notePendingAddition( this.backbone.display, block, this.backbone );

      if ( assertSlow ) {
        this.pendingAdditions.push( {
          drawable: drawable,
          block: block
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Records that this {Drawable} drawable should be moved to the {Block} at a later time (called only on external
    // drawables). notePendingAddition and notePendingRemoval should not be called on a drawable that had
    // notePendingMove called on it during the same stitch, and vice versa.
    notePendingMove: function( drawable, block ) {
      assert && assert( drawable.renderer === block.renderer );

      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending move: ' + drawable.toString() + ' to ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      drawable.notePendingMove( this.backbone.display, block );

      if ( assertSlow ) {
        this.pendingMoves.push( {
          drawable: drawable,
          block: block
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Records that this {Drawable} drawable should be removed/moved from the {Block} at a later time
    notePendingRemoval: function( drawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending remove: ' + drawable.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      drawable.notePendingRemoval( this.backbone.display );

      if ( assertSlow ) {
        this.pendingRemovals.push( {
          drawable: drawable
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Records that this {Block} block should be disposed at a later time. It should not be in the blocks array at the
    // end of the stitch.
    markBlockForDisposal: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'block for disposal: ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      //TODO: PERFORMANCE: does this cause reflows / style calculation
      if ( block.domElement.parentNode === this.backbone.domElement ) {
        // guarded, since we may have a (new) child drawable add it before we can remove it
        this.backbone.domElement.removeChild( block.domElement );
      }
      block.markForDisposal( this.backbone.display );

      if ( assertSlow ) {
        this.disposedBlocks.push( {
          block: block
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    removeAllBlocks: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking all blocks for disposal (count ' + this.backbone.blocks.length + ')' );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      while ( this.backbone.blocks.length ) {
        var block = this.backbone.blocks[ 0 ];

        this.removeBlock( block );
        this.markBlockForDisposal( block );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Immediately notify a block of its first/last drawable.
    notifyInterval: function( block, firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'notify interval: ' + block.toString() + ' ' +
                                                            firstDrawable.toString() + ' to ' + lastDrawable.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();

      block.notifyInterval( firstDrawable, lastDrawable );

      // mark it dirty, since its drawables probably changed?
      //OHTWO TODO: is this necessary? What is this doing?
      this.backbone.markDirtyDrawable( block );

      if ( assertSlow ) {
        this.intervalsNotified.push( {
          block: block,
          firstDrawable: firstDrawable,
          lastDrawable: lastDrawable
        } );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },

    // Note a block's tentative first drawable and block before (should be flushed later with updateBlockIntervals())
    markBeforeBlock: function( block, firstDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking block first drawable ' + block.toString() + ' with ' + firstDrawable.toString() );

      block.pendingFirstDrawable = firstDrawable;
      this.touchedBlocks.push( block );
    },
    // Note a block's tentative last drawable and block after (should be flushed later with updateBlockIntervals())
    markAfterBlock: function( block, lastDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking block last drawable ' + block.toString() + ' with ' + lastDrawable.toString() );

      block.pendingLastDrawable = lastDrawable;
      this.touchedBlocks.push( block );
    },
    // Flushes markBeforeBlock/markAfterBlock changes to notifyInterval on blocks themselves.
    updateBlockIntervals: function() {
      while ( this.touchedBlocks.length ) {
        var block = this.touchedBlocks.pop();

        if ( block.used ) {
          sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'update interval: ' + block.toString() + ' ' +
                                                                block.pendingFirstDrawable.toString() + ' to ' + block.pendingLastDrawable.toString() );

          block.updateInterval();

          // mark it dirty, since its drawables probably changed?
          //OHTWO TODO: is this necessary? What is this doing?
          this.backbone.markDirtyDrawable( block );

          if ( assertSlow ) {
            this.intervalsNotified.push( {
              block: block,
              firstDrawable: block.pendingFirstDrawable,
              lastDrawable: block.pendingLastDrawable
            } );
          }
        }
        else {
          sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'skipping update interval: ' + block.toString() + ', unused' );
        }
      }
    },

    // Creates a fresh block with the desired renderer and {Drawable} arbitrary drawable included, and adds it to
    // our DOM.
    createBlock: function( renderer, drawable ) {
      var backbone = this.backbone;
      var block;

      if ( Renderer.isCanvas( renderer ) ) {
        block = CanvasBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else if ( Renderer.isSVG( renderer ) ) {
        //OHTWO TODO: handle filter root separately from the backbone instance?
        block = SVGBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else if ( Renderer.isDOM( renderer ) ) {
        block = DOMBlock.createFromPool( backbone.display, drawable );
      }
      else if ( Renderer.isWebGL( renderer ) ) {
        block = WebGLBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else {
        throw new Error( 'unsupported renderer for createBlock: ' + renderer );
      }

      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'created block: ' + block.toString() +
                                                            ' with renderer: ' + renderer +
                                                            ' for drawable: ' + drawable.toString() );

      block.setBlockBackbone( backbone );

      //OHTWO TODO: minor speedup by appending only once its fragment is constructed? or use DocumentFragment?
      backbone.domElement.appendChild( block.domElement );

      // if backbone is a display root, hide all of its content from screen readers
      if ( backbone.isDisplayRoot ) {
        block.domElement.setAttribute( 'aria-hidden', true );
      }

      // mark it dirty for now, so we can check
      backbone.markDirtyDrawable( block );

      if ( assertSlow ) {
        this.createdBlocks.push( {
          block: block,
          renderer: renderer,
          drawable: drawable
        } );
      }

      return block;
    },

    // Immediately appends a block to our blocks array
    appendBlock: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'appending block: ' + block.toString() );

      this.backbone.blocks.push( block );

      if ( assertSlow ) {
        this.reindexed = false;
      }
    },

    // Immediately removes a block to our blocks array
    removeBlock: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'removing block: ' + block.toString() );

      // remove the block from our internal list
      var blockIndex = _.indexOf( this.backbone.blocks, block );
      assert && assert( blockIndex >= 0, 'Cannot remove block, not attached: ' + block.toString() );
      this.backbone.blocks.splice( blockIndex, 1 );

      if ( assertSlow ) {
        this.reindexed = false;
      }
    },

    useNoBlocks: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'using no blocks' );

      // i.e. we will not use any blocks
      cleanArray( this.backbone.blocks );
    },

    // Triggers all blocks in the blocks array to have their z-index properties set so that they visually stack
    // correctly.
    reindex: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'reindexing blocks' );

      this.backbone.reindexBlocks();

      if ( assertSlow ) {
        this.reindexed = true;
      }
    },

    // An audit for testing assertions
    auditStitch: function() {
      if ( assertSlow ) {
        var self = this;

        var blocks = self.backbone.blocks;
        var previousBlocks = self.previousBlocks;

        assertSlow( self.initialized, 'We seem to have finished a stitch without proper initialization' );
        assertSlow( self.boundariesRecorded, 'Our stitch API requires recordBackboneBoundaries() to be called before' +
                                                 ' it is finished.' );

        // ensure our indices are up-to-date (reindexed, or did not change)
        assertSlow( self.reindexed || blocks.length === 0 ||
                    // array equality of previousBlocks and blocks
                    ( previousBlocks.length === blocks.length &&
                      _.every( _.zip( previousBlocks, blocks ), function( arr ) {
                        return arr[ 0 ] === arr[ 1 ];
                      } ) ),
          'Did not reindex on a block change where we are left with blocks' );

        // all created blocks had intervals notified
        _.each( self.createdBlocks, function( blockData ) {
          assertSlow( _.some( self.intervalsNotified, function( intervalData ) {
            return blockData.block === intervalData.block;
          } ), 'Created block does not seem to have an interval notified: ' + blockData.block.toString() );
        } );

        // no disposed blocks had intervals notified
        _.each( self.disposedBlocks, function( blockData ) {
          assertSlow( !_.some( self.intervalsNotified, function( intervalData ) {
            return blockData.block === intervalData.block;
          } ), 'Removed block seems to have an interval notified: ' + blockData.block.toString() );
        } );

        // all drawables for disposed blocks have been marked as pending removal (or moved)
        _.each( self.disposedBlocks, function( blockData ) {
          var block = blockData.block;
          _.each( Drawable.oldListToArray( block.firstDrawable, block.lastDrawable ), function( drawable ) {
            assertSlow( _.some( self.pendingRemovals, function( removalData ) {
                return removalData.drawable === drawable;
              } ) || _.some( self.pendingMoves, function( moveData ) {
                return moveData.drawable === drawable;
              } ), 'Drawable ' + drawable.toString() + ' originally listed for disposed block ' + block.toString() +
                   ' does not seem to be marked for pending removal or move!' );
          } );
        } );

        // all drawables for created blocks have been marked as pending addition or moved for our block
        _.each( self.createdBlocks, function( blockData ) {
          var block = blockData.block;
          _.each( Drawable.listToArray( block.pendingFirstDrawable, block.pendingLastDrawable ), function( drawable ) {
            assertSlow( _.some( self.pendingAdditions, function( additionData ) {
                return additionData.drawable === drawable && additionData.block === block;
              } ) || _.some( self.pendingMoves, function( moveData ) {
                return moveData.drawable === drawable && moveData.block === block;
              } ), 'Drawable ' + drawable.toString() + ' now listed for created block ' + block.toString() +
                   ' does not seem to be marked for pending addition or move!' );
          } );
        } );

        // all disposed blocks should have been removed
        _.each( self.disposedBlocks, function( blockData ) {
          var blockIdx = _.indexOf( blocks, blockData.block );
          assertSlow( blockIdx < 0, 'Disposed block ' + blockData.block.toString() + ' still present at index ' + blockIdx );
        } );

        // all created blocks should have been added
        _.each( self.createdBlocks, function( blockData ) {
          var blockIdx = _.indexOf( blocks, blockData.block );
          assertSlow( blockIdx >= 0, 'Created block ' + blockData.block.toString() + ' is not in the blocks array' );
        } );

        // all current blocks should be marked as used
        _.each( blocks, function( block ) {
          assertSlow( block.used, 'All current blocks should be marked as used' );
        } );

        assertSlow( blocks.length - previousBlocks.length === self.createdBlocks.length - self.disposedBlocks.length,
          'The count of unmodified blocks should be constant (equal differences):\n' +
          'created: ' + _.map( self.createdBlocks, function( n ) { return n.block.id; } ).join( ',' ) + '\n' +
          'disposed: ' + _.map( self.disposedBlocks, function( n ) { return n.block.id; } ).join( ',' ) + '\n' +
          'before: ' + _.map( previousBlocks, function( n ) { return n.id; } ).join( ',' ) + '\n' +
          'after: ' + _.map( blocks, function( n ) { return n.id; } ).join( ',' ) );

        assertSlow( this.touchedBlocks.length === 0,
          'If we marked any blocks for changes, we should have called updateBlockIntervals' );

        if ( blocks.length ) {

          assertSlow( self.backbone.previousFirstDrawable !== null &&
                      self.backbone.previousLastDrawable !== null,
            'If we are left with at least one block, we must be tracking at least one drawable' );

          assertSlow( blocks[ 0 ].pendingFirstDrawable === self.backbone.previousFirstDrawable,
            'Our first drawable should match the first drawable of our first block' );

          assertSlow( blocks[ blocks.length - 1 ].pendingLastDrawable === self.backbone.previousLastDrawable,
            'Our last drawable should match the last drawable of our last block' );

          for ( var i = 0; i < blocks.length - 1; i++ ) {
            // [i] and [i+1] are a pair of consecutive blocks
            assertSlow( blocks[ i ].pendingLastDrawable.nextDrawable === blocks[ i + 1 ].pendingFirstDrawable &&
                        blocks[ i ].pendingLastDrawable === blocks[ i + 1 ].pendingFirstDrawable.previousDrawable,
              'Consecutive blocks should have boundary drawables that are also consecutive in the linked list' );
          }
        }
        else {
          assertSlow( self.backbone.previousFirstDrawable === null &&
                      self.backbone.previousLastDrawable === null,
            'If we are left with no blocks, it must mean we are tracking precisely zero drawables' );
        }
      }
    }
  } );

  Stitcher.debugIntervals = function( firstChangeInterval ) {
    if ( sceneryLog && sceneryLog.Stitch ) {
      for ( var debugInterval = firstChangeInterval; debugInterval !== null; debugInterval = debugInterval.nextChangeInterval ) {
        sceneryLog.Stitch( '  interval: ' +
                           ( debugInterval.isEmpty() ? '(empty) ' : '' ) +
                           ( debugInterval.drawableBefore ? debugInterval.drawableBefore.toString() : '-' ) + ' to ' +
                           ( debugInterval.drawableAfter ? debugInterval.drawableAfter.toString() : '-' ) );
      }
    }
  };

  // logs a bunch of information about the old (useCurrent===false) or new (useCurrent===true) drawable linked list.
  Stitcher.debugDrawables = function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval, useCurrent ) {
    if ( sceneryLog && sceneryLog.StitchDrawables ) {
      if ( firstDrawable === null ) {
        sceneryLog.StitchDrawables( 'nothing', 'color: #666;' );
        return;
      }

      var isChanged = firstChangeInterval.drawableBefore === null;
      var currentInterval = firstChangeInterval;

      for ( var drawable = firstDrawable; ; drawable = ( useCurrent ? drawable.nextDrawable : drawable.oldNextDrawable ) ) {
        if ( isChanged && drawable === currentInterval.drawableAfter ) {
          isChanged = false;
          currentInterval = currentInterval.nextChangeInterval;
        }

        var drawableString = drawable.renderer + ' ' + ( ( !useCurrent && drawable.parentDrawable ) ? drawable.parentDrawable.toString() : '' ) + ' ' + drawable.toDetailedString();
        sceneryLog.StitchDrawables( drawableString, isChanged ? ( useCurrent ? 'color: #0a0;' : 'color: #a00;' ) : 'color: #666' );

        if ( !isChanged && currentInterval && currentInterval.drawableBefore === drawable ) {
          isChanged = true;
        }

        if ( drawable === lastDrawable ) {
          break;
        }
      }
    }
  };

  return Stitcher;
} );

// Copyright 2014-2015, University of Colorado Boulder


/**
 * Stitcher that only rebuilds the parts necessary, and attempts greedy block matching as an optimization.
 *
 * Given a list of change intervals, our greedy stitcher breaks it down into 'sub-blocks' consisting of
 * drawables that are 'internal' to the change interval that all have the same renderer, and handles the
 * glue/unglue/matching situations in a greedy way by always using the first possible (allowing only one sweep
 * instead of multiple ones over the drawable linked list for this process).
 *
 * Conceptually, we break down drawables into groups that are 'internal' to each change interval (inside, not
 * including the un-changed ends), and 'external' (that are not internal to any intervals).
 *
 * For each interval, we first make sure that the next 'external' group of drawables has the proper blocks (for
 * instance, this can change with a glue/unglue operation, with processEdgeCases), then proceed to break the 'internal'
 * drawables into sub-blocks and process those with processSubBlock.
 *
 * Our stitcher has a list of blocks noted as 'reusable' that we use for two purposes:
 *   1. So that we can shift blocks to where they are needed, instead of removing (e.g.) an SVG block and
 *      creating another.
 *   2. So that blocks that are unused at the end of our stitch can be removed, and marked for disposal.
 * At the start of the stitch, we mark completely 'internal' blocks as reusable, so they can be shifted around as
 * necessary (used in a greedy way which may not be optimal). It's also possible during later phases for blocks that
 * also contain 'external' drawables to be marked as reusable, due to glue cases where before we needed multiple
 * blocks and now we only need one.
 *
 * We also use a linked-list of blocks during stitch operations (that then re-builds an array of blocks on any changes
 * after all stitching is done) for simplicity, and to avoid O(n^2) cases that would result from having to look up
 * indices in the block array during stitching.
 *
 * NOTE: Stitcher instances may be reused many times, even with different backbones. It should always release any
 * object references that it held after usage.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/GreedyStitcher',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/display/Stitcher'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );

  // Returns whether the consecutive {Drawable}s 'a' and 'b' should be put into separate blocks
  function hasGapBetweenDrawables( a, b ) {
    return a.renderer !== b.renderer || Renderer.isDOM( a.renderer ) || Renderer.isDOM( b.renderer );
  }

  // Whether the drawable and its previous sibling should be in the same block. Will be false if there is no sibling
  function isOpenBefore( drawable ) {
    return drawable.previousDrawable !== null && !hasGapBetweenDrawables( drawable.previousDrawable, drawable );
  }

  // Whether the drawable and its next sibling should be in the same block. Will be false if there is no sibling
  function isOpenAfter( drawable ) {
    return drawable.nextDrawable !== null && !hasGapBetweenDrawables( drawable, drawable.nextDrawable );
  }

  // If the change interval will contain any new (added) drawables
  function intervalHasNewInternalDrawables( interval, firstStitchDrawable, lastStitchDrawable ) {
    if ( interval.drawableBefore ) {
      return interval.drawableBefore.nextDrawable !== interval.drawableAfter; // OK for after to be null
    }
    else if ( interval.drawableAfter ) {
      return interval.drawableAfter.previousDrawable !== interval.drawableBefore; // OK for before to be null
    }
    else {
      return firstStitchDrawable !== null;
    }
  }

  // If the change interval contained any drawables that are to be removed
  function intervalHasOldInternalDrawables( interval, oldFirstStitchDrawable, oldLastStitchDrawable ) {
    if ( interval.drawableBefore ) {
      return interval.drawableBefore.oldNextDrawable !== interval.drawableAfter; // OK for after to be null
    }
    else if ( interval.drawableAfter ) {
      return interval.drawableAfter.oldPreviousDrawable !== interval.drawableBefore; // OK for before to be null
    }
    else {
      return oldFirstStitchDrawable !== null;
    }
  }

  // Whether there are blocks that consist of drawables that are ALL internal to the {ChangeInterval} interval.
  function intervalHasOldInternalBlocks( interval, firstStitchBlock, lastStitchBlock ) {
    var beforeBlock = interval.drawableBefore ? interval.drawableBefore.parentDrawable : null;
    var afterBlock = interval.drawableAfter ? interval.drawableAfter.parentDrawable : null;

    if ( beforeBlock && afterBlock && beforeBlock === afterBlock ) {
      return false;
    }

    if ( beforeBlock ) {
      return beforeBlock.nextBlock !== afterBlock; // OK for after to be null
    }
    else if ( afterBlock ) {
      return afterBlock.previousBlock !== beforeBlock; // OK for before to be null
    }
    else {
      return firstStitchBlock !== null;
    }
  }

  /**
   * Finds the furthest external drawable that:
   * (a) Before the next change interval (if we have a next change interval)
   * (b) Has the same renderer as the interval's drawableAfter
   */
  function getLastCompatibleExternalDrawable( interval ) {
    var firstDrawable = interval.drawableAfter;

    if ( firstDrawable ) {
      var renderer = firstDrawable.renderer;

      // we stop our search before we reach this (null is acceptable), ensuring we don't go into the next change interval
      var cutoffDrawable = interval.nextChangeInterval ? interval.nextChangeInterval.drawableBefore.nextDrawable : null;

      var drawable = firstDrawable;

      while ( true ) { //eslint-disable-line no-constant-condition
        var nextDrawable = drawable.nextDrawable;

        // first comparison also does null check when necessary
        if ( nextDrawable !== cutoffDrawable && nextDrawable.renderer === renderer ) {
          drawable = nextDrawable;
        }
        else {
          break;
        }
      }

      return drawable;
    }
    else {
      return null; // with no drawableAfter, we don't have any external drawables after our interval
    }
  }

  var prototype = {
    // Main stitch entry point, called directly from the backbone or cache. We are modifying our backbone's blocks and
    // their attached drawables.
    // @param {Drawable | null} firstStitchDrawable: What our backbone's first drawable will be after this stitch
    // @param {Drawable | null} lastStitchDrawable: What our backbone's last drawable will be after this stitch
    // @param {Drawable | null} oldFirstStitchDrawable: What our backbone's first drawable was before this stitch
    // @param {Drawable | null} oldLastStitchDrawable: What our backbone's last drawable was before this stitch
    // @param {ChangeInterval} firstChangeInterval: The first change interval of our interval linked-list
    // @param {ChangeInterval} lastChangeInterval: The last change interval of our interval linked-list
    // The change-interval pair denotes a linked-list of change intervals that we will need to stitch across (they
    // contain drawables that need to be removed and added, and it may affect how we lay out blocks in the stacking
    // order).
    stitch: function( backbone, firstStitchDrawable, lastStitchDrawable, oldFirstStitchDrawable, oldLastStitchDrawable, firstChangeInterval, lastChangeInterval ) {
      // required call to the Stitcher interface (see Stitcher.initialize()).
      this.initialize( backbone, firstStitchDrawable, lastStitchDrawable, oldFirstStitchDrawable, oldLastStitchDrawable, firstChangeInterval, lastChangeInterval );

      // Tracks whether our order of blocks changed. If it did, we'll need to rebuild our blocks array. This flag is
      // set if we remove any blocks, create any blocks, or change the order between two blocks (via linkBlocks).
      // It does NOT occur in unuseBlock, since we may reuse the same block in the same position (thus not having an
      // order change).
      this.blockOrderChanged = false;

      // List of blocks that (in the current part of the stitch being processed) are not set to be used by any
      // drawables. Blocks are added to here when they are fully internal to a change interval, and when we glue
      // blocks together. They can be reused through the block-matching process. If they are not reused at the end of
      // this stitch, they will be marked for removal.
      this.reusableBlocks = cleanArray( this.reusableBlocks ); // re-use instance, since we are effectively pooled

      // To properly handle glue/unglue situations with external blocks (ones that aren't reusable after phase 1),
      // we need some extra tracking for our inner sub-block edge case loop.
      this.blockWasAdded = false; // we need to know if a previously-existing block was added, and remove it otherwise.

      var interval;

      // record current first/last drawables for the entire backbone
      this.recordBackboneBoundaries();

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 1: old linked list' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      // Handle pending removal of old blocks/drawables. First, we need to mark all 'internal' drawables with
      // notePendingRemoval(), so that if they aren't added back in this backbone, that they are removed from their
      // old block. Note that later we will add the ones that stay on this backbone, so that they only either change
      // blocks, or stay on the same block.
      if ( backbone.blocks.length ) {
        var veryFirstBlock = backbone.blocks[ 0 ];
        var veryLastBlock = backbone.blocks[ backbone.blocks.length - 1 ];

        for ( interval = firstChangeInterval; interval !== null; interval = interval.nextChangeInterval ) {
          assert && assert( !interval.isEmpty(), 'We now guarantee that the intervals are non-empty' );

          // First, we need to mark all old 'internal' drawables with notePendingRemoval(), so that if they aren't added
          // back in this backbone, that they are removed from their old block. Note that later we will add the ones
          // that stay on this backbone, so that they only either change blocks, or stay on the same block.
          if ( intervalHasOldInternalDrawables( interval, oldFirstStitchDrawable, oldLastStitchDrawable ) ) {
            var firstRemoval = interval.drawableBefore ?
                               interval.drawableBefore.oldNextDrawable :
                               oldFirstStitchDrawable;
            var lastRemoval = interval.drawableAfter ?
                              interval.drawableAfter.oldPreviousDrawable :
                              oldLastStitchDrawable;

            // drawable iteration on the 'old' linked list
            for ( var removedDrawable = firstRemoval; ; removedDrawable = removedDrawable.oldNextDrawable ) {
              this.notePendingRemoval( removedDrawable );
              if ( removedDrawable === lastRemoval ) { break; }
            }
          }

          // Blocks totally contained within the change interval are marked as reusable (doesn't include end blocks).
          if ( intervalHasOldInternalBlocks( interval, veryFirstBlock, veryLastBlock ) ) {
            var firstBlock = interval.drawableBefore === null ? backbone.blocks[ 0 ] : interval.drawableBefore.parentDrawable.nextBlock;
            var lastBlock = interval.drawableAfter === null ? backbone.blocks[ backbone.blocks.length - 1 ] : interval.drawableAfter.parentDrawable.previousBlock;

            for ( var markedBlock = firstBlock; ; markedBlock = markedBlock.nextBlock ) {
              this.unuseBlock( markedBlock );
              if ( markedBlock === lastBlock ) { break; }
            }
          }
        }
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 2: new linked list' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      // Don't process the single interval left if we aren't left with any drawables (thus left with no blocks)
      if ( firstStitchDrawable ) {
        for ( interval = firstChangeInterval; interval !== null; interval = interval.nextChangeInterval ) {
          this.processInterval( backbone, interval, firstStitchDrawable, lastStitchDrawable );
        }
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 3: cleanup' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      // Anything in our 'reusable' blocks array should be removed from our DOM and marked for disposal.
      this.removeUnusedBlocks();

      // Fire off notifyInterval calls to blocks if their boundaries (first/last drawables) have changed. This is
      // a necessary call since we used markBeforeBlock/markAfterBlock to record block boundaries as we went along.
      // We don't want to do this synchronously, because then you could update a block's boundaries multiple times,
      // which may be expensive.
      this.updateBlockIntervals();

      if ( firstStitchDrawable === null ) {
        // i.e. clear our blocks array
        this.useNoBlocks();
      }
      else if ( this.blockOrderChanged ) {
        // Rebuild our blocks array from the linked list format we used for recording our changes (avoids O(n^2)
        // situations since we don't need to do array index lookups while making changes, but only at the end).
        this.processBlockLinkedList( backbone, firstStitchDrawable.pendingParentDrawable, lastStitchDrawable.pendingParentDrawable );

        // Actually reindex the DOM elements of the blocks (changing as necessary)
        this.reindex();
      }

      // required call to the Stitcher interface (see Stitcher.clean()).
      this.clean();

      // release the references we made in this type
      cleanArray( this.reusableBlocks );

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },

    // does the main bulk of the work for each change interval
    processInterval: function( backbone, interval, firstStitchDrawable, lastStitchDrawable ) {
      assert && assert( interval instanceof scenery.ChangeInterval );
      assert && assert( firstStitchDrawable instanceof scenery.Drawable, 'We assume we have a non-null remaining section' );
      assert && assert( lastStitchDrawable instanceof scenery.Drawable, 'We assume we have a non-null remaining section' );
      assert && assert( !interval.isEmpty(), 'We now guarantee that the intervals are non-empty' );

      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'interval: ' +
                                                                          ( interval.drawableBefore ? interval.drawableBefore.toString() : 'null' ) +
                                                                          ' to ' +
                                                                          ( interval.drawableAfter ? interval.drawableAfter.toString() : 'null' ) );
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();

      // check if our interval removes everything, we may need a glue
      if ( !intervalHasNewInternalDrawables( interval, firstStitchDrawable, lastStitchDrawable ) ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'no current internal drawables in interval' );

        // separate if, last condition above would cause issues with the normal operation branch
        if ( interval.drawableBefore && interval.drawableAfter ) {
          assert && assert( interval.drawableBefore.nextDrawable === interval.drawableAfter );

          // if we removed everything (no new internal drawables), our drawableBefore is open 'after', if our
          // drawableAfter is open 'before' since they are siblings (only one flag needed).
          var isOpen = !hasGapBetweenDrawables( interval.drawableBefore, interval.drawableAfter );

          // handle glue/unglue or any other 'external' changes
          this.processEdgeCases( interval, isOpen, isOpen );
        }

        if ( interval.drawableBefore && !isOpenAfter( interval.drawableBefore ) ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-after collapsed link:' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.linkAfterDrawable( interval.drawableBefore );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }
        else if ( interval.drawableAfter && !isOpenBefore( interval.drawableAfter ) ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-before collapsed link:' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.linkBeforeDrawable( interval.drawableAfter );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }
      }
      // otherwise normal operation
      else {
        var drawable = interval.drawableBefore ? interval.drawableBefore.nextDrawable : firstStitchDrawable;

        // if we have any current drawables at all
        var subBlockFirstDrawable = null;
        var matchedBlock = null;
        var isFirst = true;

        // separate our new-drawable linked-list into sub-blocks that we will process individually
        while ( true ) { //eslint-disable-line no-constant-condition
          var nextDrawable = drawable.nextDrawable;
          var isLast = nextDrawable === interval.drawableAfter;

          assert && assert( nextDrawable !== null || isLast, 'If our nextDrawable is null, isLast must be true' );

          if ( !subBlockFirstDrawable ) {
            subBlockFirstDrawable = drawable;
          }

          // See if any of our 'new' drawables were part of a block that we've marked as reusable. If this is the case,
          // we'll greedily try to use this block for matching if possible (ignoring the other potential matches for
          // other drawables after in the same sub-block).
          if ( matchedBlock === null && drawable.parentDrawable && !drawable.parentDrawable.used && drawable.backbone === backbone &&
               drawable.parentDrawable.parentDrawable === backbone ) {
            matchedBlock = drawable.parentDrawable;
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'matching at ' + drawable.toString() + ' with ' + matchedBlock );
          }

          if ( isLast || hasGapBetweenDrawables( drawable, nextDrawable ) ) {
            if ( isFirst ) {
              // we'll handle any glue/unglue at the start, so every processSubBlock can be set correctly.
              this.processEdgeCases( interval, isOpenBefore( subBlockFirstDrawable ), isOpenAfter( drawable ) );
            }

            // do the necessary work for each sub-block (adding drawables, linking, using matched blocks)
            this.processSubBlock( interval, subBlockFirstDrawable, drawable, matchedBlock, isFirst, isLast );

            subBlockFirstDrawable = null;
            matchedBlock = null;
            isFirst = false;
          }

          if ( isLast ) {
            break;
          }
          else {
            drawable = nextDrawable;
          }
        }
      }


      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
    },

    // firstDrawable and lastDrawable refer to the specific sub-block
    processSubBlock: function( interval, firstDrawable, lastDrawable, matchedBlock, isFirst, isLast ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose(
        'sub-block: ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() + ' ' +
        ( matchedBlock ? 'with matched: ' + matchedBlock.toString() : 'with no match' ) );
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();

      var openBefore = isOpenBefore( firstDrawable );
      var openAfter = isOpenAfter( lastDrawable );

      assert && assert( !openBefore || isFirst, 'openBefore implies isFirst' );
      assert && assert( !openAfter || isLast, 'openAfter implies isLast' );

      assert && assert( !openBefore || !openAfter || firstDrawable.previousDrawable.pendingParentDrawable === lastDrawable.nextDrawable.pendingParentDrawable,
        'If we would use both the before and after blocks, make sure any gluing ' );

      // if our sub-block gets combined into the previous block, use its block instead of any match-scanned blocks
      if ( openBefore ) {
        matchedBlock = firstDrawable.previousDrawable.pendingParentDrawable;
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'combining into before block: ' + matchedBlock.toString() );
      }

      // if our sub-block gets combined into the next block, use its block instead of any match-scanned blocks
      if ( openAfter ) {
        matchedBlock = lastDrawable.nextDrawable.pendingParentDrawable;
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'combining into after block: ' + matchedBlock.toString() );
      }

      // create a block if matchedBlock is null, otherwise mark it as used (if it is in reusableBlocks)
      matchedBlock = this.ensureUsedBlock( matchedBlock, firstDrawable );

      // add internal drawables
      for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
        this.notePendingAddition( drawable, matchedBlock );
        if ( drawable === lastDrawable ) { break; }
      }

      // link our blocks (and set pending block boundaries) as needed. assumes glue/unglue has already been performed
      if ( !openBefore ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-before link:' );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
        this.linkBeforeDrawable( firstDrawable );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }
      if ( isLast && !openAfter ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'last closed-after link:' );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
        this.linkAfterDrawable( lastDrawable );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }

      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
    },

    // firstDrawable and lastDrawable refer to the specific sub-block (if it exists), isLast refers to if it's the
    // last sub-block
    processEdgeCases: function( interval, openBefore, openAfter ) {
      // this test passes for glue and unglue cases
      if ( interval.drawableBefore !== null && interval.drawableAfter !== null ) {
        var beforeBlock = interval.drawableBefore.pendingParentDrawable;
        var afterBlock = interval.drawableAfter.pendingParentDrawable;
        var nextAfterBlock = ( interval.nextChangeInterval && interval.nextChangeInterval.drawableAfter ) ?
                             interval.nextChangeInterval.drawableAfter.pendingParentDrawable :
                             null;

        // Since we want to remove any afterBlock at the end of its run if we don't have blockWasAdded set, this check
        // is necessary to see if we have already used this specific block.
        // Otherwise, we would remove our (potentially very-first) block when it has already been used externally.
        if ( beforeBlock === afterBlock ) {
          this.blockWasAdded = true;
        }

        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose(
          'edge case: ' +
          ( openBefore ? 'open-before ' : '' ) +
          ( openAfter ? 'open-after ' : '' ) +
          beforeBlock.toString() + ' to ' + afterBlock.toString() );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();

        // deciding what new block should be used for the external group of drawables after our change interval
        var newAfterBlock;
        // if we have no gaps/boundaries, we should not have two different blocks
        if ( openBefore && openAfter ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'glue using ' + beforeBlock.toString() );
          newAfterBlock = beforeBlock;
        }
        else {
          // if we can't use our afterBlock, since it was used before, or wouldn't create a split
          if ( this.blockWasAdded || beforeBlock === afterBlock ) {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'split with fresh block' );
            // for simplicity right now, we always create a fresh block (to avoid messing up reused blocks) after, and
            // always change everything after (instead of before), so we don't have to jump across multiple previous
            // change intervals
            newAfterBlock = this.createBlock( interval.drawableAfter.renderer, interval.drawableAfter );
            this.blockOrderChanged = true; // needs to be done on block creation
          }
          // otherwise we can use our after block
          else {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'split with same afterBlock ' + afterBlock.toString() );
            newAfterBlock = afterBlock;
          }
        }

        // If we didn't change our block, mark it as added so we don't remove it.
        if ( afterBlock === newAfterBlock ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'no externals change here (blockWasAdded => true)' );
          this.blockWasAdded = true;
        }
        // Otherwise if we changed the block, move over only the external drawables between this interval and the next
        // interval.
        else {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'moving externals' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.changeExternals( interval, newAfterBlock );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }

        // If the next interval's old afterBlock isn't the same as our old afterBlock, we need to make our decision
        // about whether to mark our old afterBlock as reusable, or whether it was used.
        if ( nextAfterBlock !== afterBlock ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'end of afterBlock stretch' );

          // If our block wasn't added yet, it wouldn't ever be added later naturally (so we mark it as reusable).
          if ( !this.blockWasAdded ) {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'unusing ' + afterBlock.toString() );
            this.unuseBlock( afterBlock );
          }
          this.blockWasAdded = false;
        }

        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }
    },

    // Marks all 'external' drawables from the end (drawableAfter) of the {ChangeInterval} interval to either the end
    // of their old block or the drawableAfter of the next interval (whichever is sooner) as being needed to be moved to
    // our {Block} newBlock. The next processInterval will both handle the drawables inside that next interval, and
    // will be responsible for the 'external' drawables after that.
    changeExternals: function( interval, newBlock ) {
      var lastExternalDrawable = getLastCompatibleExternalDrawable( interval );
      this.notePendingMoves( newBlock, interval.drawableAfter, lastExternalDrawable );

      // If we didn't make it all the way to the next change interval's drawableBefore (there was another block
      // starting before the next interval), we need to link our new block to that next block.
      if ( !interval.nextChangeInterval || interval.nextChangeInterval.drawableBefore !== lastExternalDrawable ) {
        this.linkAfterDrawable( lastExternalDrawable );
      }
    },

    // Given a {Drawable} firstDrawable and {Drawable} lastDrawable, we mark all drawables in-between (inclusively) as
    // needing to be moved to our {Block} newBlock. This should only be called on external drawables, and should only
    // occur as needed with glue/unglue cases in the stitch.
    notePendingMoves: function( newBlock, firstDrawable, lastDrawable ) {
      for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
        assert && assert( !drawable.pendingAddition && !drawable.pendingRemoval,
          'Moved drawables should be thought of as unchanged, and thus have nothing pending yet' );

        this.notePendingMove( drawable, newBlock );
        if ( drawable === lastDrawable ) { break; }
      }
    },

    // If there is no currentBlock, we create one to match. Otherwise if the currentBlock is marked as 'unused' (i.e.
    // it is in the reusableBlocks array), we mark it as used so it won't me matched elsewhere.
    ensureUsedBlock: function( currentBlock, someIncludedDrawable ) {
      // if we have a matched block (or started with one)
      if ( currentBlock ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'using existing block: ' + currentBlock.toString() );
        // since our currentBlock may be from reusableBlocks, we will need to mark it as used now.
        if ( !currentBlock.used ) {
          this.useBlock( currentBlock );
        }
      }
      else {
        // need to create one
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'searching for block' );
        currentBlock = this.getBlockForRenderer( someIncludedDrawable.renderer, someIncludedDrawable );
      }
      return currentBlock;
    },

    // Attemps to find an unused block with the same renderer if possible, otherwise creates a
    // compatible block.
    // NOTE: this doesn't handle hooking up the block linked list
    getBlockForRenderer: function( renderer, drawable ) {
      var block;

      // If it's not a DOM block, scan our reusable blocks for one with the same renderer.
      // If it's DOM, it should be processed correctly in reusableBlocks, and will never reach this point.
      if ( !Renderer.isDOM( renderer ) ) {
        // backwards scan, hopefully it's faster?
        for ( var i = this.reusableBlocks.length - 1; i >= 0; i-- ) {
          var tmpBlock = this.reusableBlocks[ i ];
          assert && assert( !tmpBlock.used );
          if ( tmpBlock.renderer === renderer ) {
            this.useBlockAtIndex( tmpBlock, i );
            block = tmpBlock;
            break;
          }
        }
      }

      if ( !block ) {
        // Didn't find it in our reusable blocks, create a fresh one from scratch
        block = this.createBlock( renderer, drawable );
      }

      this.blockOrderChanged = true; // we created a new block, this will always happen

      return block;
    },

    // Marks a block as unused, moving it to the reusableBlocks array.
    unuseBlock: function( block ) {
      if ( block.used ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'unusing block: ' + block.toString() );
        block.used = false; // mark it as unused until we pull it out (so we can reuse, or quickly identify)
        this.reusableBlocks.push( block );
      }
      else {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'not using already-unused block: ' + block.toString() );
      }
    },

    // Removes a block from the list of reused blocks (done during matching)
    useBlock: function( block ) {
      this.useBlockAtIndex( block, _.indexOf( this.reusableBlocks, block ) );
    },

    useBlockAtIndex: function( block, index ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'using reusable block: ' + block.toString() + ' with renderer: ' + block.renderer );

      assert && assert( index >= 0 && this.reusableBlocks[ index ] === block, 'bad index for useBlockAtIndex: ' + index );

      assert && assert( !block.used, 'Should be called on an unused (reusable) block' );

      // remove it
      this.reusableBlocks.splice( index, 1 );

      // mark it as used
      block.used = true;
    },

    // Removes all of our unused blocks from our domElement, and marks them for disposal.
    removeUnusedBlocks: function() {
      sceneryLog && sceneryLog.GreedyStitcher && this.reusableBlocks.length && sceneryLog.GreedyStitcher( 'removeUnusedBlocks' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();
      while ( this.reusableBlocks.length ) {
        var block = this.reusableBlocks.pop();
        this.markBlockForDisposal( block );
        this.blockOrderChanged = true;
      }
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },

    // links blocks before a drawable (whether it is the first drawable or not)
    linkBeforeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'link before ' + drawable.toString() );
      var beforeDrawable = drawable.previousDrawable;
      this.linkBlocks( beforeDrawable ? beforeDrawable.pendingParentDrawable : null,
        drawable.pendingParentDrawable,
        beforeDrawable,
        drawable );
    },

    // links blocks after a drawable (whether it is the last drawable or not)
    linkAfterDrawable: function( drawable ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'link after ' + drawable.toString() );
      var afterDrawable = drawable.nextDrawable;
      this.linkBlocks( drawable.pendingParentDrawable,
        afterDrawable ? afterDrawable.pendingParentDrawable : null,
        drawable,
        afterDrawable );
    },

    // Called to mark a boundary between blocks, or at the end of our list of blocks (one block/drawable pair being
    // null notes that it is the start/end, and there is no previous/next block).
    // This updates the block linked-list as necessary (noting changes when they occur) so that we can rebuild an array
    // at the end of the stitch, avoiding O(n^2) issues if we were to do block-array-index lookups during linking
    // operations (this results in linear time for blocks).
    // It also marks block boundaries as dirty when necessary, so that we can make one pass through with
    // updateBlockIntervals() that updates all of the block's boundaries (avoiding more than one update per block per
    // frame).
    linkBlocks: function( beforeBlock, afterBlock, beforeDrawable, afterDrawable ) {
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'linking blocks: ' +
                                                                            ( beforeBlock ? ( beforeBlock.toString() + ' (' + beforeDrawable.toString() + ')' ) : 'null' ) +
                                                                            ' to ' +
                                                                            ( afterBlock ? ( afterBlock.toString() + ' (' + afterDrawable.toString() + ')' ) : 'null' ) );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      assert && assert( ( beforeBlock === null && beforeDrawable === null ) ||
                        ( beforeBlock instanceof scenery.Block && beforeDrawable instanceof scenery.Drawable ) );
      assert && assert( ( afterBlock === null && afterDrawable === null ) ||
                        ( afterBlock instanceof scenery.Block && afterDrawable instanceof scenery.Drawable ) );

      if ( beforeBlock ) {
        if ( beforeBlock.nextBlock !== afterBlock ) {
          this.blockOrderChanged = true;

          // disconnect from the previously-connected block (if any)
          if ( beforeBlock.nextBlock ) {
            beforeBlock.nextBlock.previousBlock = null;
          }

          beforeBlock.nextBlock = afterBlock;
        }
        this.markAfterBlock( beforeBlock, beforeDrawable );
      }
      if ( afterBlock ) {
        if ( afterBlock.previousBlock !== beforeBlock ) {
          this.blockOrderChanged = true;

          // disconnect from the previously-connected block (if any)
          if ( afterBlock.previousBlock ) {
            afterBlock.previousBlock.nextBlock = null;
          }

          afterBlock.previousBlock = beforeBlock;
        }
        this.markBeforeBlock( afterBlock, afterDrawable );
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },

    // Rebuilds the backbone's block array from our linked-list data.
    processBlockLinkedList: function( backbone, firstBlock, lastBlock ) {
      // for now, just clear out the array first
      while ( backbone.blocks.length ) {
        backbone.blocks.pop();
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'processBlockLinkedList: ' + firstBlock.toString() + ' to ' + lastBlock.toString() );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();

      // leave the array as-is if there are no blocks
      if ( firstBlock ) {

        // rewrite it starting with the first block
        for ( var block = firstBlock; ; block = block.nextBlock ) {
          sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( block.toString() );

          backbone.blocks.push( block );

          if ( block === lastBlock ) { break; }
        }
      }

      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    }
  };

  var GreedyStitcher = inherit( Stitcher, function GreedyStitcher() {
    // nothing done
  }, prototype );
  scenery.register( 'GreedyStitcher', GreedyStitcher );

  GreedyStitcher.stitchPrototype = prototype;

  return GreedyStitcher;
} );

// Copyright 2014-2016, University of Colorado Boulder

/**
 * Stitcher that rebuilds all of the blocks and reattaches drawables. Simple, but inefficient.
 *
 * Kept for now as a run-time comparison and baseline for the GreedyStitcher or any other more advanced (but
 * more error-prone) stitching process.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/RebuildStitcher',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/display/Stitcher'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );

  var prototype = {
    stitch: function( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval ) {
      this.initialize( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval );

      for ( var d = backbone.previousFirstDrawable; d !== null; d = d.oldNextDrawable ) {
        this.notePendingRemoval( d );
        if ( d === backbone.previousLastDrawable ) { break; }
      }

      this.recordBackboneBoundaries();

      this.removeAllBlocks();

      var currentBlock = null;
      var currentRenderer = 0;
      var firstDrawableForBlock = null;

      // linked-list iteration inclusively from firstDrawable to lastDrawable
      for ( var drawable = firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {

        // if we need to switch to a new block, create it
        if ( !currentBlock || drawable.renderer !== currentRenderer ) {
          if ( currentBlock ) {
            this.notifyInterval( currentBlock, firstDrawableForBlock, drawable.previousDrawable );
          }

          currentRenderer = drawable.renderer;

          currentBlock = this.createBlock( currentRenderer, drawable );
          if ( Renderer.isDOM( currentRenderer ) ) {
            currentRenderer = 0;
          }

          this.appendBlock( currentBlock );

          firstDrawableForBlock = drawable;
        }

        this.notePendingAddition( drawable, currentBlock );

        // don't cause an infinite loop!
        if ( drawable === lastDrawable ) { break; }
      }
      if ( currentBlock ) {
        this.notifyInterval( currentBlock, firstDrawableForBlock, lastDrawable );
      }

      this.reindex();

      this.clean();
    }
  };

  var RebuildStitcher = inherit( Stitcher, function RebuildStitcher() {
    // nothing done
  }, prototype );
  scenery.register( 'RebuildStitcher', RebuildStitcher );

  RebuildStitcher.stitchPrototype = prototype;

  return RebuildStitcher;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * A DOM drawable (div element) that contains child blocks (and is placed in the main DOM tree when visible). It should
 * use z-index for properly ordering its blocks in the correct stacking order.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/BackboneDrawable',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable','SCENERY/display/Stitcher','SCENERY/display/GreedyStitcher','SCENERY/display/RebuildStitcher','SCENERY/util/Util'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );
  var GreedyStitcher = require( 'SCENERY/display/GreedyStitcher' );
  var RebuildStitcher = require( 'SCENERY/display/RebuildStitcher' );
  var Util = require( 'SCENERY/util/Util' );

  // constants
  var useGreedyStitcher = true;

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param {Display} display
   * @param {Instance} backboneInstance
   * @param {Instance} transformRootInstance
   * @param {number} renderer
   * @param {boolean} isDisplayRoot
   */
  function BackboneDrawable( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
    this.initialize( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
  }

  scenery.register( 'BackboneDrawable', BackboneDrawable );

  inherit( Drawable, BackboneDrawable, {

    /**
     * @param {Display} display
     * @param {Instance} backboneInstance
     * @param {Instance} transformRootInstance
     * @param {number} renderer
     * @param {boolean} isDisplayRoot
     * @returns {BackboneDrawable} - Returns 'this' reference, for chaining
     */
    initialize: function( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
      Drawable.call( this, renderer );

      this.display = display;

      this.forceAcceleration = false;

      // reference to the instance that controls this backbone
      this.backboneInstance = backboneInstance;

      // where is the transform root for our generated blocks?
      this.transformRootInstance = transformRootInstance;

      // where have filters been applied to up? our responsibility is to apply filters between this and our backboneInstance
      this.filterRootAncestorInstance = backboneInstance.parent ? backboneInstance.parent.getFilterRootInstance() : backboneInstance;

      // where have transforms been applied up to? our responsibility is to apply transforms between this and our backboneInstance
      this.transformRootAncestorInstance = backboneInstance.parent ? backboneInstance.parent.getTransformRootInstance() : backboneInstance;

      this.willApplyTransform = this.transformRootAncestorInstance !== this.transformRootInstance;
      this.willApplyFilters = this.filterRootAncestorInstance !== this.backboneInstance;

      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );
      if ( this.willApplyTransform ) {
        this.backboneInstance.relativeTransform.addListener( this.transformListener ); // when our relative transform changes, notify us in the pre-repaint phase
        this.backboneInstance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated
      }

      this.backboneVisibilityListener = this.backboneVisibilityListener || this.updateBackboneVisibility.bind( this );
      this.backboneInstance.onStatic( 'relativeVisibility', this.backboneVisibilityListener );
      this.updateBackboneVisibility();
      this.visibilityDirty = true;

      this.renderer = renderer;
      this.domElement = isDisplayRoot ? display._domElement : BackboneDrawable.createDivBackbone();
      this.isDisplayRoot = isDisplayRoot;
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );

      // Apply CSS needed for future CSS transforms to work properly.
      Util.prepareForTransform( this.domElement, this.forceAcceleration );

      // if we need to, watch nodes below us (and including us) and apply their filters (opacity/visibility/clip) to the backbone.
      this.watchedFilterNodes = cleanArray( this.watchedFilterNodes );
      this.opacityDirty = true;
      this.clipDirty = true;
      this.opacityDirtyListener = this.opacityDirtyListener || this.markOpacityDirty.bind( this );
      this.clipDirtyListener = this.clipDirtyListener || this.markClipDirty.bind( this );
      if ( this.willApplyFilters ) {
        assert && assert( this.filterRootAncestorInstance.trail.nodes.length < this.backboneInstance.trail.nodes.length,
          'Our backboneInstance should be deeper if we are applying filters' );

        // walk through to see which instances we'll need to watch for filter changes
        for ( var instance = this.backboneInstance; instance !== this.filterRootAncestorInstance; instance = instance.parent ) {
          var node = instance.node;

          this.watchedFilterNodes.push( node );
          node.onStatic( 'opacity', this.opacityDirtyListener );
          node.onStatic( 'clip', this.clipDirtyListener );
        }
      }

      this.lastZIndex = 0; // our last zIndex is stored, so that overlays can be added easily

      this.blocks = this.blocks || []; // we are responsible for their disposal

      // the first/last drawables for the last the this backbone was stitched
      this.previousFirstDrawable = null;
      this.previousLastDrawable = null;

      // We track whether our drawables were marked for removal (in which case, they should all be removed by the time we dispose).
      // If removedDrawables = false during disposal, it means we need to remove the drawables manually (this should only happen if an instance tree is removed)
      this.removedDrawables = false;

      this.stitcher = this.stitcher || ( useGreedyStitcher ? new GreedyStitcher() : new RebuildStitcher() );

      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'initialized ' + this.toString() );

      return this; // chaining
    },

    dispose: function() {
      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.push();


      while ( this.watchedFilterNodes.length ) {
        var node = this.watchedFilterNodes.pop();

        node.offStatic( 'opacity', this.opacityDirtyListener );
        node.offStatic( 'clip', this.clipDirtyListener );
      }

      this.backboneInstance.offStatic( 'relativeVisibility', this.backboneVisibilityListener );

      // if we need to remove drawables from the blocks, do so
      if ( !this.removedDrawables ) {
        for ( var d = this.previousFirstDrawable; d !== null; d = d.nextDrawable ) {
          d.parentDrawable.removeDrawable( d );
          if ( d === this.previousLastDrawable ) { break; }
        }
      }

      this.markBlocksForDisposal();

      if ( this.willApplyTransform ) {
        this.backboneInstance.relativeTransform.removeListener( this.transformListener );
        this.backboneInstance.relativeTransform.removePrecompute();
      }

      this.backboneInstance = null;
      this.transformRootInstance = null;
      this.filterRootAncestorInstance = null;
      this.transformRootAncestorInstance = null;
      cleanArray( this.dirtyDrawables );
      cleanArray( this.watchedFilterNodes );

      this.previousFirstDrawable = null;
      this.previousLastDrawable = null;

      Drawable.prototype.dispose.call( this );

      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.pop();
    },

    // dispose all of the blocks while clearing our references to them
    markBlocksForDisposal: function() {
      while ( this.blocks.length ) {
        var block = this.blocks.pop();
        sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( this.toString() + ' removing block: ' + block.toString() );
        //TODO: PERFORMANCE: does this cause reflows / style calculation
        if ( block.domElement.parentNode === this.domElement ) {
          // guarded, since we may have a (new) child drawable add it before we can remove it
          this.domElement.removeChild( block.domElement );
        }
        block.markForDisposal( this.display );
      }
    },

    updateBackboneVisibility: function() {
      this.visible = this.backboneInstance.relativeVisible;

      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },

    // should be called during syncTree
    markForDisposal: function( display ) {
      for ( var d = this.previousFirstDrawable; d !== null; d = d.oldNextDrawable ) {
        d.notePendingRemoval( this.display );
        if ( d === this.previousLastDrawable ) { break; }
      }
      this.removedDrawables = true;

      // super call
      Drawable.prototype.markForDisposal.call( this, display );
    },

    markDirtyDrawable: function( drawable ) {
      if ( assert ) {
        // Catch infinite loops
        this.display.ensureNotPainting();
      }

      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },

    markTransformDirty: function() {
      assert && assert( this.willApplyTransform, 'Sanity check for willApplyTransform' );

      // relative matrix on backbone instance should be up to date, since we added the compute flags
      scenery.Util.applyPreparedTransform( this.backboneInstance.relativeTransform.matrix, this.domElement, this.forceAcceleration );
    },

    markOpacityDirty: function() {
      if ( !this.opacityDirty ) {
        this.opacityDirty = true;
        this.markDirty();
      }
    },

    markClipDirty: function() {
      if ( !this.clipDirty ) {
        this.clipDirty = true;
        this.markDirty();
      }
    },

    update: function() {
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;

        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }

        if ( this.opacityDirty ) {
          this.opacityDirty = false;

          var filterOpacity = this.willApplyFilters ? this.getFilterOpacity() : 1;
          this.domElement.style.opacity = ( filterOpacity !== 1 ) ? filterOpacity : '';
        }

        if ( this.visibilityDirty ) {
          this.visibilityDirty = false;

          this.domElement.style.display = this.visible ? '' : 'none';
        }

        if ( this.clipDirty ) {
          this.clipDirty = false;

          // var clip = this.willApplyFilters ? this.getFilterClip() : '';

          //OHTWO TODO: CSS clip-path/mask support here. see http://www.html5rocks.com/en/tutorials/masking/adobe/
          // this.domElement.style.clipPath = clip; // yikes! temporary, since we already threw something?
        }
      }
    },

    getFilterOpacity: function() {
      var opacity = 1;

      var len = this.watchedFilterNodes.length;
      for ( var i = 0; i < len; i++ ) {
        opacity *= this.watchedFilterNodes[ i ].getOpacity();
      }

      return opacity;
    },

    getFilterVisibility: function() {
      var len = this.watchedFilterNodes.length;
      for ( var i = 0; i < len; i++ ) {
        if ( !this.watchedFilterNodes[ i ].isVisible() ) {
          return false;
        }
      }

      return true;
    },

    getFilterClip: function() {
      var clip = '';

      //OHTWO TODO: proper clipping support
      // var len = this.watchedFilterNodes.length;
      // for ( var i = 0; i < len; i++ ) {
      //   if ( this.watchedFilterNodes[i].clipArea ) {
      //     throw new Error( 'clip-path for backbones unimplemented, and with questionable browser support!' );
      //   }
      // }

      return clip;
    },

    // ensures that z-indices are strictly increasing, while trying to minimize the number of times we must change it
    reindexBlocks: function() {
      // full-pass change for zindex.
      var zIndex = 0; // don't start below 1 (we ensure > in loop)
      for ( var k = 0; k < this.blocks.length; k++ ) {
        var block = this.blocks[ k ];
        if ( block.zIndex <= zIndex ) {
          var newIndex = ( k + 1 < this.blocks.length && this.blocks[ k + 1 ].zIndex - 1 > zIndex ) ?
                         Math.ceil( ( zIndex + this.blocks[ k + 1 ].zIndex ) / 2 ) :
                         zIndex + 20;

          // NOTE: this should give it its own stacking index (which is what we want)
          block.domElement.style.zIndex = block.zIndex = newIndex;
        }
        zIndex = block.zIndex;

        if ( assert ) {
          assert( this.blocks[ k ].zIndex % 1 === 0, 'z-indices should be integers' );
          assert( this.blocks[ k ].zIndex > 0, 'z-indices should be greater than zero for our needs (see spec)' );
          if ( k > 0 ) {
            assert( this.blocks[ k - 1 ].zIndex < this.blocks[ k ].zIndex, 'z-indices should be strictly increasing' );
          }
        }
      }

      // sanity check
      this.lastZIndex = zIndex + 1;
    },

    stitch: function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval ) {
      // no stitch necessary if there are no change intervals
      if ( firstChangeInterval === null || lastChangeInterval === null ) {
        assert && assert( firstChangeInterval === null );
        assert && assert( lastChangeInterval === null );
        return;
      }

      assert && assert( lastChangeInterval.nextChangeInterval === null, 'This allows us to have less checks in the loop' );

      if ( sceneryLog && sceneryLog.Stitch ) {
        sceneryLog.Stitch( 'Stitch intervals before constricting: ' + this.toString() );
        sceneryLog.push();
        Stitcher.debugIntervals( firstChangeInterval );
        sceneryLog.pop();
      }

      // Make the intervals as small as possible by skipping areas without changes, and collapse the interval
      // linked list
      var lastNonemptyInterval = null;
      var interval = firstChangeInterval;
      var intervalsChanged = false;
      while ( interval ) {
        intervalsChanged = interval.constrict() || intervalsChanged;

        if ( interval.isEmpty() ) {
          assert && assert( intervalsChanged );

          if ( lastNonemptyInterval ) {
            // skip it, hook the correct reference
            lastNonemptyInterval.nextChangeInterval = interval.nextChangeInterval;
          }
        }
        else {
          // our first non-empty interval will be our new firstChangeInterval
          if ( !lastNonemptyInterval ) {
            firstChangeInterval = interval;
          }
          lastNonemptyInterval = interval;
        }
        interval = interval.nextChangeInterval;
      }

      if ( !lastNonemptyInterval ) {
        // eek, no nonempty change intervals. do nothing (good to catch here, but ideally there shouldn't be change
        // intervals that all collapse).
        return;
      }

      lastChangeInterval = lastNonemptyInterval;
      lastChangeInterval.nextChangeInterval = null;

      if ( sceneryLog && sceneryLog.Stitch && intervalsChanged ) {
        sceneryLog.Stitch( 'Stitch intervals after constricting: ' + this.toString() );
        sceneryLog.push();
        Stitcher.debugIntervals( firstChangeInterval );
        sceneryLog.pop();
      }

      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.display.perfStitchCount++;

        var dInterval = firstChangeInterval;

        while ( dInterval ) {
          this.display.perfIntervalCount++;

          this.display.perfDrawableOldIntervalCount += dInterval.getOldInternalDrawableCount( this.previousFirstDrawable, this.previousLastDrawable );
          this.display.perfDrawableNewIntervalCount += dInterval.getNewInternalDrawableCount( firstDrawable, lastDrawable );

          dInterval = dInterval.nextChangeInterval;
        }
      }

      this.stitcher.stitch( this, firstDrawable, lastDrawable, this.previousFirstDrawable, this.previousLastDrawable, firstChangeInterval, lastChangeInterval );
    },

    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        Drawable.prototype.audit.call( this, allowPendingBlock, allowPendingList, allowDirty );

        assertSlow && assertSlow( this.backboneInstance.isBackbone, 'We should reference an instance that requires a backbone' );
        assertSlow && assertSlow( this.transformRootInstance.isTransformed, 'Transform root should be transformed' );

        for ( var i = 0; i < this.blocks.length; i++ ) {
          this.blocks[ i ].audit( allowPendingBlock, allowPendingList, allowDirty );
        }
      }
    }
  } );

  BackboneDrawable.createDivBackbone = function() {
    var div = document.createElement( 'div' );
    div.style.position = 'absolute';
    div.style.left = '0';
    div.style.top = '0';
    div.style.width = '0';
    div.style.height = '0';
    return div;
  };

  BackboneDrawable.repurposeBackboneContainer = function( element ) {
    if ( element.style.position !== 'relative' || element.style.position !== 'absolute' ) {
      element.style.position = 'relative';
    }
    element.style.left = '0';
    element.style.top = '0';
    return element;
  };

  Poolable.mixin( BackboneDrawable, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'new from pool' );
          return pool.pop().initialize( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
        }
        else {
          sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'new from constructor' );
          return new BackboneDrawable( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
        }
      };
    }
  } );

  return BackboneDrawable;
} );

// Copyright 2014-2016, University of Colorado Boulder


/**
 * An interval (implicit consecutive sequence of drawables) that has a recorded change in-between the two ends.
 * We store the closest drawables to the interval that aren't changed, or null itself to indicate "to the end".
 *
 * isEmpty() should be used before checking the endpoints, since it could have a null-to-null state but be empty,
 * since we arrived at that state from constriction.
 *
 * For documentation purposes, an 'internal' drawable is one that is in-between (but not including) our un-changed ends
 * (drawableBefore and drawableAfter), and 'external' drawables are outside (or including) the un-changed ends.
 *
 * For stitching purposes, a ChangeInterval effectively represents two linked lists: the "old" one that was displayed
 * in the previous frame (using oldNextDrawable for iteration across the drawable linked-list), or the "new" one that
 * will be displayed in the next frame (using nextDrawable for iteration).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/ChangeInterval',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param drawableBefore
   * @param drawableAfter
   */
  function ChangeInterval( drawableBefore, drawableAfter ) {
    this.initialize( drawableBefore, drawableAfter );
  }

  scenery.register( 'ChangeInterval', ChangeInterval );

  inherit( Object, ChangeInterval, {
    initialize: function( drawableBefore, drawableAfter ) {
      assert && assert( drawableBefore === null || ( drawableBefore instanceof Drawable ),
        'drawableBefore can either be null to indicate that there is no un-changed drawable before our changes, ' +
        'or it can reference an un-changed drawable' );
      assert && assert( drawableAfter === null || ( drawableAfter instanceof Drawable ),
        'drawableAfter can either be null to indicate that there is no un-changed drawable after our changes, ' +
        'or it can reference an un-changed drawable' );

      /*---------------------------------------------------------------------------*
       * All @public properties
       *----------------------------------------------------------------------------*/

      // {ChangeInterval|null}, singly-linked list
      this.nextChangeInterval = null;

      // {Drawable|null}, the drawable before our ChangeInterval that is not modified. null indicates that we don't yet
      // have a "before" boundary, and should be connected to the closest drawable that is unchanged.
      this.drawableBefore = drawableBefore;

      // {Drawable|null}, the drawable after our ChangeInterval that is not modified. null indicates that we don't yet
      // have a "after" boundary, and should be connected to the closest drawable that is unchanged.
      this.drawableAfter = drawableAfter;

      // {boolean} If a null-to-X interval gets collapsed all the way, we want to have a flag that indicates that.
      // Otherwise, it would be interpreted as a null-to-null change interval ("change everything"), instead of the
      // correct "change nothing".
      this.collapsedEmpty = false;

      // chaining for PoolableMixin
      return this;
    },

    dispose: function() {
      // release our references
      this.nextChangeInterval = null;
      this.drawableBefore = null;
      this.drawableAfter = null;

      this.freeToPool();
    },

    // Make our interval as tight as possible (we may have over-estimated it before)
    constrict: function() {
      var changed = false;

      if ( this.isEmpty() ) { return true; }

      // Notes: We don't constrict null boundaries, and we should never constrict a non-null boundary to a null
      // boundary (this the this.drawableX.Xdrawable truthy check), since going from a null-to-X interval to
      // null-to-null has a completely different meaning. This should be checked by a client of this API.

      while ( this.drawableBefore && this.drawableBefore.nextDrawable === this.drawableBefore.oldNextDrawable ) {
        this.drawableBefore = this.drawableBefore.nextDrawable;
        changed = true;

        // check for a totally-collapsed state
        if ( !this.drawableBefore ) {
          assert && assert( !this.drawableAfter );
          this.collapsedEmpty = true;
        }

        // if we are empty, bail out before continuing
        if ( this.isEmpty() ) { return true; }
      }

      while ( this.drawableAfter && this.drawableAfter.previousDrawable === this.drawableAfter.oldPreviousDrawable ) {
        this.drawableAfter = this.drawableAfter.previousDrawable;
        changed = true;

        // check for a totally-collapsed state
        if ( !this.drawableAfter ) {
          assert && assert( !this.drawableBefore );
          this.collapsedEmpty = true;
        }

        // if we are empty, bail out before continuing
        if ( this.isEmpty() ) { return true; }
      }

      return changed;
    },

    isEmpty: function() {
      return this.collapsedEmpty || ( this.drawableBefore !== null && this.drawableBefore === this.drawableAfter );
    },

    // {number} The quantity of "old" internal drawables. Requires the old first/last drawables for the backbone, since
    // we need that information for null-before/after boundaries.
    getOldInternalDrawableCount: function( oldStitchFirstDrawable, oldStitchLastDrawable ) {
      var firstInclude = this.drawableBefore ? this.drawableBefore.oldNextDrawable : oldStitchFirstDrawable;
      var lastExclude = this.drawableAfter; // null is OK here

      var count = 0;
      for ( var drawable = firstInclude; drawable !== lastExclude; drawable = drawable.oldNextDrawable ) {
        count++;
      }

      return count;
    },

    // {number} The quantity of "new" internal drawables. Requires the old first/last drawables for the backbone, since
    // we need that information for null-before/after boundaries.
    getNewInternalDrawableCount: function( newStitchFirstDrawable, newStitchLastDrawable ) {
      var firstInclude = this.drawableBefore ? this.drawableBefore.nextDrawable : newStitchFirstDrawable;
      var lastExclude = this.drawableAfter; // null is OK here

      var count = 0;
      for ( var drawable = firstInclude; drawable !== lastExclude; drawable = drawable.nextDrawable ) {
        count++;
      }

      return count;
    }
  } );

  Poolable.mixin( ChangeInterval, {
    constructorDuplicateFactory: function( pool ) {
      return function( drawableBefore, drawableAfter ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'new from pool' );
          return pool.pop().initialize( drawableBefore, drawableAfter );
        }
        else {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'new from constructor' );
          return new ChangeInterval( drawableBefore, drawableAfter );
        }
      };
    }
  } );

  // creates a ChangeInterval that will be disposed after syncTree is complete (see Display phases)
  ChangeInterval.newForDisplay = function( drawableBefore, drawableAfter, display ) {
    var changeInterval = ChangeInterval.createFromPool( drawableBefore, drawableAfter );
    display.markChangeIntervalToDispose( changeInterval );
    return changeInterval;
  };

  return ChangeInterval;
} );

// Copyright 2014-2016, University of Colorado Boulder

/**
 * RelativeTransform is a component of an Instance. It is responsible for tracking changes to "relative" transforms, and
 * computing them in an efficient manner.
 *
 * A "relative" transform here is the transform that a Trail would have, not necessarily rooted at the display's root.
 * Imagine we have a CSS-transformed backbone div, and nodes underneath that render to Canvas. On the Canvas, we will
 * need to set the context's transform to the matrix that will transform from the displayed instances' local coordinates
 * frames to the CSS-transformed backbone instance. Notably, transforming the backbone instance or any of its ancestors
 * does NOT affect this "relative" transform from the instance to the displayed instances, while any Node transform
 * changes between (not including) the backbone instance and (including) the displayed instance WILL affect that
 * relative transform. This is key to setting the CSS transform on backbones, DOM nodes, having the transforms necessary
 * for the fastest Canvas display, and determining fitting bounds for layers.
 *
 * Each Instance has its own "relative trail", although these aren't stored. We use implicit hierarchies in the Instance
 * tree for this purpose. If an Instance is a CSS-transformed backbone, or any other case that requires drawing beneath
 * to be done relative to its local coordinate frame, we call it a transform "root", and it has instance.isTransformed
 * set to true. This should NEVER change for an instance (any changes that would do this require reconstructing the
 * instance tree).
 *
 * There are implicit hierarchies for each root, with trails starting from that root's children (they won't apply that
 * root's transform since we assume we are working within that root's local coordinate frame). These should be
 * effectively independent (if there are no bugs), so that flags affecting one implicit hierarchy will not affect the
 * other (dirty flags, etc.), and traversals should not cross these boundaries.
 *
 * For various purposes, we want a system that can:
 * - every frame before repainting: notify listeners on instances whether its relative transform has changed
 *                                  (add|removeListener)
 * - every frame before repainting: precompute relative transforms on instances where we know this is required
 *                                  (add|removePrecompute)
 * - any time during repainting:    provide an efficient way to lazily compute relative transforms when needed
 *
 * This is done by first having one step in the pre-repaint phase that traverses the tree where necessary, notifying
 * relative transform listeners, and precomputing relative transforms when they have changed (and precomputation is
 * requested). This traversal leaves metadata on the instances so that we can (fairly) efficiently force relative
 * transform "validation" any time afterwards that makes sure the matrix property is up-to-date.
 *
 * First of all, to ensure we traverse the right parts of the tree, we need to keep metadata on what needs to be
 * traversed. This is done by tracking counts of listeners/precompution needs, both on the instance itself, and how many
 * children have these needs. We use counts instead of boolean flags so that we can update this quickly while (a) never
 * requiring full children scans to update this metadata, and (b) minimizing the need to traverse all the way up to the
 * root to update the metadata. The end result is hasDescendantListenerNeed and hasDescendantComputeNeed which compute,
 * respectively, whether we need to traverse this instance for listeners and precomputation. Additionally,
 * hasAncestorListenerNeed and hasAncestorComputeNeed compute whether our parent needs to traverse up to us.
 *
 * The other tricky bits to remember for this traversal are the flags it sets, and how later validation uses and updates
 * these flags. First of all, we have relativeSelfDirty and relativeChildDirtyFrame. When a node's transform changes,
 * we mark relativeSelfDirty on the node, and relativeChildDirtyFrame for all ancestors up to (and including) the
 * transform root. relativeChildDirtyFrame allows us to prune our traversal to only modified subtrees. Additionally, so
 * that we can retain the invariant that it is "set" parent node if it is set on a child, we store the rendering frame
 * ID (unique to traversals) instead of a boolean true/false. Our traversal may skip subtrees where
 * relativeChildDirtyFrame is "set" due to no listeners or precomputation needed for that subtree, so if we used
 * booleans this would be violated. Violating that invariant would prevent us from "bailing out" when setting the
 * relativeChildDirtyFrame flag, and on EVERY transform change we would have to traverse ALL of the way to the root
 * (instead of the efficient "stop at the ancestor where it is also set").
 *
 * relativeSelfDirty is initially set on instances whose nodes had transform changes (they mark that this relative
 * transform, and all transforms beneath, are dirty). We maintain the invariant that if a relative transform needs to be
 * recomputed, it or one of its ancestors WILL ALWAYS have this flag set. This is required so that later validation of
 * the relative transform can verify whether it has been changed in an efficient way. When we recompute the relative
 * transform for one instance, we have to set this flag on all children to maintain this invariant.
 *
 * Additionally, so that we can have fast "validation" speed, we also store into relativeFrameId the last rendering
 * frame ID (counter) where we either verified that the relative transform is up to date, or we have recomputed it. Thus
 * when "validating" a relative transform that wasn't precomputed, we only need to scan up the ancestors to the first
 * one that was verified OK this frame (boolean flags are insufficient for this, since we would have to clear them all
 * to false on every frame, requiring a full tree traversal). In the future, we may set this flag to the frame
 * proactively during traversal to speed up validation, but that is not done at the time of this writing.
 *
 * Some helpful notes for the scope of various relativeTransform bits:
 *                         (transformRoot) (regular) (regular) (transformRoot)
 * relativeChildDirtyFrame [---------------------------------]                 (int)
 * relativeSelfDirty                       [---------------------------------]
 * matrix                                  [---------------------------------] (transform on root applies to
 *                                                                             its parent context)
 * relativeFrameId                         [---------------------------------] (int)
 * child counts            [---------------------------------]                 (e.g. relativeChildrenListenersCount,
 *                                                                             relativeChildrenPrecomputeCount)
 * self counts                             [---------------------------------] (e.g. relativePrecomputeCount,
 *                                                                             relativeTransformListeners.length)
 **********************
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/RelativeTransform',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','DOT/Matrix3','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var scenery = require( 'SCENERY/scenery' );

  function RelativeTransform( instance ) {
    this.instance = instance;
  }

  scenery.register( 'RelativeTransform', RelativeTransform );

  inherit( Object, RelativeTransform, {
    /**
     * Responsible for initialization and cleaning of this. If the parameters are both null, we'll want to clean our
     * external references (like Instance does).
     *
     * @param {Display|null} display
     * @param {Trail|null} trail
     * @returns {RelativeTransform} - Returns this, to allow chaining.
     */
    initialize: function( display, trail ) {
      this.display = display;
      this.trail = trail;
      this.node = trail && trail.lastNode();

      // properties relevant to the node's direct transform
      this.transformDirty = true; // whether the node's transform has changed (until the pre-repaint phase)
      this.nodeTransformListener = this.nodeTransformListener || this.onNodeTransformDirty.bind( this );

      // the actual cached transform to the root
      this.matrix = this.matrix || Matrix3.identity();

      // whether our matrix is dirty
      this.relativeSelfDirty = true;

      // how many children have (or have descendants with) relativeTransformListeners
      this.relativeChildrenListenersCount = 0;

      // if >0, indicates this should be precomputed in the pre-repaint phase
      this.relativePrecomputeCount = 0;

      // how many children have (or have descendants with) >0 relativePrecomputeCount
      this.relativeChildrenPrecomputeCount = 0;

      // used to mark what frame the transform was updated in (to accelerate non-precomputed relative transform access)
      this.relativeFrameId = -1;

      // Whether children have dirty transforms (if it is the current frame) NOTE: used only for pre-repaint traversal,
      // and can be ignored if it has a value less than the current frame ID. This allows us to traverse and hit all
      // listeners for this particular traversal, without leaving an invalid subtree (a boolean flag here is
      // insufficient, since our traversal handling would validate our invariant of
      // this.relativeChildDirtyFrame => parent.relativeChildDirtyFrame). In this case, they are both effectively
      // "false" unless they are the current frame ID, in which case that invariant holds.
      this.relativeChildDirtyFrame = display ? display._frameId : 0;

      // will be notified in pre-repaint phase that our relative transform has changed (but not computed by default)
      //OHTWO TODO: should we rely on listeners removing themselves?
      this.relativeTransformListeners = cleanArray( this.relativeTransformListeners );

      return this; // allow chaining
    },

    get parent() {
      return this.instance.parent ? this.instance.parent.relativeTransform : null;
    },

    // NOTE: different parameter order compared to Node
    insertInstance: function( instance, index ) {
      if ( instance.stateless ) {
        assert && assert( !instance.relativeTransform.hasAncestorListenerNeed(),
          'We only track changes properly if stateless instances do not have needs' );
        assert && assert( !instance.relativeTransform.hasAncestorComputeNeed(),
          'We only track changes properly if stateless instances do not have needs' );
      }
      else {
        if ( instance.relativeTransform.hasAncestorListenerNeed() ) {
          this.incrementTransformListenerChildren();
        }
        if ( instance.relativeTransform.hasAncestorComputeNeed() ) {
          this.incrementTransformPrecomputeChildren();
        }
      }

      // mark the instance's transform as dirty, so that it will be reachable in the pre-repaint traversal pass
      instance.relativeTransform.forceMarkTransformDirty();
    },

    removeInstanceWithIndex: function( instance, index ) {
      if ( instance.relativeTransform.hasAncestorListenerNeed() ) {
        this.decrementTransformListenerChildren();
      }
      if ( instance.relativeTransform.hasAncestorComputeNeed() ) {
        this.decrementTransformPrecomputeChildren();
      }
    },

    attachNodeListeners: function() {
      this.node.onStatic( 'transform', this.nodeTransformListener );
    },

    detachNodeListeners: function() {
      this.node.offStatic( 'transform', this.nodeTransformListener );
    },

    /*---------------------------------------------------------------------------*
     * Relative transform listener count recursive handling
     *----------------------------------------------------------------------------*/

    // @private: Only for descendants need, ignores 'self' need on isTransformed
    hasDescendantListenerNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeChildrenListenersCount > 0;
      }
      else {
        return this.relativeChildrenListenersCount > 0 || this.relativeTransformListeners.length > 0;
      }
    },
    // @private: Only for ancestors need, ignores child need on isTransformed
    hasAncestorListenerNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeTransformListeners.length > 0;
      }
      else {
        return this.relativeChildrenListenersCount > 0 || this.relativeTransformListeners.length > 0;
      }
    },
    // @private
    hasSelfListenerNeed: function() {
      return this.relativeTransformListeners.length > 0;
    },
    // @private (called on the ancestor of the instance with the need)
    incrementTransformListenerChildren: function() {
      var before = this.hasAncestorListenerNeed();

      this.relativeChildrenListenersCount++;
      if ( before !== this.hasAncestorListenerNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );

        this.parent && this.parent.incrementTransformListenerChildren();
      }
    },
    // @private (called on the ancestor of the instance with the need)
    decrementTransformListenerChildren: function() {
      var before = this.hasAncestorListenerNeed();

      this.relativeChildrenListenersCount--;
      if ( before !== this.hasAncestorListenerNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );

        this.parent && this.parent.decrementTransformListenerChildren();
      }
    },

    // @public (called on the instance itself)
    addListener: function( listener ) {
      var before = this.hasAncestorListenerNeed();

      this.relativeTransformListeners.push( listener );
      if ( before !== this.hasAncestorListenerNeed() ) {
        this.parent && this.parent.incrementTransformListenerChildren();

        // if we just went from "not needing to be traversed" to "needing to be traversed", mark ourselves as dirty so
        // that we for-sure get future updates
        if ( !this.hasAncestorComputeNeed() ) {
          // TODO: can we do better than this?
          this.forceMarkTransformDirty();
        }
      }
    },

    // @public (called on the instance itself)
    removeListener: function( listener ) {
      var before = this.hasAncestorListenerNeed();

      // TODO: replace with a 'remove' function call
      this.relativeTransformListeners.splice( _.indexOf( this.relativeTransformListeners, listener ), 1 );
      if ( before !== this.hasAncestorListenerNeed() ) {
        this.parent && this.parent.decrementTransformListenerChildren();
      }
    },

    /*---------------------------------------------------------------------------*
     * Relative transform precompute flag recursive handling
     *----------------------------------------------------------------------------*/

    // @private: Only for descendants need, ignores 'self' need on isTransformed
    hasDescendantComputeNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeChildrenPrecomputeCount > 0;
      }
      else {
        return this.relativeChildrenPrecomputeCount > 0 || this.relativePrecomputeCount > 0;
      }
    },
    // @private: Only for ancestors need, ignores child need on isTransformed
    hasAncestorComputeNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativePrecomputeCount > 0;
      }
      else {
        return this.relativeChildrenPrecomputeCount > 0 || this.relativePrecomputeCount > 0;
      }
    },
    // @private
    hasSelfComputeNeed: function() {
      return this.relativePrecomputeCount > 0;
    },
    // @private (called on the ancestor of the instance with the need)
    incrementTransformPrecomputeChildren: function() {
      var before = this.hasAncestorComputeNeed();

      this.relativeChildrenPrecomputeCount++;
      if ( before !== this.hasAncestorComputeNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );

        this.parent && this.parent.incrementTransformPrecomputeChildren();
      }
    },
    // @private (called on the ancestor of the instance with the need)
    decrementTransformPrecomputeChildren: function() {
      var before = this.hasAncestorComputeNeed();

      this.relativeChildrenPrecomputeCount--;
      if ( before !== this.hasAncestorComputeNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );

        this.parent && this.parent.decrementTransformPrecomputeChildren();
      }
    },

    // @public (called on the instance itself)
    addPrecompute: function() {
      var before = this.hasAncestorComputeNeed();

      this.relativePrecomputeCount++;
      if ( before !== this.hasAncestorComputeNeed() ) {
        this.parent && this.parent.incrementTransformPrecomputeChildren();

        // if we just went from "not needing to be traversed" to "needing to be traversed", mark ourselves as dirty so
        // that we for-sure get future updates
        if ( !this.hasAncestorListenerNeed() ) {
          // TODO: can we do better than this?
          this.forceMarkTransformDirty();
        }
      }
    },

    // @public (called on the instance itself)
    removePrecompute: function() {
      var before = this.hasAncestorComputeNeed();

      this.relativePrecomputeCount--;
      if ( before !== this.hasAncestorComputeNeed() ) {
        this.parent && this.parent.decrementTransformPrecomputeChildren();
      }
    },

    /*---------------------------------------------------------------------------*
     * Relative transform handling
     *----------------------------------------------------------------------------*/

    // called immediately when the corresponding node has a transform change (can happen multiple times between renders)
    onNodeTransformDirty: function() {
      if ( !this.transformDirty ) {
        this.forceMarkTransformDirty();
      }
    },

    forceMarkTransformDirty: function() {
      this.transformDirty = true;
      this.relativeSelfDirty = true;

      var frameId = this.display._frameId;

      // mark all ancestors with relativeChildDirtyFrame, bailing out when possible
      var instance = this.instance.parent;
      while ( instance && instance.relativeTransform.relativeChildDirtyFrame !== frameId ) {
        var parentInstance = instance.parent;
        var isTransformed = instance.isTransformed;

        // NOTE: our while loop guarantees that it wasn't frameId
        instance.relativeTransform.relativeChildDirtyFrame = frameId;

        // always mark an instance without a parent (root instance!)
        if ( parentInstance === null ) {
          // passTransform depends on whether it is marked as a transform root
          this.display.markTransformRootDirty( instance, isTransformed );
          break;
        }
        else if ( isTransformed ) {
          this.display.markTransformRootDirty( instance, true ); // passTransform true
          break;
        }

        instance = parentInstance;
      }
    },

    // @private, updates our matrix based on any parents, and the node's current transform
    computeRelativeTransform: function() {
      var nodeMatrix = this.node.getMatrix();

      if ( this.instance.parent && !this.instance.parent.isTransformed ) {
        // mutable form of parentMatrix * nodeMatrix
        this.matrix.set( this.parent.matrix );
        this.matrix.multiplyMatrix( nodeMatrix );
      }
      else {
        // we are the first in the trail transform, so we just directly copy the matrix over
        this.matrix.set( nodeMatrix );
      }

      // mark the frame where this transform was updated, to accelerate non-precomputed access
      this.relativeFrameId = this.display._frameId;
      this.relativeSelfDirty = false;
    },

    // @public
    isValidationNotNeeded: function() {
      return this.hasAncestorComputeNeed() || this.relativeFrameId === this.display._frameId;
    },

    // Called from any place in the rendering process where we are not guaranteed to have a fresh relative transform.
    // needs to scan up the tree, so it is more expensive than precomputed transforms.
    // @returns Whether we had to update this transform
    validate: function() {
      // if we are clean, bail out. If we have a compute "need", we will always be clean here since this is after the
      // traversal step. If we did not have a compute "need", we check whether we were already updated this frame by
      // computeRelativeTransform.
      if ( this.isValidationNotNeeded() ) {
        return;
      }

      // if we are not the first transform from the root, validate our parent. isTransform check prevents us from
      // passing a transform root.
      if ( this.instance.parent && !this.instance.parent.isTransformed ) {
        this.parent.validate();
      }

      // validation of the parent may have changed our relativeSelfDirty flag to true, so we check now (could also have
      // been true before)
      if ( this.relativeSelfDirty ) {
        // compute the transform, and mark us as not relative-dirty
        this.computeRelativeTransform();

        // mark all children now as dirty, since we had to update (marked so that other children from the one we are
        // validating will know that they need updates)
        // if we were called from a child's validate(), they will now need to compute their transform
        var len = this.instance.children.length;
        for ( var i = 0; i < len; i++ ) {
          this.instance.children[ i ].relativeTransform.relativeSelfDirty = true;
        }
      }
    },

    // called during the pre-repaint phase to (a) fire off all relative transform listeners that should be fired, and
    // (b) precompute transforms were desired
    updateTransformListenersAndCompute: function( ancestorWasDirty, ancestorIsDirty, frameId, passTransform ) {
      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.RelativeTransform(
        'update/compute: ' + this.toString() + ' ' + ancestorWasDirty + ' => ' + ancestorIsDirty +
        ( passTransform ? ' passTransform' : '' ) );
      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.push();

      var len;
      var i;

      if ( passTransform ) {
        // if we are passing isTransform, just apply this to the children
        len = this.instance.children.length;
        for ( i = 0; i < len; i++ ) {
          this.instance.children[ i ].relativeTransform.updateTransformListenersAndCompute( false, false, frameId, false );
        }
      }
      else {
        var wasDirty = ancestorWasDirty || this.relativeSelfDirty;
        var wasSubtreeDirty = wasDirty || this.relativeChildDirtyFrame === frameId;
        var hasComputeNeed = this.hasDescendantComputeNeed();
        var hasListenerNeed = this.hasDescendantListenerNeed();
        var hasSelfComputeNeed = this.hasSelfComputeNeed();
        var hasSelfListenerNeed = this.hasSelfListenerNeed();

        // if our relative transform will be dirty but our parents' transform will be clean, we need to mark ourselves
        // as dirty (so that later access can identify we are dirty).
        if ( !hasComputeNeed && wasDirty && !ancestorIsDirty ) {
          this.relativeSelfDirty = true;
        }

        // check if traversal isn't needed (no instances marked as having listeners or needing computation)
        // either the subtree is clean (no traversal needed for compute/listeners), or we have no compute/listener needs
        if ( !wasSubtreeDirty || ( !hasComputeNeed && !hasListenerNeed && !hasSelfComputeNeed && !hasSelfListenerNeed ) ) {
          sceneryLog && sceneryLog.RelativeTransform && sceneryLog.pop();
          return;
        }

        // if desired, compute the transform
        if ( wasDirty && ( hasComputeNeed || hasSelfComputeNeed ) ) {
          // compute this transform in the pre-repaint phase, so it is cheap when always used/
          // we update when the child-precompute count >0, since those children will need
          this.computeRelativeTransform();
        }

        if ( this.transformDirty ) {
          this.transformDirty = false;
        }

        // no hasListenerNeed guard needed?
        this.notifyRelativeTransformListeners();

        // only update children if we aren't transformed (completely other context)
        if ( !this.instance.isTransformed || passTransform ) {

          var isDirty = wasDirty && !( hasComputeNeed || hasSelfComputeNeed );

          // continue the traversal
          len = this.instance.children.length;
          for ( i = 0; i < len; i++ ) {
            this.instance.children[ i ].relativeTransform.updateTransformListenersAndCompute( wasDirty, isDirty, frameId, false );
          }
        }
      }

      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.pop();
    },

    // @private
    notifyRelativeTransformListeners: function() {
      var len = this.relativeTransformListeners.length;
      for ( var i = 0; i < len; i++ ) {
        this.relativeTransformListeners[ i ]();
      }
    },

    audit: function( frameId, allowValidationNotNeededChecks ) {
      // get the relative matrix, computed to be up-to-date, and ignores any flags/counts so we can check whether our
      // state is consistent
      function currentRelativeMatrix( instance ) {
        var resultMatrix = Matrix3.dirtyFromPool();
        var nodeMatrix = instance.node.getMatrix();

        if ( !instance.parent ) {
          // if our instance has no parent, ignore its transform
          resultMatrix.set( Matrix3.IDENTITY );
        }
        else if ( !instance.parent.isTransformed ) {
          // mutable form of parentMatrix * nodeMatrix
          resultMatrix.set( currentRelativeMatrix( instance.parent ) );
          resultMatrix.multiplyMatrix( nodeMatrix );
        }
        else {
          // we are the first in the trail transform, so we just directly copy the matrix over
          resultMatrix.set( nodeMatrix );
        }

        return resultMatrix;
      }

      function hasRelativeSelfDirty( instance ) {
        // if validation isn't needed, act like nothing is dirty (matching our validate behavior)
        if ( allowValidationNotNeededChecks && instance.isValidationNotNeeded() ) {
          return false;
        }

        return instance.relativeSelfDirty || ( instance.parent && hasRelativeSelfDirty( instance.parent ) );
      }

      if ( assertSlow ) {
        // count verification for invariants
        var notifyRelativeCount = 0;
        var precomputeRelativeCount = 0;
        for ( var i = 0; i < this.instance.children.length; i++ ) {
          var childInstance = this.instance.children[ i ];

          if ( childInstance.relativeTransform.hasAncestorListenerNeed() ) {
            notifyRelativeCount++;
          }
          if ( childInstance.relativeTransform.hasAncestorComputeNeed() ) {
            precomputeRelativeCount++;
          }
        }
        assertSlow( notifyRelativeCount === this.relativeChildrenListenersCount,
          'Relative listener count invariant' );
        assertSlow( precomputeRelativeCount === this.relativeChildrenPrecomputeCount,
          'Relative precompute count invariant' );

        assertSlow( !this.parent || this.instance.isTransformed || ( this.relativeChildDirtyFrame !== frameId ) ||
                    ( this.parent.relativeChildDirtyFrame === frameId ),
          'If we have a parent, we need to hold the invariant ' +
          'this.relativeChildDirtyFrame => parent.relativeChildDirtyFrame' );

        // Since we check to see if something is not dirty, we need to handle this when we are actually reporting
        // what is dirty. See https://github.com/phetsims/scenery/issues/512
        if ( !allowValidationNotNeededChecks && !hasRelativeSelfDirty( this ) ) {
          var matrix = currentRelativeMatrix( this );
          assertSlow( matrix.equals( this.matrix ), 'If there is no relativeSelfDirty flag set here or in our' +
                                                    ' ancestors, our matrix should be up-to-date' );
        }
      }
    }
  } );

  return RelativeTransform;
} );

// Copyright 2015-2016, University of Colorado Boulder

/**
 * A sub-component of an Instance that handles matters relating to whether fitted blocks should not fit if possible.
 * We mostly mark our own drawables as fittable, and track whether our subtree is all fittable (so that common-ancestor
 * fits can determine if their bounds will change).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Fittability',['require','PHET_CORE/inherit','AXON/Emitter','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @constructor
   *
   * @param {Instance} instance - Our Instance, never changes.
   */
  function Fittability( instance ) {
    // @private {Instance}
    this.instance = instance;
  }

  scenery.register( 'Fittability', Fittability );

  inherit( Object, Fittability, {
    /**
     * Responsible for initialization and cleaning of this. If the parameters are both null, we'll want to clean our
     * external references (like Instance does).
     *
     * @param {Display|null} display
     * @param {Trail|null} trail
     * @returns {Fittability} - Returns this, to allow chaining.
     */
    initialize: function( display, trail ) {
      this.display = display; // @private {Display}
      this.trail = trail; // @private {Trail}
      this.node = trail && trail.lastNode(); // @private {Node}

      // @public {boolean} - When our instance's node has a particular combination of features and/or flags (like
      // preventDefault:true) that should make any FittedBlock containing drawables under that node OR that would
      // include the bounds of the node in its FittedBlock to not compute the relevant fit (e.g. have it take up the
      // full display instead).
      this.selfFittable = !!trail && this.isSelfFitSupported();

      // @public {boolean} - Whether this instance AND all of its ancestor instances (down to the root instance for the
      // display) all are self-fittable.
      this.ancestorsFittable = this.selfFittable;

      // @public {number} - The number of children whose subtrees have an unfittable instance, plus 1 if this instance
      // itself is unfittable. Using a number allows us to quickly increment/decrement when a particular child changes
      // its fittability (so we don't have to check other subtrees or traverse further up the tree). For a more
      // complete description of this technique, see RendererSummary.
      // This is important, since if it's 0, it indicates that this entire subtree has NO unfittable content. Thus if
      // a FittedBlock's common ancestor (for the common-ancestor fit) is this instance, we shouldn't have issues
      // updating our bounds.
      this.subtreeUnfittableCount = this.selfFittable ? 0 : 1;

      // @public {Emitter} - Called with no arguments when the subtree fittability changes (whether
      // subtreeUnfittableCount is greater than zero or not).
      this.subtreeFittabilityChange = this.subtreeFittabilityChange || new Emitter();

      return this; // allow chaining
    },

    /**
     * Easy access to our parent Instance's Fittability, if it exists.
     * @private
     *
     * @returns {Fittability|null}
     */
    get parent() {
      return this.instance.parent ? this.instance.parent.fittability : null;
    },

    /**
     * Called when the instance is updating its rendering state (as any fittability changes to existing instances will
     * trigger an update there).
     * @public
     */
    checkSelfFittability: function() {
      var newSelfFittable = this.isSelfFitSupported();
      if ( this.selfFittable !== newSelfFittable ) {
        this.updateSelfFittable();
      }
    },

    /**
     * Whether our node's performance flags allows the subtree to be fitted.
     * @private
     *
     * Any updates to flags (for instance, a 'dynamic' flag perhaps?) should be added here.
     *
     * @returns {boolean}
     */
    isSelfFitSupported: function() {
      return !this.node.isPreventFit();
    },

    /**
     * Called when our parent just became fittable. Responsible for flagging subtrees with the ancestorsFittable flag,
     * up to the point where they are fittable.
     * @private
     */
    markSubtreeFittable: function() {
      // Bail if we can't be fittable ourselves
      if ( !this.selfFittable ) {
        return;
      }

      this.ancestorsFittable = true;

      var children = this.instance.children;
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].fittability.markSubtreeFittable();
      }

      // Update the Instance's drawables, so that their blocks can potentially now be fitted.
      this.instance.updateDrawableFittability( true );
    },

    /**
     * Called when our parent just became unfittable and we are fittable. Responsible for flagging subtrees with
     * the !ancestorsFittable flag, up to the point where they are unfittable.
     * @private
     */
    markSubtreeUnfittable: function() {
      // Bail if we are already unfittable
      if ( !this.ancestorsFittable ) {
        return;
      }

      this.ancestorsFittable = false;

      var children = this.instance.children;
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].fittability.markSubtreeUnfittable();
      }

      // Update the Instance's drawables, so that their blocks can potentially now be prevented from being fitted.
      this.instance.updateDrawableFittability( false );
    },

    /**
     * Called when our Node's self fit-ability has changed.
     * @private
     */
    updateSelfFittable: function() {
      var newSelfFittable = this.isSelfFitSupported();
      assert && assert( this.selfFittable !== newSelfFittable );

      this.selfFittable = newSelfFittable;

      if ( this.selfFittable && ( !this.parent || this.parent.ancestorsFittable ) ) {
        this.markSubtreeFittable();
      }
      else if ( !this.selfFittable ) {
        this.markSubtreeUnfittable();
      }

      if ( this.selfFittable ) {
        this.decrementSubtreeUnfittableCount();
      }
      else {
        this.incrementSubtreeUnfittableCount();
      }
    },

    /**
     * A child instance's subtree became unfittable, OR our 'self' became unfittable. This is responsible for updating
     * the subtreeFittableCount for this instance AND up to all ancestors that would be affected by the change.
     * @private
     */
    incrementSubtreeUnfittableCount: function() {
      this.subtreeUnfittableCount++;

      // If now something in our subtree can't be fitted, we need to notify our parent
      if ( this.subtreeUnfittableCount === 1 ) {
        this.parent && this.parent.incrementSubtreeUnfittableCount();

        // Notify anything listening that the condition ( this.subtreeUnfittableCount > 0 ) changed.
        this.subtreeFittabilityChange.emit();
      }
    },

    /**
     * A child instance's subtree became fittable, OR our 'self' became fittable. This is responsible for updating
     * the subtreeFittableCount for this instance AND up to all ancestors that would be affected by the change.
     * @private
     */
    decrementSubtreeUnfittableCount: function() {
      this.subtreeUnfittableCount--;

      // If now our subtree can all be fitted, we need to notify our parent
      if ( this.subtreeUnfittableCount === 0 ) {
        this.parent && this.parent.decrementSubtreeUnfittableCount();

        // Notify anything listening that the condition ( this.subtreeUnfittableCount > 0 ) changed.
        this.subtreeFittabilityChange.emit();
      }
    },

    /**
     * Called when an instance is added as a child to our instance. Updates necessary counts.
     * @public
     *
     * @param {Fittability} childFittability - The Fittability of the new child instance.
     */
    onInsert: function( childFittability ) {
      if ( !this.ancestorsFittable ) {
        childFittability.markSubtreeUnfittable();
      }

      if ( childFittability.subtreeUnfittableCount > 0 ) {
        this.incrementSubtreeUnfittableCount();
      }
    },

    /**
     * Called when a child instance is removed from our instance. Updates necessary counts.
     * @public
     *
     * @param {Fittability} childFittability - The Fittability of the old child instance.
     */
    onRemove: function( childFittability ) {
      if ( !this.ancestorsFittable ) {
        childFittability.markSubtreeFittable();
      }

      if ( childFittability.subtreeUnfittableCount > 0 ) {
        this.decrementSubtreeUnfittableCount();
      }
    },

    /**
     * Sanity checks that run when slow assertions are enabled. Enforces the invariants of the Fittability subsystem.
     * @public
     */
    audit: function() {
      if ( assertSlow ) {
        assertSlow( this.selfFittable === this.isSelfFitSupported(),
          'selfFittable diverged from isSelfFitSupported()' );

        assertSlow( this.ancestorsFittable === ( ( this.parent ? this.parent.ancestorsFittable : true ) && this.selfFittable ),
          'Our ancestorsFittable should be false if our parent or our self is not fittable.' );

        // Our subtree unfittable count should be the sum of children that have a non-zero count, plus 1 if our self
        // is not fittable
        var subtreeUnfittableCount = 0;
        if ( !this.selfFittable ) {
          subtreeUnfittableCount++;
        }
        _.each( this.instance.children, function( instance ) {
          if ( instance.fittability.subtreeUnfittableCount > 0 ) {
            subtreeUnfittableCount++;
          }
        } );
        assertSlow( this.subtreeUnfittableCount === subtreeUnfittableCount, 'Incorrect subtreeUnfittableCount' );
      }
    }
  } );

  return Fittability;
} );

// Copyright 2013-2016, University of Colorado Boulder


/**
 * An instance that is specific to the display (not necessarily a global instance, could be in a Canvas cache, etc),
 * that is needed to tracking instance-specific display information, and signals to the display system when other
 * changes are necessary.
 *
 * Instances generally form a true tree, as opposed to the DAG of nodes. The one exception is for shared Canvas caches,
 * where multiple instances can point to one globally-stored (shared) cache instance.
 *
 * An Instance is pooled, but when constructed will not automatically create children, drawables, etc.
 * syncTree() is responsible for synchronizing the instance itself and its entire subtree.
 *
 * Instances are created as 'stateless' instances, but during syncTree the rendering state (properties to determine
 * how to construct the drawable tree for this instance and its subtree) are set.
 *
 * While Instances are considered 'stateful', they will have listeners added to their Node which records actions taken
 * in-between Display.updateDisplay().
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Instance',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','PHET_CORE/arrayRemove','SCENERY/scenery','SCENERY/display/ChangeInterval','SCENERY/display/Drawable','SCENERY/display/Renderer','SCENERY/display/RelativeTransform','SCENERY/display/Fittability','SCENERY/util/Util','AXON/Events'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var arrayRemove = require( 'PHET_CORE/arrayRemove' );
  var scenery = require( 'SCENERY/scenery' );
  var ChangeInterval = require( 'SCENERY/display/ChangeInterval' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var RelativeTransform = require( 'SCENERY/display/RelativeTransform' );
  var Fittability = require( 'SCENERY/display/Fittability' );
  var Util = require( 'SCENERY/util/Util' );
  var Events = require( 'AXON/Events' );

  var globalIdCounter = 1;

  // preferences top to bottom in general
  var defaultPreferredRenderers = Renderer.createOrderBitmask(
    Renderer.bitmaskSVG, Renderer.bitmaskCanvas, Renderer.bitmaskDOM, Renderer.bitmaskWebGL );

  /**
   * @constructor
   * @mixes Poolable
   *
   * See initialize() for documentation
   *
   * @param display
   * @param trail
   * @param isDisplayRoot
   * @param isSharedCanvasCacheRoot
   */
  function Instance( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
    Events.call( this );

    this.active = false;

    this.initialize( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
  }

  scenery.register( 'Instance', Instance );

  inherit( Events, Instance, {
    /*
     * @param {Display} display - Instances are bound to a single display
     * @param {Trail} trail - The list of ancestors going back up to our root instance (for the display, or for a cache)
     * @param {boolean} isDisplayRoot - Whether our instance is for the root node provided to the Display.
     * @param {boolean} isSharedCanvasCacheRoot - Whether our instance is the root for a shared Canvas cache (which can
     *                                            be used multiple places in the main instance tree)
     */
    initialize: function( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
      assert && assert( !this.active,
        'We should never try to initialize an already active object' );

      // prevent the trail passed in from being mutated after this point (we want a consistent trail)
      trail.setImmutable();

      this.id = this.id || globalIdCounter++;

      this.isWebGLSupported = display._allowWebGL && Util.isWebGLSupported;

      // {RelativeTransform}, provides high-performance access to 'relative' transforms (from our nearest
      // transform root), and allows for listening to when our relative transform changes (called during
      // a phase of Display.updateDisplay()).
      this.relativeTransform = ( this.relativeTransform || new RelativeTransform( this ) );

      // {Fittability}, provides logic for whether our drawables (or common-fit ancestors) will support fitting for
      // FittedBlock subtypes. See https://github.com/phetsims/scenery/issues/406.
      this.fittability = ( this.fittability || new Fittability( this ) );

      // Tracking of visibility {boolean} and associated boolean flags.
      this.visible = true; // global visibility (whether this instance will end up appearing on the display)
      this.relativeVisible = true; // relative visibility (ignores the closest ancestral visibility root and below)
      this.selfVisible = true; // like relative visibility, but is always true if we are a visibility root
      this.visibilityDirty = true; // entire subtree of visibility will need to be updated
      this.childVisibilityDirty = true; // an ancestor needs its visibility updated

      // Maps Instance.id => branch index (first index where the two trails are different)
      this.branchIndexMap = {}; // TODO: Can we not recreate an object?

      // {Array.<Instance>} All instances where we have entries in our map
      this.branchIndexReferences = cleanArray( this.branchIndexReferences );

      // In the range (-1,0), to help us track insertions and removals of this instance's node to its parent
      // (did we get removed but added back?).
      // If it's -1 at its parent's syncTree, we'll end up removing our reference to it.
      // We use an integer just for sanity checks (if it ever reaches -2 or 1, we've reached an invalid state)
      this.addRemoveCounter = 0;

      // If equal to the current frame ID (it is initialized as such), then it is treated during the change interval
      // waterfall as "completely changed", and an interval for the entire instance is used.
      this.stitchChangeFrame = display._frameId;

      // If equal to the current frame ID, an instance was removed from before or after this instance, so we'll want to
      // add in a proper change interval (related to siblings)
      this.stitchChangeBefore = 0;
      this.stitchChangeAfter = 0;

      // If equal to the current frame ID, child instances were added or removed from this instance.
      this.stitchChangeOnChildren = 0;

      // whether we have been included in our parent's drawables the previous frame
      this.stitchChangeIncluded = false;

      // Node listeners for tracking children. Listeners should be added only when we become stateful
      this.childInsertedListener = this.childInsertedListener || this.onChildInserted.bind( this );
      this.childRemovedListener = this.childRemovedListener || this.onChildRemoved.bind( this );
      this.visibilityListener = this.visibilityListener || this.onVisibilityChange.bind( this );
      this.markRenderStateDirtyListener = this.markRenderStateDirtyListener || this.markRenderStateDirty.bind( this );

      this.cleanInstance( display, trail );

      // We need to add this reference on stateless instances, so that we can find out if it was removed before our
      // syncTree was called.
      this.node.addInstance( this );

      // Outstanding external references. used for shared cache instances, where multiple instances can point to us.
      this.externalReferenceCount = 0;

      this.stateless = true; // {boolean} - Whether we have had our state initialized yet

      // Rendering state constants (will not change over the life of an instance)
      this.isDisplayRoot = isDisplayRoot; // {boolean} - Whether we are the root instance for a Display
      this.isSharedCanvasCacheRoot = isSharedCanvasCacheRoot; // {boolean} - Whether we are the root of a Canvas cache

      // 'Cascading' render state for the instance tree. These are properties that can affect the entire subtree when set
      this.preferredRenderers = 0; // {number} - Packed renderer order bitmask (what our renderer preferences are)
      this.isUnderCanvasCache = isSharedCanvasCacheRoot; // {boolean} - Whether we are beneath a Canvas cache (Canvas required)

      // Render state exports for this instance.
      this.isBackbone = false; // {boolean} - Whether we will have a BackboneDrawable group drawable
      this.isTransformed = false;  // {boolean} - Whether this instance creates a new "root" for the relative trail transforms
      this.isVisibilityApplied = false; // {boolean} - Whether this instance handles visibility with a group drawable
      this.isInstanceCanvasCache = false; // {boolean} - Whether we have a Canvas cache specific to this instance's position
      this.isSharedCanvasCachePlaceholder = false; // {boolean}
      this.isSharedCanvasCacheSelf = isSharedCanvasCacheRoot; // {boolean}
      this.selfRenderer = 0; // {number} Renderer bitmask for the 'self' drawable (if our Node is painted)
      this.groupRenderer = 0; // {number} Renderer bitmask for the 'group' drawable (if applicable)
      this.sharedCacheRenderer = 0; // {number} Renderer bitmask for the cache drawable (if applicable)

      // pruning flags (whether we need to be visited, whether updateRenderingState is required, and whether to visit children)
      this.renderStateDirtyFrame = display._frameId; // {number} - When equal to the current frame it is considered "dirty"
      this.skipPruningFrame = display._frameId; // {number} - When equal to the current frame we can't prune at this instance

      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'initialized ' + this.toString() );

      // Whether we have been instantiated. false if we are in a pool waiting to be instantiated.
      this.active = true;

      return this;
    },

    /*
     * Called for initialization of properties (via initialize(), via constructor), and to clean the instance for
     * placement in the pool (don't leak memory).
     *
     * If the parameters are null, we remove all external references so that we don't leak memory.
     *
     * @param {Display|null} display - Instances are bound to a single display
     * @param {Trail|null} trail - The list of ancestors going back up to our root instance (for the display, or for a cache)
     */
    cleanInstance: function( display, trail ) {
      this.display = display;
      this.trail = trail;
      this.node = trail ? trail.lastNode() : null;
      this.parent = null; // will be set as needed
      this.oldParent = null; // set when removed from us, so that we can easily reattach it when necessary
      // NOTE: reliance on correct order after syncTree by at least SVGBlock/SVGGroup
      this.children = cleanArray( this.children ); // Array[Instance].
      this.sharedCacheInstance = null; // reference to a shared cache instance (different than a child)

      // initialize/clean sub-components
      this.relativeTransform.initialize( display, trail );
      this.fittability.initialize( display, trail );

      // {Instance[]} - Child instances are pushed to here when their node is removed from our node.
      // We don't immediately dispose, since it may be added back.
      this.instanceRemovalCheckList = cleanArray( this.instanceRemovalCheckList );

      // {Drawable} - references to our drawables in the drawable tree
      this.selfDrawable = null;
      this.groupDrawable = null; // e.g. backbone or non-shared cache
      this.sharedCacheDrawable = null; // our drawable if we are a shared cache

      // {Drawable} - references into the linked list of drawables (null if nothing is drawable under this)
      this.firstDrawable = null;
      this.lastDrawable = null;

      // {Drawable} - references into the linked list of drawables (excludes any group drawables handling)
      this.firstInnerDrawable = null;
      this.lastInnerDrawable = null;

      // {SVGGroup[]} - List of SVG groups associated with this display instance
      this.svgGroups = cleanArray( this.svgGroups );

      this.cleanSyncTreeResults();
    },

    /*
     * Initializes or clears properties that are all set as pseudo 'return values' of the syncTree() method. It is the
     * responsibility of the caller of syncTree() to afterwards (optionally read these results and) clear the references
     * using this method to prevent memory leaks.
     *
     * TODO: consider a pool of (or a single global) typed return object(s), since setting these values on the instance
     * generally means hitting the heap, and can slow us down.
     */
    cleanSyncTreeResults: function() {
      // Tracking bounding indices / drawables for what has changed, so we don't have to over-stitch things.

      // if (not iff) child's index <= beforeStableIndex, it hasn't been added/removed. relevant to current children.
      this.beforeStableIndex = this.children.length;

      // if (not iff) child's index >= afterStableIndex, it hasn't been added/removed. relevant to current children.
      this.afterStableIndex = -1;

      // NOTE: both of these being null indicates "there are no change intervals", otherwise it assumes it points to
      // a linked-list of change intervals. We use {ChangeInterval}s to hold this information, see ChangeInterval to see
      // the individual properties that are considered part of a change interval.

      // {ChangeInterval}, first change interval (should have nextChangeInterval linked-list to lastChangeInterval)
      this.firstChangeInterval = null;

      // {ChangeInterval}, last change interval
      this.lastChangeInterval = null;

      // {boolean} - render state change flags, all set in updateRenderingState()
      this.incompatibleStateChange = false; // {boolean} - Whether we need to recreate the instance tree
      this.groupChanged = false; // {boolean} - Whether we need to force a rebuild of the group drawable
      this.cascadingStateChange = false; // {boolean} - Whether we had a render state change that requires visiting all children
      this.anyStateChange = false; // {boolean} - Whether there was any change of rendering state with the last updateRenderingState()
    },

    /*
     * Updates the rendering state properties, and returns a {boolean} flag of whether it was successful if we were
     * already stateful.
     *
     * Rendering state properties determine how we construct the drawable tree from our instance tree (e.g. do we
     * create an SVG or Canvas rectangle, where to place CSS transforms, how to handle opacity, etc.)
     *
     * Instances start out as 'stateless' until updateRenderingState() is called the first time.
     *
     * Node changes that can cause a potential state change (using Node event listeners):
     * - hints
     * - opacity
     * - clipArea
     * - _rendererSummary
     * - _rendererBitmask
     *
     * State changes that can cause cascading state changes in descendants:
     * - isUnderCanvasCache
     * - preferredRenderers
     */
    updateRenderingState: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'updateRenderingState ' + this.toString() +
                                                                ( this.stateless ? ' (stateless)' : '' ) );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'old: ' + this.getStateString() );

      // old state information, so we can compare what was changed
      var wasBackbone = this.isBackbone;
      var wasTransformed = this.isTransformed;
      var wasVisibilityApplied = this.isVisibilityApplied;
      var wasInstanceCanvasCache = this.isInstanceCanvasCache;
      var wasSharedCanvasCacheSelf = this.isSharedCanvasCacheSelf;
      var wasSharedCanvasCachePlaceholder = this.isSharedCanvasCachePlaceholder;
      var wasUnderCanvasCache = this.isUnderCanvasCache;
      var oldSelfRenderer = this.selfRenderer;
      var oldGroupRenderer = this.groupRenderer;
      var oldSharedCacheRenderer = this.sharedCacheRenderer;
      var oldPreferredRenderers = this.preferredRenderers;

      // default values to set (makes the logic much simpler)
      this.isBackbone = false;
      this.isTransformed = false;
      this.isVisibilityApplied = false;
      this.isInstanceCanvasCache = false;
      this.isSharedCanvasCacheSelf = false;
      this.isSharedCanvasCachePlaceholder = false;
      this.selfRenderer = 0;
      this.groupRenderer = 0;
      this.sharedCacheRenderer = 0;

      var hints = this.node._hints;

      this.isUnderCanvasCache = this.isSharedCanvasCacheRoot ||
                                ( this.parent ? ( this.parent.isUnderCanvasCache || this.parent.isInstanceCanvasCache || this.parent.isSharedCanvasCacheSelf ) : false );

      // set up our preferred renderer list (generally based on the parent)
      this.preferredRenderers = this.parent ? this.parent.preferredRenderers : defaultPreferredRenderers;
      // allow the node to modify its preferred renderers (and those of its descendants)
      if ( hints.renderer ) {
        this.preferredRenderers = Renderer.pushOrderBitmask( this.preferredRenderers, hints.renderer );
      }

      var hasClip = this.node.hasClipArea();
      var hasTransparency = this.node.opacity !== 1 || hints.usesOpacity;
      var requiresSplit = hints.requireElement || hints.cssTransform || hints.layerSplit;
      var backboneRequired = this.isDisplayRoot || ( !this.isUnderCanvasCache && requiresSplit );

      // Support either "all Canvas" or "all SVG" opacity/clip
      var applyTransparencyWithBlock = !backboneRequired &&
                                       ( hasTransparency || hasClip ) &&
                                       ( this.node._rendererSummary.isSubtreeRenderedExclusivelySVG( this.preferredRenderers ) ||
                                         this.node._rendererSummary.isSubtreeRenderedExclusivelyCanvas( this.preferredRenderers ) );
      var useBackbone = applyTransparencyWithBlock ? false : ( backboneRequired || hasTransparency || hasClip );

      // check if we need a backbone or cache
      // if we are under a canvas cache, we will NEVER have a backbone
      // splits are accomplished just by having a backbone
      // NOTE: If changing, check RendererSummary.summaryBitmaskForNodeSelf
      //OHTWO TODO: Update this to properly identify when backbones are necessary/and-or when we forward opacity/clipping
      if ( useBackbone ) {
        this.isBackbone = true;
        this.isVisibilityApplied = true;
        this.isTransformed = this.isDisplayRoot || !!hints.cssTransform; // for now, only trigger CSS transform if we have the specific hint
        //OHTWO TODO: check whether the force acceleration hint is being used by our DOMBlock
        this.groupRenderer = Renderer.bitmaskDOM; // probably won't be used
      }
      else if ( !applyTransparencyWithBlock && ( hasTransparency || hasClip || hints.canvasCache ) ) {
        // everything underneath needs to be renderable with Canvas, otherwise we cannot cache
        assert && assert( this.node._rendererSummary.isSingleCanvasSupported(),
          'hints.canvasCache provided, but not all node contents can be rendered with Canvas under ' +
          this.node.constructor.name );

        if ( hints.singleCache ) {
          // TODO: scale options - fixed size, match highest resolution (adaptive), or mipmapped
          if ( this.isSharedCanvasCacheRoot ) {
            this.isSharedCanvasCacheSelf = true;

            this.sharedCacheRenderer = this.isWebGLSupported ? Renderer.bitmaskWebGL : Renderer.bitmaskCanvas;
          }
          else {
            // everything underneath needs to guarantee that its bounds are valid
            //OHTWO TODO: We'll probably remove this if we go with the "safe bounds" approach
            assert && assert( this.node._rendererSummary.areBoundsValid(),
              'hints.singleCache provided, but not all node contents have valid bounds under ' +
              this.node.constructor.name );

            this.isSharedCanvasCachePlaceholder = true;
          }
        }
        else {
          this.isInstanceCanvasCache = true;
          this.isUnderCanvasCache = true;
          this.groupRenderer = this.isWebGLSupported ? Renderer.bitmaskWebGL : Renderer.bitmaskCanvas;
        }
      }

      if ( this.node.isPainted() ) {
        if ( this.isUnderCanvasCache ) {
          this.selfRenderer = Renderer.bitmaskCanvas;
        }
        else {
          var supportedNodeBitmask = this.node._rendererBitmask;
          if ( !this.isWebGLSupported ) {
            var invalidBitmasks = Renderer.bitmaskWebGL;
            supportedNodeBitmask = supportedNodeBitmask ^ ( supportedNodeBitmask & invalidBitmasks );
          }

          // use the preferred rendering order if specified, otherwise use the default
          this.selfRenderer = ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 0 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 1 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 2 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 3 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskSVG ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskCanvas ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskDOM ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskWebGL ) ||
                              0;

          assert && assert( this.selfRenderer, 'setSelfRenderer failure?' );
        }
      }

      // whether we need to force rebuilding the group drawable
      this.groupChanged = ( wasBackbone !== this.isBackbone ) ||
                          ( wasInstanceCanvasCache !== this.isInstanceCanvasCache ) ||
                          ( wasSharedCanvasCacheSelf !== this.isSharedCanvasCacheSelf );

      // whether any of our render state changes can change descendant render states
      this.cascadingStateChange = ( wasUnderCanvasCache !== this.isUnderCanvasCache ) ||
                                  ( oldPreferredRenderers !== this.preferredRenderers );

      /*
       * Whether we can just update the state on an Instance when changing from this state => otherState.
       * This is generally not possible if there is a change in whether the instance should be a transform root
       * (e.g. backbone/single-cache), so we will have to recreate the instance and its subtree if that is the case.
       *
       * Only relevant if we were previously stateful, so it can be ignored if this is our first updateRenderingState()
       */
      this.incompatibleStateChange = ( this.isTransformed !== wasTransformed ) ||
                                     ( this.isSharedCanvasCachePlaceholder !== wasSharedCanvasCachePlaceholder );

      // whether there was any render state change
      this.anyStateChange = this.groupChanged || this.cascadingStateChange || this.incompatibleStateChange ||
                            ( oldSelfRenderer !== this.selfRenderer ) ||
                            ( oldGroupRenderer !== this.groupRenderer ) ||
                            ( oldSharedCacheRenderer !== this.sharedCacheRenderer );

      // if our visibility applications changed, update the entire subtree
      if ( wasVisibilityApplied !== this.isVisibilityApplied ) {
        this.visibilityDirty = true;
        this.parent && this.parent.markChildVisibilityDirty();
      }

      // If our fittability has changed, propagate those changes. (It's generally a hint change which will trigger an
      // update of rendering state).
      this.fittability.checkSelfFittability();

      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new: ' + this.getStateString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },

    /*
     * @returns A short string that contains a summary of the rendering state, for debugging/logging purposes.
     */
    getStateString: function() {
      var result = 'S[ ' +
                   ( this.isDisplayRoot ? 'displayRoot ' : '' ) +
                   ( this.isBackbone ? 'backbone ' : '' ) +
                   ( this.isInstanceCanvasCache ? 'instanceCache ' : '' ) +
                   ( this.isSharedCanvasCachePlaceholder ? 'sharedCachePlaceholder ' : '' ) +
                   ( this.isSharedCanvasCacheSelf ? 'sharedCacheSelf ' : '' ) +
                   ( this.isTransformed ? 'TR ' : '' ) +
                   ( this.isVisibilityApplied ? 'VIS ' : '' ) +
                   ( this.selfRenderer ? this.selfRenderer.toString( 16 ) : '-' ) + ',' +
                   ( this.groupRenderer ? this.groupRenderer.toString( 16 ) : '-' ) + ',' +
                   ( this.sharedCacheRenderer ? this.sharedCacheRenderer.toString( 16 ) : '-' ) + ' ';
      return result + ']';
    },

    /*
     * The main entry point for syncTree(), called on the root instance. See syncTree() for more information.
     */
    baseSyncTree: function() {
      assert && assert( this.isDisplayRoot, 'baseSyncTree() should only be called on the root instance' );

      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( '-------- START baseSyncTree ' + this.toString() + ' --------' );
      this.syncTree();
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( '-------- END baseSyncTree ' + this.toString() + ' --------' );
      this.cleanSyncTreeResults();
    },

    /*
     * Updates the rendering state, synchronizes the instance sub-tree (so that our instance tree matches
     * the Node tree the client provided), and back-propagates {ChangeInterval} information for stitching backbones
     * and/or caches.
     *
     * syncTree() also sets a number of pseudo 'return values' (documented in cleanSyncTreeResults()). After calling
     * syncTree() and optionally reading those results, cleanSyncTreeResults() should be called on the same instance
     * in order to prevent memory leaks.
     *
     * @returns {boolean} - Whether the sync was possible. If it wasn't, a new instance subtree will need to be created.
     */
    syncTree: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'syncTree ' + this.toString() + ' ' + this.getStateString() +
                                                                ( this.stateless ? ' (stateless)' : '' ) );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.display.perfSyncTreeCount++;
      }

      // may access isTransformed up to root to determine relative trails
      assert && assert( !this.parent || !this.parent.stateless, 'We should not have a stateless parent instance' );

      var wasStateless = this.stateless;
      if ( wasStateless ||
           ( this.parent && this.parent.cascadingStateChange ) || // if our parent had cascading state changes, we need to recompute
           ( this.renderStateDirtyFrame === this.display._frameId ) ) { // if our render state is dirty
        this.updateRenderingState();
      }
      else {
        // we can check whether updating state would have made any changes when we skip it (for slow assertions)
        if ( assertSlow ) {
          this.updateRenderingState();
          assertSlow( !this.anyStateChange );
        }
      }

      if ( !wasStateless && this.incompatibleStateChange ) {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'incompatible instance ' + this.toString() + ' ' + this.getStateString() + ', aborting' );
        sceneryLog && sceneryLog.Instance && sceneryLog.pop();

        // The false return will signal that a new instance needs to be used. our tree will be disposed soon.
        return false;
      }
      this.stateless = false;

      // no need to overwrite, should always be the same
      assert && assert( !wasStateless || this.children.length === 0,
        'We should not have child instances on an instance without state' );

      if ( wasStateless ) {
        // If we are a transform root, notify the display that we are dirty. We'll be validated when it's at that phase
        // at the next updateDisplay().
        if ( this.isTransformed ) {
          this.display.markTransformRootDirty( this, true );
        }

        this.attachNodeListeners();
      }

      // TODO: pruning of shared caches
      if ( this.isSharedCanvasCachePlaceholder ) {
        this.sharedSyncTree();
      }
      // pruning so that if no changes would affect a subtree it is skipped
      else if ( wasStateless || this.skipPruningFrame === this.display._frameId || this.anyStateChange ) {

        // mark fully-removed instances for disposal, and initialize child instances if we were stateless
        this.prepareChildInstances( wasStateless );

        var oldFirstDrawable = this.firstDrawable;
        var oldLastDrawable = this.lastDrawable;
        var oldFirstInnerDrawable = this.firstInnerDrawable;
        var oldLastInnerDrawable = this.lastInnerDrawable;

        var selfChanged = this.updateSelfDrawable();

        // Synchronizes our children and self, with the drawables and change intervals of both combined
        this.localSyncTree( selfChanged );

        if ( assertSlow ) {
          // before and after first/last drawables (inside any potential group drawable)
          this.auditChangeIntervals( oldFirstInnerDrawable, oldLastInnerDrawable, this.firstInnerDrawable, this.lastInnerDrawable );
        }

        // If we use a group drawable (backbone, etc.), we'll collapse our drawables and change intervals to reference
        // the group drawable (as applicable).
        this.groupSyncTree( wasStateless );

        if ( assertSlow ) {
          // before and after first/last drawables (outside of any potential group drawable)
          this.auditChangeIntervals( oldFirstDrawable, oldLastDrawable, this.firstDrawable, this.lastDrawable );
        }
      }
      else {
        // our sub-tree was not visited, since there were no relevant changes to it (that need instance synchronization
        // or drawable changes)
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'pruned' );
      }

      sceneryLog && sceneryLog.Instance && sceneryLog.pop();

      return true;
    },

    /*
     * Responsible for syncing children, connecting the drawable linked list as needed, and outputting change intervals
     * and first/last drawable information.
     */
    localSyncTree: function( selfChanged ) {
      var frameId = this.display._frameId;

      // local variables, since we can't overwrite our instance properties yet
      var firstDrawable = this.selfDrawable; // possibly null
      var currentDrawable = firstDrawable; // possibly null

      assert && assert( this.firstChangeInterval === null && this.lastChangeInterval === null,
        'sanity checks that cleanSyncTreeResults were called' );

      var firstChangeInterval = null;
      if ( selfChanged ) {
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'self' );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();
        firstChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
      }
      var currentChangeInterval = firstChangeInterval;
      var lastUnchangedDrawable = selfChanged ? null : this.selfDrawable; // possibly null

      for ( var i = 0; i < this.children.length; i++ ) {
        var childInstance = this.children[ i ];

        var isCompatible = childInstance.syncTree();
        if ( !isCompatible ) {
          childInstance = this.updateIncompatibleChildInstance( childInstance, i );
          childInstance.syncTree();
        }

        var includeChildDrawables = childInstance.shouldIncludeInParentDrawables();

        //OHTWO TODO: only strip out invisible Canvas drawables, while leaving SVG (since we can more efficiently hide
        // SVG trees, memory-wise)
        // here we strip out invisible drawable sections out of the drawable linked list
        if ( includeChildDrawables ) {
          // if there are any drawables for that child, link them up in our linked list
          if ( childInstance.firstDrawable ) {
            if ( currentDrawable ) {
              // there is already an end of the linked list, so just append to it
              Drawable.connectDrawables( currentDrawable, childInstance.firstDrawable, this.display );
            }
            else {
              // start out the linked list
              firstDrawable = childInstance.firstDrawable;
            }
            // update the last drawable of the linked list
            currentDrawable = childInstance.lastDrawable;
          }
        }

        /*---------------------------------------------------------------------------*
         * Change intervals
         *----------------------------------------------------------------------------*/

        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'changes for ' + childInstance.toString() +
                                                                              ' in ' + this.toString() );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();

        var wasIncluded = childInstance.stitchChangeIncluded;
        var isIncluded = includeChildDrawables;
        childInstance.stitchChangeIncluded = isIncluded;

        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'included: ' + wasIncluded + ' => ' + isIncluded );

        // check for forcing full change-interval on child
        if ( childInstance.stitchChangeFrame === frameId ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'stitchChangeFrame full change interval' );
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();

          // e.g. it was added, moved, or had visibility changes. requires full change interval
          childInstance.firstChangeInterval = childInstance.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );

          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
        }
        else {
          assert && assert( wasIncluded === isIncluded,
            'If we do not have stitchChangeFrame activated, our inclusion should not have changed' );
        }

        var firstChildChangeInterval = childInstance.firstChangeInterval;
        var isBeforeOpen = currentChangeInterval && currentChangeInterval.drawableAfter === null;
        var isAfterOpen = firstChildChangeInterval && firstChildChangeInterval.drawableBefore === null;
        var needsBridge = childInstance.stitchChangeBefore === frameId && !isBeforeOpen && !isAfterOpen;

        // We need to insert an additional change interval (bridge) when we notice a link in the drawable linked list
        // where there were nodes that needed stitch changes that aren't still children, or were moved. We create a
        // "bridge" change interval to span the gap where nodes were removed.
        if ( needsBridge ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'bridge' );
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();

          var bridge = ChangeInterval.newForDisplay( lastUnchangedDrawable, null, this.display );
          if ( currentChangeInterval ) {
            currentChangeInterval.nextChangeInterval = bridge;
          }
          currentChangeInterval = bridge;
          firstChangeInterval = firstChangeInterval || currentChangeInterval; // store if it is the first
          isBeforeOpen = true;

          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
        }

        // Exclude child instances that are now (and were before) not included. NOTE: We still need to include those in
        // bridge calculations, since a removed (before-included) instance could be between two still-invisible
        // instances.
        if ( wasIncluded || isIncluded ) {
          if ( isBeforeOpen ) {
            // we want to try to glue our last ChangeInterval up
            if ( firstChildChangeInterval ) {
              if ( firstChildChangeInterval.drawableBefore === null ) {
                // we want to glue from both sides

                // basically have our current change interval replace the child's first change interval
                currentChangeInterval.drawableAfter = firstChildChangeInterval.drawableAfter;
                currentChangeInterval.nextChangeInterval = firstChildChangeInterval.nextChangeInterval;

                currentChangeInterval = childInstance.lastChangeInterval === firstChildChangeInterval ?
                                        currentChangeInterval : // since we are replacing, don't give an origin reference
                                        childInstance.lastChangeInterval;
              }
              else {
                // only a desire to glue from before
                currentChangeInterval.drawableAfter = childInstance.firstDrawable; // either null or the correct drawable
                currentChangeInterval.nextChangeInterval = firstChildChangeInterval;
                currentChangeInterval = childInstance.lastChangeInterval;
              }
            }
            else {
              // no changes to the child. grabs the first drawable reference it can
              currentChangeInterval.drawableAfter = childInstance.firstDrawable; // either null or the correct drawable
            }
          }
          else if ( firstChildChangeInterval ) {
            firstChangeInterval = firstChangeInterval || firstChildChangeInterval; // store if it is the first
            if ( firstChildChangeInterval.drawableBefore === null ) {
              assert && assert( !currentChangeInterval || lastUnchangedDrawable,
                'If we have a current change interval, we should be guaranteed a non-null ' +
                'lastUnchangedDrawable' );
              firstChildChangeInterval.drawableBefore = lastUnchangedDrawable; // either null or the correct drawable
            }
            if ( currentChangeInterval ) {
              currentChangeInterval.nextChangeInterval = firstChildChangeInterval;
            }
            currentChangeInterval = childInstance.lastChangeInterval;
          }
          lastUnchangedDrawable = ( currentChangeInterval && currentChangeInterval.drawableAfter === null ) ?
                                  null :
                                  ( childInstance.lastDrawable ?
                                    childInstance.lastDrawable :
                                    lastUnchangedDrawable );
        }

        // if the last instance, check for post-bridge
        if ( i === this.children.length - 1 ) {
          if ( childInstance.stitchChangeAfter === frameId && !( currentChangeInterval && currentChangeInterval.drawableAfter === null ) ) {
            var endingBridge = ChangeInterval.newForDisplay( lastUnchangedDrawable, null, this.display );
            if ( currentChangeInterval ) {
              currentChangeInterval.nextChangeInterval = endingBridge;
            }
            currentChangeInterval = endingBridge;
            firstChangeInterval = firstChangeInterval || currentChangeInterval; // store if it is the first
          }
        }

        // clean up the metadata on our child (can't be done in the child call, since we use these values like a
        // composite return value)
        //OHTWO TODO: only do this on instances that were actually traversed
        childInstance.cleanSyncTreeResults();

        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
      }

      // it's really the easiest way to compare if two things (casted to booleans) are the same?
      assert && assert( !!firstChangeInterval === !!currentChangeInterval,
        'Presence of first and current change intervals should be equal' );

      // Check to see if we are emptied and marked as changed (but without change intervals). This should imply we have
      // no children (and thus no stitchChangeBefore / stitchChangeAfter to use), so we'll want to create a change
      // interval to cover our entire range.
      if ( !firstChangeInterval && this.stitchChangeOnChildren === this.display._frameId && this.children.length === 0 ) {
        firstChangeInterval = currentChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }

      // store our results
      // NOTE: these may get overwritten with the group change intervals (in that case, groupSyncTree will read from these)
      this.firstChangeInterval = firstChangeInterval;
      this.lastChangeInterval = currentChangeInterval;

      // NOTE: these may get overwritten with the group drawable (in that case, groupSyncTree will read from these)
      this.firstDrawable = this.firstInnerDrawable = firstDrawable;
      this.lastDrawable = this.lastInnerDrawable = currentDrawable; // either null, or the drawable itself

      // ensure that our firstDrawable and lastDrawable are correct
      if ( assertSlow ) {
        var firstDrawableCheck = null;
        for ( var j = 0; j < this.children.length; j++ ) {
          if ( this.children[ j ].shouldIncludeInParentDrawables() && this.children[ j ].firstDrawable ) {
            firstDrawableCheck = this.children[ j ].firstDrawable;
            break;
          }
        }
        if ( this.selfDrawable ) {
          firstDrawableCheck = this.selfDrawable;
        }

        var lastDrawableCheck = this.selfDrawable;
        for ( var k = this.children.length - 1; k >= 0; k-- ) {
          if ( this.children[ k ].shouldIncludeInParentDrawables() && this.children[ k ].lastDrawable ) {
            lastDrawableCheck = this.children[ k ].lastDrawable;
            break;
          }
        }

        assertSlow( firstDrawableCheck === this.firstDrawable );
        assertSlow( lastDrawableCheck === this.lastDrawable );
      }
    },

    /*
     * If necessary, create/replace/remove our selfDrawable.
     *
     * @returns whether the selfDrawable changed
     */
    updateSelfDrawable: function() {
      if ( this.node.isPainted() ) {
        var selfRenderer = this.selfRenderer; // our new self renderer bitmask

        // bitwise trick, since only one of Canvas/SVG/DOM/WebGL/etc. flags will be chosen, and bitmaskRendererArea is
        // the mask for those flags. In English, "Is the current selfDrawable compatible with our selfRenderer (if any),
        // or do we need to create a selfDrawable?"
        //OHTWO TODO: For Canvas, we won't care about anything else for the drawable, but for DOM we care about the
        // force-acceleration flag! That's stripped out here.
        if ( !this.selfDrawable || ( ( this.selfDrawable.renderer & selfRenderer & Renderer.bitmaskRendererArea ) === 0 ) ) {
          if ( this.selfDrawable ) {
            sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing old drawable ' + this.selfDrawable.toString() + ' with new renderer' );

            // scrap the previous selfDrawable, we need to create one with a different renderer.
            this.selfDrawable.markForDisposal( this.display );
          }

          this.selfDrawable = Renderer.createSelfDrawable( this, this.node, selfRenderer, this.fittability.ancestorsFittable );
          assert && assert( this.selfDrawable );

          return true;
        }
      }
      else {
        assert && assert( this.selfDrawable === null, 'Non-painted nodes should not have a selfDrawable' );
      }

      return false;
    },

    // returns the up-to-date instance
    updateIncompatibleChildInstance: function( childInstance, index ) {
      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        var affectedInstanceCount = childInstance.getDescendantCount() + 1; // +1 for itself

        if ( affectedInstanceCount > 100 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
        else if ( affectedInstanceCount > 40 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
        else if ( affectedInstanceCount > 0 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
      }

      // mark it for disposal
      this.display.markInstanceRootForDisposal( childInstance );

      // swap in a new instance
      var replacementInstance = Instance.createFromPool( this.display, this.trail.copy().addDescendant( childInstance.node, index ), false, false );
      this.replaceInstanceWithIndex( childInstance, replacementInstance, index );
      return replacementInstance;
    },

    groupSyncTree: function( wasStateless ) {
      var groupRenderer = this.groupRenderer;
      assert && assert( ( this.isBackbone ? 1 : 0 ) +
                        ( this.isInstanceCanvasCache ? 1 : 0 ) +
                        ( this.isSharedCanvasCacheSelf ? 1 : 0 ) === ( groupRenderer ? 1 : 0 ),
        'We should have precisely one of these flags set for us to have a groupRenderer' );

      // if we switched to/away from a group, our group type changed, or our group renderer changed
      var groupChanged = ( !!groupRenderer !== !!this.groupDrawable ) ||
                         ( !wasStateless && this.groupChanged ) ||
                         ( this.groupDrawable && this.groupDrawable.renderer !== groupRenderer );

      // if there is a change, prepare
      if ( groupChanged ) {
        if ( this.groupDrawable ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing group drawable ' + this.groupDrawable.toString() );

          this.groupDrawable.markForDisposal( this.display );
          this.groupDrawable = null;
        }

        // change everything, since we may need a full restitch
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }

      if ( groupRenderer ) {
        // ensure our linked list is fully disconnected from others
        this.firstDrawable && Drawable.disconnectBefore( this.firstDrawable, this.display );
        this.lastDrawable && Drawable.disconnectAfter( this.lastDrawable, this.display );

        if ( this.isBackbone ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.BackboneDrawable.createFromPool( this.display, this, this.getTransformRootInstance(), groupRenderer, this.isDisplayRoot );

            if ( this.isTransformed ) {
              this.display.markTransformRootDirty( this, true );
            }
          }

          if ( this.firstChangeInterval ) {
            this.groupDrawable.stitch( this.firstDrawable, this.lastDrawable, this.firstChangeInterval, this.lastChangeInterval );
          }
        }
        else if ( this.isInstanceCanvasCache ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.InlineCanvasCacheDrawable.createFromPool( groupRenderer, this );
          }
          if ( this.firstChangeInterval ) {
            this.groupDrawable.stitch( this.firstDrawable, this.lastDrawable, this.firstChangeInterval, this.lastChangeInterval );
          }
        }
        else if ( this.isSharedCanvasCacheSelf ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.CanvasBlock.createFromPool( groupRenderer, this );
          }
          //OHTWO TODO: restitch here??? implement it
        }
        // Update the fittable flag
        this.groupDrawable.setFittable( this.fittability.ancestorsFittable );

        this.firstDrawable = this.lastDrawable = this.groupDrawable;
      }

      // change interval handling
      if ( groupChanged ) {
        // if our group status changed, mark EVERYTHING as potentially changed
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }
      else if ( groupRenderer ) {
        // our group didn't have to change at all, so we prevent any change intervals
        this.firstChangeInterval = this.lastChangeInterval = null;
      }
    },

    sharedSyncTree: function() {
      //OHTWO TODO: we are probably missing syncTree for shared trees properly with pruning. investigate!!

      this.ensureSharedCacheInitialized();

      var sharedCacheRenderer = this.sharedCacheRenderer;

      if ( !this.sharedCacheDrawable || this.sharedCacheDrawable.renderer !== sharedCacheRenderer ) {
        //OHTWO TODO: mark everything as changed (big change interval)

        if ( this.sharedCacheDrawable ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing shared cache drawable ' + this.sharedCacheDrawable.toString() );

          this.sharedCacheDrawable.markForDisposal( this.display );
        }

        //OHTWO TODO: actually create the proper shared cache drawable depending on the specified renderer
        // (update it if necessary)
        this.sharedCacheDrawable = new scenery.SharedCanvasCacheDrawable( this.trail, sharedCacheRenderer, this, this.sharedCacheInstance );
        this.firstDrawable = this.sharedCacheDrawable;
        this.lastDrawable = this.sharedCacheDrawable;

        // basically everything changed now, and won't from now on
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }
    },

    prepareChildInstances: function( wasStateless ) {
      // mark all removed instances to be disposed (along with their subtrees)
      while ( this.instanceRemovalCheckList.length ) {
        var instanceToMark = this.instanceRemovalCheckList.pop();
        if ( instanceToMark.addRemoveCounter === -1 ) {
          instanceToMark.addRemoveCounter = 0; // reset it, so we don't mark it for disposal more than once
          this.display.markInstanceRootForDisposal( instanceToMark );
        }
      }

      if ( wasStateless ) {
        // we need to create all of the child instances
        for ( var k = 0; k < this.node.children.length; k++ ) {
          // create a child instance
          var child = this.node.children[ k ];
          this.appendInstance( Instance.createFromPool( this.display, this.trail.copy().addDescendant( child, k ), false, false ) );
        }
      }
    },

    ensureSharedCacheInitialized: function() {
      // we only need to initialize this shared cache reference once
      if ( !this.sharedCacheInstance ) {
        var instanceKey = this.node.getId();
        // TODO: have this abstracted away in the Display?
        this.sharedCacheInstance = this.display._sharedCanvasInstances[ instanceKey ];

        // TODO: increment reference counting?
        if ( !this.sharedCacheInstance ) {
          this.sharedCacheInstance = Instance.createFromPool( this.display, new scenery.Trail( this.node ), false, true );
          this.sharedCacheInstance.syncTree();
          this.display._sharedCanvasInstances[ instanceKey ] = this.sharedCacheInstance;
          // TODO: reference counting?

          // TODO: this.sharedCacheInstance.isTransformed?

          //OHTWO TODO: is this necessary?
          this.display.markTransformRootDirty( this.sharedCacheInstance, true );
        }

        this.sharedCacheInstance.externalReferenceCount++;

        //OHTWO TODO: is this necessary?
        if ( this.isTransformed ) {
          this.display.markTransformRootDirty( this, true );
        }
      }
    },

    // @private, whether out drawables (from firstDrawable to lastDrawable) should be included in our parent's drawables
    shouldIncludeInParentDrawables: function() {
      return this.node.isVisible() || !this.node.isExcludeInvisible();
    },

    // @private, finds the closest drawable (not including the child instance at childIndex) using lastDrawable, or null
    findPreviousDrawable: function( childIndex ) {
      for ( var i = childIndex - 1; i >= 0; i-- ) {
        var option = this.children[ i ].lastDrawable;
        if ( option !== null ) {
          return option;
        }
      }

      return null;
    },

    // @private, finds the closest drawable (not including the child instance at childIndex) using nextDrawable, or null
    findNextDrawable: function( childIndex ) {
      var len = this.children.length;
      for ( var i = childIndex + 1; i < len; i++ ) {
        var option = this.children[ i ].firstDrawable;
        if ( option !== null ) {
          return option;
        }
      }

      return null;
    },

    /*---------------------------------------------------------------------------*
     * Children handling
     *----------------------------------------------------------------------------*/

    appendInstance: function( instance ) {
      this.insertInstance( instance, this.children.length );
    },

    // NOTE: different parameter order compared to Node
    insertInstance: function( instance, index ) {
      assert && assert( instance instanceof Instance );
      assert && assert( index >= 0 && index <= this.children.length,
        'Instance insertion bounds check for index ' + index + ' with previous children length ' +
        this.children.length );

      sceneryLog && sceneryLog.InstanceTree && sceneryLog.InstanceTree(
        'inserting ' + instance.toString() + ' into ' + this.toString() );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.push();

      // mark it as changed during this frame, so that we can properly set the change interval
      instance.stitchChangeFrame = this.display._frameId;
      this.stitchChangeOnChildren = this.display._frameId;

      this.children.splice( index, 0, instance );
      instance.parent = this;
      instance.oldParent = this;

      // maintain our stitch-change interval
      if ( index <= this.beforeStableIndex ) {
        this.beforeStableIndex = index - 1;
      }
      if ( index > this.afterStableIndex ) {
        this.afterStableIndex = index + 1;
      }
      else {
        this.afterStableIndex++;
      }

      // maintain fittable flags
      this.fittability.onInsert( instance.fittability );

      this.relativeTransform.insertInstance( instance, index );

      this.markChildVisibilityDirty();

      sceneryLog && sceneryLog.InstanceTree && sceneryLog.pop();
    },

    removeInstance: function( instance ) {
      return this.removeInstanceWithIndex( instance, _.indexOf( this.children, instance ) );
    },

    removeInstanceWithIndex: function( instance, index ) {
      assert && assert( instance instanceof Instance );
      assert && assert( index >= 0 && index < this.children.length,
        'Instance removal bounds check for index ' + index + ' with previous children length ' +
        this.children.length );

      sceneryLog && sceneryLog.InstanceTree && sceneryLog.InstanceTree(
        'removing ' + instance.toString() + ' from ' + this.toString() );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.push();

      var frameId = this.display._frameId;

      // mark it as changed during this frame, so that we can properly set the change interval
      instance.stitchChangeFrame = frameId;
      this.stitchChangeOnChildren = frameId;

      // mark neighbors so that we can add a change interval for our removal area
      if ( index - 1 >= 0 ) {
        this.children[ index - 1 ].stitchChangeAfter = frameId;
      }
      if ( index + 1 < this.children.length ) {
        this.children[ index + 1 ].stitchChangeBefore = frameId;
      }

      this.children.splice( index, 1 ); // TODO: replace with a 'remove' function call
      instance.parent = null;
      instance.oldParent = this;

      // maintain our stitch-change interval
      if ( index <= this.beforeStableIndex ) {
        this.beforeStableIndex = index - 1;
      }
      if ( index >= this.afterStableIndex ) {
        this.afterStableIndex = index;
      }
      else {
        this.afterStableIndex--;
      }

      // maintain fittable flags
      this.fittability.onRemove( instance.fittability );

      this.relativeTransform.removeInstanceWithIndex( instance, index );

      sceneryLog && sceneryLog.InstanceTree && sceneryLog.pop();
    },

    replaceInstanceWithIndex: function( childInstance, replacementInstance, index ) {
      // TODO: optimization? hopefully it won't happen often, so we just do this for now
      this.removeInstanceWithIndex( childInstance, index );
      this.insertInstance( replacementInstance, index );
    },

    // if we have a child instance that corresponds to this node, return it (otherwise null)
    findChildInstanceOnNode: function( node ) {
      var instances = node.getInstances();
      for ( var i = 0; i < instances.length; i++ ) {
        if ( instances[ i ].oldParent === this ) {
          return instances[ i ];
        }
      }
      return null;
    },

    // event callback for Node's 'childInserted' event, used to track children
    onChildInserted: function( childNode, index ) {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance(
        'inserting child node ' + childNode.constructor.name + '#' + childNode.id + ' into ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );

      var instance = this.findChildInstanceOnNode( childNode );

      if ( instance ) {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'instance already exists' );
        // it must have been added back. increment its counter
        instance.addRemoveCounter += 1;
        assert && assert( instance.addRemoveCounter === 0 );
      }
      else {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'creating stub instance' );
        sceneryLog && sceneryLog.Instance && sceneryLog.push();
        instance = Instance.createFromPool( this.display, this.trail.copy().addDescendant( childNode, index ), false, false );
        sceneryLog && sceneryLog.Instance && sceneryLog.pop();
      }

      this.insertInstance( instance, index );

      // make sure we are visited for syncTree()
      this.markSkipPruning();

      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },

    // event callback for Node's 'childRemoved' event, used to track children
    onChildRemoved: function( childNode, index ) {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance(
        'removing child node ' + childNode.constructor.name + '#' + childNode.id + ' from ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );
      assert && assert( this.children[ index ].node === childNode, 'Ensure that our instance matches up' );

      var instance = this.findChildInstanceOnNode( childNode );
      assert && assert( instance !== null, 'We should always have a reference to a removed instance' );

      instance.addRemoveCounter -= 1;
      assert && assert( instance.addRemoveCounter === -1 );

      // track the removed instance here. if it doesn't get added back, this will be the only reference we have (we'll
      // need to dispose it)
      this.instanceRemovalCheckList.push( instance );

      this.removeInstanceWithIndex( instance, index );

      // make sure we are visited for syncTree()
      this.markSkipPruning();

      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },

    // event callback for Node's 'visibility' event, used to notify about stitch changes
    onVisibilityChange: function() {
      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );

      // for now, just mark which frame we were changed for our change interval
      this.stitchChangeFrame = this.display._frameId;

      // make sure we aren't pruned in the next syncTree()
      this.parent && this.parent.markSkipPruning();

      // mark visibility changes
      this.visibilityDirty = true;
      this.parent && this.parent.markChildVisibilityDirty();
    },

    // event callback for Node's 'opacity' change event
    onOpacityChange: function() {
      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );

      this.markRenderStateDirty();
    },

    markChildVisibilityDirty: function() {
      if ( !this.childVisibilityDirty ) {
        this.childVisibilityDirty = true;
        this.parent && this.parent.markChildVisibilityDirty();
      }
    },

    /**
     * Updates the currently fittability for all of the drawables attached to this instance.
     * @public
     *
     * @param {boolean} fittable
     */
    updateDrawableFittability: function( fittable ) {
      this.selfDrawable && this.selfDrawable.setFittable( fittable );
      this.groupDrawable && this.groupDrawable.setFittable( fittable );
      // this.sharedCacheDrawable && this.sharedCacheDrawable.setFittable( fittable );
    },

    /**
     * Updates the visible/relativeVisible flags on the Instance and its entire subtree.
     *
     * @param {boolean} parentGloballyVisible - Whether our parent (if any) is globally visible
     * @param {boolean} parentRelativelyVisible - Whether our parent (if any) is relatively visible
     * @param {boolean} updateFullSubtree - If true, we will visit the entire subtree to ensure visibility is correct.
     */
    updateVisibility: function( parentGloballyVisible, parentRelativelyVisible, updateFullSubtree ) {
      // If our visibility flag for ourself is dirty, we need to update our entire subtree
      if ( this.visibilityDirty ) {
        updateFullSubtree = true;
      }

      // calculate our visibilities
      var nodeVisible = this.node.isVisible();
      var wasVisible = this.visible;
      var wasRelativeVisible = this.relativeVisible;
      var wasSelfVisible = this.selfVisible;
      this.visible = parentGloballyVisible && nodeVisible;
      this.relativeVisible = parentRelativelyVisible && nodeVisible;
      this.selfVisible = this.isVisibilityApplied ? true : this.relativeVisible;

      var len = this.children.length;
      for ( var i = 0; i < len; i++ ) {
        var child = this.children[ i ];

        if ( updateFullSubtree || child.visibilityDirty || child.childVisibilityDirty ) {
          // if we are a visibility root (isVisibilityApplied===true), disregard ancestor visibility
          child.updateVisibility( this.visible, this.isVisibilityApplied ? true : this.relativeVisible, updateFullSubtree );
        }
      }

      this.visibilityDirty = false;
      this.childVisibilityDirty = false;

      // trigger changes after we do the full visibility update
      if ( this.visible !== wasVisible ) {
        this.trigger0( 'visibility' );
      }
      if ( this.relativeVisible !== wasRelativeVisible ) {
        this.trigger0( 'relativeVisibility' );
      }
      if ( this.selfVisible !== wasSelfVisible ) {
        this.trigger0( 'selfVisibility' );
      }
    },

    getDescendantCount: function() {
      var count = this.children.length;
      for ( var i = 0; i < this.children.length; i++ ) {
        count += this.children[ i ].getDescendantCount();
      }
      return count;
    },

    /*---------------------------------------------------------------------------*
     * Miscellaneous
     *----------------------------------------------------------------------------*/

    // add a reference for an SVG group (fastest way to track them)
    addSVGGroup: function( group ) {
      this.svgGroups.push( group );
    },

    // remove a reference for an SVG group (fastest way to track them)
    removeSVGGroup: function( group ) {
      var index = _.indexOf( this.svgGroups, group );
      assert && assert( index >= 0, 'Tried to remove an SVGGroup from an Instance when it did not exist' );

      this.svgGroups.splice( index, 1 ); // TODO: remove function
    },

    // returns null when a lookup fails (which is legitimate)
    lookupSVGGroup: function( block ) {
      var len = this.svgGroups.length;
      for ( var i = 0; i < len; i++ ) {
        var group = this.svgGroups[ i ];
        if ( group.block === block ) {
          return group;
        }
      }
      return null;
    },

    // what instance have filters (opacity/visibility/clip) been applied up to?
    getFilterRootInstance: function() {
      if ( this.isBackbone || this.isInstanceCanvasCache || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getFilterRootInstance();
      }
    },

    // what instance transforms have been applied up to?
    getTransformRootInstance: function() {
      if ( this.isTransformed || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getTransformRootInstance();
      }
    },

    getVisibilityRootInstance: function() {
      if ( this.isVisibilityApplied || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getVisibilityRootInstance();
      }
    },

    attachNodeListeners: function() {
      // attach listeners to our node
      this.relativeTransform.attachNodeListeners();

      if ( !this.isSharedCanvasCachePlaceholder ) {
        this.node.onStatic( 'childInserted', this.childInsertedListener );
        this.node.onStatic( 'childRemoved', this.childRemovedListener );
        this.node.onStatic( 'visibility', this.visibilityListener );

        this.node.onStatic( 'opacity', this.markRenderStateDirtyListener );
        this.node.onStatic( 'hint', this.markRenderStateDirtyListener );
        this.node.onStatic( 'clip', this.markRenderStateDirtyListener );
        this.node.onStatic( 'rendererBitmask', this.markRenderStateDirtyListener );
        this.node.onStatic( 'rendererSummary', this.markRenderStateDirtyListener );
      }
    },

    detachNodeListeners: function() {
      this.relativeTransform.detachNodeListeners();

      if ( !this.isSharedCanvasCachePlaceholder ) {
        this.node.offStatic( 'childInserted', this.childInsertedListener );
        this.node.offStatic( 'childRemoved', this.childRemovedListener );
        this.node.offStatic( 'visibility', this.visibilityListener );

        this.node.offStatic( 'opacity', this.markRenderStateDirtyListener );
        this.node.offStatic( 'hint', this.markRenderStateDirtyListener );
        this.node.offStatic( 'clip', this.markRenderStateDirtyListener );
        this.node.offStatic( 'rendererBitmask', this.markRenderStateDirtyListener );
        this.node.offStatic( 'rendererSummary', this.markRenderStateDirtyListener );
      }
    },

    // ensure that the render state is updated in the next syncTree()
    markRenderStateDirty: function() {
      this.renderStateDirtyFrame = this.display._frameId;

      // ensure we aren't pruned (not set on this instance, since we may not need to visit our children)
      this.parent && this.parent.markSkipPruning();
    },

    // ensure that this instance and its children will be visited in the next syncTree()
    markSkipPruning: function() {
      this.skipPruningFrame = this.display._frameId;

      // walk it up to the root
      this.parent && this.parent.markSkipPruning();
    },

    getBranchIndexTo: function( instance ) {
      var cachedValue = this.branchIndexMap[ instance.id ];
      if ( cachedValue !== undefined ) {
        return cachedValue;
      }

      var branchIndex = this.trail.getBranchIndexTo( instance.trail );
      this.branchIndexMap[ instance.id ] = branchIndex;
      instance.branchIndexMap[ this.id ] = branchIndex;
      this.branchIndexReferences.push( instance );
      instance.branchIndexReferences.push( this );

      return branchIndex;
    },

    // clean up listeners and garbage, so that we can be recycled (or pooled)
    dispose: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();

      assert && assert( this.active, 'Seems like we tried to dispose this Instance twice, it is not active' );

      this.active = false;

      // Release branch index references (see getBranchIndexTo)
      while ( this.branchIndexReferences.length ) {
        var branchIndexReference = this.branchIndexReferences.pop(); // {Instance}
        delete this.branchIndexMap[ branchIndexReference.id ];
        delete branchIndexReference.branchIndexMap[ this.id ];
        arrayRemove( branchIndexReference.branchIndexReferences, this );
      }

      // order is somewhat important
      this.groupDrawable && this.groupDrawable.disposeImmediately( this.display );
      this.sharedCacheDrawable && this.sharedCacheDrawable.disposeImmediately( this.display );
      this.selfDrawable && this.selfDrawable.disposeImmediately( this.display );

      // Dispose the rest of our subtree
      var numChildren = this.children.length;
      for ( var i = 0; i < numChildren; i++ ) {
        this.children[ i ].dispose();
      }
      // Check for child instances that were removed (we are still responsible for disposing them, since we didn't get
      // synctree to happen for them).
      while ( this.instanceRemovalCheckList.length ) {
        var child = this.instanceRemovalCheckList.pop();

        // they could have already been disposed, so we need a guard here
        if ( child.active ) {
          child.dispose();
        }
      }

      // we don't originally add in the listener if we are stateless
      if ( !this.stateless ) {
        this.detachNodeListeners();
      }

      this.node.removeInstance( this );

      // release our reference to a shared cache if applicable, and dispose if there are no other references
      if ( this.sharedCacheInstance ) {
        this.sharedCacheInstance.externalReferenceCount--;
        if ( this.sharedCacheInstance.externalReferenceCount === 0 ) {
          delete this.display._sharedCanvasInstances[ this.node.getId() ];
          this.sharedCacheInstance.dispose();
        }
      }

      // clean our variables out to release memory
      this.cleanInstance( null, null );

      this.removeAllEventListeners();

      this.freeToPool();

      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },

    audit: function( frameId, allowValidationNotNeededChecks ) {
      if ( assertSlow ) {
        if ( frameId === undefined ) {
          frameId = this.display._frameId;
        }

        assertSlow( !this.stateless,
          'State is required for all display instances' );

        assertSlow( ( this.firstDrawable === null ) === ( this.lastDrawable === null ),
          'First/last drawables need to both be null or non-null' );

        assertSlow( ( !this.isBackbone && !this.isSharedCanvasCachePlaceholder ) || this.groupDrawable,
          'If we are a backbone or shared cache, we need to have a groupDrawable reference' );

        assertSlow( !this.isSharedCanvasCachePlaceholder || !this.node.isPainted() || this.selfDrawable,
          'We need to have a selfDrawable if we are painted and not a shared cache' );

        assertSlow( ( !this.isTransformed && !this.isCanvasCache ) || this.groupDrawable,
          'We need to have a groupDrawable if we are a backbone or any type of canvas cache' );

        assertSlow( !this.isSharedCanvasCachePlaceholder || this.sharedCacheDrawable,
          'We need to have a sharedCacheDrawable if we are a shared cache' );

        assertSlow( this.addRemoveCounter === 0,
          'Our addRemoveCounter should always be 0 at the end of syncTree' );

        // validate the subtree
        for ( var i = 0; i < this.children.length; i++ ) {
          var childInstance = this.children[ i ];

          childInstance.audit( frameId, allowValidationNotNeededChecks );
        }

        this.relativeTransform.audit( frameId, allowValidationNotNeededChecks );

        this.fittability.audit();
      }
    },

    // @public (scenery-internal) - Applies checks to make sure our visibility tracking is working as expected.
    auditVisibility: function( parentVisible ) {
      if ( assertSlow ) {
        var visible = parentVisible && this.node.isVisible();
        var trailVisible = this.trail.isVisible();
        assertSlow( visible === trailVisible, 'Trail visibility failure' );
        assertSlow( visible === this.visible, 'Visible flag failure' );

        // validate the subtree
        for ( var i = 0; i < this.children.length; i++ ) {
          var childInstance = this.children[ i ];

          childInstance.auditVisibility( visible );
        }
      }
    },

    auditChangeIntervals: function( oldFirstDrawable, oldLastDrawable, newFirstDrawable, newLastDrawable ) {
      if ( oldFirstDrawable ) {
        var oldOne = oldFirstDrawable;

        // should hit, or will have NPE
        while ( oldOne !== oldLastDrawable ) {
          oldOne = oldOne.oldNextDrawable;
        }
      }

      if ( newFirstDrawable ) {
        var newOne = newFirstDrawable;

        // should hit, or will have NPE
        while ( newOne !== newLastDrawable ) {
          newOne = newOne.nextDrawable;
        }
      }

      function checkBetween( a, b ) {
        // have the body of the function stripped (it's not inside the if statement due to JSHint)
        if ( assertSlow ) {
          assertSlow( a !== null );
          assertSlow( b !== null );

          while ( a !== b ) {
            assertSlow( a.nextDrawable === a.oldNextDrawable, 'Change interval mismatch' );
            a = a.nextDrawable;
          }
        }
      }

      if ( assertSlow ) {
        var firstChangeInterval = this.firstChangeInterval;
        var lastChangeInterval = this.lastChangeInterval;

        if ( !firstChangeInterval || firstChangeInterval.drawableBefore !== null ) {
          assertSlow( oldFirstDrawable === newFirstDrawable,
            'If we have no changes, or our first change interval is not open, our firsts should be the same' );
        }
        if ( !lastChangeInterval || lastChangeInterval.drawableAfter !== null ) {
          assertSlow( oldLastDrawable === newLastDrawable,
            'If we have no changes, or our last change interval is not open, our lasts should be the same' );
        }

        if ( !firstChangeInterval ) {
          assertSlow( !lastChangeInterval, 'We should not be missing only one change interval' );

          // with no changes, everything should be identical
          oldFirstDrawable && checkBetween( oldFirstDrawable, oldLastDrawable );
        }
        else {
          assertSlow( lastChangeInterval, 'We should not be missing only one change interval' );

          // endpoints
          if ( firstChangeInterval.drawableBefore !== null ) {
            // check to the start if applicable
            checkBetween( oldFirstDrawable, firstChangeInterval.drawableBefore );
          }
          if ( lastChangeInterval.drawableAfter !== null ) {
            // check to the end if applicable
            checkBetween( lastChangeInterval.drawableAfter, oldLastDrawable );
          }

          // between change intervals (should always be guaranteed to be fixed)
          var interval = firstChangeInterval;
          while ( interval && interval.nextChangeInterval ) {
            var nextInterval = interval.nextChangeInterval;

            assertSlow( interval.drawableAfter !== null );
            assertSlow( nextInterval.drawableBefore !== null );

            checkBetween( interval.drawableAfter, nextInterval.drawableBefore );

            interval = nextInterval;
          }
        }
      }
    },

    toString: function() {
      return this.id + '#' + ( this.node ? ( this.node.constructor.name ? this.node.constructor.name : '?' ) + '#' + this.node.id : '-' );
    }
  } );

  // object pooling
  Poolable.mixin( Instance, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new from pool' );
          return pool.pop().initialize( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
        }
        else {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new from constructor' );
          return new Instance( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
        }
      };
    }
  } );

  return Instance;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * TODO docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/InlineCanvasCacheDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  function InlineCanvasCacheDrawable( renderer, instance ) {
    Drawable.call( this, renderer );


    //OHTWO TODO: pooling!

    // TODO: NOTE: may have to separate into separate drawables for separate group renderers

    this.instance = instance; // will need this so we can get bounds for layer fitting
  }

  scenery.register( 'InlineCanvasCacheDrawable', InlineCanvasCacheDrawable );

  inherit( Drawable, InlineCanvasCacheDrawable, {
    // TODO: support Canvas/SVG/DOM

    stitch: function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval ) {
      //OHTWO TODO: called when we have a change in our drawables
    }
  } );

  return InlineCanvasCacheDrawable;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * TODO docs
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SharedCanvasCacheDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );

  function SharedCanvasCacheDrawable( trail, renderer, instance, sharedInstance ) {
    Drawable.call( this, renderer );

    // TODO: NOTE: may have to separate into separate drawables for separate group renderers

    this.instance = instance; // will need this so we can get bounds for layer fitting
    this.sharedInstance = sharedInstance;
  }

  scenery.register( 'SharedCanvasCacheDrawable', SharedCanvasCacheDrawable );

  inherit( Drawable, SharedCanvasCacheDrawable, {
    // TODO: support Canvas/SVG/DOM
  } );

  return SharedCanvasCacheDrawable;
} );

// Copyright 2015-2016, University of Colorado Boulder

/**
 * An instance that is synchronously created, for handling accessibility needs.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/accessibility/AccessibleInstance',['require','PHET_CORE/inherit','PHET_CORE/Poolable','AXON/Events','SCENERY/scenery','PHET_CORE/cleanArray'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  // var AccessiblePeer = require( 'SCENERY/accessibility/AccessiblePeer' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );

  var globalId = 1;

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param parent
   * @param display
   * @param trail
   */
  function AccessibleInstance( parent, display, trail ) {
    this.initializeAccessibleInstance( parent, display, trail );
  }

  scenery.register( 'AccessibleInstance', AccessibleInstance );

  inherit( Events, AccessibleInstance, {
    /**
     * @param {AccessibleInstance|null} parent
     * @param {Display} display
     * @param {HTMLElement} [domElement] - If not included here, subtype is responsible for setting it in the constructor.
     * @returns {AccessibleInstance} - Returns 'this' reference, for chaining
     */
    initializeAccessibleInstance: function( parent, display, trail ) {
      Events.call( this ); // TODO: is Events worth mixing in by default? Will we need to listen to events?

      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );

      // unique ID
      this.id = this.id || globalId++;

      this.parent = parent;
      this.display = display;
      this.trail = trail;
      this.node = trail.lastNode();
      this.isRootInstance = this.trail.length === 0;

      this.children = cleanArray( this.children );

      // If we are the root accessible instance, we won't actually have a reference to a node.
      if ( this.node ) {
        this.node.addAccessibleInstance( this );
      }

      this.isSorted = true;

      if ( this.isRootInstance ) {
        var accessibilityContainer = document.createElement( 'div' );
        accessibilityContainer.className = 'accessibility';
        accessibilityContainer.style.position = 'absolute';
        accessibilityContainer.style.left = '0';
        accessibilityContainer.style.top = '0';
        accessibilityContainer.style.width = '0';
        accessibilityContainer.style.height = '0';
        accessibilityContainer.style.clip = 'rect(0,0,0,0)';
        accessibilityContainer.style.pointerEvents = 'none';
        this.peer = new scenery.AccessiblePeer( this, accessibilityContainer );
      }
      else {
        this.peer = this.node.accessibleContent.createPeer( this );
        var childContainerElement = this.parent.peer.getChildContainerElement();

        // insert the peer's dom element or its parent if it is contained in a parent element for structure
        childContainerElement.insertBefore( this.peer.getParentContainerElement(), childContainerElement.childNodes[ 0 ] );
      }

      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Initialized ' + this.toString() );

      return this;
    },

    /**
     * Consider the following example:
     *
     * We have a node structure:
     * A
     *  B ( accessible )
     *    C (accessible )
     *      D
     *        E (accessible)
     *         G (accessible)
     *        F
     *          H (accessible)
     *
     *
     * Which has an equivalent accessible instance tree:
     * root
     *  AB
     *    ABC
     *      ABCDE
     *        ABCDEG
     *      ABCDFH
     *
     * Produces the call tree for adding instances to the accessible instance tree:
     * ABC.addSubtree( ABCD ) - not accessible
     *     ABC.addSubtree( ABCDE)
     *       ABCDE.addSubtree( ABCDEG )
     *     ABC.addSubtree( ABCDF )
     *       ABC.addSubtree( ABCDFH )
     */
    addSubtree: function( trail ) {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'addSubtree on ' + this.toString() + ' with trail ' + trail.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();

      var node = trail.lastNode();
      var nextInstance = this; // eslint-disable-line consistent-this
      if ( node.accessibleContent ) {
        var accessibleInstance = AccessibleInstance.createFromPool( this, this.display, trail.copy() ); // TODO: Pooling
        sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
          'Insert parent: ' + this.toString() + ', (new) child: ' + accessibleInstance.toString() );
        this.children.push( accessibleInstance ); // TODO: Mark us as dirty for performance.
        this.markAsUnsorted();

        nextInstance = accessibleInstance;
      }
      var children = node._children;
      for ( var i = 0; i < children.length; i++ ) {
        trail.addDescendant( children[ i ], i );
        nextInstance.addSubtree( trail );
        trail.removeDescendant();
      }

      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },

    removeSubtree: function( trail ) {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'removeSubtree on ' + this.toString() + ' with trail ' + trail.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();

      for ( var i = this.children.length - 1; i >= 0; i-- ) {
        var childInstance = this.children[ i ];
        if ( childInstance.trail.isExtensionOf( trail, true ) ) {
          sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
            'Remove parent: ' + this.toString() + ', child: ' + childInstance.toString() );
          this.children.splice( i, 1 ); // remove it from the children array

          // Dispose the entire subtree of AccessibleInstances
          childInstance.dispose();
        }
      }

      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },

    markAsUnsorted: function() {
      if ( this.isSorted ) {
        this.isSorted = false;
        this.display.markUnsortedAccessibleInstance( this );
      }
    },

    /**
     * Sort our children accessible instances in the order they should appear in the parallel DOM. We do this by
     * creating a comparison function between two accessible instances, and sorting the array with that.
     */
    sortChildren: function() {
      assert && assert( !this.isSorted, 'No need to sort children if it is already marked as sorted' );
      this.isSorted = true;

      var parentInstance = this; // eslint-disable-line consistent-this

      // Reindex trails in preparation for sorting
      for ( var m = 0; m < this.children.length; m++ ) {
        this.children[ m ].trail.reindex();
      }

      this.children.sort( function( a, b ) {
        // Sort between a {AccessibleInstance} and b {AccessibleInstance}. This is a process where we start at our
        // "parent" accessible instance's location in the trail, and walk down looking for accessible orders that may
        // determine the order between these two instances.
        // This allows ancestor orders (for instance, an order on this instance) to override descendant orders.
        var aNodes = a.trail.nodes;
        var bNodes = b.trail.nodes;

        // Starting at the Node for this accessible instance, and walking down until the trails diverge. If our loop
        // here reaches a place where they diverge, we can use document order to determine which comes first (since
        // that means we didn't hit any relevant accessible orders). If our parentInstance is the root instance, its
        // trail will have length 0 (nothing shared), so our starting index should be set to 0.
        for ( var i = Math.max( 0, parentInstance.trail.length - 1 ); aNodes[ i ] === bNodes[ i ]; i++ ) {
          var currentNode = aNodes[ i ];
          var order = currentNode.accessibleOrder;

          // If there is no order specified on this node, we want to continue to the next children in the trails.
          if ( !order ) {
            continue;
          }

          // Loop through items in the order, since the first elements in the order are the most significant.
          for ( var j = 0; j < order.length; j++ ) {
            var orderedNode = order[ j ];
            // Find where (if at all) our Node in the order is present in the trails.
            var aIndex = aNodes.indexOf( orderedNode );
            var bIndex = bNodes.indexOf( orderedNode );

            // If the ordered node is present in both trails, we need to first determine whether the trail to those
            // nodes is the same. If they are the same, we will jump ahead to that ordered node (deliberately skipping
            // any orders on nodes in-between), and continuing on from there. If they are different, the document order
            // between the two trails to the ordered node will determine which of our instances comes first.
            if ( aIndex >= 0 && bIndex >= 0 ) {
              // Determine the index at where our two trails diverge.
              var branchIndex = i + 1;
              while ( aNodes[ branchIndex ] === bNodes[ branchIndex ] ) {
                branchIndex++;
              }

              // If the index of our ordered node in one of the trails is before our branch index, it means the trails
              // to the ordered node are the same. We want to jump ahead to the ordered node's location and continue
              // with our outer for loop.
              if ( aIndex < branchIndex ) {
                // We want the next iteration of the outer for loop to start at the index of the ordered node. Since i
                // will be incremented before the next loop begins, we subtract 1 here.
                i = aIndex - 1;

                // Exit the inner for loop
                break;
              }
              // The trails to the ordered node are different. We use the document order between the two trails to
              // determine which instance is first. This can be done by inspecting just the difference at the branch
              // index.
              else {
                // Since branchIndex is the index in the trail of two different children, we want to compare the indices
                // for the parent node of the branch nodes, thus we need to subtract 1 from our branch index.
                var aChildIndex = a.trail.indices[ branchIndex - 1 ];
                var bChildIndex = b.trail.indices[ branchIndex - 1 ];
                if ( aChildIndex < bChildIndex ) {
                  return -1;
                }
                else if ( aChildIndex > bChildIndex ) {
                  return 1;
                }
                else {
                  throw new Error( 'Two different children have the same child index' );
                }
              }
            }
            // If only the first trail is under an ordered node, it is first
            else if ( aIndex >= 0 ) {
              return -1;
            }
            // If only the second trail is under an ordered node, it is first
            else if ( bIndex >= 0 ) {
              return 1;
            }
          }
        }

        // If we reach here and haven't returned, it should be a document order comparison AND the index i determines
        // the current index where the nodes are different (branch index).
        // Since i is the index in the trail of two different children, we want to compare the indices
        // for the parent node of the branch nodes, thus we need to subtract 1 from our branch index.
        var aEndChildIndex = a.trail.indices[ i - 1 ];
        var bEndChildIndex = b.trail.indices[ i - 1 ];
        if ( aEndChildIndex < bEndChildIndex ) {
          return -1;
        }
        else if ( aEndChildIndex > bEndChildIndex ) {
          return 1;
        }
        else {
          throw new Error( 'Two different children have the same child index' );
        }
      } );

      var containerElement = this.peer.getChildContainerElement();
      for ( var n = this.children.length - 1; n >= 0; n-- ) {
        var peerDOMElement = this.children[ n ].peer.domElement;

        // if the peer has a parent container element, this structure containing the peerDOMElement should be inserted
        if ( this.children[ n ].peer.hasParentContainer() ) {
          peerDOMElement = this.children[ n ].peer.getParentContainerElement();
        }
        if ( peerDOMElement === containerElement.childNodes[ n ] ) {
          continue;
        }
        containerElement.insertBefore( peerDOMElement, containerElement.childNodes[ n + 1 ] );
      }
    },

    // Recursive disposal
    dispose: function() {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Disposing ' + this.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();

      // Disconnect DOM and remove listeners
      if ( !this.isRootInstance ) {
        this.peer.dispose();

        // remove this peer's dom element (or its parent container) from the parent peer's
        // dom element (or its child container), disabling input so that we do not call input listeners
        // while the elements are removed from the DOM
        this.node.accessibleInputEnabled = false;
        this.parent.peer.getChildContainerElement().removeChild( this.peer.getParentContainerElement() );
        this.node.accessibleInputEnabled = true;
      }

      while ( this.children.length ) {
        this.children.pop().dispose();
      }

      // If we are the root accessible instance, we won't actually have a reference to a node.
      if ( this.node ) {
        this.node.removeAccessibleInstance( this );
      }

      this.display = null;
      this.trail = null;
      this.node = null;
      this.peer = null;
      this.disposed = true;

      this.freeToPool();

      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },

    toString: function() {
      return this.id + '#{' + this.trail.toString() + '}';
    },

    auditRoot: function() {
      assert && assert( this.trail.length === 0,
        'Should only call auditRoot() on the root AccessibleInstance for a display' );

      function audit( nestedOrderArray, accessibleInstance ) {
        assert && assert( nestedOrderArray.length === accessibleInstance.children.length,
          'Different number of children in accessible instance' );

        _.each( nestedOrderArray, function( nestedChild ) {
          var instance = _.find( accessibleInstance.children, function( childInstance ) {
            return childInstance.trail.equals( nestedChild.trail );
          } );
          assert && assert( instance, 'Missing child accessible instance' );

          audit( nestedChild.children, instance );
        } );

        // Exact Order checks
        for ( var i = 0; i < nestedOrderArray.length; i++ ) {
          assert && assert( nestedOrderArray[ i ].trail.lastNode() === accessibleInstance.children[ i ].node,
            'Accessible order mismatch' );
        }
      }

      audit( this.display.rootNode.getNestedAccessibleOrder(), this );
    }
  } );

  Poolable.mixin( AccessibleInstance, {
    constructorDuplicateFactory: function( pool ) {
      return function( parent, display, trail ) {
        if ( pool.length ) {
          return pool.pop().initializeAccessibleInstance( parent, display, trail );
        }
        else {
          return new AccessibleInstance( parent, display, trail );
        }
      };
    }
  } );

  return AccessibleInstance;
} );

// Copyright 2013-2015, University of Colorado Boulder


/**
 * Creates and references a stylesheet that can be built up while Scenery is loading.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/SceneryStyle',['require','SCENERY/scenery'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var styleElement = document.createElement( 'style' );
  styleElement.type = 'text/css';
  document.head.appendChild( styleElement );

  var stylesheet = document.styleSheets[ document.styleSheets.length - 1 ];
  assert && assert( stylesheet.disabled === false );

  return scenery.register( 'SceneryStyle', {
    stylesheet: stylesheet,
    styleElement: styleElement,

    addRule: function( ruleString ) {
      // using a this reference so it doesn't need to be a closure
      this.stylesheet.insertRule( ruleString, 0 );
    }
  } );
} );

// Copyright 2015-2016, University of Colorado Boulder

/**
 * Used for identifying when any ancestor transform of a node in a trail causes that node's global transform to change.
 * It also provides fast computation of that global matrix, NOT recomputing every matrix, even on most transform
 * changes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Jesse Greenberg
 */

define( 'SCENERY/util/TransformTracker',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );

  /**
   * Creates a transform-tracking object, where it can send out updates on transform changes, and also efficiently
   * compute the transform.
   * @constructor
   * @public
   *
   * @param {Trail} trail
   * @param {Object} [options]
   */
  function TransformTracker( trail, options ) {
    var self = this;

    options = _.extend( {
      isStatic: false // {boolean} - Whether the bounds listeners should be added with on() or onStatic().
    }, options );
    this._isStatic = options.isStatic;

    // @public {Trail}
    this.trail = trail;

    // @private {Array.<Matrix3>|null}
    // this._matrices[ i ] will be equal to: trail.nodes[ 1 ].matrix * ... * trail.nodes[ i + 1 ].matrix
    //
    this._matrices = null; // Will be initialized on first need.

    // @private {number} - this._matrices[ i ] where i >= this._dirtyIndex will need to be recomputed
    this._dirtyIndex = 0;

    // @private {Array.<Function>} - Listeners added by client, will be called on transform changes.
    this._listeners = [];

    // Hook up listeners to each Node in the trail, so we are notified of changes. Will be removed on disposal.
    this._nodeTransformListeners = [];
    for ( var j = 1; j < this.trail.length; j++ ) {
      // Wrapping with closure to prevent changes
      var nodeTransformListener = (function( index ) {
        return function() {
          self.onTransformChange( index );
        };
      })( j - 1 );

      this._nodeTransformListeners.push( nodeTransformListener );

      if ( this._isStatic ) {
        trail.nodes[ j ].onStatic( 'transform', nodeTransformListener );
      }
      else {
        trail.nodes[ j ].on( 'transform', nodeTransformListener );
      }
    }
  }

  scenery.register( 'TransformTracker', TransformTracker );

  inherit( Object, TransformTracker, {
    /**
     * Gets rid of all external references and listeners. This object is inoperable afterwards.
     * @public
     */
    dispose: function() {
      for ( var j = 1; j < this.trail.length; j++ ) {
        var nodeTransformListener = this._nodeTransformListeners[ j - 1 ];

        if ( this._isStatic ) {
          this.trail.nodes[ j ].offStatic( 'transform', nodeTransformListener );
        }
        else {
          this.trail.nodes[ j ].off( 'transform', nodeTransformListener );
        }
      }
    },

    /**
     * Adds a listener function that will be synchronously called whenever the transform for this Trail changes.
     * @public
     *
     * @param {Function} listener - Listener will be called with no arguments.
     */
    addListener: function( listener ) {
      assert && assert( typeof listener === 'function' );

      this._listeners.push( listener );
    },

    /**
     * Removes a listener that was previously added with addListener().
     * @public
     *
     * @param {Function} listener
     */
    removeListener: function( listener ) {
      assert && assert( typeof listener === 'function' );

      var index = _.indexOf( this._listeners, listener );
      assert && assert( index >= 0, 'TransformTracker listener not found' );

      this._listeners.splice( index, 1 );
    },

    /**
     * Notifies listeners of a transform change.
     * @private
     */
    notifyListeners: function() {
      var listeners = this._listeners;

      if ( !this._isStatic ) {
        listeners = listeners.slice();
      }

      var length = listeners.length;
      for ( var i = 0; i < length; i++ ) {
        listeners[ i ]();
      }
    },

    /**
     * Called when one of the nodes' transforms is changed.
     * @private
     *
     * @param {number} matrixIndex - The index into our matrices array, e.g. this._matrices[ matrixIndex ].
     */
    onTransformChange: function( matrixIndex ) {
      this._dirtyIndex = Math.min( this._dirtyIndex, matrixIndex );
      this.notifyListeners();
    },

    /**
     * Returns the local-to-global transformation matrix for the Trail, which transforms its leaf node's local
     * coordinate frame into the global coordinate frame.
     * @public
     *
     * NOTE: The matrix returned should not be mutated. Please make a copy if needed.
     *
     * @returns {Matrix3}
     */
    getMatrix: function() {
      if ( this._matrices === null ) {
        this._matrices = [];

        // Start at 1, so that we don't include the root node's transform
        for ( var i = 1; i < this.trail.length; i++ ) {
          this._matrices.push( new Matrix3() );
        }
      }

      // If the trail isn't long enough to have a transform, return the identity matrix
      if ( this._matrices.length <= 0 ) {
        return Matrix3.IDENTITY;
      }

      // Starting at the dirty index, recompute matrices.
      var numMatrices = this._matrices.length;
      for ( var index = this._dirtyIndex; index < numMatrices; index++ ) {
        var nodeMatrix = this.trail.nodes[ index + 1 ].matrix;

        if ( index === 0 ) {
          this._matrices[ index ].set( nodeMatrix );
        }
        else {
          this._matrices[ index ].set( this._matrices[ index - 1 ] );
          this._matrices[ index ].multiplyMatrix( nodeMatrix );
        }
      }

      // Reset the dirty index to mark all matrices as 'clean'.
      this._dirtyIndex = numMatrices;

      // Return the last matrix, which contains our composite transformation.
      return this._matrices[ numMatrices - 1 ];
    },
    get matrix() { return this.getMatrix(); }
  } );

  return TransformTracker;
} );

// Copyright 2015-2016, University of Colorado Boulder

/**
 * Focus highlight overlay for accessible displays.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/FocusOverlay',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','SCENERY/nodes/Rectangle','SCENERY/util/Color','SCENERY/util/TransformTracker','KITE/Shape','SCENERY/nodes/Node','SCENERY/nodes/Path'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );

  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Color = require( 'SCENERY/util/Color' );
  var TransformTracker = require( 'SCENERY/util/TransformTracker' );
  var Shape = require( 'KITE/Shape' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );

  function FocusOverlay( display, focusRootNode ) {
    this.display = display; // @private {Display}
    this.focusRootNode = focusRootNode; // @private {Node} - The root Node of our child display

    // When the focus changes, all of these are modified.
    this.trail = null; // @private {Trail|null}
    this.node = null; // @private {Node|null}
    this.mode = null; // @private {String|null}
    this.transformTracker = null; // @private {TransformTracker|null}

    // @private {boolean} - If true, the next update() will trigger an update to the highlight's transform.
    this.transformDirty = true;

    // @private - The main node for the highlight. It will be transformed.
    this.highlightNode = new Node();
    this.focusRootNode.addChild( this.highlightNode );

    // @private {Display}
    this.focusDisplay = new scenery.Display( this.focusRootNode, {
      width: this.width,
      height: this.height,
      allowWebGL: display._allowWebGL,
      allowCSSHacks: false,
      accessibility: false,
      isApplication: false,
      interactive: false
    } );

    // @private {HTMLElement}
    this.domElement = this.focusDisplay.domElement;
    this.domElement.style.pointerEvents = 'none';

    // @private Bounds highlight
    this.boundsHighlight = new Rectangle( 0, 0, 0, 0, { stroke: FocusOverlay.focusColor, visible: false } );
    this.innerBoundsHighlight = new Rectangle( 0, 0, 0, 0, { stroke: FocusOverlay.innerFocusColor } );
    this.boundsHighlight.addChild( this.innerBoundsHighlight );

    // @private Shape highlight
    this.shapeHighlight = new Path( null, { stroke: FocusOverlay.focusColor, visible: false } );
    this.innerShapeHighlight = new Path( null, { stroke: FocusOverlay.innerFocusColor } );
    this.shapeHighlight.addChild( this.innerShapeHighlight );

    // @private Node highlight
    this.nodeHighlight = null;

    this.highlightNode.addChild( this.boundsHighlight );
    this.highlightNode.addChild( this.shapeHighlight );

    // @private - Listeners bound once, so we can access them for removal.
    this.boundsListener = this.onBoundsChange.bind( this );
    this.transformListener = this.onTransformChange.bind( this );
    this.focusListener = this.onFocusChange.bind( this );

    scenery.Display.focusProperty.link( this.focusListener );
  }

  scenery.register( 'FocusOverlay', FocusOverlay );

  inherit( Object, FocusOverlay, {
    dispose: function() {
      if ( this.hasHighlight() ) {
        this.deactivateHighlight();
      }

      scenery.Display.focusProperty.unlink( this.focusListener );
    },

    hasHighlight: function() {
      return !!this.trail;
    },

    /**
     * Activates the highlight, choosing a mode for whether the highlight will be a shape, node, or bounds.
     * @private
     *
     * @param {Trail} trail - The focused trail to highlight. It assumes that this trail is in this display.
     */
    activateHighlight: function( trail ) {
      this.trail = trail;
      this.node = trail.lastNode();
      this.transformTracker = new TransformTracker( trail, {
        isStatic: true
      } );
      this.transformTracker.addListener( this.transformListener );

      // Invisible mode - no focus highlight
      if ( this.node.accessibleContent.focusHighlight === 'invisible' ) {
        this.mode = 'invisible';
      }
      // Shape mode
      else if ( this.node.accessibleContent.focusHighlight instanceof Shape ) {
        this.mode = 'shape';

        this.shapeHighlight.visible = true;
        this.shapeHighlight.shape = this.innerShapeHighlight.shape = this.node.accessibleContent.focusHighlight;
      }
      // Node mode
      else if ( this.node.accessibleContent.focusHighlight instanceof Node ) {
        this.mode = 'node';

        // If focusHighlightLayerable, then the focusHighlight is just a node in the scene graph, so set it visible
        if ( this.node.accessibleContent.focusHighlightLayerable ) {
          this.node.accessibleContent.focusHighlight.visible = true;
        }
        else {
          this.nodeHighlight = this.node.accessibleContent.focusHighlight;

          // Use the node itself as the highlight
          this.highlightNode.addChild( this.nodeHighlight );
        }
      }
      // Bounds mode
      else {
        this.mode = 'bounds';

        this.boundsHighlight.visible = true;
        this.node.onStatic( 'localBounds', this.boundsListener );

        this.onBoundsChange();
      }

      this.transformDirty = true;
    },

    /**
     * Deactivates the current highlight, disposing and removing listeners as necessary.
     * @private
     */
    deactivateHighlight: function() {
      if ( this.mode === 'shape' ) {
        this.shapeHighlight.visible = false;
      }
      else if ( this.mode === 'node' ) {

        // If focusHighlightLayerable, then the focusHighlight is just a node in the scene graph, so set it invisible
        if ( this.node.accessibleContent.focusHighlightLayerable ) {
          this.node.accessibleContent.focusHighlight.visible = false;
        }
        else {
          this.highlightNode.removeChild( this.nodeHighlight );
          this.nodeHighlight = null;
        }
      }
      else if ( this.mode === 'bounds' ) {
        this.boundsHighlight.visible = false;
        this.node.offStatic( 'localBounds', this.boundsListener );
      }

      this.trail = null;
      this.node = null;
      this.mode = null;
      this.transformTracker.removeListener( this.transformListener );
      this.transformTracker.dispose();
    },

    // Called from FocusOverlay after transforming the highlight. Only called when the transform changes.
    afterTransform: function() {
      if ( this.mode === 'shape' ) {
        this.shapeHighlight.lineWidth = 4 / this.shapeHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
        this.innerShapeHighlight.lineWidth = 2.5 / this.shapeHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
      }
      else if ( this.mode === 'bounds' ) {
        this.boundsHighlight.lineWidth = 4 / this.boundsHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
        this.innerBoundsHighlight.lineWidth = 2.5 / this.boundsHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
      }
    },

    onTransformChange: function() {
      this.transformDirty = true;
    },

    // Called when bounds change on our node when we are in "Bounds" mode
    onBoundsChange: function() {
      this.boundsHighlight.setRectBounds( this.node.localBounds );
      this.innerBoundsHighlight.setRectBounds( this.node.localBounds );
    },

    // Called when the main Scenery focus pair (Display,Trail) changes.
    onFocusChange: function( focus ) {
      var newTrail = ( focus && focus.display === this.display ) ? focus.trail : null;

      if ( this.hasHighlight() ) {
        this.deactivateHighlight();
      }

      if ( newTrail ) {
        this.activateHighlight( newTrail );
      }
    },

    update: function() {
      // Transform the highlight to match the position of the node
      if ( this.hasHighlight() && this.transformDirty ) {
        this.transformDirty = false;

        this.highlightNode.setMatrix( this.transformTracker.matrix );
        this.afterTransform();
      }

      if ( !this.display.size.equals( this.focusDisplay.size ) ) {
        this.focusDisplay.setWidthHeight( this.display.width, this.display.height );
      }
      this.focusDisplay.updateDisplay();
    }
  }, {
    focusColor: new Color( 'rgba(212,19,106,0.5)' ),
    innerFocusColor: new Color( 'rgba(250,40,135,0.9)' )
  } );

  return FocusOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Supertype for overlays that display colored shapes (updated every frame).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/ShapeBasedOverlay',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  function ShapeBasedOverlay( display, rootNode, name ) {
    this.display = display;
    this.rootNode = rootNode;

    var svg = this.svg = document.createElementNS( scenery.svgns, 'svg' );
    svg.style.position = 'absolute';
    svg.setAttribute( 'class', name );
    svg.style.top = 0;
    svg.style.left = 0;
    svg.style[ 'pointer-events' ] = 'none';

    function resize( width, height ) {
      svg.setAttribute( 'width', width );
      svg.setAttribute( 'height', height );
      svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
    }

    display.onStatic( 'displaySize', function( dimension ) {
      resize( dimension.width, dimension.height );
    } );
    resize( display.width, display.height );

    this.domElement = svg;
  }

  scenery.register( 'ShapeBasedOverlay', ShapeBasedOverlay );

  inherit( Object, ShapeBasedOverlay, {
    addShape: function( shape, color, isOffset ) {
      var path = document.createElementNS( scenery.svgns, 'path' );
      var svgPath = shape.getSVGPath();

      // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980
      // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing
      // the attribute can cause this bug
      if ( !svgPath ) { svgPath = 'M0 0'; }

      if ( svgPath ) {
        // only set the SVG path if it's not the empty string
        path.setAttribute( 'd', svgPath );
      }
      else if ( path.hasAttribute( 'd' ) ) {
        path.removeAttribute( 'd' );
      }

      path.setAttribute( 'style', 'fill: none; stroke: ' + color + '; stroke-dasharray: 5, 3; stroke-dashoffset: ' + ( isOffset ? 5 : 0 ) + '; stroke-width: 3;' );
      this.svg.appendChild( path );
    },

    update: function() {
      while ( this.svg.childNodes.length ) {
        this.svg.removeChild( this.svg.childNodes[ this.svg.childNodes.length - 1 ] );
      }

      this.addShapes();
    },

    // STUB to be overridden
    addShapes: function() {

    },

    dispose: function() {

    }
  } );

  return ShapeBasedOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Displays mouse and touch areas when they are customized. Expensive to display!
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/PointerAreaOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  function PointerAreaOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'mouseTouchAreaOverlay' );
  }

  scenery.register( 'PointerAreaOverlay', PointerAreaOverlay );

  inherit( ShapeBasedOverlay, PointerAreaOverlay, {
    // @override
    addShapes: function() {
      var self = this;

      new scenery.Trail( this.rootNode ).eachTrailUnder( function( trail ) {
        var node = trail.lastNode();
        if ( !node.isVisible() ) {
          // skip this subtree if the node is invisible
          return true;
        }
        if ( ( node.mouseArea || node.touchArea ) && trail.isVisible() ) {
          var transform = trail.getTransform();

          if ( node.mouseArea ) {
            self.addShape( transform.transformShape( node.mouseArea.isBounds ? Shape.bounds( node.mouseArea ) : node.mouseArea ), 'rgba(0,0,255,0.8)', true );
          }
          if ( node.touchArea ) {
            self.addShape( transform.transformShape( node.touchArea.isBounds ? Shape.bounds( node.touchArea ) : node.touchArea ), 'rgba(255,0,0,0.8)', false );
          }
        }
      } );
    }
  } );

  return PointerAreaOverlay;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * The PointerOverlay shows pointer locations in the scene.  This is useful when recording a session for interviews or when a teacher is broadcasting
 * a tablet session on an overhead projector.  See https://github.com/phetsims/scenery/issues/111
 *
 * Each pointer is rendered in a different <svg> so that CSS3 transforms can be used to make performance smooth on iPad.
 *
 * @author Sam Reid
 */
define( 'SCENERY/overlays/PointerOverlay',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/scenery','SCENERY/util/Trail','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  var Util = require( 'SCENERY/util/Util' );

  function PointerOverlay( display, rootNode ) {
    var self = this;
    this.display = display;
    this.rootNode = rootNode;

    // add element to show the pointers
    this.pointerSVGContainer = document.createElement( 'div' );
    this.pointerSVGContainer.style.position = 'absolute';
    this.pointerSVGContainer.style.top = 0;
    this.pointerSVGContainer.style.left = 0;
    this.pointerSVGContainer.style[ 'pointer-events' ] = 'none';

    var innerRadius = 10;
    var strokeWidth = 1;
    var diameter = (innerRadius + strokeWidth / 2) * 2;
    var radius = diameter / 2;

    //Resize the parent div when the rootNode is resized
    display.onStatic( 'displaySize', function( dimension ) {
      self.pointerSVGContainer.setAttribute( 'width', dimension.width );
      self.pointerSVGContainer.setAttribute( 'height', dimension.height );
      self.pointerSVGContainer.style.clip = 'rect(0px,' + dimension.width + 'px,' + dimension.height + 'px,0px)';
    } );

    var scratchMatrix = Matrix3.IDENTITY.copy();

    //Display a pointer that was added.  Use a separate SVG layer for each pointer so it can be hardware accelerated, otherwise it is too slow just setting svg internal attributes
    var pointerAdded = this.pointerAdded = function( pointer ) {

      if ( pointer.isKey ) { return; }

      var svg = document.createElementNS( scenery.svgns, 'svg' );
      svg.style.position = 'absolute';
      svg.style.top = 0;
      svg.style.left = 0;
      svg.style[ 'pointer-events' ] = 'none';

      Util.prepareForTransform( svg, false );

      //Fit the size to the display
      svg.setAttribute( 'width', diameter );
      svg.setAttribute( 'height', diameter );

      var circle = document.createElementNS( scenery.svgns, 'circle' );

      //use css transform for performance?
      circle.setAttribute( 'cx', innerRadius + strokeWidth / 2 );
      circle.setAttribute( 'cy', innerRadius + strokeWidth / 2 );
      circle.setAttribute( 'r', innerRadius );
      circle.setAttribute( 'style', 'fill:black;' );
      circle.setAttribute( 'style', 'stroke:white;' );
      circle.setAttribute( 'opacity', 0.4 );

      //Add a move listener to the pointer to update position when it has moved
      var pointerRemoved = function() {

        //For touches that get a touch up event, remove them.  But when the mouse button is released, don't stop showing the mouse location
        if ( pointer.isTouch ) {
          self.pointerSVGContainer.removeChild( svg );
          pointer.removeInputListener( moveListener );
        }
      };
      var moveListener = {
        move: function() {
          //TODO: Why is point sometimes null?
          if ( pointer.point ) {

            Util.applyPreparedTransform( scratchMatrix.setToTranslation( pointer.point.x - radius, pointer.point.y - radius ), svg, false );
          }
        },

        up: pointerRemoved,
        cancel: pointerRemoved
      };
      pointer.addInputListener( moveListener );

      moveListener.move();
      svg.appendChild( circle );
      self.pointerSVGContainer.appendChild( svg );
    };
    display._input.addPointerAddedListener( pointerAdded );

    //if there is already a mouse, add it here
    //TODO: if there already other non-mouse touches, could be added here
    if ( display._input && display._input.mouse ) {
      pointerAdded( display._input.mouse );
    }

    this.domElement = this.pointerSVGContainer;
  }

  scenery.register( 'PointerOverlay', PointerOverlay );

  inherit( Object, PointerOverlay, {
    dispose: function() {
      this.display._input.removePointerAddedListener( this.pointerAdded );
    },

    update: function() {

    }
  } );

  return PointerOverlay;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Displays CanvasNode bounds.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/CanvasNodeBoundsOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  function CanvasNodeBoundsOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'canvasNodeBoundsOverlay' );
  }

  scenery.register( 'CanvasNodeBoundsOverlay', CanvasNodeBoundsOverlay );

  inherit( ShapeBasedOverlay, CanvasNodeBoundsOverlay, {
    // @override
    addShapes: function() {
      var self = this;

      new scenery.Trail( this.rootNode ).eachTrailUnder( function( trail ) {
        var node = trail.lastNode();
        if ( !node.isVisible() ) {
          // skip this subtree if the node is invisible
          return true;
        }
        if ( ( node instanceof scenery.CanvasNode ) && trail.isVisible() ) {
          var transform = trail.getTransform();

          self.addShape( transform.transformShape( Shape.bounds( node.selfBounds ) ), 'rgba(0,255,0,0.8)', true );
        }
      } );
    }
  } );

  return CanvasNodeBoundsOverlay;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Shows the bounds of current fitted blocks.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/overlays/FittedBlockBoundsOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','DOT/Matrix3','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );
  var Matrix3 = require( 'DOT/Matrix3' );

  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );

  function FittedBlockBoundsOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'canvasNodeBoundsOverlay' );
  }

  scenery.register( 'FittedBlockBoundsOverlay', FittedBlockBoundsOverlay );

  inherit( ShapeBasedOverlay, FittedBlockBoundsOverlay, {
    // @override
    addShapes: function() {
      var self = this;

      function processBackbone( backbone, matrix ) {
        if ( backbone.willApplyTransform ) {
          matrix = matrix.timesMatrix( backbone.backboneInstance.relativeTransform.matrix );
        }
        backbone.blocks.forEach( function( block ) {
          processBlock( block, matrix );
        } );
      }

      function processBlock( block, matrix ) {
        if ( block.fitBounds && !block.fitBounds.isEmpty() ) {
          self.addShape( Shape.bounds( block.fitBounds ).transformed( matrix ), 'rgba(255,0,0,0.8)', true );
        }
        if ( block.firstDrawable && block.lastDrawable ) {
          for ( var childDrawable = block.firstDrawable; childDrawable !== block.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            processDrawable( childDrawable, matrix );
          }
          processDrawable( block.lastDrawable, matrix );
        }
      }

      function processDrawable( drawable, matrix ) {
        // How we detect backbones (for now)
        if ( drawable.backboneInstance ) {
          processBackbone( drawable, matrix );
        }
      }

      processBackbone( this.display._rootBackbone, Matrix3.IDENTITY );
    }
  } );

  return FittedBlockBoundsOverlay;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Wrapper type for scenery's Focus region.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */
define( 'SCENERY/accessibility/TFocus',['require','SCENERY/scenery','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject'],function( require ) {
  'use strict';

  // modules
  var scenery = require( 'SCENERY/scenery' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );

  /**
   * Wrapper type for phet/sun's Faucet class.
   * @param {Object} focus - the focus region which has {display,trail}
   * @param {string} phetioID - the unique tandem assigned to the focus
   * @constructor
   */
  function TFocus( focus, phetioID ) {
    assertInstanceOf( focus, phet.scenery.Focus );
    TObject.call( this, focus, phetioID );
  }

  phetioInherit( TObject, 'TFocus', TFocus, {}, {

    /**
     * Convert the focus region to a plain JS object for serialization.
     * @param {Object} focus - the focus region which has {display,trail}
     * @returns {Object} - the serialized object
     */
    toStateObject: function( focus ) {

      // If nothing is focused, the focus is nulls
      if ( focus === null ) {
        return null;
      }
      else {
        return focus.trail.indices;
      }
    },

    /**
     * Convert the serialized instance back to a focus object
     * @param {number[]} indices
     * @returns {Object} with {display,trail}
     */
    fromStateObject: function( indices ) {

      if ( indices === null ) {

        // support unfocused
        return null;
      }
      else {

        // Follow the path of children based on their indices, starting from the root of the display.
        // There is always one more node in Trail than indices, representing the root node.
        var currentNode = phet.joist.sim.display.rootNode;
        var nodes = [ currentNode ];
        for ( var i = 0; i < indices.length; i++ ) {
          var index = indices[ i ];
          currentNode = currentNode.children[ index ];
          nodes.push( currentNode );
        }

        return { display: phet.joist.sim.display, trail: new phet.scenery.Trail( nodes ) };
      }
    },

    documentation: 'A wrapper type for the instance in the simulation which currently has keyboard focus.'
  } );

  scenery.register( 'TFocus', TFocus );

  return TFocus;
} );
// Copyright 2013-2016, University of Colorado Boulder

/**
 * A persistent display of a specific Node and its descendants, which is updated at discrete points in time.
 *
 * Use display.getDOMElement or display.domElement to retrieve the Display's DOM representation.
 * Use display.updateDisplay() to trigger the visual update in the Display's DOM element.
 *
 * A standard way of using a Display with Scenery is to:
 * 1. Create a Node that will be the root
 * 2. Create a Display, referencing that node
 * 3. Make changes to the scene graph
 * 4. Call display.updateDisplay() to draw the scene graph into the Display
 * 5. Go to (3)
 *
 * Common ways to simplify the change/update loop would be to:
 * - Use Node-based events. Initialize it with Display.initializeEvents(), then
 *   add input listeners to parts of the scene graph (see Node.addInputListener).
 * - Execute code (and update the display afterwards) by using Display.updateOnRequestAnimationFrame.
 *
 * Internal documentation:
 *
 * Lifecycle information:
 *   Instance (create,dispose)
 *     - out of update:            Stateless stub is created synchronously when a Node's children are added where we
 *                                 have no relevant Instance.
 *     - start of update:          Creates first (root) instance if it doesn't exist (stateless stub).
 *     - synctree:                 Create descendant instances under stubs, fills in state, and marks removed subtree
 *                                 roots for disposal.
 *     - update instance disposal: Disposes root instances that were marked. This also disposes all descendant
 *                                 instances, and for every instance,
 *                                 it disposes the currently-attached drawables.
 *   Drawable (create,dispose)
 *     - synctree:                 Creates all drawables where necessary. If it replaces a self/group/shared drawable on
 *                                 the instance,
 *                                 that old drawable is marked for disposal.
 *     - update instance disposal: Any drawables attached to disposed instances are disposed themselves (see Instance
 *                                 lifecycle).
 *     - update drawable disposal: Any marked drawables that were replaced or removed from an instance (it didn't
 *                                 maintain a reference) are disposed.
 *
 *   add/remove drawables from blocks:
 *     - stitching changes pending "parents", marks for block update
 *     - backbones marked for disposal (e.g. instance is still there, just changed to not have a backbone) will mark
 *         drawables for block updates
 *     - add/remove drawables phase updates drawables that were marked
 *     - disposed backbone instances will only remove drawables if they weren't marked for removal previously (e.g. in
 *         case we are from a removed instance)
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/Display',['require','PHET_CORE/inherit','AXON/Emitter','PHET_CORE/extend','AXON/Events','AXON/Property','DOT/Dimension2','DOT/Vector2','DOT/Matrix3','TANDEM/Tandem','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/util/Features','SCENERY/display/BackboneDrawable','SCENERY/display/CanvasBlock','SCENERY/display/CanvasSelfDrawable','SCENERY/display/ChangeInterval','SCENERY/display/DOMSelfDrawable','SCENERY/display/Drawable','SCENERY/display/Instance','SCENERY/display/InlineCanvasCacheDrawable','SCENERY/display/Renderer','SCENERY/display/SharedCanvasCacheDrawable','SCENERY/display/SVGSelfDrawable','SCENERY/input/Input','SCENERY/util/Trail','SCENERY/accessibility/AccessibleInstance','SCENERY/util/SceneryStyle','SCENERY/overlays/FocusOverlay','SCENERY/overlays/PointerAreaOverlay','SCENERY/overlays/PointerOverlay','SCENERY/overlays/CanvasNodeBoundsOverlay','SCENERY/overlays/FittedBlockBoundsOverlay','SCENERY/accessibility/TFocus','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var extend = require( 'PHET_CORE/extend' );
  var Events = require( 'AXON/Events' );
  var Property = require( 'AXON/Property' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Tandem = require( 'TANDEM/Tandem' );

  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Features = require( 'SCENERY/util/Features' );
  require( 'SCENERY/display/BackboneDrawable' );
  require( 'SCENERY/display/CanvasBlock' );
  require( 'SCENERY/display/CanvasSelfDrawable' );
  var ChangeInterval = require( 'SCENERY/display/ChangeInterval' );
  require( 'SCENERY/display/DOMSelfDrawable' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Instance = require( 'SCENERY/display/Instance' );
  require( 'SCENERY/display/InlineCanvasCacheDrawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  require( 'SCENERY/display/SharedCanvasCacheDrawable' );
  require( 'SCENERY/display/SVGSelfDrawable' );
  var Input = require( 'SCENERY/input/Input' );
  require( 'SCENERY/util/Trail' );
  var AccessibleInstance = require( 'SCENERY/accessibility/AccessibleInstance' );
  var SceneryStyle = require( 'SCENERY/util/SceneryStyle' );
  var FocusOverlay = require( 'SCENERY/overlays/FocusOverlay' );
  var PointerAreaOverlay = require( 'SCENERY/overlays/PointerAreaOverlay' );
  var PointerOverlay = require( 'SCENERY/overlays/PointerOverlay' );
  var CanvasNodeBoundsOverlay = require( 'SCENERY/overlays/CanvasNodeBoundsOverlay' );
  var FittedBlockBoundsOverlay = require( 'SCENERY/overlays/FittedBlockBoundsOverlay' );
  var TFocus = require( 'SCENERY/accessibility/TFocus' );
  var Util = require( 'SCENERY/util/Util' );

  /*
   * Constructs a Display that will show the rootNode and its subtree in a visual state. Default options provided below
   *
   * @param {Node} rootNode - Displays this node and all of its descendants
   *
   * Valid parameters in the parameter object:
   * {
   *   allowSceneOverflow: false,           // Usually anything displayed outside of this $main (DOM/CSS3 transformed SVG) is hidden with CSS overflow
   *   allowCSSHacks: true,                 // Applies styling that prevents mobile browser graphical issues
   *   width: <current main width>,         // Override the main container's width
   *   height: <current main height>,       // Override the main container's height
   *   preserveDrawingBuffer: false,        // Whether WebGL Canvases should preserve their drawing buffer.
   *                                        //   WARNING!: This can significantly reduce performance if set to true.
   *   allowWebGL: true,                    // Boolean flag that indicates whether scenery is allowed to use WebGL for rendering
   *                                        // Makes it possible to disable WebGL for ease of testing on non-WebGL platforms, see #289
   *   accessibility: true                  // Whether accessibility enhancements is enabled
   *   interactive: true                    // Whether mouse/touch/keyboard inputs are enabled (if input has been added)
   */
  function Display( rootNode, options ) {
    assert && assert( rootNode, 'rootNode is a required parameter' );

    //OHTWO TODO: hybrid batching (option to batch until an event like 'up' that might be needed for security issues)

    // supertype call to axon.Events (should just initialize a few properties here, notably _eventListeners and _staticEventListeners)
    Events.call( this );

    // Inline platform detection in maintenance release, since usually we won't need to hit phet-core
    var ua = navigator.userAgent;
    // Whether the browser is most likely Safari running on iOS
    // See http://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari
    function isMobileSafari() {
      return !!( ua.match( /(iPod|iPhone|iPad)/ ) && ua.match( /AppleWebKit/ ) );
    }
    var safari = isMobileSafari() || !!( ua.match( /Version\// ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) );

    options = _.extend( {
      // initial display width
      width: ( options && options.container && options.container.clientWidth ) || 640,

      // initial display height
      height: ( options && options.container && options.container.clientHeight ) || 480,

      allowCSSHacks: true,       // applies CSS styles to the root DOM element that make it amenable to interactive content
      allowSceneOverflow: false, // usually anything displayed outside of our dom element is hidden with CSS overflow
      defaultCursor: 'default',  // what cursor is used when no other cursor is specified
      backgroundColor: null,      // initial background color
      preserveDrawingBuffer: false,
      allowWebGL: true,
      accessibility: true,
      isApplication: false,      // adds the aria-role: 'application' when accessibility is enabled
      interactive: true,

      // {boolean} - If true, input event listeners will be attached to the Display's DOM element instead of the window.
      // Normally, attaching listeners to the window is preferred (it will see mouse moves/ups outside of the browser
      // window, allowing correct button tracking), however there may be instances where a global listener is not
      // preferred.
      listenToOnlyElement: false,

      // TODO: doc
      batchDOMEvents: false,

      // {boolean} - If true, the input event location (based on the top-left of the browser tab's viewport, with no
      // scaling applied) will be used. Usually, this is not a safe assumption, so when false the location of the
      // display's DOM element will be used to get the correct event location. There is a slight performance hit to
      // doing so, thus this option is provided if the top-left location can be guaranteed.
      // NOTE: Rotation of the Display's DOM element (e.g. with a CSS transform) will result in an incorrect event
      //       mapping, as getBoundingClientRect() can't work with this. getBoxQuads() should fix this when browser
      //       support is available.
      assumeFullWindow: false,

      // {boolean} - Whether Scenery will try to aggressively re-create WebGL Canvas/context instead of waiting for
      // a context restored event. Sometimes context losses can occur without a restoration afterwards, but this can
      // jump-start the process.
      // See https://github.com/phetsims/scenery/issues/347.
      aggressiveContextRecreation: true,
      passiveEvents: safari ? false : null
    }, options );

    // TODO: don't store the options, it's an anti-pattern.
    this.options = options; // @private

    this._allowWebGL = options.allowWebGL;

    // The (integral, > 0) dimensions of the Display's DOM element (only updates the DOM element on updateDisplay())
    this._size = new Dimension2( this.options.width, this.options.height );
    this._currentSize = new Dimension2( -1, -1 ); // used to check against new size to see what we need to change

    this._rootNode = rootNode;
    this._rootNode.addRootedDisplay( this );
    this._rootBackbone = null; // to be filled in later
    this._domElement = ( options && options.container ) ?
                       scenery.BackboneDrawable.repurposeBackboneContainer( options.container ) :
                       scenery.BackboneDrawable.createDivBackbone();
    this._sharedCanvasInstances = {}; // map from Node ID to Instance, for fast lookup
    this._baseInstance = null; // will be filled with the root Instance

    // We have a monotonically-increasing frame ID, generally for use with a pattern where we can mark objects with this
    // to note that they are either up-to-date or need refreshing due to this particular frame (without having to clear
    // that information after use). This is incremented every frame
    this._frameId = 0; // {number}

    this._dirtyTransformRoots = [];
    this._dirtyTransformRootsWithoutPass = [];

    this._instanceRootsToDispose = [];
    this._drawablesToDispose = [];

    // Block changes are handled by changing the "pending" block/backbone on drawables. We want to change them all after
    // the main stitch process has completed, so we can guarantee that a single drawable is removed from its previous
    // block before being added to a new one. This is taken care of in an updateDisplay pass after syncTree / stitching.
    this._drawablesToChangeBlock = []; // {[Drawable]}

    // Drawables have two implicit linked-lists, "current" and "old". syncTree modifies the "current" linked-list
    // information so it is up-to-date, but needs to use the "old" information also. We move updating the
    // "current" => "old" linked-list information until after syncTree and stitching is complete, and is taken care of
    // in an updateDisplay pass.
    this._drawablesToUpdateLinks = []; // {[Drawable]}

    // We store information on {ChangeInterval}s that records change interval information, that may contain references.
    // We don't want to leave those references dangling after we don't need them, so they are recorded and cleaned in
    // one of updateDisplay's phases.
    this._changeIntervalsToDispose = []; // {[ChangeInterval]}

    this._lastCursor = null;

    this._currentBackgroundCSS = null;
    this._backgroundColor = null;

    // used for shortcut animation frame functions
    this._requestAnimationFrameID = 0;

    // will be filled in with a scenery.Input if event handling is enabled
    this._input = null;
    this._inputListeners = []; // {Array.<Object>} - Listeners that will be called for every event.
    this._interactive = this.options.interactive;
    this._listenToOnlyElement = options.listenToOnlyElement; // TODO: doc
    this._batchDOMEvents = options.batchDOMEvents; // TODO: doc
    this._assumeFullWindow = options.assumeFullWindow; // TODO: doc
    this._passiveEvents = options.passiveEvents;

    // @public (scenery-internal) {boolean}
    this._aggressiveContextRecreation = options.aggressiveContextRecreation;

    // overlays currently being displayed.
    // API expected:
    //   .domElement
    //   .update()
    this._overlays = [];
    this._pointerOverlay = null;
    this._pointerAreaOverlay = null;
    this._canvasAreaBoundsOverlay = null;
    this._fittedBlockBoundsOverlay = null;

    // properties for fuzzMouseEvents, so that we can track the status of a persistent mouse pointer
    this._fuzzMouseIsDown = false;
    this._fuzzMousePosition = new Vector2(); // start at 0,0
    this._fuzzMouseLastMoved = false; // whether the last mouse event was a move (we skew probabilities based on this)

    if ( assert ) {
      // @private @assertion-only {boolean} - Whether we are running the paint phase of updateDisplay() for this Display.
      this._isPainting = false;
    }

    this.applyCSSHacks();

    this.setBackgroundColor( this.options.backgroundColor );

    // global reference if we have a Display (useful)
    this.scenery = scenery;

    if ( this.options.accessibility ) {
      if ( this.options.isApplication ) {
        this._domElement.setAttribute( 'aria-role', 'application' );
      }

      SceneryStyle.addRule( '.accessibility * { position: absolute; left: 0; top: 0; width: 0; height: 0, clip: rect(0,0,0,0); }' );

      this._focusRootNode = new Node();
      this._focusOverlay = new FocusOverlay( this, this._focusRootNode );
      this.addOverlay( this._focusOverlay );

      this._unsortedAccessibleInstances = [];

      // @private - the node that currently has focus when we remove an accessible trail,
      // tracked so that we can restore focus during sorting of accessible instances
      this._focusedNodeOnRemoveTrail = null;

      this._rootAccessibleInstance = AccessibleInstance.createFromPool( null, this, new scenery.Trail() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Display root instance: ' + this._rootAccessibleInstance.toString() );
      this._rootAccessibleInstance.addSubtree( new scenery.Trail( this._rootNode ) );

      // add the accessible DOM as a child of this DOM element
      this._domElement.appendChild( this._rootAccessibleInstance.peer.domElement );
    }
  }

  scenery.register( 'Display', Display );

  inherit( Object, Display, extend( {
    // returns the base DOM element that will be displayed by this Display
    getDOMElement: function() {
      return this._domElement;
    },
    get domElement() { return this.getDOMElement(); },

    // updates the display's DOM element with the current visual state of the attached root node and its descendants
    updateDisplay: function() {

      //OHTWO TODO: turn off after most debugging work is done
      if ( window.sceneryDebugPause ) {
        return;
      }

      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.perfSyncTreeCount = 0;
        this.perfStitchCount = 0;
        this.perfIntervalCount = 0;
        this.perfDrawableBlockChangeCount = 0;
        this.perfDrawableOldIntervalCount = 0;
        this.perfDrawableNewIntervalCount = 0;
      }

      if ( assert ) {
        Display.assertSubtreeDisposed( this._rootNode );
      }

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'updateDisplay frame ' + this._frameId );
      sceneryLog && sceneryLog.Display && sceneryLog.push();

      var firstRun = !!this._baseInstance;

      // check to see whether contents under pointers changed (and if so, send the enter/exit events) to
      // maintain consistent state
      if ( this._input ) {
        // TODO: Should this be handled elsewhere?
        this._input.validatePointers();
      }

      // validate bounds for everywhere that could trigger bounds listeners. we want to flush out any changes, so that we can call validateBounds()
      // from code below without triggering side effects (we assume that we are not reentrant).
      this._rootNode.validateWatchedBounds();

      if ( assertSlow ) { this.options.accessibility && this._rootAccessibleInstance.auditRoot(); }

      if ( assertSlow ) { this._rootNode._picker.audit(); }

      this._baseInstance = this._baseInstance || scenery.Instance.createFromPool( this, new scenery.Trail( this._rootNode ), true, false );
      this._baseInstance.baseSyncTree();
      if ( firstRun ) {
        this.markTransformRootDirty( this._baseInstance, this._baseInstance.isTransformed ); // marks the transform root as dirty (since it is)
      }

      // update our drawable's linked lists where necessary
      while ( this._drawablesToUpdateLinks.length ) {
        this._drawablesToUpdateLinks.pop().updateLinks();
      }

      // clean change-interval information from instances, so we don't leak memory/references
      while ( this._changeIntervalsToDispose.length ) {
        this._changeIntervalsToDispose.pop().dispose();
      }

      this._rootBackbone = this._rootBackbone || this._baseInstance.groupDrawable;
      assert && assert( this._rootBackbone, 'We are guaranteed a root backbone as the groupDrawable on the base instance' );
      assert && assert( this._rootBackbone === this._baseInstance.groupDrawable, 'We don\'t want the base instance\'s groupDrawable to change' );


      if ( assertSlow ) { this._rootBackbone.audit( true, false, true ); } // allow pending blocks / dirty

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'drawable block change phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      while ( this._drawablesToChangeBlock.length ) {
        var changed = this._drawablesToChangeBlock.pop().updateBlock();
        if ( sceneryLog && scenery.isLoggingPerformance() && changed ) {
          this.perfDrawableBlockChangeCount++;
        }
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();

      if ( assertSlow ) { this._rootBackbone.audit( false, false, true ); } // allow only dirty
      if ( assertSlow ) { this._baseInstance.audit( this._frameId, false ); }

      // pre-repaint phase: update relative transform information for listeners (notification) and precomputation where desired
      this.updateDirtyTransformRoots();
      // pre-repaint phase update visibility information on instances
      this._baseInstance.updateVisibility( true, true, false );

      if ( assertSlow ) { this._baseInstance.auditVisibility( true ); }

      if ( assertSlow ) { this._baseInstance.audit( this._frameId, true ); }

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'instance root disposal phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      // dispose all of our instances. disposing the root will cause all descendants to also be disposed.
      // will also dispose attached drawables (self/group/etc.)
      while ( this._instanceRootsToDispose.length ) {
        this._instanceRootsToDispose.pop().dispose();
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();

      if ( assertSlow ) { this._rootNode.auditInstanceSubtreeForDisplay( this ); } // make sure trails are valid

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'drawable disposal phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      // dispose all of our other drawables.
      while ( this._drawablesToDispose.length ) {
        this._drawablesToDispose.pop().dispose();
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();

      if ( assertSlow ) { this._baseInstance.audit( this._frameId ); }

      if ( assert ) {
        assert( !this._isPainting, 'Display was already updating paint, may have thrown an error on the last update' );
        this._isPainting = true;
      }

      // repaint phase
      //OHTWO TODO: can anything be updated more efficiently by tracking at the Display level? Remember, we have recursive updates so things get updated in the right order!
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'repaint phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      this._rootBackbone.update();
      sceneryLog && sceneryLog.Display && sceneryLog.pop();

      if ( assert ) {
        this._isPainting = false;
      }

      if ( assertSlow ) { this._rootBackbone.audit( false, false, false ); } // allow nothing
      if ( assertSlow ) { this._baseInstance.audit( this._frameId ); }

      this.updateCursor();
      this.updateBackgroundColor();

      this.updateSize();

      if ( this._overlays.length ) {
        var zIndex = this._rootBackbone.lastZIndex;
        for ( var i = 0; i < this._overlays.length; i++ ) {
          // layer the overlays properly
          var overlay = this._overlays[ i ];
          overlay.domElement.style.zIndex = zIndex++;

          overlay.update();
        }
      }

      this._frameId++;

      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        var syncTreeMessage = 'syncTree count: ' + this.perfSyncTreeCount;
        if ( this.perfSyncTreeCount > 500 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 100 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 20 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 0 ) {
          sceneryLog.PerfVerbose && sceneryLog.PerfVerbose( syncTreeMessage );
        }

        var drawableBlockCountMessage = 'drawable block changes: ' + this.perfDrawableBlockChangeCount + ' for' +
                                        ' -' + this.perfDrawableOldIntervalCount +
                                        ' +' + this.perfDrawableNewIntervalCount;
        if ( this.perfDrawableBlockChangeCount > 200 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 60 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 10 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 0 ) {
          sceneryLog.PerfVerbose && sceneryLog.PerfVerbose( drawableBlockCountMessage );
        }
      }

      sceneryLog && sceneryLog.Display && sceneryLog.pop();
    },

    updateSize: function() {
      var sizeDirty = false;
      //OHTWO TODO: if we aren't clipping or setting background colors, can we get away with having a 0x0 container div and using absolutely-positioned children?
      if ( this._size.width !== this._currentSize.width ) {
        sizeDirty = true;
        this._currentSize.width = this._size.width;
        this._domElement.style.width = this._size.width + 'px';
      }
      if ( this._size.height !== this._currentSize.height ) {
        sizeDirty = true;
        this._currentSize.height = this._size.height;
        this._domElement.style.height = this._size.height + 'px';
      }
      if ( sizeDirty && !this.options.allowSceneOverflow ) {
        // to prevent overflow, we add a CSS clip
        //TODO: 0px => 0?
        this._domElement.style.clip = 'rect(0px,' + this._size.width + 'px,' + this._size.height + 'px,0px)';
      }
    },

    getRootNode: function() {
      return this._rootNode;
    },
    get rootNode() { return this.getRootNode(); },

    // The dimensions of the Display's DOM element
    getSize: function() {
      return this._size;
    },
    get size() { return this.getSize(); },

    getBounds: function() {
      return this._size.toBounds();
    },
    get bounds() { return this.getBounds(); },

    // size: dot.Dimension2. Changes the size that the Display's DOM element will be after the next updateDisplay()
    setSize: function( size ) {
      assert && assert( size instanceof Dimension2 );
      assert && assert( size.width % 1 === 0, 'Display.width should be an integer' );
      assert && assert( size.width > 0, 'Display.width should be greater than zero' );
      assert && assert( size.height % 1 === 0, 'Display.height should be an integer' );
      assert && assert( size.height > 0, 'Display.height should be greater than zero' );

      if ( !this._size.equals( size ) ) {
        this._size = size;

        this.trigger1( 'displaySize', this._size );
      }
    },

    setWidthHeight: function( width, height ) {
      // TODO: don't burn an instance here?
      this.setSize( new Dimension2( width, height ) );
    },

    // The width of the Display's DOM element
    getWidth: function() {
      return this._size.width;
    },
    get width() { return this.getWidth(); },

    // Sets the width that the Display's DOM element will be after the next updateDisplay(). Should be an integral value.
    setWidth: function( width ) {
      assert && assert( typeof width === 'number', 'Display.width should be a number' );

      if ( this.getWidth() !== width ) {
        // TODO: remove allocation here?
        this.setSize( new Dimension2( width, this.getHeight() ) );
      }
    },
    set width( value ) { this.setWidth( value ); },

    // The height of the Display's DOM element
    getHeight: function() {
      return this._size.height;
    },
    get height() { return this.getHeight(); },

    // Sets the height that the Display's DOM element will be after the next updateDisplay(). Should be an integral value.
    setHeight: function( height ) {
      assert && assert( typeof height === 'number', 'Display.height should be a number' );

      if ( this.getHeight() !== height ) {
        // TODO: remove allocation here?
        this.setSize( new Dimension2( this.getWidth(), height ) );
      }
    },
    set height( value ) { this.setHeight( value ); },

    // {string} (CSS), {Color} instance, or null (no background color).
    // Will be applied to the root DOM element on updateDisplay(), and no sooner.
    setBackgroundColor: function( color ) {
      assert && assert( color === null || typeof color === 'string' || color instanceof scenery.Color );

      this._backgroundColor = color;
    },
    set backgroundColor( value ) { this.setBackgroundColor( value ); },

    getBackgroundColor: function() {
      return this._backgroundColor;
    },
    get backgroundColor() { return this.getBackgroundColor(); },

    get interactive() { return this._interactive; },
    set interactive( value ) {
      this._interactive = value;
      if ( !this._interactive && this._input ) {
        this._input.clearBatchedEvents();
        this._input.removeTemporaryPointers();
        this._rootNode.interruptSubtreeInput();
      }
    },

    addOverlay: function( overlay ) {
      this._overlays.push( overlay );
      this._domElement.appendChild( overlay.domElement );

      // ensure that the overlay is hidden from screen readers, all accessible content should be in the dom element
      // of the this._rootAccessibleInstance
      overlay.domElement.setAttribute( 'aria-hidden', true );
    },

    removeOverlay: function( overlay ) {
      this._domElement.removeChild( overlay.domElement );
      this._overlays.splice( _.indexOf( this._overlays, overlay ), 1 );
    },

    /**
     * Returns the AccessibleInstance which has the longest trail that is an ancestor of the passed in trail. It will
     * fall back to the root accessible instance if there is no other available one.
     * @private
     *
     * @param {Trail} trail
     * @returns {AccessibleInstance}
     */
    getBaseAccessibleInstance: function( trail ) {
      // Search through trail to find longest trail extension where the leafmost node has accessible content, but does
      // not include the node that was just added.
      var i;
      for ( i = trail.length - 2; i >= 0; i-- ) {
        // break if there is accessible content for nodes along the trail, including root.
        if ( trail.nodes[ i ].accessibleContent ) {
          break;
        }
      }
      // no ancestor of the added node was accessible, so add things directly to root accessible instance.
      if ( i < 0 ) {
        return this._rootAccessibleInstance;
      }
      // otherwise, we encountered an accessible instance and i points to the leaf most node for the sub trail.
      else {
        var leafMostAccessibleNode = trail.nodes[ i ];
        var accessibleInstances = leafMostAccessibleNode._accessibleInstances;
        // look up the accessible instance given the leaf most accessible node.
        for ( var j = 0; j < accessibleInstances.length; j++ ) {
          var accessibleInstance = accessibleInstances[ j ];
          if ( trail.isExtensionOf( accessibleInstance.trail ) ) {
            return accessibleInstance;
          }
        }
      }

      throw new Error( 'A base accessible instance must be defined.' );
    },

    markUnsortedAccessibleInstance: function( accessibleInstance ) {
      this._unsortedAccessibleInstances.push( accessibleInstance );
    },

    sortAccessibleInstances: function() {
      while ( this._unsortedAccessibleInstances.length ) {
        this._unsortedAccessibleInstances.pop().sortChildren();
      }
    },

    /**
     * Called when a subtree with accessible content is added.
     * @private
     *
     * @param {Trail} trail
     */
    addAccessibleTrail: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.addAccessibleTrail ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();

      this.getBaseAccessibleInstance( trail ).addSubtree( trail );

      this.sortAccessibleInstances();

      // after sorting, restore focus if the browser blured while removing DOM elements
      if ( this._focusedNodeOnRemoveTrail ) {
        this._focusedNodeOnRemoveTrail.focusable && this._focusedNodeOnRemoveTrail.focus();
        this._focusedNodeOnRemoveTrail = null;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },

    /**
     * Called when a subtree with accessible content is removed.
     * @private
     *
     * @param {Trail} trail
     */
    removeAccessibleTrail: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.removeAccessibleTrail ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();

      this._focusedNodeOnRemoveTrail = Display.focusedNode;
      this.getBaseAccessibleInstance( trail ).removeSubtree( trail );

      this.sortAccessibleInstances();

      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },

    /**
     * Called when an ancestor node's accessible content is changed.
     * @private
     *
     * @param {Trail} trail
     * @param {Object} oldAccessibleContent
     * @param {Object} newAccessibleContent
     */
    changedAccessibleContent: function( trail, oldAccessibleContent, newAccessibleContent ) {
      if ( !this.options.accessibility ) {
        return;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility(
        'Display.changedAccessibleContent ' + trail.toString() +
        ' old: ' + ( !!oldAccessibleContent ) +
        ' new: ' + ( !!newAccessibleContent ) );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();

      this.getBaseAccessibleInstance( trail ).removeSubtree( trail );
      this.getBaseAccessibleInstance( trail ).addSubtree( trail );

      this.sortAccessibleInstances();

      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },

    /**
     * Called when an ancestor node's accessible order is changed.
     * @private
     *
     * @param {Trail} trail
     */
    changedAccessibleOrder: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }

      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.changedAccessibleOrder ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();

      this.getBaseAccessibleInstance( trail ).markAsUnsorted();

      this.sortAccessibleInstances();

      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },

    /**
     * Get the root accessible DOM element which represents this display and provides semantics for assistive
     * technology.
     * @public
     * @returns {HTMLElement}
     */
    getAccessibleDOMElement: function() {
      return this._rootAccessibleInstance.peer.domElement;
    },
    get accessibleDOMElement() { return this.getAccessibleDOMElement(); },

    /*
     * Returns the bitmask union of all renderers (canvas/svg/dom/webgl) that are used for display, excluding
     * BackboneDrawables (which would be DOM).
     */
    getUsedRenderersBitmask: function() {
      function renderersUnderBackbone( backbone ) {
        var bitmask = 0;
        _.each( backbone.blocks, function( block ) {
          if ( block instanceof scenery.DOMBlock && block.domDrawable instanceof scenery.BackboneDrawable ) {
            bitmask = bitmask | renderersUnderBackbone( block.domDrawable );
          }
          else {
            bitmask = bitmask | block.renderer;
          }
        } );
        return bitmask;
      }

      // only return the renderer-specific portion (no other hints, etc)
      return renderersUnderBackbone( this._rootBackbone ) & Renderer.bitmaskRendererArea;
    },

    /*
     * Called from Instances that will need a transform update (for listeners and precomputation).
     * @param passTransform {boolean} - Whether we should pass the first transform root when validating transforms (should be true if the instance is transformed)
     */
    markTransformRootDirty: function( instance, passTransform ) {
      passTransform ? this._dirtyTransformRoots.push( instance ) : this._dirtyTransformRootsWithoutPass.push( instance );
    },

    updateDirtyTransformRoots: function() {
      sceneryLog && sceneryLog.transformSystem && sceneryLog.transformSystem( 'updateDirtyTransformRoots' );
      sceneryLog && sceneryLog.transformSystem && sceneryLog.push();
      while ( this._dirtyTransformRoots.length ) {
        this._dirtyTransformRoots.pop().relativeTransform.updateTransformListenersAndCompute( false, false, this._frameId, true );
      }
      while ( this._dirtyTransformRootsWithoutPass.length ) {
        this._dirtyTransformRootsWithoutPass.pop().relativeTransform.updateTransformListenersAndCompute( false, false, this._frameId, false );
      }
      sceneryLog && sceneryLog.transformSystem && sceneryLog.pop();
    },

    markDrawableChangedBlock: function( drawable ) {
      assert && assert( drawable instanceof Drawable );

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markDrawableChangedBlock: ' + drawable.toString() );
      this._drawablesToChangeBlock.push( drawable );
    },

    markInstanceRootForDisposal: function( instance ) {
      assert && assert( instance instanceof Instance, 'How would an instance not be an instance of an instance?!?!?' );

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markInstanceRootForDisposal: ' + instance.toString() );
      this._instanceRootsToDispose.push( instance );
    },

    markDrawableForDisposal: function( drawable ) {
      assert && assert( drawable instanceof Drawable );

      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markDrawableForDisposal: ' + drawable.toString() );
      this._drawablesToDispose.push( drawable );
    },

    markDrawableForLinksUpdate: function( drawable ) {
      assert && assert( drawable instanceof Drawable );

      this._drawablesToUpdateLinks.push( drawable );
    },

    // Add a {ChangeInterval} for the "remove change interval info" phase (we don't want to leak memory/references)
    markChangeIntervalToDispose: function( changeInterval ) {
      assert && assert( changeInterval instanceof ChangeInterval );

      this._changeIntervalsToDispose.push( changeInterval );
    },

    updateBackgroundColor: function() {
      assert && assert( this._backgroundColor === null ||
                        typeof this._backgroundColor === 'string' ||
                        this._backgroundColor instanceof scenery.Color );

      var newBackgroundCSS = this._backgroundColor === null ?
                             '' :
                             ( this._backgroundColor.toCSS ?
                               this._backgroundColor.toCSS() :
                               this._backgroundColor );
      if ( newBackgroundCSS !== this._currentBackgroundCSS ) {
        this._currentBackgroundCSS = newBackgroundCSS;

        this._domElement.style.backgroundColor = newBackgroundCSS;
      }
    },

    /*---------------------------------------------------------------------------*
     * Cursors
     *----------------------------------------------------------------------------*/

    updateCursor: function() {
      if ( this._input && this._input.mouse && this._input.mouse.point ) {
        if ( this._input.mouse.cursor ) {
          sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( 'set on pointer: ' + this._input.mouse.cursor );
          return this.setSceneCursor( this._input.mouse.cursor );
        }

        //OHTWO TODO: For a display, just return an instance and we can avoid the garbage collection/mutation at the cost of the linked-list traversal instead of an array
        var mouseTrail = this._rootNode.trailUnderPointer( this._input.mouse );

        if ( mouseTrail ) {
          for ( var i = mouseTrail.getCursorCheckIndex(); i >= 0; i-- ) {
            var node = mouseTrail.nodes[ i ];
            var cursor = node.getCursor();

            if ( cursor ) {
              sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( cursor + ' on ' + node.constructor.name + '#' + node.id );
              return this.setSceneCursor( cursor );
            }
          }
        }

        sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( '--- for ' + ( mouseTrail ? mouseTrail.toString() : '(no hit)' ) );
      }

      // fallback case
      return this.setSceneCursor( this.options.defaultCursor );
    },

    setSceneCursor: function( cursor ) {
      if ( cursor !== this._lastCursor ) {
        this._lastCursor = cursor;
        var customCursors = Display.customCursors[ cursor ];
        if ( customCursors ) {
          // go backwards, so the most desired cursor sticks
          for ( var i = customCursors.length - 1; i >= 0; i-- ) {
            this._domElement.style.cursor = customCursors[ i ];
            if ( this._assumeFullWindow !== false ) {
              document.body.style.cursor = customCursors[ i ];
            }
          }
        }
        else {
          this._domElement.style.cursor = cursor;
          if ( this._assumeFullWindow !== false ) {
            document.body.style.cursor = cursor;
          }
        }
      }
    },

    applyCSSHacks: function() {
      // to use CSS3 transforms for performance, hide anything outside our bounds by default
      if ( !this.options.allowSceneOverflow ) {
        this._domElement.style.overflow = 'hidden';
      }

      // Prevents selection cursor issues in Safari, see https://github.com/phetsims/scenery/issues/476
      document.onselectstart = function() {
        return false;
      };

      // forward all pointer events
      this._domElement.style.msTouchAction = 'none';

      // don't allow browser to switch between font smoothing methods for text (see https://github.com/phetsims/scenery/issues/431)
      Features.setStyle( this._domElement, Features.fontSmoothing, 'antialiased' );

      if ( this.options.allowCSSHacks ) {
        // some css hacks (inspired from https://github.com/EightMedia/hammer.js/blob/master/hammer.js).
        // modified to only apply the proper prefixed version instead of spamming all of them, and doesn't use jQuery.
        Features.setStyle( this._domElement, Features.userDrag, 'none' );
        Features.setStyle( this._domElement, Features.userSelect, 'none' );
        Features.setStyle( this._domElement, Features.touchAction, 'none' );
        Features.setStyle( this._domElement, Features.touchCallout, 'none' );
        Features.setStyle( this._domElement, Features.tapHighlightColor, 'rgba(0,0,0,0)' );
      }
    },

    // TODO: consider SVG data URLs
    canvasDataURL: function( callback ) {
      this.canvasSnapshot( function( canvas ) {
        callback( canvas.toDataURL() );
      } );
    },

    // renders what it can into a Canvas (so far, Canvas and SVG layers work fine)
    canvasSnapshot: function( callback ) {
      var canvas = document.createElement( 'canvas' );
      canvas.width = this._size.width;
      canvas.height = this._size.height;

      var context = canvas.getContext( '2d' );

      //OHTWO TODO: allow actual background color directly, not having to check the style here!!!
      this._rootNode.renderToCanvas( canvas, context, function() {
        callback( canvas, context.getImageData( 0, 0, canvas.width, canvas.height ) );
      }, this.domElement.style.backgroundColor );
    },

    //TODO: reduce code duplication for handling overlays
    setPointerDisplayVisible: function( visibility ) {
      assert && assert( typeof visibility === 'boolean' );

      var hasOverlay = !!this._pointerOverlay;

      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._pointerOverlay );
          this._pointerOverlay.dispose();
          this._pointerOverlay = null;
        }
        else {
          this._pointerOverlay = new PointerOverlay( this, this._rootNode );
          this.addOverlay( this._pointerOverlay );
        }
      }
    },

    //TODO: reduce code duplication for handling overlays
    setPointerAreaDisplayVisible: function( visibility ) {
      assert && assert( typeof visibility === 'boolean' );

      var hasOverlay = !!this._pointerAreaOverlay;

      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._pointerAreaOverlay );
          this._pointerAreaOverlay.dispose();
          this._pointerAreaOverlay = null;
        }
        else {
          this._pointerAreaOverlay = new PointerAreaOverlay( this, this._rootNode );
          this.addOverlay( this._pointerAreaOverlay );
        }
      }
    },

    //TODO: reduce code duplication for handling overlays
    setCanvasNodeBoundsVisible: function( visibility ) {
      assert && assert( typeof visibility === 'boolean' );

      var hasOverlay = !!this._canvasAreaBoundsOverlay;

      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._canvasAreaBoundsOverlay );
          this._canvasAreaBoundsOverlay.dispose();
          this._canvasAreaBoundsOverlay = null;
        }
        else {
          this._canvasAreaBoundsOverlay = new CanvasNodeBoundsOverlay( this, this._rootNode );
          this.addOverlay( this._canvasAreaBoundsOverlay );
        }
      }
    },

    //TODO: reduce code duplication for handling overlays
    setFittedBlockBoundsVisible: function( visibility ) {
      assert && assert( typeof visibility === 'boolean' );

      var hasOverlay = !!this._fittedBlockBoundsOverlay;

      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._fittedBlockBoundsOverlay );
          this._fittedBlockBoundsOverlay.dispose();
          this._fittedBlockBoundsOverlay = null;
        }
        else {
          this._fittedBlockBoundsOverlay = new FittedBlockBoundsOverlay( this, this._rootNode );
          this.addOverlay( this._fittedBlockBoundsOverlay );
        }
      }
    },

    resizeOnWindowResize: function() {
      var self = this;

      var resizer = function() {
        self.setWidthHeight( window.innerWidth, window.innerHeight );
      };
      window.addEventListener( 'resize', resizer );
      resizer();
    },

    // Updates on every request animation frame. If stepCallback is passed in, it is called before updateDisplay() with
    // stepCallback( timeElapsedInSeconds )
    updateOnRequestAnimationFrame: function( stepCallback ) {
      // keep track of how much time elapsed over the last frame
      var lastTime = 0;
      var timeElapsedInSeconds = 0;

      var self = this;
      (function step() {
        self._requestAnimationFrameID = window.requestAnimationFrame( step, self._domElement );

        // calculate how much time has elapsed since we rendered the last frame
        var timeNow = new Date().getTime();
        if ( lastTime !== 0 ) {
          timeElapsedInSeconds = ( timeNow - lastTime ) / 1000.0;
        }
        lastTime = timeNow;

        stepCallback && stepCallback( timeElapsedInSeconds );
        self.updateDisplay();
      })();
    },

    cancelUpdateOnRequestAnimationFrame: function() {
      window.cancelAnimationFrame( this._requestAnimationFrameID );
    },

    /**
     * Initializes event handling, and connects the browser's input event handlers to notify this Display of events.
     * @public
     *
     * NOTE: This can be reversed with detachEvents().
     */
    initializeEvents: function() {
      assert && assert( !this._input, 'Events cannot be attached twice to a display (for now)' );

      // TODO: refactor here
      var input = new Input( this, !this._listenToOnlyElement, this._batchDOMEvents, this._assumeFullWindow, this._passiveEvents );
      this._input = input;

      input.connectListeners();
    },

    /**
     * Detach already-attached input event handling (from initializeEvents()).
     * @public
     */
    detachEvents: function() {
      assert && assert( this._input, 'detachEvents() should be called only when events are attached' );

      this._input.disconnectListeners();
      this._input = null;
    },


    /**
     * Adds an input listener.
     * @public
     *
     * @param {Object} listener
     * @returns {Display} - For chaining
     */
    addInputListener: function( listener ) {
      assert && assert( !_.includes( this._inputListeners, listener ), 'Input listener already registered on this Node' );

      // don't allow listeners to be added multiple times
      if ( !_.includes( this._inputListeners, listener ) ) {
        this._inputListeners.push( listener );
      }
      return this;
    },

    /**
     * Removes an input listener that was previously added with addInputListener.
     * @public
     *
     * @param {Object} listener
     * @returns {Display} - For chaining
     */
    removeInputListener: function( listener ) {
      // ensure the listener is in our list
      assert && assert( _.includes( this._inputListeners, listener ) );

      this._inputListeners.splice( _.indexOf( this._inputListeners, listener ), 1 );

      return this;
    },

    /**
     * Returns whether this input listener is currently listening to this node.
     * @public
     *
     * More efficient than checking node.inputListeners, as that includes a defensive copy.
     *
     * @param {Object} listener
     * @returns {boolean}
     */
    hasInputListener: function( listener ) {
      for ( var i = 0; i < this._inputListeners.length; i++ ) {
        if ( this._inputListeners[ i ] === listener ) {
          return true;
        }
      }
      return false;
    },

    /**
     * Returns a copy of all of our input listeners.
     * @public
     *
     * @returns {Array.<Object>}
     */
    getInputListeners: function() {
      return this._inputListeners.slice( 0 ); // defensive copy
    },
    get inputListeners() { return this.getInputListeners(); },

    /**
     * Dispose function for Display.
     *
     * TODO: this dispose function is not complete.
     * @public
     */
    dispose: function() {
      if ( this._input ) {
        this.detachEvents();
      }
      this._rootNode.removeRootedDisplay( this );
    },

    ensureNotPainting: function() {
      assert && assert( !this._isPainting,
        'This should not be run in the call tree of updateDisplay(). If you see this, it is likely that either the ' +
        'last updateDisplay() had a thrown error and it is trying to be run again (in which case, investigate that ' +
        'error), OR code was run/triggered from inside an updateDisplay() that has the potential to cause an infinite ' +
        'loop, e.g. CanvasNode paintCanvas() call manipulating another Node, or a bounds listener that Scenery missed.' );
    },

    /**
     * Triggers a loss of context for all WebGL blocks.
     * @public
     *
     * NOTE: Should generally only be used for debugging.
     */
    loseWebGLContexts: function() {
      (function loseBackbone( backbone ) {
        if ( backbone.blocks ) {
          backbone.blocks.forEach( function( block ) {
            if ( block.gl ) {
              Util.loseContext( block.gl );
            }

            //TODO: pattern for this iteration
            for ( var drawable = block.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
              loseBackbone( drawable );
              if ( drawable === block.lastDrawable ) { break; }
            }
          } );
        }
      })( this._rootBackbone );
    },

    /**
     * Sends a number of random mouse events through the input system
     *
     * @param {number} averageEventQuantity - The average number of mouse events
     */
    fuzzMouseEvents: function( averageEventQuantity ) {
      var chance;

      assert && assert( averageEventQuantity > 0, 'averageEventQuantity must be positive: ' + averageEventQuantity );

      // run a variable number of events, with a certain chance of bailing out (so no events are possible)
      // models a geometric distribution of events
      // See https://github.com/phetsims/joist/issues/343 for notes on the distribution.
      while ( ( chance = Math.random() ) < 1 - 1 / ( averageEventQuantity + 1 ) ) {
        var domEvent;
        if ( chance < ( this._fuzzMouseLastMoved ? 0.7 : 0.4 ) ) {
          // toggle up/down
          domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec

          // technically deprecated, but DOM4 event constructors not out yet. people on #whatwg said to use it
          domEvent.initMouseEvent( this._fuzzMouseIsDown ? 'mouseup' : 'mousedown', true, true, window, 1, // click count
            this._fuzzMousePosition.x, this._fuzzMousePosition.y, this._fuzzMousePosition.x, this._fuzzMousePosition.y,
            false, false, false, false,
            0, // button
            null );

          this._input.validatePointers();

          if ( this._fuzzMouseIsDown ) {
            this._input.mouseUp( this._fuzzMousePosition, domEvent );
            this._fuzzMouseIsDown = false;
          }
          else {
            this._input.mouseDown( null, this._fuzzMousePosition, domEvent );
            this._fuzzMouseIsDown = true;
          }

          this._fuzzMouseLastMoved = false;
        }
        else {
          // change the mouse position
          this._fuzzMousePosition = new Vector2(
            Math.floor( Math.random() * this.width ),
            Math.floor( Math.random() * this.height )
          );

          // our move event
          domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec

          // technically deprecated, but DOM4 event constructors not out yet. people on #whatwg said to use it
          domEvent.initMouseEvent( 'mousemove', true, true, window, 0, // click count
            this._fuzzMousePosition.x, this._fuzzMousePosition.y, this._fuzzMousePosition.x, this._fuzzMousePosition.y,
            false, false, false, false,
            0, // button
            null );

          this._input.validatePointers();
          this._input.mouseMove( this._fuzzMousePosition, domEvent );

          this._fuzzMouseLastMoved = true;
        }
      }
    },

    /**
     * Makes this Display available for inspection.
     * @public
     */
    inspect: function() {
      localStorage.scenerySnapshot = JSON.stringify( scenery.serialize( this ) );
    },

    /**
     * Returns an HTML fragment {string} that includes a large amount of debugging information, including a view of the
     * instance tree and drawable tree.
     */
    getDebugHTML: function() {
      function str( ob ) {
        return ob ? ob.toString() : ob + '';
      }

      var headerStyle = 'font-weight: bold; font-size: 120%; margin-top: 5px;';

      var depth = 0;

      var result = '';

      result += '<div style="' + headerStyle + '">Display Summary</div>';
      result += this._size.toString() + ' frame:' + this._frameId + ' input:' + !!this._input + ' cursor:' + this._lastCursor + '<br>';

      function nodeCount( node ) {
        var count = 1; // for us
        for ( var i = 0; i < node.children.length; i++ ) {
          count += nodeCount( node.children[ i ] );
        }
        return count;
      }

      result += 'Nodes: ' + nodeCount( this._rootNode ) + '<br>';

      function instanceCount( instance ) {
        var count = 1; // for us
        for ( var i = 0; i < instance.children.length; i++ ) {
          count += instanceCount( instance.children[ i ] );
        }
        return count;
      }

      result += this._baseInstance ? ( 'Instances: ' + instanceCount( this._baseInstance ) + '<br>' ) : '';

      function drawableCount( drawable ) {
        var count = 1; // for us
        if ( drawable.blocks ) {
          // we're a backbone
          _.each( drawable.blocks, function( childDrawable ) {
            count += drawableCount( childDrawable );
          } );
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          // we're a block
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            count += drawableCount( childDrawable );
          }
          count += drawableCount( drawable.lastDrawable );
        }
        return count;
      }

      result += this._rootBackbone ? ( 'Drawables: ' + drawableCount( this._rootBackbone ) + '<br>' ) : '';

      var drawableCountMap = {}; // {string} drawable constructor name => {number} count of seen
      // increment the count in our map
      function countRetainedDrawable( drawable ) {
        var name = drawable.constructor.name;
        if ( drawableCountMap[ name ] ) {
          drawableCountMap[ name ]++;
        }
        else {
          drawableCountMap[ name ] = 1;
        }
      }

      function retainedDrawableCount( instance ) {
        var count = 0;
        if ( instance.selfDrawable ) {
          countRetainedDrawable( instance.selfDrawable );
          count++;
        }
        if ( instance.groupDrawable ) {
          countRetainedDrawable( instance.groupDrawable );
          count++;
        }
        if ( instance.sharedCacheDrawable ) {
          countRetainedDrawable( instance.sharedCacheDrawable );
          count++;
        }
        for ( var i = 0; i < instance.children.length; i++ ) {
          count += retainedDrawableCount( instance.children[ i ] );
        }
        return count;
      }

      result += this._baseInstance ? ( 'Retained Drawables: ' + retainedDrawableCount( this._baseInstance ) + '<br>' ) : '';
      for ( var drawableName in drawableCountMap ) {
        result += '&nbsp;&nbsp;&nbsp;&nbsp;' + drawableName + ': ' + drawableCountMap[ drawableName ] + '<br>';
      }

      function blockSummary( block ) {
        // ensure we are a block
        if ( !block.firstDrawable || !block.lastDrawable ) {
          return;
        }

        var hasBackbone = block.domDrawable && block.domDrawable.blocks;

        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';

        div += block.toString();
        if ( !hasBackbone ) {
          div += ' (' + block.drawableCount + ' drawables)';
        }

        div += '</div>';

        depth += 1;
        if ( hasBackbone ) {
          for ( var k = 0; k < block.domDrawable.blocks.length; k++ ) {
            div += blockSummary( block.domDrawable.blocks[ k ] );
          }
        }
        depth -= 1;

        return div;
      }

      if ( this._rootBackbone ) {
        result += '<div style="' + headerStyle + '">Block Summary</div>';
        for ( var i = 0; i < this._rootBackbone.blocks.length; i++ ) {
          result += blockSummary( this._rootBackbone.blocks[ i ] );
        }
      }

      function instanceSummary( instance ) {
        var iSummary = '';

        function addQualifier( text ) {
          iSummary += ' <span style="color: #008">' + text + '</span>';
        }

        var node = instance.node;

        iSummary += instance.id;
        iSummary += ' ' + ( node.constructor.name ? node.constructor.name : '?' );
        iSummary += ' <span style="font-weight: ' + ( node.isPainted() ? 'bold' : 'normal' ) + '">' + node.id + '</span>';
        iSummary += node.getDebugHTMLExtras();

        if ( !node.visible ) {
          addQualifier( 'invis' );
        }
        if ( !instance.visible ) {
          addQualifier( 'I-invis' );
        }
        if ( !instance.relativeVisible ) {
          addQualifier( 'I-rel-invis' );
        }
        if ( !instance.selfVisible ) {
          addQualifier( 'I-self-invis' );
        }
        if ( !instance.fittability.ancestorsFittable ) {
          addQualifier( 'nofit-ancestor' );
        }
        if ( !instance.fittability.selfFittable ) {
          addQualifier( 'nofit-self' );
        }
        if ( node.pickable === true ) {
          addQualifier( 'pickable' );
        }
        if ( node.pickable === false ) {
          addQualifier( 'unpickable' );
        }
        if ( instance.trail.isPickable() ) {
          addQualifier( '<span style="color: #808">hits</span>' );
        }
        if ( node.clipArea ) {
          addQualifier( 'clipArea' );
        }
        if ( node.mouseArea ) {
          addQualifier( 'mouseArea' );
        }
        if ( node.touchArea ) {
          addQualifier( 'touchArea' );
        }
        if ( node.getInputListeners().length ) {
          addQualifier( 'inputListeners' );
        }
        if ( node.getRenderer() ) {
          addQualifier( 'renderer:' + node.getRenderer() );
        }
        if ( node.isLayerSplit() ) {
          addQualifier( 'layerSplit' );
        }
        if ( node.opacity < 1 ) {
          addQualifier( 'opacity:' + node.opacity );
        }

        if ( node._boundsEventCount > 0 ) {
          addQualifier( '<span style="color: #800">boundsListen:' + node._boundsEventCount + ':' + node._boundsEventSelfCount + '</span>' );
        }

        var transformType = '';
        switch( node.transform.getMatrix().type ) {
          case Matrix3.Types.IDENTITY:
            transformType = '';
            break;
          case Matrix3.Types.TRANSLATION_2D:
            transformType = 'translated';
            break;
          case Matrix3.Types.SCALING:
            transformType = 'scale';
            break;
          case Matrix3.Types.AFFINE:
            transformType = 'affine';
            break;
          case Matrix3.Types.OTHER:
            transformType = 'other';
            break;
          default:
            throw new Error( 'invalid matrix type: ' + node.transform.getMatrix().type );
        }
        if ( transformType ) {
          iSummary += ' <span style="color: #88f" title="' + node.transform.getMatrix().toString().replace( '\n', '&#10;' ) + '">' + transformType + '</span>';
        }

        iSummary += ' <span style="color: #888">[Trail ' + instance.trail.indices.join( '.' ) + ']</span>';
        iSummary += ' <span style="color: #c88">' + str( instance.state ) + '</span>';
        iSummary += ' <span style="color: #8c8">' + node._rendererSummary.bitmask.toString( 16 ) + ( node._rendererBitmask !== Renderer.bitmaskNodeDefault ? ' (' + node._rendererBitmask.toString( 16 ) + ')' : '' ) + '</span>';

        return iSummary;
      }

      function drawableSummary( drawable ) {
        var drawableString = drawable.toString();
        if ( drawable.visible ) {
          drawableString = '<strong>' + drawableString + '</strong>';
        }
        if ( drawable.dirty ) {
          drawableString += ( drawable.dirty ? ' <span style="color: #c00;">[x]</span>' : '' );
        }
        if ( !drawable.fittable ) {
          drawableString += ( drawable.dirty ? ' <span style="color: #0c0;">[no-fit]</span>' : '' );
        }
        return drawableString;
      }

      function printInstanceSubtree( instance ) {
        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';

        function addDrawable( name, drawable ) {
          div += ' <span style="color: #888">' + name + ':' + drawableSummary( drawable ) + '</span>';
        }

        div += instanceSummary( instance );

        instance.selfDrawable && addDrawable( 'self', instance.selfDrawable );
        instance.groupDrawable && addDrawable( 'group', instance.groupDrawable );
        instance.sharedCacheDrawable && addDrawable( 'sharedCache', instance.sharedCacheDrawable );

        div += '</div>';
        result += div;

        depth += 1;
        _.each( instance.children, function( childInstance ) {
          printInstanceSubtree( childInstance );
        } );
        depth -= 1;
      }

      if ( this._baseInstance ) {
        result += '<div style="' + headerStyle + '">Root Instance Tree</div>';
        printInstanceSubtree( this._baseInstance );
      }

      _.each( this._sharedCanvasInstances, function( instance ) {
        result += '<div style="' + headerStyle + '">Shared Canvas Instance Tree</div>';
        printInstanceSubtree( instance );
      } );

      function printDrawableSubtree( drawable ) {
        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';

        div += drawableSummary( drawable );
        if ( drawable.instance ) {
          div += ' <span style="color: #0a0;">(' + drawable.instance.trail.toPathString() + ')</span>';
          div += '&nbsp;&nbsp;&nbsp;' + instanceSummary( drawable.instance );
        }
        else if ( drawable.backboneInstance ) {
          div += ' <span style="color: #a00;">(' + drawable.backboneInstance.trail.toPathString() + ')</span>';
          div += '&nbsp;&nbsp;&nbsp;' + instanceSummary( drawable.backboneInstance );
        }

        div += '</div>';
        result += div;

        if ( drawable.blocks ) {
          // we're a backbone
          depth += 1;
          _.each( drawable.blocks, function( childDrawable ) {
            printDrawableSubtree( childDrawable );
          } );
          depth -= 1;
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          // we're a block
          depth += 1;
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            printDrawableSubtree( childDrawable );
          }
          printDrawableSubtree( drawable.lastDrawable ); // wasn't hit in our simplified (and safer) loop
          depth -= 1;
        }
      }

      if ( this._rootBackbone ) {
        result += '<div style="font-weight: bold;">Root Drawable Tree</div>';
        printDrawableSubtree( this._rootBackbone );
      }

      //OHTWO TODO: add shared cache drawable trees

      return result;
    },

    popupDebug: function() {
      var htmlContent = '<!DOCTYPE html>' +
                        '<html lang="en">' +
                        '<head><title>Scenery Debug Snapshot</title></head>' +
                        '<body style="font-size: 12px;">' + this.getDebugHTML() + '</body>' +
                        '</html>';
      window.open( 'data:text/html;charset=utf-8,' + encodeURIComponent( htmlContent ) );
    },

    /**
     * Will attempt to call callback( {string} dataURI ) with the rasterization of the entire Display's DOM structure,
     * used for internal testing. Will call-back null if there was an error
     *
     * Only tested on recent Chrome and Firefox, not recommended for general use. Guaranteed not to work for IE <= 10.
     *
     * See https://github.com/phetsims/scenery/issues/394 for some details.
     */
    foreignObjectRasterization: function( callback ) {
      // Scan our drawable tree for Canvases. We'll rasterize them here (to data URLs) so we can replace them later in
      // the HTML tree (with images) before putting that in the foreignObject. That way, we can actually display
      // things rendered in Canvas in our rasterization.
      var canvasUrlMap = {};

      function scanForCanvases( drawable ) {
        if ( drawable.blocks ) {
          // we're a backbone
          _.each( drawable.blocks, function( childDrawable ) {
            scanForCanvases( childDrawable );
          } );
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          // we're a block
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            scanForCanvases( childDrawable );
          }
          scanForCanvases( drawable.lastDrawable ); // wasn't hit in our simplified (and safer) loop

          if ( drawable.canvas && drawable.canvas instanceof window.HTMLCanvasElement ) {
            canvasUrlMap[ drawable.canvasId ] = drawable.canvas.toDataURL();
          }
        }
      }

      scanForCanvases( this._rootBackbone );

      // Create a new document, so that we can (1) serialize it to XHTML, and (2) manipulate it independently.
      // Inspired by http://cburgmer.github.io/rasterizeHTML.js/
      var doc = document.implementation.createHTMLDocument( '' );
      doc.documentElement.innerHTML = this.domElement.outerHTML;
      doc.documentElement.setAttribute( 'xmlns', doc.documentElement.namespaceURI );

      // Replace each <canvas> with an <img> that has src=canvas.toDataURL() and the same style
      var displayCanvases = doc.documentElement.getElementsByTagName( 'canvas' );
      displayCanvases = Array.prototype.slice.call( displayCanvases ); // don't use a live HTMLCollection copy!
      for ( var i = 0; i < displayCanvases.length; i++ ) {
        var displayCanvas = displayCanvases[ i ];

        var cssText = displayCanvas.style.cssText;

        var displayImg = doc.createElement( 'img' );
        var src = canvasUrlMap[ displayCanvas.id ];
        assert && assert( src, 'Must have missed a toDataURL() on a Canvas' );

        displayImg.src = src;
        displayImg.setAttribute( 'style', cssText );

        displayCanvas.parentNode.replaceChild( displayImg, displayCanvas );
      }

      var displayWidth = this.width;
      var displayHeight = this.height;
      var completeFunction = function() {
        Display.elementToSVGDataURL( doc.documentElement, displayWidth, displayHeight, callback );
      };

      // Convert each <image>'s xlink:href so that it's a data URL with the relevant data, e.g.
      // <image ... xlink:href="http://localhost:8080/scenery-phet/images/battery-D-cell.png?bust=1476308407988"/>
      // gets replaced with a data URL.
      // See https://github.com/phetsims/scenery/issues/573
      var replacedImages = 0; // Count how many images get replaced. We'll decrement with each finished image.
      var hasReplacedImages = false; // Whether any images are replaced
      var displaySVGImages = Array.prototype.slice.call( doc.documentElement.getElementsByTagName( 'image' ) );
      for ( var j = 0; j < displaySVGImages.length; j++ ) {
        var displaySVGImage = displaySVGImages[ j ];
        var currentHref = displaySVGImage.getAttribute( 'xlink:href' );
        if ( currentHref.slice( 0, 5 ) !== 'data:' ) {
          replacedImages++;
          hasReplacedImages = true;

          (function() {
            // Closure variables need to be stored for each individual SVG image.
            var refImage = new window.Image();
            var svgImage = displaySVGImage;

            refImage.onload = function() {
              // Get a Canvas
              var refCanvas = document.createElement( 'canvas' );
              refCanvas.width = refImage.width;
              refCanvas.height = refImage.height;
              var refContext = refCanvas.getContext( '2d' );

              // Draw the (now loaded) image into the Canvas
              refContext.drawImage( refImage, 0, 0 );

              // Replace the <image>'s href with the Canvas' data.
              svgImage.setAttribute( 'xlink:href', refCanvas.toDataURL() );

              // If it's the last replaced image, go to the next step
              if ( --replacedImages === 0 ) {
                completeFunction();
              }

              assert && assert( replacedImages >= 0 );
            };
            refImage.onerror = function() {
              // NOTE: not much we can do, leave this element alone.

              // If it's the last replaced image, go to the next step
              if ( --replacedImages === 0 ) {
                completeFunction();
              }

              assert && assert( replacedImages >= 0 );
            };

            // Kick off loading of the image.
            refImage.src = currentHref;
          })();
        }
      }

      // If no images are replaced, we need to call our callback through this route.
      if ( !hasReplacedImages ) {
        completeFunction();
      }
    },

    popupRasterization: function() {
      this.foreignObjectRasterization( window.open );
    }
  }, Events.prototype ), {
    /**
     * Takes a given DOM element, and asynchronously renders it to a string that is a data URL representing an SVG
     * file.
     * @public
     *
     * @param {HTMLElement} domElement
     * @param {number} width - The width of the output SVG
     * @param {number} height - The height of the output SVG
     * @param {function} callback - Called as callback( url: {string} ), where the URL will be the encoded SVG file.
     */
    elementToSVGDataURL: function( domElement, width, height, callback ) {
      var canvas = document.createElement( 'canvas' );
      var context = canvas.getContext( '2d' );
      canvas.width = width;
      canvas.height = height;

      // Serialize it to XHTML that can be used in foreignObject (HTML can't be)
      var xhtml = new window.XMLSerializer().serializeToString( domElement );

      // Create an SVG container with a foreignObject.
      var data = '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' +
                 '<foreignObject width="100%" height="100%">' +
                 '<div xmlns="http://www.w3.org/1999/xhtml">' +
                 xhtml +
                 '</div>' +
                 '</foreignObject>' +
                 '</svg>';

      // Load an <img> with the SVG data URL, and when loaded draw it into our Canvas
      var img = new window.Image();
      img.onload = function() {
        context.drawImage( img, 0, 0 );
        callback( canvas.toDataURL() ); // Endpoint here
      };
      img.onerror = function() {
        callback( null );
      };

      // We can't btoa() arbitrary unicode, so we need another solution,
      // see https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22
      var uint8array = new window.TextEncoderLite( 'utf-8' ).encode( data );
      var base64 = window.fromByteArray( uint8array );

      // turn it to base64 and wrap it in the data URL format
      img.src = 'data:image/svg+xml;base64,' + base64;
    },

    /**
     * Set the focus for Display.  Can set to null to clear focus from Display.
     * @public
     *
     * @param  {Focus|null} value
     */
    set focus( value ) {
      this.focusProperty.value = value;
    },

    /**
     * Get the focus for Display. Null if nothing under a Display has focus.
     * @public
     *
     * @return {Focus|null}
     */
    get focus() {
      return this.focusProperty.value;
    },

    /**
     * Get the currently focused Node, the leaf-most Node of the focusProperty value's Trail. Null if no
     * Node has focus.
     *
     * @public
     * @return {Node|null}
     */
    getFocusedNode: function() {
      var focusedNode = null;
      var focus = this.focusProperty.get();
      if ( focus ) {
        focusedNode = focus.trail.lastNode();
      }
      return focusedNode;
    },
    get focusedNode() { return this.getFocusedNode(); }
  } );

  Display.customCursors = {
    'scenery-grab-pointer': [ 'grab', '-moz-grab', '-webkit-grab', 'pointer' ],
    'scenery-grabbing-pointer': [ 'grabbing', '-moz-grabbing', '-webkit-grabbing', 'pointer' ]
  };

  // @public (a11y) {Focus|null} - Display has an axon Property to indicate which component is focused (or null
  // if no scenery node has focus).  By pasing the tandem and phetioValueType, PhET-iO is able to interoperate (save,
  // restore, control, observe what is currently focused.
  Display.focusProperty = new Property( null, {

    // Make this a static tandem so that it can be added to instance proxies correctly (batched and then flushed when the
    // listener is added).
    tandem: Tandem.createStaticTandem( 'display' ).createTandem( 'focusProperty' ),
    phetioValueType: TFocus
  } );

  /**
   * Returns true when NO nodes in the subtree are disposed.
   * @private
   *
   * @param {Node} node
   * @returns {boolean}
   */
  Display.assertSubtreeDisposed = function( node ) {
    assert && assert( !node.isDisposed(), 'Disposed nodes should not be included in a scene graph to display.' );

    if ( assert ) {
      for ( var i = 0; i < node.children.length; i++ ) {
        Display.assertSubtreeDisposed( node.children[ i ] );
      }
    }
  };

  // @public {Emitter} - Fires when we detect an input event that would be considered a "user gesture" by Chrome, so
  // that we can trigger browser actions that are only allowed as a result.
  // See https://github.com/phetsims/scenery/issues/802 and https://github.com/phetsims/vibe/issues/32 for more
  // information.
  Display.userGestureEmitter = new Emitter();

  return Display;
} );

// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/TPanel',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','SUN/sun','ifphetio!PHET_IO/phetioInherit','SCENERY/nodes/TNode'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var sun = require( 'SUN/sun' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  /**
   * Wrapper type for phet/sun's Panel class.
   * @param panel
   * @param phetioID
   * @constructor
   */
  function TPanel( panel, phetioID ) {
    TNode.call( this, panel, phetioID );
    assertInstanceOf( panel, phet.sun.Panel );
  }

  phetioInherit( TNode, 'TPanel', TPanel, {}, {
    documentation: 'A container for other TNodes'
  } );

  sun.register( 'TPanel', TPanel );

  return TPanel;
} );


// Copyright 2013-2015, University of Colorado Boulder

/**
 * Control panel around a content node.
 * Dynamically adjusts its size to fit its contents.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 * @author John Blanco (PhET Interactive Simulations)
 */
define( 'SUN/Panel',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SUN/sun','TANDEM/Tandem','SUN/TPanel'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );

  // phet-io modules
  var TPanel = require( 'SUN/TPanel' );

  // valid values for options.align
  var ALIGN_VALUES = [ 'left', 'center', 'right' ];

  var DEFAULT_OPTIONS = {
    fill: 'white',
    stroke: 'black',
    lineWidth: 1, // width of the background border
    xMargin: 5,
    yMargin: 5,
    cornerRadius: 10, // radius of the rounded corners on the background
    resize: true, // dynamically resize when content bounds change
    backgroundPickable: false,

    // {string} horizontal alignment of content in the pane, see ALIGN_VALUES
    // All alignments are equal when the content width >= minWidth
    // Left is the default alignment so when there are multiple panels, their content will left align, see #252
    align: 'left',

    minWidth: 0, // minimum width of the panel
    tandem: Tandem.tandemRequired(),
    phetioType: TPanel
  };
  assert && Object.freeze( DEFAULT_OPTIONS );


  /**
   * @param {Node} content
   * @param {Object} [options]
   * @constructor
   */
  function Panel( content, options ) {

    options = _.extend( {}, DEFAULT_OPTIONS, options );

    assert && assert( _.includes( ALIGN_VALUES, options.align ), 'invalid align: ' + options.align );

    Node.call( this );

    // correct size will be set by updateBackground
    var background = new Rectangle( 0, 0, 1, 1, {
      lineWidth: options.lineWidth,
      pickable: options.backgroundPickable,
      lineDash: options.lineDash,
      cornerRadius: options.cornerRadius
    } );
    this.background = background; // @private
    // update the fill and stroke
    this.setStroke( options.stroke );
    this.setFill( options.fill );

    this.addChild( background );
    this.addChild( content );

    // flag for preventing recursion
    var backgroundUpdateInProgress = false;

    // Adjust the background size to match the content.
    var updateBackground = function() {

      // Check that an update isn't already in progress, lest we end up with some nasty recursion.  For details, please
      // see https://github.com/phetsims/sun/issues/110 and https://github.com/phetsims/molecule-shapes/issues/130.
      if ( backgroundUpdateInProgress ) {
        return;
      }

      // Bail out (and make the background invisible) if our bounds are invalid
      background.visible = content.bounds.isValid();
      if ( !background.visible ) {
        return;
      }

      backgroundUpdateInProgress = true;

      // size the background to fit the content
      var backgroundWidth = Math.max( options.minWidth, content.width + ( 2 * options.xMargin ) );
      background.setRect( 0, 0, backgroundWidth, content.height + ( 2 * options.yMargin ) );

      // Align the content within the background. If the content width >= minWidth, then all alignments are equivalent.
      if ( options.align === 'center' ) {
        content.center = background.center;
      }
      else if ( options.align === 'left' ) {

        // Use backgroundWidth instead of background.width because they differ by the background lineWidth
        content.left = background.centerX - backgroundWidth / 2 + options.xMargin;
        content.centerY = background.centerY;
      }
      else { /* right */

        // Use backgroundWidth instead of background.width because they differ by the background lineWidth
        content.right = background.centerX + backgroundWidth / 2 - options.xMargin;
        content.centerY = background.centerY;
      }

      // clear the recursion-prevention flag
      backgroundUpdateInProgress = false;
    };

    if ( options.resize ) {
      content.on( 'bounds', updateBackground );
    }
    updateBackground();

    this.disposePanel = function() {
      if ( options.resize ) {
        content.off( 'bounds', updateBackground );
      }
    };

    // Apply options after the layout is done, so that options that use the bounds will work properly.
    this.mutate( options );
  }

  sun.register( 'Panel', Panel );

  inherit( Node, Panel, {

    // @public
    dispose: function() {
      this.disposePanel();
      Node.prototype.dispose.call( this );
    },

    // @public - Change the background rectangle's stroke (can be overridden)
    setStroke: function( stroke ) {
      this.background.stroke = stroke;
    },

    // @public - Get the background rectangle's stroke (can be overridden)
    getStroke: function() {
      return this.background.stroke;
    },

    // @public - Getter/setter for background stroke
    set stroke( value ) { this.setStroke( value ); },
    get stroke() { return this.getStroke(); },

    // @public - Change the background rectangle's fill (can be overridden)
    setFill: function( fill ) {
      this.background.fill = fill;
    },

    // @public - Get the background rectangle's fill (can be overridden)
    getFill: function() {
      return this.background.fill;
    },

    // @public - Getter/setter for background fill
    set fill( value ) { this.setFill( value ); },
    get fill() { return this.getFill(); }
  }, {

    // @static @public (read-only)
    DEFAULT_OPTIONS: DEFAULT_OPTIONS
  } );

  return Panel;
} );
// Copyright 2015, University of Colorado Boulder

/**
 * Creates the namespace for this repository.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'JOIST/joist',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  // modules
  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'joist' );
} );
// Copyright 2017, University of Colorado Boulder

/**
 * Single location of all accessibility strings used in joist.  These
 * strings are not meant to be translatable yet.  Rosetta needs some work to
 * provide translators with context for these strings, and we want to receive
 * some community feedback before these strings are submitted for translation.
 *
 * @author Jesse Greenberg
 */
define( 'JOIST/JoistA11yStrings',['require','JOIST/joist'],function( require ) {
  'use strict';

  var joist = require( 'JOIST/joist' );

  var JoistA11yStrings = {

    // dialogs
    hotKeysAndHelpString: 'Keyboard Shortcuts',
    closeString: 'Close',

    // sections in a simulation
    sceneSummaryString: 'Scene Summary',
    playAreaString: 'Play Area',
    controlPanelString: 'Control Panel',

    // navigation bar
    simResourcesAndToolsString: 'Sim Resources and Tools',

    // PhET menu
    phetString: 'PhET Menu'
  };

  if ( phet.chipper.queryParameters.stringTest === 'xss' ) {
    for ( var key in JoistA11yStrings ) {
      JoistA11yStrings[ key ] += '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==" onload="window.location.href=atob(\'aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1kUXc0dzlXZ1hjUQ==\')" />';
    }
  }

  // verify that object is immutable, without the runtime penalty in production code
  if ( assert ) { Object.freeze( JoistA11yStrings ); }

  joist.register( 'JoistA11yStrings', JoistA11yStrings );

  return JoistA11yStrings;
} );
// Copyright 2017, University of Colorado Boulder

/**
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */
define( 'SCENERY_PHET/accessibility/TAriaHerald',['require','SCENERY_PHET/sceneryPhet','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';

  // modules
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  // var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  // var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );

  /**
   * Wrapper type for phet/scenery-phet's AriaHerald controller
   * @param ariaHerald
   * @param phetioID
   * @constructor
   */
  function TAriaHerald( ariaHerald, phetioID ) {
    TObject.call( this, ariaHerald, phetioID );
    assertInstanceOf( ariaHerald, Object );
  }

  phetioInherit( TObject, 'TAriaHerald', TAriaHerald, {

    announcePolite: {
      returnType: TVoid,
      parameterTypes: [ TString, TBoolean ],
      implementation: function( textContent, withClear ) {
        return this.instance.announcePolite( textContent, withClear );
      },
      documentation: 'Set the polite aria-live attribute in the sim frame\'s PDOM.'
    },

    setEnabled: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( enabled ) {
        this.instance.setEnabled (enabled) ;
      },
      documentation: 'Set whether the ariaHerald will be enabled.'
    }

  }, {
    documentation: 'Interfacing type to handle Aria alerts via the aria-live attribute.'
  } );

  sceneryPhet.register( 'TAriaHerald', TAriaHerald );

  return TAriaHerald;
} );


// Copyright 2017, University of Colorado Boulder

/**
 * A static object used to send aria-live updates to the screen reader.  The herald simply references 'aria-live'
 * elements in the HTML document and updates their content. ARIA attributes specify the behavior of timing for the
 * alerts. The following alert elements must be in the HTML document, see
 * https://github.com/phetsims/chipper/issues/472.
 * These elements were tested and determined to be the most widely supported and most useful for PhET sims.
 *
 *    <p id="assertive" aria-live="assertive" aria-atomic="true"></p>
 *    <p id="polite" aria-live="polite" aria-atomic="true"></p>
 *    <p id="assertive-alert" aria-live="assertive" role="alert" aria-atomic="true"></p>
 *    <p id="polite-status" aria-live="polite" role="status" aria-atomic="true"></p>
 *
 * @author Jesse Greenberg
 * @author John Blanco
 */

define( 'SCENERY_PHET/accessibility/AriaHerald',['require','AXON/Property','PHET_CORE/Timer','SCENERY_PHET/accessibility/TAriaHerald','SCENERY_PHET/sceneryPhet','TANDEM/Tandem','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TString'],function( require ) {
  'use strict';

  // modules
  var Property = require( 'AXON/Property' );
  var Timer = require( 'PHET_CORE/Timer' );
  var TAriaHerald = require( 'SCENERY_PHET/accessibility/TAriaHerald' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  // phet-io modules
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );

  // phet-io support
  var tandem = Tandem.createStaticTandem( 'ariaHerald' );

  // ids for each of the aria-live elements
  var ASSERTIVE_ELEMENT_ID = 'assertive';
  var POLITE_ELEMENT_ID = 'polite';
  var ASSERTIVE_ALERT_ELEMENT_ID = 'assertive-alert';
  var POLITE_STATUS_ELEMENT_ID = 'polite-status';
  var ALERT_CONTAINER_ELEMENT_ID = 'aria-live-elements';

  // by default, clear old text so sequential updates with identical text are announced, see updateLiveElement()
  var DEFAULT_WITH_CLEAR = true;

  // DOM elements which will receive the updated content
  var assertiveElement = document.getElementById( ASSERTIVE_ELEMENT_ID );
  var politeElement = document.getElementById( POLITE_ELEMENT_ID );
  var assertiveAlertElement = document.getElementById( ASSERTIVE_ALERT_ELEMENT_ID );
  var politeStatusElement = document.getElementById( POLITE_STATUS_ELEMENT_ID );
  var alertContainer = document.getElementById( ALERT_CONTAINER_ELEMENT_ID );

  // verify that all elements are present
  assert && assert( assertiveElement, 'No assertive element found in document' );
  assert && assert( politeElement, 'No polite element found in document' );
  assert && assert( assertiveAlertElement, 'No assertive alert element found in document' );
  assert && assert( politeStatusElement, 'No polite status element found in document' );
  assert && assert( alertContainer, 'No alert container element found in document' );

  // associate a property with each live region - this is done in support of phet-io, otherwise the region values would
  // simply be set directly
  var assertiveElementProperty = new Property( '', {
    tandem: tandem.createTandem( 'assertiveElementProperty' ),
    phetioValueType: TString,
    phetioInstanceDocumentation: 'This Property is read-only, do not attempt to set its value.'
  } );
  assertiveElementProperty.link( function( text ) {
    assertiveElement.textContent = text;
  } );
  var politeElementProperty = new Property( '', {
    tandem: tandem.createTandem( 'politeElementProperty' ),
    phetioValueType: TString,
    phetioInstanceDocumentation: 'This Property is read-only, do not attempt to set its value.'
  } );
  politeElementProperty.link( function( text ) {
    politeElement.textContent = text;
  } );
  var assertiveAlertElementProperty = new Property( '', {
    tandem: tandem.createTandem( 'assertiveAlertElementProperty' ),
    phetioValueType: TString,
    phetioInstanceDocumentation: 'This Property is read-only, do not attempt to set its value.'
  } );
  assertiveAlertElementProperty.link( function( text ) {
    assertiveAlertElement.textContent = text;
  } );
  var politeStatusElementProperty = new Property( '', {
    tandem: tandem.createTandem( 'politeStatusElementProperty' ),
    phetioValueType: TString,
    phetioInstanceDocumentation: 'This Property is read-only, do not attempt to set its value.'
  } );
  politeStatusElementProperty.link( function( text ) {
    politeStatusElement.textContent = text;
  } );

  // Properties that indicate whether or not AriaHerald is enabled and visible. When disabled, no new alerts will
  // come through the screen reader.  When hidden, no alerts will come through, and the content will be hidden from 
  // the screen creader virtual cursor.  Properties are used primarily to support phet-io so that they can be observed.
  var alertsVisibleProperty = new Property( true, {
    tandem: tandem.createTandem( 'alertsVisibleProperty' ),
    phetioValueType: TBoolean
  } );
  var alertsEnabledProperty = new Property( true, {
    tandem: tandem.createTandem( 'alertsEnabledProperty' ),
    phetioValueType: TBoolean
  } );

  // Hide the container when alerts are not visible, hiding all of this content from the virtual cursor and preventing
  // alerts from coming through the assistive technology
  alertsVisibleProperty.link( function( visible ) {
    alertContainer.hidden = !visible;
  } );

  /**
   * Update an element with the 'aria-live' attribute by setting its text content.
   * If using withClear, old element text content will be explicitly removed before new text content is set.  This will
   * allow sequential alerts with identical text content to be announced multiple times in a row, which some screen
   * readers might have prevented.  Text content is only updated if the alerts are enabled.
   *
   * @param {HTMLElement} liveElement - the HTML element that will send the alert to the assistive technology
   * @param {Property.<string>} elementContentProperty - the property containing text content as a string
   * @param {string} textContent - the content to be announced
   * @param {boolean} [withClear] - optional, whether or not to remove the old text content before updating the element
   */
  function updateLiveElement( liveElement, elementContentProperty, textContent, withClear ) {
    withClear = ( withClear === undefined ) ? DEFAULT_WITH_CLEAR : withClear;
    assert && assert( typeof withClear === 'boolean', 'withClear must be of type boolean' );

    // only update content if the group of aria-live elements are enabled
    if ( alertsEnabledProperty.get() ) {

      // clearing the old content allows repeated alerts, but clear the HTMLElement content directly
      // so that we don't see the empty content in the PhET-iO data stream
      if ( withClear ) { liveElement.textContent = ''; }

      // update the content with a small delay - refresh rate of the accessibility tree is often slow, and without a
      // delay, many alerts would be lost forever
      Timer.setTimeout( function() { elementContentProperty.set( textContent ); }, 200 );
    }
  }

  /**
   * Static object that provides the functions for updating the aria-live regions for screen reader announcements.
   */
  var AriaHerald = {

    /**
     * Announce an assertive alert.  This alert should be announced by the AT immediately, regardless of current user
     * interaction status.
     * @public
     *
     * @param {string} textContent - the alert to announce
     * @param {boolean} [withClear] - optional, whether or not to remove the old content from the alert before updating
     */
    announceAssertive: function( textContent, withClear ) {
      updateLiveElement( assertiveElement, assertiveElementProperty, textContent, withClear );
    },

    /**
     * Announce a polite alert.  This alert should be announced when the user has finished their current interaction or
     * after other utterances in the queue are finished.
     * @public
     *
     * @param {string} textContent - the polite content to announce
     * @param {boolean} [withClear] - optional, whether or not to remove the old content from the alert before updating
     */
    announcePolite: function( textContent, withClear ) {
      updateLiveElement( politeElement, politeElementProperty, textContent, withClear );
    },

    /**
     * Announce an assertive alert, with ARIA alert behavior.  This behaves similarly to announceAssertive but AT will
     * add extra functionality with the alert role, such as literally saying 'Alert' or providing extra navigation
     * strategies to find this content.
     * @public
     *
     * @param  {string} textContent - the content ot announce
     * @param {boolean} [withClear] - optional, whether or not to remove the old content from the alert before updating
     */
    announceAssertiveWithAlert: function( textContent, withClear ) {
      updateLiveElement( assertiveAlertElement, assertiveAlertElementProperty, textContent, withClear );
    },

    /**
     * Announce polite with ARIA status behavior.  This behaves similarly to announcePolite but AT will add extra
     * functionality with the status role, such as literally saying 'Status' or providing extra navigation strategies
     * to find this content.
     * @public
     *
     * @param {string} textContent - the content ot announce
     * @param {boolean} [withClear] - optional, whether or not to remove the old content from the alert before updating
     */
    announcePoliteWithStatus: function( textContent, withClear ) {
      updateLiveElement( politeStatusElement, politeStatusElementProperty, textContent, withClear );
    },

    /**
     * Clear all alerts by resetting text content with empty strings. A screen reader will not announce anything, but
     * this will remove all text content from the aria-live elements so that it cannot be found by the virtual cursor.
     * @public
     */
    clearAll: function() {
      assertiveElementProperty.reset();
      politeElementProperty.reset();
      assertiveAlertElementProperty.reset();
      politeStatusElementProperty.reset();
    },

    /**
     * Clear the text content from the assertive alert element. AT will not announce anything but this will prevent
     * content from being found in the document with the virtual cursor.
     * @public
     */
    clearAssertive: function() {
      assertiveElementProperty.reset();
    },

    /**
     * Clear the text content from the polite alert element.  AT will not announce anything but this will prevent
     * text content from being found in the document with the virtual cursor.
     * @public
     */
    clearPolite: function() {
      politeElementProperty.reset();
    },

    /**
     * Clear the text content from the assertive alert element.  AT will not announce anything but this will prevent
     * the text content from being found in the document with the virtual cursor.
     * @public
     */
    clearAssertiveWithAlert: function() {
      assertiveAlertElementProperty.reset();
    },

    /**
     * Clear the text content from the polite status element.  AT will not announce anything but this will prevent
     * the text content from being found in the document with the virtual cursor.
     * @public
     */
    clearPoliteWithStatus: function() {
      politeStatusElementProperty.reset();
    },

    /**
     * Completely hide or show the aria-live elements to screen readers. If hidden, all alerts will be 'invisible'
     * to a screen reader user, and alerts wil also be effectively disabled.
     */
    setVisible: function( visible ) {
      alertsVisibleProperty.set( visible );
    },
    set visible( visible ) { AriaHerald.setVisible( visible ); },

    /**
     * Get whether or not the elements associated with the AriaHerald are visible.  While not visible, all alerts
     * are disabled, screen readers will not announce any updates.
     * @public
     * @returns {boolean}
     */
    getVisible: function() {
      return alertsVisibleProperty.get();
    },
    get visible() { return alertsVisibleProperty.get(); },

    /**
     * Enable or disable all aria-live elements. When not enabled, the user will hear no alerts.
     * @public
     *
     * @param {boolean} enabled
     */
    setEnabled: function( enabled ) {
      this.clearAll();
      alertsEnabledProperty.set( enabled );
    },
    set enabled( enabled ) { AriaHerald.setEnabled( enabled ); },

    /**
     * Get whether or not all alerts are enabled.
     * @returns {boolean}
     */
    getEnabled: function() {
      return alertsEnabledProperty.get();
    },
    get enabled() { return AriaHerald.getEnabled(); },

    /**
     * Call the desired callback, first disabling all alerts. When the callback returns, enable alerts again.
     * @public
     *
     * @param {function} callback
     */
    callWithDisabledAlerts: function( callback ) {
      alertsEnabledProperty.set( false );
      callback();
      alertsEnabledProperty.set( true );
    },

    // static constants
    ASSERTIVE_ELEMENT_ID: ASSERTIVE_ELEMENT_ID,
    POLITE_ELEMENT_ID: POLITE_ELEMENT_ID,
    ASSERTIVE_ALERT_ELEMENT_ID: ASSERTIVE_ALERT_ELEMENT_ID,
    POLITE_STATUS_ELEMENT_ID: POLITE_STATUS_ELEMENT_ID,
    ALERT_CONTAINER_ELEMENT_ID: ALERT_CONTAINER_ELEMENT_ID
  };

  tandem.addInstance( AriaHerald, TAriaHerald );

  sceneryPhet.register( 'AriaHerald', AriaHerald );

  return AriaHerald;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Scans through potential event properties on an object to detect prefixed forms, and returns the first match.
 *
 * E.g. currently:
 * phetCore.detectPrefixEvent( document, 'fullscreenchange' ) === 'webkitfullscreenchange'
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PHET_CORE/detectPrefixEvent',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';

  var phetCore = require( 'PHET_CORE/phetCore' );

  // @returns the best String str where obj['on'+str] !== undefined, or returns undefined if that is not available
  function detectPrefixEvent( obj, name, isEvent ) {
    if ( obj[ 'on' + name ] !== undefined ) { return name; }

    // Chrome planning to not introduce prefixes in the future, hopefully we will be safe
    if ( obj[ 'on' + 'moz' + name ] !== undefined ) { return 'moz' + name; }
    if ( obj[ 'on' + 'Moz' + name ] !== undefined ) { return 'Moz' + name; } // some prefixes seem to have all-caps?
    if ( obj[ 'on' + 'webkit' + name ] !== undefined ) { return 'webkit' + name; }
    if ( obj[ 'on' + 'ms' + name ] !== undefined ) { return 'ms' + name; }
    if ( obj[ 'on' + 'o' + name ] !== undefined ) { return 'o' + name; }
    return undefined;
  }

  phetCore.register( 'detectPrefixEvent', detectPrefixEvent );

  return detectPrefixEvent;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Utilities for full-screen support
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/FullScreen',['require','PHET_CORE/platform','PHET_CORE/detectPrefix','PHET_CORE/detectPrefixEvent','AXON/Property','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var platform = require( 'PHET_CORE/platform' );
  var detectPrefix = require( 'PHET_CORE/detectPrefix' );
  var detectPrefixEvent = require( 'PHET_CORE/detectPrefixEvent' );
  var Property = require( 'AXON/Property' );
  var joist = require( 'JOIST/joist' );

  // get prefixed (and properly capitalized) property names
  var requestFullscreenPropertyName = detectPrefix( document.body, 'requestFullscreen' ) ||
                                      detectPrefix( document.body, 'requestFullScreen' ); // Firefox capitalization
  var exitFullscreenPropertyName = detectPrefix( document, 'exitFullscreen' ) ||
                                   detectPrefix( document, 'cancelFullScreen' ); // Firefox
  var fullscreenElementPropertyName = detectPrefix( document, 'fullscreenElement' ) ||
                                      detectPrefix( document, 'fullScreenElement' ); // Firefox capitalization
  var fullscreenEnabledPropertyName = detectPrefix( document, 'fullscreenEnabled' ) ||
                                      detectPrefix( document, 'fullScreenEnabled' ); // Firefox capitalization
  var fullscreenChangeEvent = detectPrefixEvent( document, 'fullscreenchange' );

  // required capitalization workaround for now
  if ( fullscreenChangeEvent === 'msfullscreenchange' ) {
    fullscreenChangeEvent = 'MSFullscreenChange';
  }

  var FullScreen = {

    // @public (joist-internal)
    isFullScreen: function() {
      return !!document[ fullscreenElementPropertyName ];
    },

    // @public (joist-internal)
    isFullScreenEnabled: function() {
      return document[ fullscreenEnabledPropertyName ] && !platform.safari7;
    },

    // @public (joist-internal)
    enterFullScreen: function( sim ) {
      if ( !platform.ie9 && !platform.ie10 ) {
        sim.display.domElement[ requestFullscreenPropertyName ] && sim.display.domElement[ requestFullscreenPropertyName ]();
      }
      else if ( typeof window.ActiveXObject !== 'undefined' ) { // Older IE.
        var wscript = new window.ActiveXObject( 'WScript.Shell' );
        if ( wscript !== null ) {
          wscript.SendKeys( '{F11}' );
        }
      }
    },

    // @public (joist-internal)
    exitFullScreen: function() {
      document[ exitFullscreenPropertyName ] && document[ exitFullscreenPropertyName ]();
    },

    // @public (joist-internal)
    toggleFullScreen: function( sim ) {
      if ( FullScreen.isFullScreen() ) {
        FullScreen.exitFullScreen();
      }
      else {
        FullScreen.enterFullScreen( sim );
      }
    },

    isFullScreenProperty: new Property( false )
  };

  // update isFullScreenProperty on potential changes
  document.addEventListener( fullscreenChangeEvent, function( evt ) {
    FullScreen.isFullScreenProperty.set( FullScreen.isFullScreen() );
  } );

  joist.register( 'FullScreen', FullScreen );

  return FullScreen;
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'JOIST/TDialog',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','JOIST/joist','ifphetio!PHET_IO/phetioInherit','SUN/TPanel'],function( require ) {
  'use strict';

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var joist = require( 'JOIST/joist' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TPanel = require( 'SUN/TPanel' );

  /**
   * @constructor
   * Wrapper type for phet/joist's Dialog
   * @param {Dialog} dialog - instance of Dialog
   * @param {string} phetioID - identifier string
   */
  function TDialog( dialog, phetioID ) {
    TPanel.call( this, dialog, phetioID );
    assertInstanceOf( dialog, phet.joist.Dialog );
  }

  phetioInherit( TPanel, 'TDialog', TDialog, {}, {
    documentation: 'A dialog panel'
  } );

  joist.register( 'TDialog', TDialog );

  return TDialog;
} );

// Copyright 2014-2017, University of Colorado Boulder

/**
 * General dialog type
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/Dialog',['require','PHET_CORE/inherit','KITE/Shape','SCENERY/nodes/Node','SCENERY/display/Display','SCENERY/nodes/Path','SCENERY/input/Input','SUN/Panel','SUN/buttons/RectangularPushButton','JOIST/joist','JOIST/JoistA11yStrings','SCENERY_PHET/accessibility/AriaHerald','SCENERY/accessibility/AccessibilityUtil','JOIST/FullScreen','JOIST/TDialog','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Display = require( 'SCENERY/display/Display' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Input = require( 'SCENERY/input/Input' );
  var Panel = require( 'SUN/Panel' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var joist = require( 'JOIST/joist' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var AriaHerald = require( 'SCENERY_PHET/accessibility/AriaHerald' );
  var AccessibilityUtil = require( 'SCENERY/accessibility/AccessibilityUtil' );
  var FullScreen = require( 'JOIST/FullScreen' );
  var TDialog = require( 'JOIST/TDialog' );
  var Tandem = require( 'TANDEM/Tandem' );

  // strings
  var closeString = JoistA11yStrings.closeString;

  /**
   * @param {Node} content - The content to display inside the dialog (not including the title)
   * @param {Object} [options]
   * @constructor
   */
  function Dialog( content, options ) {

    var self = this;
    options = _.extend( {

      // Dialog-specific options
      modal: false, // {boolean} modal dialogs prevent interaction with the rest of the sim while open
      title: null, // {Node} title to be displayed at top
      titleAlign: 'center', // horizontal alignment of the title: {string} left, right or center
      titleSpacing: 20, // {number} how far the title is placed above the content
      hasCloseButton: true, // whether to put a close 'X' button is upper-right corner

      // {function} which sets the dialog's position in global coordinates. called as
      // layoutStrategy( dialog, simBounds, screenBounds, scale )
      layoutStrategy: Dialog.DEFAULT_LAYOUT_STRATEGY,

      // pass through to Panel options
      cornerRadius: 10, // {number} radius of the dialog's corners
      resize: true, // {boolean} whether to resize if content's size changes
      fill: 'white', // {string|Color}
      stroke: 'black', // {string|Color}
      backgroundPickable: true,
      xMargin: 20,
      yMargin: 20,
      closeButtonBaseColor: '#d00',
      closeButtonMargin: 5, // {number} how far away should the close button be from the panel border
      tandem: Tandem.tandemRequired(),
      phetioType: TDialog,

      // a11y options
      tagName: 'div',
      ariaRole: 'dialog',
      focusOnCloseNode: null // {Node} receives focus on close, if null focus returns to element that had focus on open
    }, options );

    // @private (read-only)
    this.isModal = options.modal;

    // see https://github.com/phetsims/joist/issues/293
    assert && assert( this.isModal, 'Non-modal dialogs not currently supported' );

    // @private - whether the dialog is showing
    this.isShowing = false;

    var dialogContent = new Node( {
      children: [ content ]
    } );

    if ( options.title ) {

      var titleNode = options.title;
      dialogContent.addChild( titleNode );

      var updateTitlePosition = function() {
        switch( options.titleAlign ) {
          case 'center':
            titleNode.centerX = content.centerX;
            break;
          case 'left':
            titleNode.left = content.left;
            break;
          case 'right':
            titleNode.right = content.right;
            break;
          default:
            throw new Error( 'unknown titleAlign for Dialog: ' + options.titleAlign );
        }
        titleNode.bottom = content.top - options.titleSpacing;
      };

      if ( options.resize ) {
        content.on( 'bounds', updateTitlePosition );
        titleNode.on( 'localBounds', updateTitlePosition );
      }
      updateTitlePosition();
    }

    Panel.call( this, dialogContent, options );

    if ( options.hasCloseButton ) {

      var crossSize = 10;
      var crossNode = new Path( new Shape().moveTo( 0, 0 ).lineTo( crossSize, crossSize ).moveTo( 0, crossSize ).lineTo( crossSize, 0 ), {
        stroke: '#fff',
        lineWidth: 3
      } );

      var closeButton = new RectangularPushButton( {
        content: crossNode,
        baseColor: options.closeButtonBaseColor,
        xMargin: 5,
        yMargin: 5,
        listener: function() {
          self.hide();
        },
        accessibleFire: function() {
          self.focusActiveElement();
        },
        tandem: options.tandem.createTandem( 'closeButton' ),

        // a11y options
        tagName: 'button',
        accessibleLabel: closeString
      } );
      this.addChild( closeButton );

      var updateClosePosition = function() {
        closeButton.right = dialogContent.right + options.xMargin - options.closeButtonMargin;
        closeButton.top = dialogContent.top - options.yMargin + options.closeButtonMargin;

        // place the focus highlight, and make it a bit bigger than the
        closeButton.focusHighlight = Shape.bounds( crossNode.bounds.dilated( 10 ) );
      };

      if ( options.resize ) {
        dialogContent.on( 'bounds', updateClosePosition );
        if ( options.title ) {
          options.title.on( 'bounds', updateClosePosition );
        }
      }
      updateClosePosition();
    }

    var sim = window.phet.joist.sim;

    // @private
    this.updateLayout = function() {
      options.layoutStrategy( self, sim.boundsProperty.value, sim.screenBoundsProperty.value, sim.scaleProperty.value );
    };

    this.updateLayout();

    // @private
    this.sim = sim;

    // a11y - set the order of content for accessibility, title before content
    this.accessibleOrder = [ titleNode, dialogContent ];

    // a11y - set the aria labelledby and describedby relations so that whenever focus enters the dialog, the title
    // and description content are read in full
    content.tagName && content.setAriaDescribesNode( this );
    if ( options.title ) {
      options.title.tagName && options.title.setAriaLabelsNode( this );
    }

    // must be removed on dispose
    this.sim.resizedEmitter.addListener( this.updateLayout );

    // @private (a11y) - the active element when the dialog is shown, tracked so that focus can be restored on close
    this.activeElement = options.focusOnCloseNode || null;

    // a11y - close the dialog when pressing "escape"
    var escapeListener = this.addAccessibleInputListener( {
      keydown: function( event ) {
        if ( event.keyCode === Input.KEY_ESCAPE ) {
          event.preventDefault();
          self.hide();
          self.focusActiveElement();
        }
        else if ( event.keyCode === Input.KEY_TAB && FullScreen.isFullScreen() ) {

          // prevent a particular bug in Windows 7/8.1 Firefox where focus gets trapped in the document
          // when the navigation bar is hidden and there is only one focusable element in the DOM
          // see https://bugzilla.mozilla.org/show_bug.cgi?id=910136
          var activeElement = Display.focusedNode;
          var noNextFocusable = AccessibilityUtil.getNextFocusable() === activeElement;
          var noPreviousFocusable = AccessibilityUtil.getPreviousFocusable() === activeElement;

          if ( noNextFocusable && noPreviousFocusable ) {
            event.preventDefault();
          }
        }
      }
    } );

    // @private - to be called on dispose()
    this.disposeDialog = function() {
      options.tandem.removeInstance( this );
      self.sim.resizedEmitter.removeListener( self.updateLayout );
      self.removeAccessibleInputListener( escapeListener );

      if ( options.hasCloseButton ) {
        closeButton.dispose();
      }

      if ( options.resize ) {
        dialogContent.off( 'bounds', updateClosePosition );
        if ( options.title ) {
          options.title.off( 'bounds', updateClosePosition );
          titleNode.off( 'localBounds', updateTitlePosition );
          content.off( 'bounds', updateTitlePosition );
        }
      }

      // remove dialog content from scene graph, but don't dispose because Panel
      // needs to remove listeners on the content in its dispose()
      dialogContent.removeAllChildren();
      dialogContent.detach();
    };
  }

  joist.register( 'Dialog', Dialog );

  // @private
  Dialog.DEFAULT_LAYOUT_STRATEGY = function( dialog, simBounds, screenBounds, scale ) {

    // The size is set in the Sim.topLayer, but we need to update the location here
    dialog.center = simBounds.center.times( 1.0 / scale );
  };

  return inherit( Panel, Dialog, {

    // @public
    show: function() {
      if ( !this.isShowing ) {
        window.phet.joist.sim.showPopup( this, this.isModal );
        this.isShowing = true;

        // a11y - store the currently active element before hiding all other accessible content
        // so that the active element isn't blurred
        this.activeElement = this.activeElement || Display.focusedNode;
        this.setAccessibleViewsHidden( true );

        // In case the window size has changed since the dialog was hidden, we should try layout out again.
        // See https://github.com/phetsims/joist/issues/362
        this.updateLayout();
      }
    },

    /**
     * Hide the dialog.  If you create a new dialog next time you show(), be sure to dispose this
     * dialog instead.
     * @public
     */
    hide: function() {
      if ( this.isShowing ) {
        window.phet.joist.sim.hidePopup( this, this.isModal );
        this.isShowing = false;

        // a11y - when the dialog is hidden, unhide all ScreenView content from assistive technology
        this.setAccessibleViewsHidden( false );
      }
    },

    /**
     * Make eligible for garbage collection.
     * @public
     */
    dispose: function() {
      this.hide();
      this.disposeDialog();
      Panel.prototype.dispose.call( this );
    },

    /**
     * Hide or show all accessible content related to the sim ScreenViews, navigation bar, and alert content. Instead
     * of using setHidden, we have to remove the subtree of accessible content from each view element in order to
     * prevent an IE11 bug where content remains invisible in the accessibility tree, see
     * https://github.com/phetsims/john-travoltage/issues/247
     *
     * @param {boolean} hidden
     */
    setAccessibleViewsHidden: function( hidden ) {
      for ( var i = 0; i < this.sim.screens.length; i++ ) {
        this.sim.screens[ i ].view.accessibleContentDisplayed = !hidden;
      }
      this.sim.navigationBar.accessibleContentDisplayed = !hidden;

      // workaround for a strange Edge bug where this child of the navigation bar remains hidden,
      // see https://github.com/phetsims/a11y-research/issues/30
      this.sim.navigationBar.keyboardHelpButton.accessibleHidden = hidden;

      // clear the aria-live alert content from the DOM
      AriaHerald.clearAll();
    },

    /**
     * If there is an active element, focus it.  Should almost always be closed after the Dialog has been closed.
     *
     * @public
     * @a11y
     */
    focusActiveElement: function() {
      this.activeElement && this.activeElement.focus();
    }
  } );
} );
// Copyright 2014-2016, University of Colorado Boulder

/**
 * LayoutBox lays out its children in a row, either horizontally or vertically (based on an optional parameter).
 * VBox and HBox are convenience subtypes that specify the orientation.
 * See https://github.com/phetsims/scenery/issues/281
 *
 * @author Sam Reid
 * @author Aaron Davis
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'SCENERY/nodes/LayoutBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Node','DOT/Bounds2'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Bounds2 = require( 'DOT/Bounds2' );

  // constants
  var DEFAULT_SPACING = 0;

  // LayoutBox-specific options that can be passed in the constructor or mutate() call.
  var LAYOUT_BOX_OPTION_KEYS = [
    'orientation', // 'horizontal' or 'vertical', see setOrientation for documentation
    'spacing', // Spacing between each Node, see setSpacing for documentation
    'align', // How to line up items, see setAlign for documentation
    'resize' // Whether we should update the layout when children change, see setResize for documentation
  ];

  // The position (left/top) property name on the primary axis
  var LAYOUT_POSITION = {
    vertical: 'top',
    horizontal: 'left'
  };

  // The size (width/height) property name on the primary axis
  var LAYOUT_DIMENSION = {
    vertical: 'height',
    horizontal: 'width'
  };

  // The alignment (left/right/bottom/top/centerX/centerY) property name on the secondary axis
  var LAYOUT_ALIGNMENT = {
    vertical: {
      left: 'left',
      center: 'centerX',
      right: 'right'
    },
    horizontal: {
      top: 'top',
      center: 'centerY',
      bottom: 'bottom'
    }
  };

  /**
   * @public
   * @constructor
   * @extends Node
   *
   * @param {Object} [options] - LayoutBox-specific options are documented in LAYOUT_BOX_OPTION_KEYS above, and can be
   *                             provided along-side options for Node.
   */
  function LayoutBox( options ) {

    // @private {string} - Either 'vertical' or 'horizontal'. The default chosen by popular vote (with more references).
    //                     see setOrientation() for more documentation.
    this._orientation = 'vertical';

    // @private {number} - Spacing between nodes, see setSpacing() for more documentation.
    this._spacing = DEFAULT_SPACING;

    // @private {string} - Either 'left', 'center' or 'right' for vertical layout, or 'top', 'center' or 'bottom' for
    //                     horizontal layout, which controls positioning of nodes on the other axis.
    //                     See setAlign() for more documentation.
    this._align = 'center';

    // @private {boolean} - Whether we'll layout after children are added/removed/resized, see #116. See setResize()
    //                      for more documentation.
    this._resize = true;

    Node.call( this );

    // @private {function} - If resize:true, will be called whenever a child has its bounds change
    this._boundsListener = this.updateLayoutAutomatically.bind( this );

    // @private {boolean} - Prevents layout() from running while true. Generally will be unlocked and laid out.
    this._updateLayoutLocked = false;

    this.onStatic( 'childInserted', this.onLayoutBoxChildInserted.bind( this ) );
    this.onStatic( 'childRemoved', this.onLayoutBoxChildRemoved.bind( this ) );

    // @private {boolean} - We'll ignore the resize flag while running the initial mutate.
    this._layoutMutating = true;

    this.mutate( options );

    this._layoutMutating = false;
  }

  scenery.register( 'LayoutBox', LayoutBox );

  return inherit( Node, LayoutBox, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: LAYOUT_BOX_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),

    /**
     * Given the current children, determines what bounds should they be aligned inside of.
     * @private
     *
     * Triggers bounds validation for all children
     *
     * @returns {Bounds2}
     */
    getAlignmentBounds: function() {
      // Construct a Bounds2 at the origin, but with the maximum width/height of the children.
      var maxWidth = Number.NEGATIVE_INFINITY;
      var maxHeight = Number.NEGATIVE_INFINITY;

      for ( var i = 0; i < this._children.length; i++ ) {
        var child = this._children[ i ];
        maxWidth = Math.max( maxWidth, child.width );
        maxHeight = Math.max( maxHeight, child.height );
      }
      return new Bounds2( 0, 0, maxWidth, maxHeight );
    },

    /**
     * The actual layout logic, typically run from the constructor OR updateLayout().
     * @private
     */
    layout: function() {
      var children = this._children;

      // The position (left/top) property name on the primary axis
      var layoutPosition = LAYOUT_POSITION[ this._orientation ];

      // The size (width/height) property name on the primary axis
      var layoutDimension = LAYOUT_DIMENSION[ this._orientation ];

      // The alignment (left/right/bottom/top/centerX/centerY) property name on the secondary axis
      var layoutAlignment = LAYOUT_ALIGNMENT[ this._orientation ][ this._align ];

      // The bounds that children will be aligned in (on the secondary axis)
      var alignmentBounds = this.getAlignmentBounds();

      // Starting at 0, position the children
      var position = 0;
      for ( var i = 0; i < children.length; i++ ) {
        var child = children[ i ];
        if ( !child.bounds.isValid() ) {
          continue; // Skip children without bounds
        }
        child[ layoutPosition ] = position;
        child[ layoutAlignment ] = alignmentBounds[ layoutAlignment ];
        position += child[ layoutDimension ] + this._spacing; // Move forward by the node's size, including spacing
      }
    },

    /**
     * Updates the layout of this LayoutBox. Called automatically during initialization, when children change (if
     * resize is true), or when client wants to call this public method for any reason.
     * @public
     */
    updateLayout: function() {
      // Since we trigger bounds changes in our children during layout, we don't want to trigger layout off of those
      // changes, causing a stack overflow.
      if ( !this._updateLayoutLocked ) {
        this._updateLayoutLocked = true;
        this.layout();
        this._updateLayoutLocked = false;
      }
    },

    /**
     * Called when we attempt to automatically layout components.
     * @private
     */
    updateLayoutAutomatically: function() {
      if ( this._layoutMutating || this._resize ) {
        this.updateLayout();
      }
    },

    /**
     * Called when a child is inserted.
     * @private
     *
     * @param {Node} node
     */
    onLayoutBoxChildInserted: function( node ) {
      if ( this._resize ) {
        node.onStatic( 'bounds', this._boundsListener );

        this.updateLayoutAutomatically();
      }
    },

    /**
     * Called when a child is removed.
     * @private
     *
     * @param {Node} node
     */
    onLayoutBoxChildRemoved: function( node ) {
      if ( this._resize ) {
        node.offStatic( 'bounds', this._boundsListener );

        this.updateLayoutAutomatically();
      }
    },

    /**
     * Sets the children of the Node to be equivalent to the passed-in array of Nodes. Does this by removing all current
     * children, and adding in children from the array.
     * @public
     * @override
     *
     * Overridden so we can group together setChildren() and only update layout (a) at the end, and (b) if there
     * are changes.
     *
     * @param {Array.<Node>} children
     * @returns {LayoutBox} - Returns 'this' reference, for chaining
     */
    setChildren: function( children ) {
      // If the layout is already locked, we need to bail and only call Node's setChildren.
      if ( this._updateLayoutLocked ) {
        return Node.prototype.setChildren.call( this, children );
      }

      var oldChildren = this.getChildren(); // defensive copy

      // Lock layout while the children are removed and added
      this._updateLayoutLocked = true;
      Node.prototype.setChildren.call( this, children );
      this._updateLayoutLocked = false;

      // Determine if the children array has changed. We'll gain a performance benefit by not triggering layout when
      // the children haven't changed.
      if ( !_.isEqual( oldChildren, children ) ) {
        this.updateLayoutAutomatically();
      }

      return this;
    },

    /**
     * Sets the orientation of the LayoutBox (the axis along which nodes will be placed, separated by spacing).
     * @public
     *
     * @param {string} orientation - Should be either 'vertical' or 'horizontal'
     * @returns {Node} - For chaining
     */
    setOrientation: function( orientation ) {
      assert && assert( this._orientation === 'vertical' || this._orientation === 'horizontal' );

      if ( this._orientation !== orientation ) {
        this._orientation = orientation;

        this.updateLayout();
      }

      return this;
    },
    set orientation( value ) { this.setOrientation( value ); },

    /**
     * Returns the current orientation.
     * @public
     *
     * See setOrientation for more documentation on the orientation.
     *
     * @returns {string}
     */
    getOrientation: function() {
      return this._orientation;
    },
    get orientation() { return this.getOrientation(); },

    /**
     * Sets spacing between items in the LayoutBox.
     * @public
     *
     * @param {number} spacing
     * @returns {Node} - For chaining
     */
    setSpacing: function( spacing ) {
      assert && assert( typeof spacing === 'number' && isFinite( spacing ),
        'spacing must be a finite number' );

      if ( this._spacing !== spacing ) {
        this._spacing = spacing;

        this.updateLayout();
      }

      return this;
    },
    set spacing( value ) { this.setSpacing( value ); },

    /**
     * Gets the spacing between items in the LayoutBox.
     * @public
     *
     * See setSpacing() for more documentation on spacing.
     *
     * @returns {number}
     */
    getSpacing: function() {
      return this._spacing;
    },
    get spacing() { return this.getSpacing(); },

    /**
     * Sets the alignment of the LayoutBox.
     * @public
     *
     * Determines how children of this LayoutBox will be positioned along the opposite axis from the orientation.
     *
     * For vertical alignments (the default), the following align values are allowed:
     * - left
     * - center
     * - right
     *
     * For horizontal alignments, the following align values are allowed:
     * - top
     * - center
     * - bottom
     *
     * @param {string} align
     * @returns {Node} - For chaining
     */
    setAlign: function( align ) {
      if ( assert ) {
        if ( this._orientation === 'vertical' ) {
          assert( this._align === 'left' || this._align === 'center' || this._align === 'right',
            'Illegal vertical LayoutBox alignment: ' + align );
        }
        else {
          assert( this._align === 'top' || this._align === 'center' || this._align === 'bottom',
            'Illegal horizontal LayoutBox alignment: ' + align );
        }
      }

      if ( this._align !== align ) {
        this._align = align;

        this.updateLayout();
      }

      return this;
    },
    set align( value ) { this.setAlign( value ); },

    /**
     * Returns the current alignment.
     * @public
     *
     * See setAlign for more documentation on the orientation.
     *
     * @returns {string}
     */
    getAlign: function() {
      return this._align;
    },
    get align() { return this.getAlign(); },

    /**
     * Sets whether this LayoutBox will trigger layout when children are added/removed/resized.
     * @public
     *
     * Layout will always still be triggered on orientation/align/spacing changes.
     *
     * @param {boolean} resize
     * @returns {Node} - For chaining
     */
    setResize: function( resize ) {
      assert && assert( typeof resize === 'boolean', 'resize should be a boolean' );

      if ( this._resize !== resize ) {
        this._resize = resize;

        // Add or remove listeners, based on how resize switched
        for ( var i = 0; i < this._children.length; i++ ) {
          var child = this._children[ i ];

          // If we are now resizable, we need to add listeners to every child
          if ( resize ) {
            child.onStatic( 'bounds', this._boundsListener );
          }
          // Otherwise we are now not resizeable, and need to remove the listeners
          else {
            child.offStatic( 'bounds', this._boundsListener );
          }
        }

        // Only trigger an update if we switched TO resizing
        this.updateLayoutAutomatically();
      }

      return this;
    },
    set resize( value ) { this.setResize( value ); },

    /**
     * Returns whether this LayoutBox will trigger layout when children are added/removed/resized.
     * @public
     *
     * See setResize() for more documentation on spacing.
     *
     * @returns {boolean}
     */
    isResize: function() {
      return this._resize;
    },
    get resize() { return this.isResize(); }
  } );
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * HBox is a convenience specialization of LayoutBox with horizontal orientation.
 *
 * @author Sam Reid
 */
define( 'SCENERY/nodes/HBox',['require','PHET_CORE/inherit','SCENERY/nodes/LayoutBox','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var LayoutBox = require( 'SCENERY/nodes/LayoutBox' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @public
   * @constructor
   * @extends LayoutBox
   *
   * @param {Object} [options] see LayoutBox
   */
  function HBox( options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );

    LayoutBox.call( this, _.extend( {}, options, { orientation: 'horizontal' } ) );
  }

  scenery.register( 'HBox', HBox );

  return inherit( LayoutBox, HBox );
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * VBox is a convenience specialization of LayoutBox with vertical orientation.
 *
 * @author Sam Reid
 */
define( 'SCENERY/nodes/VBox',['require','PHET_CORE/inherit','SCENERY/nodes/LayoutBox','SCENERY/scenery'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var LayoutBox = require( 'SCENERY/nodes/LayoutBox' );
  var scenery = require( 'SCENERY/scenery' );

  /**
   * @public
   * @constructor
   * @extends LayoutBox
   *
   * @param {Object} [options] see LayoutBox
   */
  function VBox( options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );

    LayoutBox.call( this, _.extend( {}, options, { orientation: 'vertical' } ) );
  }

  scenery.register( 'VBox', VBox );

  return inherit( LayoutBox, VBox );
} );


define("string!PENDULUM_LAB/energyLegend",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/energyLegend");});


define("string!PENDULUM_LAB/legend.kineticEnergy",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/legend.kineticEnergy");});


define("string!PENDULUM_LAB/legend.potentialEnergy",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/legend.potentialEnergy");});


define("string!PENDULUM_LAB/legend.thermalEnergy",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/legend.thermalEnergy");});


define("string!PENDULUM_LAB/legend.totalEnergy",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/legend.totalEnergy");});

// Copyright 2017, University of Colorado Boulder

/**
 * Legend dialog for the energy labels
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PENDULUM_LAB/energy/view/EnergyLegendDialog',['require','SCENERY/nodes/AlignBox','SCENERY/nodes/AlignGroup','JOIST/Dialog','SCENERY/nodes/HBox','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY/nodes/RichText','SCENERY/nodes/Text','SCENERY/nodes/VBox','string!PENDULUM_LAB/energyLegend','string!PENDULUM_LAB/legend.kineticEnergy','string!PENDULUM_LAB/legend.kineticEnergyAbbreviation','string!PENDULUM_LAB/legend.potentialEnergy','string!PENDULUM_LAB/legend.potentialEnergyAbbreviation','string!PENDULUM_LAB/legend.thermalEnergy','string!PENDULUM_LAB/legend.thermalEnergyAbbreviation','string!PENDULUM_LAB/legend.totalEnergy','string!PENDULUM_LAB/legend.totalEnergyAbbreviation'],function( require ) {
  'use strict';

  // modules
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var AlignGroup = require( 'SCENERY/nodes/AlignGroup' );
  var Dialog = require( 'JOIST/Dialog' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var RichText = require( 'SCENERY/nodes/RichText' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VBox = require( 'SCENERY/nodes/VBox' );

  // strings
  var energyLegendString = require( 'string!PENDULUM_LAB/energyLegend' );
  var legendKineticEnergyString = require( 'string!PENDULUM_LAB/legend.kineticEnergy' );
  var legendKineticEnergyAbbreviationString = require( 'string!PENDULUM_LAB/legend.kineticEnergyAbbreviation' );
  var legendPotentialEnergyString = require( 'string!PENDULUM_LAB/legend.potentialEnergy' );
  var legendPotentialEnergyAbbreviationString = require( 'string!PENDULUM_LAB/legend.potentialEnergyAbbreviation' );
  var legendThermalEnergyString = require( 'string!PENDULUM_LAB/legend.thermalEnergy' );
  var legendThermalEnergyAbbreviationString = require( 'string!PENDULUM_LAB/legend.thermalEnergyAbbreviation' );
  var legendTotalEnergyString = require( 'string!PENDULUM_LAB/legend.totalEnergy' );
  var legendTotalEnergyAbbreviationString = require( 'string!PENDULUM_LAB/legend.totalEnergyAbbreviation' );

  /**
   * @constructor
   */
  function EnergyLegendDialog() {
    var abbreviationGroup = new AlignGroup();
    var descriptionGroup = new AlignGroup();

    var content = new VBox( {
      spacing: 15,
      children: [
        {
          abbreviation: legendKineticEnergyAbbreviationString,
          description: legendKineticEnergyString,
          color: PendulumLabConstants.KINETIC_ENERGY_COLOR
        }, {
          abbreviation: legendPotentialEnergyAbbreviationString,
          description: legendPotentialEnergyString,
          color: PendulumLabConstants.POTENTIAL_ENERGY_COLOR
        }, {
          abbreviation: legendThermalEnergyAbbreviationString,
          description: legendThermalEnergyString,
          color: PendulumLabConstants.THERMAL_ENERGY_COLOR
        }, {
          abbreviation: legendTotalEnergyAbbreviationString,
          description: legendTotalEnergyString,
          color: PendulumLabConstants.TOTAL_ENERGY_COLOR
        },
      ].map( function( itemData ) {
        return new HBox( {
          spacing: 20,
          children: [
            new AlignBox( new RichText( itemData.abbreviation, {
              font: PendulumLabConstants.LEGEND_ABBREVIATION_FONT,
              fill: itemData.color,
              maxWidth: 100
            } ), {
              group: abbreviationGroup,
              xAlign: 'left'
            } ),
            new AlignBox( new Text( itemData.description, {
              font: PendulumLabConstants.LEGEND_DESCRIPTION_FONT
            } ), {
              group: descriptionGroup,
              xAlign: 'left',
              maxWidth: 500
            } )
          ]
        } );
      } )
    } );

    Dialog.call( this, content, {
      modal: true,
      title: new Text( energyLegendString, {
        font: PendulumLabConstants.DIALOG_TITLE_FONT,
        maxWidth: 700
      } ),
      xMargin: 30,
      yMargin: 20
    } );
  }

  pendulumLab.register( 'EnergyLegendDialog', EnergyLegendDialog );

  return inherit( Dialog, EnergyLegendDialog );
} );

// Copyright 2017, University of Colorado Boulder

/**
 * Controller that creates and keeps an SVG radial gradient up-to-date with a Scenery RadialGradient
 *
 * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/SVGRadialGradient',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/SVGGradient'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGGradient = require( 'SCENERY/display/SVGGradient' );

  /**
   * @constructor
   * @mixes Poolable
   *
   * @param {SVGBlock} svgBlock
   * @param {RadialGradient} radialGradient
   */
  function SVGRadialGradient( svgBlock, radialGradient ) {
    this.initialize( svgBlock, radialGradient );
  }

  scenery.register( 'SVGRadialGradient', SVGRadialGradient );

  inherit( SVGGradient, SVGRadialGradient, {
    /**
     * Poolable initializer.
     * @private
     *
     * @param {SVGBlock} svgBlock
     * @param {RadialGradient} radialGradient
     */
    initialize: function( svgBlock, radialGradient ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGRadialGradient] initialize ' + radialGradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();

      SVGGradient.prototype.initialize.call( this, svgBlock, radialGradient );

      // Radial-specific setup
      this.definition.setAttribute( 'cx', radialGradient.largePoint.x );
      this.definition.setAttribute( 'cy', radialGradient.largePoint.y );
      this.definition.setAttribute( 'r', radialGradient.maxRadius );
      this.definition.setAttribute( 'fx', radialGradient.focalPoint.x );
      this.definition.setAttribute( 'fy', radialGradient.focalPoint.y );

      sceneryLog && sceneryLog.Paints && sceneryLog.pop();

      return this;
    },

    /**
     * Creates the gradient-type-specific definition.
     * @protected
     * @override
     *
     * @returns {SVGRadialGradientElement}
     */
    createDefinition: function() {
      return document.createElementNS( scenery.svgns, 'radialGradient' );
    }
  } );

  Poolable.mixin( SVGRadialGradient, {
    constructorDuplicateFactory: function( pool ) {
      return function( svgBlock, radialGradient ) {
        if ( pool.length ) {
          return pool.pop().initialize( svgBlock, radialGradient );
        }
        else {
          return new SVGRadialGradient( svgBlock, radialGradient );
        }
      };
    }
  } );

  return SVGRadialGradient;
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * A radial gradient that can be passed into the 'fill' or 'stroke' parameters.
 *
 * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/util/RadialGradient',['require','SCENERY/util/Gradient','PHET_CORE/inherit','PHET_CORE/platform','SCENERY/scenery','SCENERY/display/SVGRadialGradient','DOT/Vector2'],function( require ) {
  'use strict';

  var Gradient = require( 'SCENERY/util/Gradient' );
  var inherit = require( 'PHET_CORE/inherit' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGRadialGradient = require( 'SCENERY/display/SVGRadialGradient' );
  var Vector2 = require( 'DOT/Vector2' );

  /**
   * @constructor
   * @extends Gradient
   *
   * TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]
   *
   * TODO: support Vector2s as p0 and p1
   *
   * @param {number} x0 - X coordinate of the start point (ratio 0) in the local coordinate frame
   * @param {number} y0 - Y coordinate of the start point (ratio 0) in the local coordinate frame
   * @param {number} r0 - Radius of the start point (ratio 0) in the local coordinate frame
   * @param {number} x1 - X coordinate of the end point (ratio 1) in the local coordinate frame
   * @param {number} y1 - Y coordinate of the end point (ratio 1) in the local coordinate frame
   * @param {number} r1 - Radius of the end point (ratio 1) in the local coordinate frame
   */
  function RadialGradient( x0, y0, r0, x1, y1, r1 ) {
    // @public {Vector2}
    this.start = new Vector2( x0, y0 );
    this.end = new Vector2( x1, y1 );

    // If we are using Safari, we need to work around incorrect gradient handling for now,
    // see https://github.com/phetsims/sun/issues/526
    if ( platform.safari ) {
      var x = ( x0 + x1 ) / 2;
      var y = ( y0 + y1 ) / 2;
      this.start.x = x;
      this.start.y = y;
      this.end.x = x;
      this.end.y = y;
    }

    // @public {number}
    this.startRadius = r0;
    this.endRadius = r1;

    // @public {Vector2} - linear function from radius to point on the line from start to end
    this.focalPoint = this.start.plus( this.end.minus( this.start ).times( this.startRadius / ( this.startRadius - this.endRadius ) ) );

    // @public {boolean}
    this.startIsLarger = this.startRadius > this.endRadius;

    // @public {Vector2}
    this.largePoint = this.startIsLarger ? this.start : this.end;

    // @public {number}
    this.maxRadius = Math.max( this.startRadius, this.endRadius );
    this.minRadius = Math.min( this.startRadius, this.endRadius );

    // make sure that the focal point is in both circles. SVG doesn't support rendering outside of them
    if ( this.startRadius >= this.endRadius ) {
      assert && assert( this.focalPoint.minus( this.start ).magnitude() <= this.startRadius );
    }
    else {
      assert && assert( this.focalPoint.minus( this.end ).magnitude() <= this.endRadius );
    }

    Gradient.call( this );
  }

  scenery.register( 'RadialGradient', RadialGradient );

  inherit( Gradient, RadialGradient, {

    isRadialGradient: true,

    /**
     * Returns a fresh gradient given the starting parameters
     * @protected
     * @override
     *
     * @returns {CanvasGradient}
     */
    createCanvasGradient: function() {
      // use the global scratch canvas instead of creating a new Canvas
      return scenery.scratchContext.createRadialGradient( this.start.x, this.start.y, this.startRadius, this.end.x, this.end.y, this.endRadius );
    },

    /**
     * Creates an SVG paint object for creating/updating the SVG equivalent definition.
     * @public
     *
     * @param {SVGBlock} svgBlock
     * @returns {SVGGradient|SVGPattern}
     */
    createSVGPaint: function( svgBlock ) {
      return SVGRadialGradient.createFromPool( svgBlock, this );
    },

    /**
     * Returns stops suitable for direct SVG use.
     * @public
     * @override
     *
     * NOTE: SVG has certain stop requirements, so we need to remap/reverse in some cases.
     *
     * @returns {Array.<{ ratio: {number}, stop: {Color|string|Property.<Color|string|null>|null} }>}
     */
    getSVGStops: function() {
      var startIsLarger = this.startIsLarger;
      var maxRadius = this.maxRadius;
      var minRadius = this.minRadius;

      //TODO: replace with dot.Util.linear
      // maps x linearly from [a0,b0] => [a1,b1]
      function linearMap( a0, b0, a1, b1, x ) {
        return a1 + ( x - a0 ) * ( b1 - a1 ) / ( b0 - a0 );
      }

      function mapStop( stop ) {
        // flip the stops if the start has a larger radius
        var ratio = startIsLarger ? 1 - stop.ratio : stop.ratio;

        // scale the stops properly if the smaller radius isn't 0
        if ( minRadius > 0 ) {
          // scales our ratio from [0,1] => [minRadius/maxRadius,0]
          ratio = linearMap( 0, 1, minRadius / maxRadius, 1, ratio );
        }

        return {
          ratio: ratio,
          color: stop.color
        };
      }

      var stops = this.stops.map( mapStop );

      // switch the direction we apply stops in, so that the ratios always are increasing.
      if ( startIsLarger ) {
        stops.reverse();
      }

      return stops;
    },

    toString: function() {
      var result = 'new scenery.RadialGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.startRadius + ', ' + this.end.x + ', ' + this.end.y + ', ' + this.endRadius + ' )';

      _.each( this.stops, function( stop ) {
        result += '.addColorStop( ' + stop.ratio + ', \'' + stop.color.toString() + '\' )';
      } );

      return result;
    }
  } );

  return RadialGradient;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Visual representation of a round button.  It is provided with a 'button
 * model' that is monitored to change the appearance of the button.
 *
 * Note: this is only the visual representation and does not have associated
 * input listeners so that it can be reused in multiple contexts.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RoundButtonView',['require','SUN/buttons/ButtonListener','SCENERY/nodes/Circle','SCENERY/util/Color','SUN/ColorConstants','PHET_CORE/inherit','SCENERY/nodes/Node','AXON/Property','SCENERY/util/RadialGradient','KITE/Shape','SUN/sun','DOT/Vector2'],function( require ) {
  'use strict';

  // modules
  var ButtonListener = require( 'SUN/buttons/ButtonListener' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var Color = require( 'SCENERY/util/Color' );
  var ColorConstants = require( 'SUN/ColorConstants' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var RadialGradient = require( 'SCENERY/util/RadialGradient' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Vector2 = require( 'DOT/Vector2' );

  // constants
  var HIGHLIGHT_GRADIENT_LENGTH = 5; // In screen coords, which are roughly pixels.
  var DEFAULT_COLOR = ColorConstants.LIGHT_BLUE;

  /**
   * @param {ButtonModel} buttonModel
   * @param {Property} interactionStateProperty - A property that is used to drive the visual appearance of the button.
   * @param {Object} [options]
   * @constructor
   */
  function RoundButtonView( buttonModel, interactionStateProperty, options ) {
    this.buttonModel = buttonModel; // @protected

    options = _.extend( {

      radius: ( options && options.content ) ? undefined : 30,
      content: null,
      cursor: 'pointer',
      baseColor: DEFAULT_COLOR,
      disabledBaseColor: ColorConstants.LIGHT_GRAY,
      minXMargin: 5, // Minimum margin in x direction, i.e. on left and right
      minYMargin: 5, // Minimum margin in y direction, i.e. on top and bottom
      fireOnDown: false,
      touchAreaDilation: 0, // radius dilation for touch area
      mouseAreaDilation: 0, // radius dilation for mouse area
      stroke: undefined, // undefined by default, which will cause a stroke to be derived from the base color
      lineWidth: 0.5, // Only meaningful if stroke is non-null

      // By default, icons are centered in the button, but icons with odd
      // shapes that are not wrapped in a normalizing parent node may need to
      // specify offsets to line things up properly
      xContentOffset: 0,
      yContentOffset: 0,

      // Strategy for controlling the button's appearance, excluding any
      // content.  This can be a stock strategy from this file or custom.  To
      // create a custom one, model it off of the stock strategies defined in
      // this file.
      buttonAppearanceStrategy: RoundButtonView.ThreeDAppearanceStrategy,

      // Strategy for controlling the appearance of the button's content based
      // on the button's state.  This can be a stock strategy from this file,
      // or custom.  To create a custom one, model it off of the stock
      // version(s) defined in this file.
      contentAppearanceStrategy: RoundButtonView.FadeContentWhenDisabled
    }, options );

    Node.call( this );
    var content = options.content; // convenience variable
    var upCenter = new Vector2( options.xContentOffset, options.yContentOffset );

    // For performance reasons, the content should be unpickable.
    if ( content ) {
      content.pickable = false;
    }

    // Make the base color into a property so that the appearance strategy can update itself if changes occur.
    this.baseColorProperty = new Property( Color.toColor( options.baseColor ) ); // @private

    // Hook up the input listener
    this.addInputListener( new ButtonListener( buttonModel ) );

    // Use the user-specified radius if present, otherwise calculate the
    // radius based on the content and the margin.
    var buttonRadius = options.radius || Math.max( content.width + options.minXMargin * 2, content.height + options.minYMargin * 2 ) / 2;

    // Create the basic button shape.
    var button = new Circle( buttonRadius, { fill: options.baseColor, lineWidth: options.lineWidth } );
    this.addChild( button );

    // Hook up the strategy that will control the basic button appearance.
    var buttonAppearanceStrategy = new options.buttonAppearanceStrategy(
      button,
      interactionStateProperty,
      this.baseColorProperty,
      options
    );

    // Add the content to the button.
    if ( content ) {
      content.center = upCenter;
      this.addChild( content );
    }

    // Hook up the strategy that will control the content appearance.
    var contentAppearanceStrategy = new options.contentAppearanceStrategy( content, interactionStateProperty );

    // Control the pointer state based on the interaction state.
    var self = this;
    function handleInteractionStateChanged( state ) {
      self.cursor = state === 'disabled' || state === 'disabled-pressed' ? null : 'pointer';
    }
    interactionStateProperty.link( handleInteractionStateChanged );

    // Dilate the pointer areas.
    this.touchArea = Shape.circle( 0, 0, buttonRadius + options.touchAreaDilation );
    this.mouseArea = Shape.circle( 0, 0, buttonRadius + options.mouseAreaDilation );

    // Set pickable such that sub-nodes are pruned from hit testing.
    this.pickable = null;

    // a11y
    this.focusHighlight = new Shape.circle( 0, 0, buttonRadius + 5 );

    // Mutate with the options after the layout is complete so that
    // width-dependent fields like centerX will work.
    this.mutate( options );

    // define a dispose function
    this.disposeRoundButtonView = function() {
      buttonAppearanceStrategy.dispose();
      contentAppearanceStrategy.dispose();
      interactionStateProperty.unlink( handleInteractionStateChanged );
    };
  }

  sun.register( 'RoundButtonView', RoundButtonView );

  /**
   * Strategy for making a button look 3D-ish by using gradients that create the appearance of highlighted and shaded
   * edges.  The gradients are intended to make the light source appear to be above and to the left of the button.
   *
   * @param {Node} button
   * @param {Property.<boolean>} interactionStateProperty
   * @param {Property.<Color>} baseColorProperty
   * @param {Object} [options]
   * @constructor
   * @public
   */
  RoundButtonView.ThreeDAppearanceStrategy = function( button, interactionStateProperty, baseColorProperty, options ) {

    // Set up variables needed to create the various gradient fills and otherwise mod the appearance
    var buttonRadius = button.width / 2;
    var disabledBaseColor = Color.toColor( options.disabledBaseColor );
    var transparentDisabledBaseColor = new Color(
      disabledBaseColor.getRed(),
      disabledBaseColor.getGreen(),
      disabledBaseColor.getBlue(),
      0
    );
    var disabledStroke = options.stroke ? disabledBaseColor.colorUtilsDarker( 0.4 ) : null;
    var innerGradientRadius = buttonRadius - HIGHLIGHT_GRADIENT_LENGTH / 2;
    var outerGradientRadius = buttonRadius + HIGHLIGHT_GRADIENT_LENGTH / 2;
    var gradientOffset = HIGHLIGHT_GRADIENT_LENGTH / 2;

    // Create and add the overlay that is used to add shading.
    var overlayForShadowGradient = new Circle( buttonRadius, { lineWidth: options.lineWidth, pickable: false } );
    button.addChild( overlayForShadowGradient );

    // various fills used to alter the appearance of the button, values set below
    var upFillHighlight;
    var upFillShadow;
    var overFillHighlight;
    var overFillShadow;
    var pressedFill;
    var disabledFillHighlight;
    var disabledFillShadow;
    var disabledPressedFillHighlight;
    var enabledStroke = null;

    // Function to create a fill that represents a pressed in round button.
    function createPressedFill( color ) {
      return new RadialGradient( -gradientOffset, -gradientOffset, 0, 0, 0, outerGradientRadius )
        .addColorStop( 0, color.colorUtilsDarker( 0.1 ) )
        .addColorStop( 0.6, color.colorUtilsDarker( 0.2 ) )
        .addColorStop( 0.8, color )
        .addColorStop( 1, color.colorUtilsBrighter( 0.8 ) );
    }

    // Function for updating the button's appearance based on the current interaction state.
    function updateAppearance( interactionState ) {

      switch( interactionState ) {

        case 'idle':
          button.fill = upFillHighlight;
          overlayForShadowGradient.stroke = enabledStroke;
          overlayForShadowGradient.fill = upFillShadow;
          break;

        case 'over':
          button.fill = overFillHighlight;
          overlayForShadowGradient.stroke = enabledStroke;
          overlayForShadowGradient.fill = overFillShadow;
          break;

        case 'pressed':
          button.fill = pressedFill;
          overlayForShadowGradient.stroke = enabledStroke;
          overlayForShadowGradient.fill = overFillShadow;
          break;

        case 'disabled':
          button.fill = disabledFillHighlight;
          overlayForShadowGradient.stroke = disabledStroke;
          overlayForShadowGradient.fill = disabledFillShadow;
          break;

        case 'disabled-pressed':
          button.fill = disabledPressedFillHighlight;
          overlayForShadowGradient.stroke = disabledStroke;
          overlayForShadowGradient.fill = disabledFillShadow;
          break;

        default:
          throw new Error( 'upsupported interactionState: ' + interactionState );
      }
    }

    // Function for creating the fills and strokes used to control the button's appearance.
    function updateFillsAndStrokes( baseColor ) {

      var transparentBaseColor = new Color( baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), 0 );

      upFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
        .addColorStop( 0, baseColor )
        .addColorStop( 1, baseColor.colorUtilsBrighter( 0.7 ) );

      upFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
        .addColorStop( 0, transparentBaseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );

      overFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
        .addColorStop( 0, baseColor.colorUtilsBrighter( 0.3 ) )
        .addColorStop( 1, baseColor.colorUtilsBrighter( 0.8 ) );

      overFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
        .addColorStop( 0, transparentBaseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );

      pressedFill = createPressedFill( baseColor );

      disabledFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
        .addColorStop( 0, disabledBaseColor )
        .addColorStop( 1, disabledBaseColor.colorUtilsBrighter( 0.5 ) );

      disabledFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
        .addColorStop( 0, transparentDisabledBaseColor )
        .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );

      disabledPressedFillHighlight = createPressedFill( disabledBaseColor );

      if ( options.stroke === null ) {
        // The stroke was explicitly set to null, so the button should have no stroke.
        enabledStroke = null;
        disabledStroke = null;
      }
      else if ( typeof( options.stroke ) === 'undefined' ) {
        // No stroke was defined, but it wasn't set to null, so default to a stroke based on the base color of the
        // button.  This behavior is a bit unconventional for Scenery nodes, but it makes the buttons look much better.
        enabledStroke = baseColor.colorUtilsDarker( 0.4 );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      else {
        enabledStroke = Color.toColor( options.stroke );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }

      button.cachedPaints = [
        upFillHighlight, overFillHighlight, pressedFill, disabledFillHighlight, disabledPressedFillHighlight
      ];

      overlayForShadowGradient.cachedPaints = [
        upFillShadow, overFillShadow, disabledFillShadow,
        enabledStroke, disabledStroke
      ];

      updateAppearance( interactionStateProperty.value );
    }

    // Do the initial update explicitly, then lazy link to the properties.  This keeps the number of initial updates to
    // a minimum and allows us to update some optimization flags the first time the base color is actually changed.
    updateFillsAndStrokes( baseColorProperty.value );
    updateAppearance( interactionStateProperty.value );

    baseColorProperty.lazyLink( updateFillsAndStrokes );
    interactionStateProperty.lazyLink( updateAppearance );

    // add a dispose function
    this.dispose = function() {
      baseColorProperty.unlink( updateFillsAndStrokes );
      interactionStateProperty.unlink( updateAppearance );
    };
  };

  /**
   * Strategy for buttons that look flat, i.e. no shading or highlighting, but
   * that change color on mouseover, press, etc.
   * @param {Node} button
   * @param {Property.<boolean>} interactionStateProperty
   * @param {Property.<Color>} baseColorProperty
   * @param {Object} [options]
   * @constructor
   * @public
   */
  RoundButtonView.FlatAppearanceStrategy = function( button, interactionStateProperty, baseColorProperty, options ) {

    // Set up variables needed to create the various gradient fills
    var disabledBaseColor = Color.toColor( options.disabledBaseColor );

    // various fills that are used to alter the button's appearance
    var upFill;
    var overFill;
    var downFill;
    var disabledFill;
    var disabledPressedFillVertical;
    var enabledStroke = null;
    var disabledStroke = null;

    function updateAppearance( interactionState ) {
      switch( interactionState ) {
        case 'idle':
          button.fill = upFill;
          button.stroke = enabledStroke;
          break;

        case 'over':
          button.fill = overFill;
          button.stroke = enabledStroke;
          break;

        case 'pressed':
          button.fill = downFill;
          button.stroke = enabledStroke;
          break;

        case 'disabled':
          button.fill = disabledFill;
          button.stroke = disabledStroke;
          break;

        case 'disabled-pressed':
          button.fill = disabledPressedFillVertical;
          button.stroke = disabledStroke;
          break;

        default:
          throw new Error( 'upsupported interactionState: ' + interactionState );
      }
    }

    function updateFillsAndStrokes( baseColor ) {
      upFill = baseColor;
      overFill = baseColor.colorUtilsBrighter( 0.4 );
      downFill = baseColor.colorUtilsDarker( 0.4 );
      disabledFill = disabledBaseColor;
      disabledPressedFillVertical = disabledFill;
      if ( options.stroke === null ) {
        // The stroke was explicitly set to null, so the button should have no stroke.
        enabledStroke = null;
        disabledStroke = null;
      }
      else if ( typeof( options.stroke ) === 'undefined' ) {
        // No stroke was defined, but it wasn't set to null, so default to a stroke based on the base color of the
        // button.  This behavior is a bit unconventional for Scenery nodes, but it makes the buttons look much better.
        enabledStroke = baseColor.colorUtilsDarker( 0.4 );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      else {
        enabledStroke = Color.toColor( options.stroke );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }

      button.cachedPaints = [
        upFill, overFill, downFill, disabledFill, disabledPressedFillVertical,
        enabledStroke, disabledStroke
      ];

      updateAppearance( interactionStateProperty.value );
    }

    // Do the initial update explicitly, then lazy link to the properties.  This keeps the number of initial updates to
    // a minimum and allows us to update some optimization flags the first time the base color is actually changed.
    updateFillsAndStrokes( baseColorProperty.value );
    updateAppearance( interactionStateProperty.value );

    baseColorProperty.lazyLink( updateFillsAndStrokes );
    interactionStateProperty.lazyLink( updateAppearance );

    // add a dispose function
    this.dispose = function() {
      baseColorProperty.unlink( updateFillsAndStrokes );
      interactionStateProperty.unlink( updateAppearance );
    };
  };

  /**
   * Basic strategy for controlling content appearance, fades the content by making it transparent when disabled.
   * @param {Node} content
   * @param {Property} interactionStateProperty
   */
  RoundButtonView.FadeContentWhenDisabled = function( content, interactionStateProperty ) {

    // update the opacity when the state changes
    function updateOpacity( state ) {
      if ( content ) {
        content.opacity = state === 'disabled' || state === 'disabled-pressed' ? 0.3 : 1;
      }
    }

    interactionStateProperty.link( updateOpacity );

    // add dispose function to unlink listener
    this.dispose = function() {
      interactionStateProperty.unlink( updateOpacity );
    };
  };

  return inherit( Node, RoundButtonView, {

    /**
     * Sets the enabled state.
     * @param {boolean} value
     * @public
     */
    setEnabled: function( value ) {
      assert && assert( typeof value === 'boolean', 'RoundButtonView.enabled must be a boolean value' );
      this.buttonModel.enabledProperty.set( value );
    },
    set enabled( value ) { this.setEnabled( value ); },

    /**
     * Gets the enabled state.
     * @returns {boolean}
     * @public
     */
    getEnabled: function() {return this.buttonModel.enabledProperty.get(); },
    get enabled() { return this.getEnabled(); },

    /**
     * Sets the base color, which is the main background fill color used for the button.
     * @param {Color|String} baseColor
     * @public
     */
    setBaseColor: function( baseColor ) { this.baseColorProperty.value = Color.toColor( baseColor ); },
    set baseColor( baseColor ) { this.setBaseColor( baseColor ); },

    /**
     * Gets the base color for this button.
     * @returns {Color}
     * @public
     */
    getBaseColor: function() { return this.baseColorProperty.value; },
    get baseColor() { return this.getBaseColor(); },

    /**
     * dispose function
     * @public
     */
    dispose: function() {
      this.disposeRoundButtonView();
      Node.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * An interactive round push button.  This is the file in which the appearance and behavior are brought together.
 *
 * This class inherits from RoundButtonView, which contains all of the
 * code that defines the button's appearance, and adds the button's behavior
 * by hooking up a button model.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RoundPushButton',['require','PHET_CORE/inherit','SUN/buttons/PushButtonInteractionStateProperty','SUN/buttons/PushButtonModel','SUN/buttons/RoundButtonView','SUN/sun','TANDEM/Tandem','SUN/buttons/TPushButton'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var PushButtonInteractionStateProperty = require( 'SUN/buttons/PushButtonInteractionStateProperty' );
  var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
  var RoundButtonView = require( 'SUN/buttons/RoundButtonView' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TPushButton = require( 'SUN/buttons/TPushButton' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function RoundPushButton( options ) {

    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      phetioType: TPushButton,

      // a11y
      tagName: 'input',
      inputType: 'button'
    }, options );

    var self = this;

    var tandem = options.tandem;
    options.tandem = tandem.createSupertypeTandem();

    // If a listener was passed in, save it and add it after creating the button model.  This is done so that
    // the same code path is always used for adding listener, thus guaranteeing a consistent code path if addListener is
    // overridden, see https://github.com/phetsims/sun/issues/284.
    var listener = options.listener;
    options = _.omit( options, [ 'listener' ] );

    // Safe to pass through options to the PushButtonModel like "fireOnDown".  Other scenery options will be safely ignored.
    this.buttonModel = new PushButtonModel( options ); // @public, listen only
    RoundButtonView.call( this, this.buttonModel, new PushButtonInteractionStateProperty( this.buttonModel ), options );

    // add the listener that was potentially saved above
    listener && this.addListener( listener );

    // a11y - when the button is clicked with assistive technology, fire
    var accessibleClickListener = this.addAccessibleInputListener( {
      click: function() {
        self.buttonModel.fire();
      }
    } );

    this.mutate( {
      tandem: tandem,
      phetioType: options.phetioType
    } );

    this.disposeRoundPushButton = function() {
      tandem.removeInstance( self );
      self.removeAccessibleInputListener( accessibleClickListener );
      self.buttonModel.dispose();
    };

  }

  sun.register( 'RoundPushButton', RoundPushButton );

  return inherit( RoundButtonView, RoundPushButton, {

    // @public
    dispose: function() {
      this.disposeRoundPushButton();
      RoundButtonView.prototype.dispose.call( this );
    },

    // @public
    addListener: function( listener ) {
      this.buttonModel.addListener( listener );
    },

    // @public
    removeListener: function( listener ) {
      this.buttonModel.removeListener( listener );
    }
  } );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Collection of utility functions related to Strings.
 */
define( 'PHETCOMMON/util/StringUtils',['require','PHETCOMMON/phetcommon'],function( require ) {
  'use strict';

  // modules
  var phetcommon = require( 'PHETCOMMON/phetcommon' );

  // Unicode embedding marks that we use.
  var LTR = '\u202a';
  var RTL = '\u202b';
  var POP = '\u202c';

  var StringUtils = {

    /**
     * NOTE: Please use StringUtils.fillIn instead of this function.
     *
     * http://mobzish.blogspot.com/2008/10/simple-messageformat-for-javascript.html
     * Similar to Java's MessageFormat, supports simple substitution, simple substitution only.
     * The full MessageFormat specification allows conditional formatting, for example to support pluralisation.
     *
     * Example:
     * > StringUtils.format( '{0} + {1}', 2, 3 )
     * "2 + 3"
     *
     * @param {string} pattern pattern string, with N placeholders, where N is an integer
     * @returns {string}
     * @public
     */
    format: function( pattern ) {
      var args = arguments;
      return pattern.replace( /{(\d)}/g, function( r, n ) { return args[ +n + 1 ];} );
    },

    /**
     * Fills in a set of placeholders in a template.
     * Placeholders are specified with pairs of curly braces, e.g. '{{name}} is {{age}} years old'
     * See https://github.com/phetsims/phetcommon/issues/36
     *
     * Example:
     * > StringUtils.fillIn( '{{name}} is {{age}} years old', { name: 'Fred', age: 23 } )
     * "Fred is 23 years old"
     *
     * @param {string} template - the template, containing zero or more placeholders
     * @param {Object} values - a hash whose keys correspond to the placeholder names, e.g. { name: 'Fred', age: 23 }
     *                          Unused keys are silently ignored.
     * @returns {string}
     * @public
     */
    fillIn: function( template, values ) {

      var newString = template;

      // {string[]} parse out the set of placeholders
      var placeholders = template.match( /\{\{[^\{\}]+\}\}/g ) || [];

      // replace each placeholder with its corresponding value
      for ( var i = 0; i < placeholders.length; i++ ) {
        var placeholder = placeholders[ i ];

        // key is the portion of the placeholder between the curly braces
        var key = placeholder.replace( '{{', '' ).replace( '}}', '' );
        assert && assert( values[ key ] !== undefined, 'missing key ' + key );

        newString = newString.replace( placeholder, values[ key ] );
      }

      return newString;
    },

    /**
     * @public
     * @returns {boolean} - Whether this length-1 string is equal to one of the three directional embedding marks used.
     */
    isEmbeddingMark: function( chr ) {
      return chr === LTR || chr === RTL || chr === POP;
    },

    /**
     * Given a string with embedding marks, this function returns an equivalent string.slice() but prefixes and suffixes
     * the string with the embedding marks needed to ensure things have the correct LTR/RTL order.
     * @public
     *
     * For example, with a test string:
     *
     * embeddedDebugString( '\u202a\u202bhi\u202c\u202c' )
     * === "[LTR][RTL]hi[POP][POP]"
     *
     * We could grab the first word, and it adds the ending POP:
     * embeddedDebugString( embeddedSlice( '\u202afirst\u202bsecond\u202cthird\u202c', 0, 6 ) )
     * === "[LTR]first[POP]"
     *
     * Or the second word:
     * embeddedDebugString( embeddedSlice( '\u202afirst\u202bsecond\u202cthird\u202c', 6, 14 ) )
     * === "[RTL]second[POP]"
     *
     * Or a custom range:
     * embeddedDebugString( embeddedSlice( '\u202afirst\u202bsecond\u202cthird\u202c', 3, -3 ) )
     * === "[LTR]rst[RTL]second[POP]thi[POP]"
     *
     * @param {string} string - The main source string to slice from
     * @param {number} startIndex - The starting index where the slice starts (includes char at this index)
     * @param {number} [endIndex] - The ending index where the slice stops (does NOT include char at this index)
     * @returns {string} - The sliced string, with embedding marks added at hte start and end.
     */
    embeddedSlice: function( string, startIndex, endIndex ) {
      // {Array.<string>} - array of LTR/RTL embedding marks that are currently on the stack for the current location.
      var stack = [];
      var chr;

      if ( endIndex === undefined ) {
        endIndex = string.length;
      }
      if ( endIndex < 0 ) {
        endIndex += string.length;
      }

      // To avoid returning an extra adjacent [LTR][POP] or [RTL][POP], we can move the start forward and the
      // end backwards as long as they are over embedding marks to avoid this.
      while ( startIndex < string.length && StringUtils.isEmbeddingMark( string.charAt( startIndex ) ) ) {
        startIndex++;
      }
      while ( endIndex >= 1 && StringUtils.isEmbeddingMark( string.charAt( endIndex - 1 ) ) ) {
        endIndex--;
      }

      // If our string will be empty, just bail out.
      if ( startIndex >= endIndex || startIndex >= string.length ) {
        return '';
      }

      // Walk up to the start of the string
      for ( var i = 0; i < startIndex; i++ ) {
        chr = string.charAt( i );
        if ( chr === LTR || chr === RTL ) {
          stack.push( chr );
        }
        else if ( chr === POP ) {
          stack.pop();
        }
      }

      // Will store the minimum stack size during our slice. This allows us to turn [LTR][RTL]boo[POP][POP] into
      // [RTL]boo[POP] by skipping the "outer" layers.
      var minimumStackSize = stack.length;

      // Save our initial stack for prefix computation
      var startStack = stack.slice();

      // A normal string slice
      var slice = string.slice( startIndex, endIndex );

      // Walk through the sliced string, to determine what we need for the suffix
      for ( var j = 0; j < slice.length; j++ ) {
        chr = slice.charAt( j );
        if ( chr === LTR || chr === RTL ) {
          stack.push( chr );
        }
        else if ( chr === POP ) {
          stack.pop();
          minimumStackSize = Math.min( stack.length, minimumStackSize );
        }
      }

      // Our ending stack for suffix computation
      var endStack = stack;

      // Always leave one stack level on top
      var numSkippedStackLevels = Math.max( 0, minimumStackSize - 1 );
      startStack = startStack.slice( numSkippedStackLevels );
      endStack = endStack.slice( numSkippedStackLevels );

      // Our prefix will be the embedding marks that have been skipped and not popped.
      var prefix = startStack.join( '' );

      // Our suffix includes one POP for each embedding mark currently on the stack
      var suffix = endStack.join( '' ).replace( /./g, POP );

      return prefix + slice + suffix;
    },

    /**
     * String's split() API, but uses embeddedSlice() on the extracted strings.
     * @public
     *
     * For example, given a string:
     *
     * StringUtils.embeddedDebugString( '\u202aHello  there, \u202bHow are you\u202c doing?\u202c' );
     * === "[LTR]Hello  there, [RTL]How are you[POP] doing?[POP]"
     *
     * Using embeddedSplit with a regular expression matching a sequence of spaces:
     * StringUtils.embeddedSplit( '\u202aHello  there, \u202bHow are you\u202c doing?\u202c', / +/ )
     *            .map( StringUtils.embeddedDebugString );
     * === [ "[LTR]Hello[POP]",
     *       "[LTR]there,[POP]",
     *       "[RTL]How[POP]",
     *       "[RTL]are[POP]",
     *       "[RTL]you[POP]",
     *       "[LTR]doing?[POP]" ]
     */
    embeddedSplit: function( string, separator, limit ) {
      // Matching split API
      if ( separator === undefined ) {
        return [ string ];
      }

      // {Array.<string>} - What we will push to and return.
      var result = [];

      // { index: {number}, length: {number} } - Last result of findSeparatorMatch()
      var separatorMatch;

      // Remaining part of the string to split up. Will have substrings removed from the start.
      var stringToSplit = string;

      // Finds the index and length of the first substring of stringToSplit that matches the separator (string or regex)
      // and returns an object with the type  { index: {number}, length: {number} }.
      // If index === -1, there was no match for the separator.
      function findSeparatorMatch() {
        var index;
        var length;
        if ( separator instanceof window.RegExp ) {
          var match = stringToSplit.match( separator );
          if ( match ) {
            index = match.index;
            length = match[ 0 ].length;
          }
          else {
            index = -1;
          }
        }
        else {
          assert && assert( typeof separator === 'string' );

          index = stringToSplit.indexOf( separator );
          length = separator.length;
        }
        return {
          index: index,
          length: length
        };
      }

      // Loop until we run out of matches for the separator. For each separator match, stringToSplit for the next
      // iteration will have everything up to the end of the separator match chopped off. The indexOffset variable
      // stores how many characters we have chopped off in this fashion, so that we can index into the original string.
      var indexOffset = 0;
      while ( ( separatorMatch = findSeparatorMatch() ).index >= 0 ) {
        // Extract embedded slice from the original, up until the separator match
        result.push( StringUtils.embeddedSlice( string, indexOffset, indexOffset + separatorMatch.index ) );

        // Handle chopping off the section of stringToSplit, so we can do simple matching in findSeparatorMatch()
        var offset = separatorMatch.index + separatorMatch.length;
        stringToSplit = stringToSplit.slice( offset );
        indexOffset += offset;
      }

      // Embedded slice for after the last match. May be an empty string.
      result.push( StringUtils.embeddedSlice( string, indexOffset ) );

      // Matching split API
      if ( limit !== undefined ) {
        assert && assert( typeof limit === 'number' );

        result = _.first( result, limit );
      }

      return result;
    },

    /**
     * Strips embedding marks out of a string.
     * @public
     *
     * @param {string} string
     * @returns {string}
     */
    stripEmbeddingMarks: function( string ) {
      return string.replace( /\u202a|\u202b|\u202c/g, '' );
    },

    /**
     * Replaces embedding mark characters with visible strings. Useful for debugging for strings with embedding marks.
     * @public
     *
     * @param {string} string
     * @returns {string} - With embedding marks replaced.
     */
    embeddedDebugString: function( string ) {
      return string.replace( /\u202a/g, '[LTR]' ).replace( /\u202b/g, '[RTL]' ).replace( /\u202c/g, '[POP]' );
    },

    /**
     * Determine whether one string ends with another.  Implementation is from the MDN polyfill at
     *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
     * @param {string} string - the string to test
     * @param {string} searchString - is this string at the end?
     * @param {number} [position] - Search within this string as if this string were only this long; defaults to
     *                        this string's actual length, clamped within the range established by this string's length.
     * @returns {boolean}
     */
    endsWith: function( string, searchString, position ) {
      var subjectString = string.toString();
      if ( typeof position !== 'number' || !isFinite( position ) || Math.floor( position ) !== position || position > subjectString.length ) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf( searchString, position );
      return lastIndex !== -1 && lastIndex === position;
    }
  };

  phetcommon.register( 'StringUtils', StringUtils );

  return StringUtils;
} );
// Copyright 2014-2017, University of Colorado Boulder

/**
 * Minus sign, created using scenery.Rectangle because scenery.Text("-") looks awful on Windows and cannot be accurately
 * centered. The origin is at the upper left.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/MinusNode',['require','DOT/Dimension2','PHET_CORE/inherit','SCENERY/nodes/Rectangle','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function MinusNode( options ) {

    options = _.extend( {
      size: new Dimension2( 20, 5 ),
      fill: 'black'
    }, options );

    assert && assert( options.size.width >= options.size.height );

    Rectangle.call( this, 0, 0, options.size.width, options.size.height, options );
  }

  sceneryPhet.register( 'MinusNode', MinusNode );

  return inherit( Rectangle, MinusNode );
} );
// Copyright 2014-2017, University of Colorado Boulder

/**
 * Plus sign, created using scenery.Path because scenery.Text("+") cannot be accurately centered.
 * Origin at upper left.
 *
 * @author Chris Malley (PixelZoom, Inc)
 */
define( 'SCENERY_PHET/PlusNode',['require','DOT/Dimension2','PHET_CORE/inherit','SCENERY/nodes/Path','KITE/Shape','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function PlusNode( options ) {

    options = _.extend( {
      size: new Dimension2( 20, 5 ), // width of the plus sign, height of the horizontal line in plus sign
      fill: 'black'
    }, options );

    // + shape, starting from top left and moving clockwise
    var c1 = ( options.size.width / 2 ) - ( options.size.height / 2 );
    var c2 = ( options.size.width / 2 ) + ( options.size.height / 2 );
    var shape = new Shape()
      .moveTo( c1, 0 )
      .lineTo( c2, 0 )
      .lineTo( c2, c1 )
      .lineTo( options.size.width, c1 )
      .lineTo( options.size.width, c2 )
      .lineTo( c2, c2 )
      .lineTo( c2, options.size.width )/* yes, use width for y param */
      .lineTo( c1, options.size.width )/* yes, use width for y param */
      .lineTo( c1, c2 )
      .lineTo( 0, c2 )
      .lineTo( 0, c1 )
      .lineTo( c1, c1 )
      .close();

    Path.call( this, shape, options );
  }

  sceneryPhet.register( 'PlusNode', PlusNode );

  return inherit( Path, PlusNode );
} );


// Copyright 2014-2017, University of Colorado Boulder

/**
 * Zoom button, has an icon with a magnifying glass, with either a plus or minus sign in the center of the glass.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/buttons/ZoomButton',['require','DOT/Dimension2','SCENERY/nodes/Circle','PHET_CORE/inherit','SCENERY_PHET/MinusNode','SCENERY/nodes/Node','SCENERY_PHET/PlusNode','SCENERY/nodes/Line','SUN/buttons/RectangularPushButton','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var Dimension2 = require( 'DOT/Dimension2' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var inherit = require( 'PHET_CORE/inherit' );
  var MinusNode = require( 'SCENERY_PHET/MinusNode' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PlusNode = require( 'SCENERY_PHET/PlusNode' );
  var Line = require( 'SCENERY/nodes/Line' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function ZoomButton( options ) {

    options = _.extend( {
      in: true, // true: zoom-in button, false: zoom-out button
      radius: 15,
      baseColor: 'rgb(255,200,0)',
      magnifyingGlassFill: 'white', // center of the glass
      magnifyingGlassStroke: 'black', // rim and handle
      tandem: Tandem.tandemRequired()
    }, options );

    // the magnifying glass
    var glassLineWidth = 0.25 * options.radius;
    var glassNode = new Circle( options.radius, {
      fill: options.magnifyingGlassFill,
      stroke: options.magnifyingGlassStroke,
      lineWidth: glassLineWidth,
      tandem: options.tandem.createTandem( 'glassNode' )
    } );

    // handle at lower-left of glass, at a 45-degree angle
    var outsideRadius = options.radius + ( glassLineWidth / 2 ); // use outside radius so handle line cap doesn't appear inside glassNode
    var handleNode = new Line(
      outsideRadius * Math.cos( Math.PI / 4 ), outsideRadius * Math.sin( Math.PI / 4 ),
      options.radius * Math.cos( Math.PI / 4 ) + ( 0.65 * options.radius ), options.radius * Math.sin( Math.PI / 4 ) + ( 0.65 * options.radius ), {
        stroke: options.magnifyingGlassStroke,
        lineWidth: 0.4 * options.radius,
        lineCap: 'round'
      } );

    // plus or minus sign in middle of magnifying glass
    var signOptions = {
      size: new Dimension2( 1.3 * options.radius, options.radius / 3 ),
      centerX: glassNode.centerX,
      centerY: glassNode.centerY,
      tandem: options.tandem.createTandem( 'signNode' )
    };
    var signNode = options.in ? new PlusNode( signOptions ) : new MinusNode( signOptions );

    options.content = new Node( { children: [ handleNode, glassNode, signNode ] } );

    RectangularPushButton.call( this, options );
  }

  sceneryPhet.register( 'ZoomButton', ZoomButton );

  return inherit( RectangularPushButton, ZoomButton );
} );


define("string!PENDULUM_LAB/energyGraph",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/energyGraph");});


define("string!PENDULUM_LAB/pendulumMassPattern",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/pendulumMassPattern");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Contains the energy plot, along with the associated controls.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/energy/view/EnergyBox',['require','SUN/AccordionBox','SCENERY/nodes/AlignBox','SUN/AquaRadioButton','DOT/Bounds2','SUN/ColorConstants','AXON/DynamicProperty','PENDULUM_LAB/energy/view/EnergyBarChartNode','PENDULUM_LAB/energy/view/EnergyLegendDialog','SUN/FontAwesomeNode','SCENERY/nodes/HBox','PHET_CORE/inherit','SCENERY/nodes/Node','SUN/Panel','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SUN/buttons/RoundPushButton','PHETCOMMON/util/StringUtils','SCENERY/nodes/Text','SCENERY/nodes/VBox','SCENERY_PHET/buttons/ZoomButton','string!PENDULUM_LAB/energyGraph','string!PENDULUM_LAB/pendulumMassPattern'],function( require ) {
  'use strict';

  // modules
  var AccordionBox = require( 'SUN/AccordionBox' );
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var AquaRadioButton = require( 'SUN/AquaRadioButton' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var ColorConstants = require( 'SUN/ColorConstants' );
  var DynamicProperty = require( 'AXON/DynamicProperty' );
  var EnergyBarChartNode = require( 'PENDULUM_LAB/energy/view/EnergyBarChartNode' );
  var EnergyLegendDialog = require( 'PENDULUM_LAB/energy/view/EnergyLegendDialog' );
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Panel = require( 'SUN/Panel' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var RoundPushButton = require( 'SUN/buttons/RoundPushButton' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var ZoomButton = require( 'SCENERY_PHET/buttons/ZoomButton' );

  // strings
  var energyGraphString = require( 'string!PENDULUM_LAB/energyGraph' );
  var pendulumMassPatternString = require( 'string!PENDULUM_LAB/pendulumMassPattern' );

  /**
   * @constructor
   *
   * @param {EnergyModel} model
   * @param {Property.<number>} chartHeightProperty
   * @param {Object} [options]
   */
  function EnergyBox( model, chartHeightProperty, options ) {
    options = _.extend( {}, PendulumLabConstants.BOX_OPTIONS, {
      expandedProperty: model.isEnergyBoxExpandedProperty,
      buttonXMargin: 10,
      buttonYMargin: 6,
      titleNode: new Text( energyGraphString, {
        font: PendulumLabConstants.TITLE_FONT,
        maxWidth: 110
      } ),
      titleAlignX: 'left',
      titleXMargin: 10,
      contentYSpacing: 0,
      resize: true
    }, options );

    var headerText = new Text( '', {
      font: PendulumLabConstants.ENERGY_HEADER_FONT,
      maxWidth: 122
    } );

    model.activeEnergyPendulumProperty.link( function( pendulum ) {
      headerText.text = StringUtils.fillIn( pendulumMassPatternString, {
        pendulumNumber: '' + ( pendulum.index + 1 )
      } );
      headerText.fill = pendulum.color;
    } );

    var kineticEnergyProperty = new DynamicProperty( model.activeEnergyPendulumProperty, { derive: 'kineticEnergyProperty' } );
    var potentialEnergyProperty = new DynamicProperty( model.activeEnergyPendulumProperty, { derive: 'potentialEnergyProperty' } );
    var thermalEnergyProperty = new DynamicProperty( model.activeEnergyPendulumProperty, {
      bidirectional: true,
      derive: 'thermalEnergyProperty'
    } );

    var graphNode = new EnergyBarChartNode( kineticEnergyProperty, potentialEnergyProperty, thermalEnergyProperty, model.energyZoomProperty, model.isEnergyBoxExpandedProperty, chartHeightProperty );
    var content = new VBox( {
      spacing: 4,
      children: [
        headerText,
        graphNode
      ]
    } );

    function createRadioButton( pendulum ) {
      var label = new Text( pendulum.index + 1, {
        font: PendulumLabConstants.TITLE_FONT
      } );
      var button = new AquaRadioButton( model.activeEnergyPendulumProperty, pendulum, label, {
        radius: label.height / 2.2,
        xSpacing: 3
      } );
      button.touchArea = button.localBounds.dilatedXY( 10, 5 );
      return button;
    }

    function createZoomButton( isIn ) {
      return new ZoomButton( _.extend( {
        in: isIn,
        listener: function() {
          var zoomMultiplier = 1.3;
          if ( isIn ) {
            model.energyZoomProperty.value *= zoomMultiplier;
          }
          else {
            model.energyZoomProperty.value /= zoomMultiplier;
          }
        }
      }, {
        baseColor: ColorConstants.LIGHT_BLUE,
        radius: 7,
        touchAreaXDilation: 5,
        touchAreaYDilation: 5
      } ) );
    }

    var radioButtonOne = createRadioButton( model.pendula[ 0 ] );
    var radioButtonTwo = createRadioButton( model.pendula[ 1 ] );

    // no need to unlink, present for the lifetime of the sim
    model.numberOfPendulaProperty.link( function( numberOfPendula ) {
      if ( numberOfPendula === 1 ) {
        model.activeEnergyPendulumProperty.value = model.pendula[ 0 ];
        radioButtonTwo.setEnabled( false );
      }
      else if ( numberOfPendula === 2 ) {
        radioButtonTwo.setEnabled( true );
      }
    } );

    var panel = new Panel( content, {
      cornerRadius: PendulumLabConstants.PANEL_CORNER_RADIUS
    } );

    var zoomOutButton = createZoomButton( false );
    var zoomInButton = createZoomButton( true );

    // Because zoom buttons don't support getting internal size, and other buttons don't resize, we need to do a
    // hacky workaround to get their content to be the same size.
    var chromeBounds = new RoundPushButton( {
      content: new Node( { localBounds: new Bounds2( 0, 0, 0, 0 ) } )
    } ).bounds;

    var iconPadding = 1;
    var icon = new FontAwesomeNode( 'info_circle', {
      fill: 'hsl(208,60%,40%)',
      maxWidth: zoomInButton.width - chromeBounds.width - 2 * iconPadding,
      maxHeight: zoomInButton.height - chromeBounds.height - 2 * iconPadding
    } );

    var energyDialog; // lazily created
    var infoButton = new RoundPushButton( {
      minXMargin: 5 + iconPadding,
      minYMargin: 5 + iconPadding,
      content: icon,
      baseColor: '#eee',
      left: panel.left,
      centerY: zoomOutButton.centerY,
      listener: function() {
        // Lazy creation.
        if ( !energyDialog ) {
          energyDialog = new EnergyLegendDialog();
        }
        energyDialog.show();
      },
      touchAreaXDilation: 10,
      touchAreaYDilation: 5
    } );

    var radioButtonBox = new HBox( {
      spacing: 20,
      children: [
        radioButtonOne,
        radioButtonTwo
      ]
    } );

    // no need to unlink, present for the lifetime of the sim
    model.numberOfPendulaProperty.link( function( numberOfPendula ) {
      radioButtonBox.visible = numberOfPendula === 2;
    } );

    var boxContent = new VBox( {
      spacing: 5,
      children: [
        radioButtonBox,
        panel,
        new Node( {
          children: [
            infoButton,
            new HBox( {
              spacing: 10,
              children: [
                zoomOutButton,
                zoomInButton
              ],
              right: panel.right
            } )
          ]
        } ),
      ]
    } );

    // add accordion box
    AccordionBox.call( this, new AlignBox( boxContent, { group: PendulumLabConstants.LEFT_CONTENT_ALIGN_GROUP } ), options );
  }

  pendulumLab.register( 'EnergyBox', EnergyBox );

  return inherit( AccordionBox, EnergyBox );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * A Scenery input listener that is able to find the closest in a list of nodes to a "down" event and trigger a drag
 * on the closest (assuming it has a SimpleDragHandler).
 *
 * Handles items of the form:
 * {
 *   startDrag: function( event ),
 *   computeDistance: function( globalPoint ) : number
 * }
 *
 * @author Jonathan Olson (PhET Interactive Simulations)
 */
define( 'SUN/ClosestDragListener',['require','PHET_CORE/inherit','SUN/sun','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @constructor
   *
   * @param {number} touchThreshold - The distance
   */
  function ClosestDragListener( touchThreshold, mouseThreshold ) {
    // @private
    this.touchThreshold = touchThreshold;
    this.mouseThreshold = mouseThreshold;

    // @private
    this.items = [];

    Tandem.indicateUninstrumentedCode();
  }

  sun.register( 'ClosestDragListener', ClosestDragListener );

  inherit( Object, ClosestDragListener, {
    /**
     * Adds an item that can be dragged.
     * @public
     *
     * @param {item} item
     */
    addDraggableItem: function( item ) {
      assert && assert( !!item.startDrag && !!item.computeDistance, 'Added an invalid item for ClosestDragListener' );
      this.items.push( item );
    },

    /**
     * Removes a previously-added item.
     * @public
     *
     * @param {item} item
     */
    removeDraggableItem: function( item ) {
      var index = _.indexOf( this.items, item );
      assert && assert( index >= 0 );
      this.items.splice( index, 1 );
    },

    down: function( event ) {
      // If there was nothing else in the way
      if ( event.target === event.currentTarget ) {
        var threshold = 0;
        if ( event.pointer.isTouch ) {
          threshold = this.touchThreshold;
        }
        if ( event.pointer.isMouse ) {
          threshold = this.mouseThreshold;
        }
        if ( threshold ) {
          // search for the closest item
          var currentItem = null;
          var currentDistance = Number.POSITIVE_INFINITY;
          var globalPoint = event.pointer.point;
          var numItems = this.items.length;
          for ( var i = 0; i < numItems; i++ ) {
            var item = this.items[ i ];

            var distance = item.computeDistance( globalPoint );
            if ( distance < currentDistance ) {
              currentDistance = distance;
              currentItem = item;
            }
          }

          // if we have a closest item under the threshold, attempt to start a drag on it
          if ( currentItem && currentDistance < threshold ) {
            currentItem.startDrag( event );
          }
        }
      }
    }
  } );

  return ClosestDragListener;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Button with one or more arrows that point up, down, left or right.
 * Press and release immediately and the button fires on 'up'.
 * Press and hold for M milliseconds and the button will fire repeatedly every N milliseconds until released.
 *
 * @author Chris Malley (PixelZoom, Inc)
 */
define( 'SUN/buttons/ArrowButton',['require','PHET_CORE/inherit','SCENERY/nodes/Path','SUN/buttons/RectangularPushButton','KITE/Shape','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );

  // constants
  var DEFAULT_ARROW_HEIGHT = 20;

  /**
   * @param {string} direction 'up'|'down'|'left'|'right'
   * @param {function} callback
   * @param {Object} [options]
   * @constructor
   */
  function ArrowButton( direction, callback, options ) {

    options = _.extend( {

      // options for the button
      cursor: 'pointer',
      baseColor: 'white',
      stroke: 'black',
      lineWidth: 1,
      cornerRadius: 4,
      xMargin: 7,
      yMargin: 5,
      touchAreaXDilation: 7,
      touchAreaYDilation: 7,

      // options for the arrows
      arrowHeight: DEFAULT_ARROW_HEIGHT, // from tip to base
      arrowWidth: DEFAULT_ARROW_HEIGHT * Math.sqrt( 3 ) / 2, // width of base
      arrowFill: 'black',
      arrowStroke: null,
      arrowLineWidth: 1,
      numberOfArrows: 1, // each arrow will have the same shape and styling
      arrowSpacing: -DEFAULT_ARROW_HEIGHT * ( 1 / 2 ), // spacing for each arrow such that they overlap slightly

      // options related to fire-on-hold feature
      fireOnHold: true,
      fireOnHoldDelay: 400, // start to fire continuously after pressing for this long (milliseconds)
      fireOnHoldInterval: 100, // fire continuously at this interval (milliseconds)

      // callbacks
      startCallback: function() {}, // called when the pointer is pressed
      endCallback: function( over ) {} // called when the pointer is released, {boolean} over indicates whether the pointer was over when released

    }, options );
    options.listener = callback;

    // arrow node
    var arrowShape = new Shape();
    for ( var i = 0; i < options.numberOfArrows; i++ ) {

      // offset for the base of the arrow, shifting the shape of the arrow when there are more than one
      var arrowOffset = i * ( options.arrowHeight + options.arrowSpacing );
      if ( direction === 'up' ) {
        arrowShape.moveTo( options.arrowHeight / 2, arrowOffset ).lineTo( options.arrowHeight, options.arrowWidth + arrowOffset ).lineTo( 0, options.arrowWidth + arrowOffset ).close();
      }
      else if ( direction === 'down' ) {
        arrowShape.moveTo( 0, arrowOffset ).lineTo( options.arrowHeight, arrowOffset ).lineTo( options.arrowHeight / 2, options.arrowWidth + arrowOffset ).close();
      }
      else if ( direction === 'left' ) {
        arrowShape.moveTo( arrowOffset, options.arrowHeight / 2 ).lineTo( options.arrowWidth + arrowOffset, 0 ).lineTo( options.arrowWidth + arrowOffset, options.arrowHeight ).close();
      }
      else if ( direction === 'right' ) {
        arrowShape.moveTo( arrowOffset, 0 ).lineTo( options.arrowWidth + arrowOffset, options.arrowHeight / 2 ).lineTo( arrowOffset, options.arrowHeight ).close();
      }
      else {
        throw new Error( 'unsupported direction: ' + direction );
      }
    }

    options.content = new Path( arrowShape, {
      fill: options.arrowFill,
      stroke: options.arrowStroke,
      lineWidth: options.arrowLineWidth,
      pickable: false
    } );

    RectangularPushButton.call( this, options );
  }

  sun.register( 'ArrowButton', ArrowButton );

  return inherit( RectangularPushButton, ArrowButton );
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * A default slider thumb, currently intended for use only in HSlider. It's a rectangle with a vertical white line down
 * the center.  The origin is at the top left (HSlider uses the thumb center for positioning).
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/HSliderThumb',['require','SCENERY/input/ButtonListener','DOT/Dimension2','PHET_CORE/inherit','SCENERY/nodes/Path','SCENERY/nodes/Rectangle','KITE/Shape','SUN/sun','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Property.<boolean>} enabledProperty
   * @param {Object} [options] see HSlider constructor
   * @constructor
   * @private
   */
  function HSliderThumb( enabledProperty, options ) {

    options = _.extend( {
      size: new Dimension2( 22, 45 ),
      fillEnabled: 'rgb(50,145,184)',
      fillHighlighted: 'rgb(71,207,255)',
      fillDisabled: '#F0F0F0',
      stroke: 'black',
      lineWidth: 1,
      centerLineStroke: 'white',
      tandem: Tandem.tandemRequired()
    }, options );

    var self = this;

    // rectangle
    var arcWidth = 0.25 * options.size.width;
    Rectangle.call( this, 0, 0,
      options.size.width, options.size.height,
      arcWidth, arcWidth,
      {
        fill: enabledProperty.get() ? options.fillEnabled : options.fillDisabled,
        stroke: options.stroke,
        lineWidth: options.lineWidth,
        cachedPaints: [
          options.fillHighlighted, options.fillEnabled, options.fillDisabled
        ]
      } );

    // vertical line down the center
    var centerLineYMargin = 3;
    this.addChild( new Path( Shape.lineSegment(
        options.size.width / 2, centerLineYMargin,
        options.size.width / 2, options.size.height - centerLineYMargin ),
      { stroke: options.centerLineStroke } ) );

    // highlight thumb on pointer over
    this.addInputListener( new ButtonListener( {
      over: function( event ) {
        if ( enabledProperty.get() ) { self.fill = options.fillHighlighted; }
      },
      up: function( event ) {
        if ( enabledProperty.get() ) { self.fill = options.fillEnabled; }
      }
    } ) );

    // @private enable/disable the look of the thumb
    var enabledObserver = function( enabled ) {
      self.fill = enabled ? options.fillEnabled : options.fillDisabled;
    };
    enabledProperty.link( enabledObserver ); // must be unlinked in disposeHSliderThumb

    // @private Called by dispose
    this.disposeHSliderThumb = function() {
      enabledProperty.unlink( enabledObserver );
    };

    // tandem support
    this.mutate( {
      tandem: options.tandem
    } );
  }

  sun.register( 'HSliderThumb', HSliderThumb );

  return inherit( Rectangle, HSliderThumb, {

    // @public - Ensures that this object is eligible for GC.
    dispose: function() {
      this.disposeHSliderThumb();
      Rectangle.prototype.dispose.call( this );
    }
  } );
} );

// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SCENERY/input/TSimpleDragHandler',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SCENERY/scenery','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var scenery = require( 'SCENERY/scenery' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * Wrapper type for phet/tandem's SimpleDragHandler class.
   * @param simpleDragHandler
   * @param phetioID
   * @constructor
   */
  function TSimpleDragHandler( simpleDragHandler, phetioID ) {
    TObject.call( this, simpleDragHandler, phetioID );
    assertInstanceOf( simpleDragHandler, phet.scenery.SimpleDragHandler );

    var toXY = function( x, y ) { return { x: x, y: y }; };
    toEventOnEmit( simpleDragHandler.startedCallbacksForDragStartedEmitter, simpleDragHandler.endedCallbacksForDragStartedEmitter, 'user', phetioID, this.constructor, 'dragStarted', toXY );
    toEventOnEmit( simpleDragHandler.startedCallbacksForDraggedEmitter, simpleDragHandler.endedCallbacksForDraggedEmitter, 'user', phetioID, this.constructor, 'dragged', toXY );
    toEventOnEmit( simpleDragHandler.startedCallbacksForDragEndedEmitter, simpleDragHandler.endedCallbacksForDragEndedEmitter, 'user', phetioID, this.constructor, 'dragEnded' );
  }

  phetioInherit( TObject, 'TSimpleDragHandler', TSimpleDragHandler, {}, {
    documentation: 'Drag listener for objects that can be dragged by the user.',
    events: [ 'dragStarted', 'dragged', 'dragEnded' ]
  } );

  scenery.register( 'TSimpleDragHandler', TSimpleDragHandler );

  return TSimpleDragHandler;
} );


// Copyright 2013-2016, University of Colorado Boulder

/**
 * Basic dragging for a node.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/input/SimpleDragHandler',['require','PHET_CORE/inherit','SCENERY/scenery','TANDEM/Tandem','AXON/Emitter','SCENERY/input/TSimpleDragHandler'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Emitter = require( 'AXON/Emitter' );

  // phet-io modules
  var TSimpleDragHandler = require( 'SCENERY/input/TSimpleDragHandler' );

  /*
   * Allowed options: {
   *    allowTouchSnag: false // allow touch swipes across an object to pick it up. If a function is passed, the value allowTouchSnag( event ) is used
   *    dragCursor: 'pointer' // while dragging with the mouse, sets the cursor to this value (or use null to not override the cursor while dragging)
   *    mouseButton: 0        // allow changing the mouse button that activates the drag listener. -1 should activate on any mouse button, 0 on left, 1 for middle, 2 for right, etc.
   *    start: null           // if non-null, called when a drag is started. start( event, trail )
   *    drag: null            // if non-null, called when the user moves something with a drag (not a start or end event).
   *                                                                         drag( event, trail )
   *    end: null             // if non-null, called when a drag is ended.   end( event, trail )
   *    translate:            // if this exists, translate( { delta: _, oldPosition: _, position: _ } ) will be called.
   * }
   */
  function SimpleDragHandler( options ) {
    var self = this;

    options = _.extend( {
      allowTouchSnag: false,
      mouseButton: 0,
      dragCursor: 'pointer',
      tandem: Tandem.tandemRequired()
    }, options );
    this.options = options; // @private

    this.dragging = false;            // whether a node is being dragged with this handler
    this.pointer = null;              // the pointer doing the current dragging
    this.trail = null;                // stores the path to the node that is being dragged
    this.transform = null;            // transform of the trail to our node (but not including our node, so we can prepend the deltas)
    this.node = null;                 // the node that we are handling the drag for
    this.lastDragPoint = null;        // the location of the drag at the previous event (so we can calculate a delta)
    this.startTransformMatrix = null; // the node's transform at the start of the drag, so we can reset on a touch cancel
    this.mouseButton = undefined;     // tracks which mouse button was pressed, so we can handle that specifically
    this.interrupted = false;         // whether the last input was interrupted (available during endDrag)
    // TODO: consider mouse buttons as separate pointers?

    // Generate all emitters in every case to minimize the number of hidden classes,
    // see http://www.html5rocks.com/en/tutorials/speed/v8/
    this.startedCallbacksForDragStartedEmitter = new Emitter( { indicateCallbacks: false } ); // @public (phet-io)
    this.endedCallbacksForDragStartedEmitter = new Emitter( { indicateCallbacks: false } ); // @public (phet-io)

    this.startedCallbacksForDraggedEmitter = new Emitter( { indicateCallbacks: false } ); // @public (phet-io)
    this.endedCallbacksForDraggedEmitter = new Emitter( { indicateCallbacks: false } ); // @public (phet-io)

    this.startedCallbacksForDragEndedEmitter = new Emitter( { indicateCallbacks: false } ); // @public (phet-io)
    this.endedCallbacksForDragEndedEmitter = new Emitter( { indicateCallbacks: false } ); // @public (phet-io)

    // if an ancestor is transformed, pin our node
    this.transformListener = {
      transform: function( args ) {
        if ( !self.trail.isExtensionOf( args.trail, true ) ) {
          return;
        }

        var newMatrix = args.trail.getMatrix();
        var oldMatrix = self.transform.getMatrix();

        // if A was the trail's old transform, B is the trail's new transform, we need to apply (B^-1 A) to our node
        self.node.prependMatrix( newMatrix.inverted().timesMatrix( oldMatrix ) );

        // store the new matrix so we can do deltas using it now
        self.transform.setMatrix( newMatrix );
      }
    };

    // this listener gets added to the pointer when it starts dragging our node
    this.dragListener = {
      // mouse/touch up
      up: function( event ) {
        if ( !self.dragging ) { return; }

        assert && assert( event.pointer === self.pointer, 'Wrong pointer in up' );
        if ( !event.pointer.isMouse || event.domEvent.button === self.mouseButton ) {
          var saveCurrentTarget = event.currentTarget;
          event.currentTarget = self.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
          self.endDrag( event );
          event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        }
      },

      // touch cancel
      cancel: function( event ) {
        if ( !self.dragging ) { return; }

        assert && assert( event.pointer === self.pointer, 'Wrong pointer in cancel' );

        var saveCurrentTarget = event.currentTarget;
        event.currentTarget = self.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
        self.endDrag( event );
        event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget

        // since it's a cancel event, go back!
        if ( !self.transform ) {
          self.node.setMatrix( self.startTransformMatrix );
        }
      },

      // mouse/touch move
      move: function( event ) {
        if ( !self.dragging ) { return; }

        assert && assert( event.pointer === self.pointer, 'Wrong pointer in move' );

        var globalDelta = self.pointer.point.minus( self.lastDragPoint );

        // ignore move events that have 0-length (Chrome seems to be auto-firing these on Windows, see https://code.google.com/p/chromium/issues/detail?id=327114)
        if ( globalDelta.magnitudeSquared() === 0 ) {
          return;
        }

        var delta = self.transform.inverseDelta2( globalDelta );

        window.phet && phet.phetio && self.startedCallbacksForDraggedEmitter.emit2( event.pointer.point.x, event.pointer.point.y );

        // move by the delta between the previous point, using the precomputed transform
        // prepend the translation on the node, so we can ignore whatever other transform state the node has
        if ( self.options.translate ) {
          var translation = self.node.getMatrix().getTranslation();
          self.options.translate.call( null, {
            delta: delta,
            oldPosition: translation,
            position: translation.plus( delta )
          } );
        }
        self.lastDragPoint = self.pointer.point;

        if ( self.options.drag ) {

          // TODO: consider adding in a delta to the listener
          // TODO: add the position in to the listener
          var saveCurrentTarget = event.currentTarget;
          event.currentTarget = self.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
          self.options.drag.call( null, event, self.trail ); // new position (old position?) delta
          event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        }
        window.phet && phet.phetio && self.endedCallbacksForDraggedEmitter.emit();
      },

      // pointer interruption
      interrupt: () => {
        self.interrupt();
      }
    };
    options.tandem.addInstance( this, TSimpleDragHandler );

    // @private
    this.disposeSimpleDragHandler = function() {
      options.tandem.removeInstance( self );
    };
  }

  scenery.register( 'SimpleDragHandler', SimpleDragHandler );

  return inherit( Object, SimpleDragHandler, {
    startDrag: function( event ) {
      if ( this.dragging ) { return; }

      // set a flag on the pointer so it won't pick up other nodes
      event.pointer.dragging = true;
      event.pointer.cursor = this.options.dragCursor;
      event.pointer.addInputListener( this.dragListener );

      // set all of our persistent information
      this.dragging = true;
      this.pointer = event.pointer;
      this.trail = event.trail.subtrailTo( event.currentTarget, true );
      this.transform = this.trail.getTransform();
      this.node = event.currentTarget;
      this.lastDragPoint = event.pointer.point;
      this.startTransformMatrix = event.currentTarget.getMatrix().copy();
      // event.domEvent may not exist if this is touch-to-snag
      this.mouseButton = event.pointer.isMouse ? event.domEvent.button : undefined;

      window.phet && phet.phetio && this.startedCallbacksForDragStartedEmitter.emit2( event.pointer.point.x, event.pointer.point.y );
      if ( this.options.start ) {
        this.options.start.call( null, event, this.trail );
      }
      window.phet && phet.phetio && this.endedCallbacksForDragStartedEmitter.emit();
    },

    endDrag: function( event ) {
      if ( !this.dragging ) { return; }

      this.pointer.dragging = false;
      this.pointer.cursor = null;
      this.pointer.removeInputListener( this.dragListener );
      this.dragging = false;

      window.phet && phet.phetio && this.startedCallbacksForDragEndedEmitter.emit();
      if ( this.options.end ) {

        // drag end may be triggered programmatically and hence event and trail may be undefined
        this.options.end.call( null, event, this.trail );
      }
      window.phet && phet.phetio && this.endedCallbacksForDragEndedEmitter.emit();

      // release our reference
      this.pointer = null;
    },

    // Called when input is interrupted on this listener, see https://github.com/phetsims/scenery/issues/218
    interrupt: function() {
      if ( this.dragging ) {
        this.interrupted = true;

        // We create a synthetic event here, as there is no available event here.
        this.endDrag( {
          pointer: this.pointer,
          currentTarget: this.node
        } );

        this.interrupted = false;
      }
    },

    tryToSnag: function( event ) {
      // don't allow drag attempts that use the wrong mouse button (-1 indicates any mouse button works)
      if ( event.pointer.isMouse && event.domEvent && this.options.mouseButton !== event.domEvent.button && this.options.mouseButton !== -1 ) {
        return;
      }

      // only start dragging if the pointer isn't dragging anything, we aren't being dragged, and if it's a mouse it's button is down
      if ( !this.dragging && !event.pointer.dragging ) {
        this.startDrag( event );
      }
    },

    tryTouchToSnag: function( event ) {
      // allow touches to start a drag by moving "over" this node, and allows clients to specify custom logic for when touchSnag is allowable
      if ( this.options.allowTouchSnag && ( this.options.allowTouchSnag === true || this.options.allowTouchSnag( event ) ) ) {
        this.tryToSnag( event );
      }
    },

    /*---------------------------------------------------------------------------*
     * events called from the node input listener
     *----------------------------------------------------------------------------*/

    // mouse/touch down on this node
    down: function( event ) {
      this.tryToSnag( event );
    },

    // touch enters this node
    touchenter: function( event ) {
      this.tryTouchToSnag( event );
    },

    // touch moves over this node
    touchmove: function( event ) {
      this.tryTouchToSnag( event );
    },

    /**
     * Disposes this listener, releasing any references it may have to a pointer.
     * @public
     */
    dispose: function() {
      if ( this.dragging ) {
        this.pointer.dragging = false;
        this.pointer.cursor = null;
        this.pointer.removeInputListener( this.dragListener );
      }
      this.disposeSimpleDragHandler();
    }
  }, {

    /**
     * Creates an input listener that forwards events to the specified input listener
     * See https://github.com/phetsims/scenery/issues/639
     * @param {function(Event)} down - down function to be added to the input listener
     * @param {Object} [options]
     * @returns {Object} a scenery input listener
     */
    createForwardingListener: function( down, options ) {

      options = _.extend( {
        allowTouchSnag: false
      }, options );

      return {
        down: function( event ) {
          if ( !event.pointer.dragging && event.canStartPress() ) {
            down( event );
          }
        },
        touchenter: function( event ) {
          options.allowTouchSnag && this.down( event );
        },
        touchmove: function( event ) {
          options.allowTouchSnag && this.down( event );
        }
      };
    }
  } );
} );



// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/THSliderTrack',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  /**
   * Wrapper type for phet/sun's HSliderTrack class.
   * @param sliderTrack
   * @param phetioID
   * @constructor
   */
  function THSliderTrack( sliderTrack, phetioID ) {
    TNode.call( this, sliderTrack, phetioID );
    assertInstanceOf( sliderTrack, phet.sun.HSliderTrack );
  }

  phetioInherit( TNode, 'THSliderTrack', THSliderTrack, {}, {
    documentation: 'The track for a knob of a traditional slider'
  } );

  sun.register( 'THSliderTrack', THSliderTrack );

  return THSliderTrack;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * A default slider track, currently intended for use only in HSlider.
 *
 * HSliderTrack is composed of two rectangles, one for the enabled section of the track and one for the disabled
 * section.  The enabled track rectangle sits on top of the disabled track so that the enabled range can be any
 * desired sub range of the full slider range.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Jesse Greenberg (PhET Interactive Simulations)
 */
define( 'SUN/HSliderTrack',['require','DOT/Dimension2','PHET_CORE/inherit','SCENERY/nodes/Node','AXON/Property','SCENERY/nodes/Rectangle','SUN/sun','TANDEM/Tandem','SCENERY/input/SimpleDragHandler','SUN/THSliderTrack'],function( require ) {
  'use strict';

  // modules
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );

  // phet-io modules
  var THSliderTrack = require( 'SUN/THSliderTrack' );

  /**
   * @param {Property.<number>} valueProperty
   * @param {function} valueToPosition - linear function that maps property value to position along the track
   * @param {function} snapToValue - function to snap to a value if slider should snap to a value on drag end
   * @param {Object} [options]
   * @constructor
   */
  function HSliderTrack( valueProperty, valueToPosition, snapToValue, options ) {

    var self = this;
    Node.call( this );

    options = _.extend( {
      size: new Dimension2( 100, 5 ),
      fillEnabled: 'white',
      fillDisabled: 'gray',
      stroke: 'black',
      lineWidth: 1,
      cornerRadius: 0,
      enabledProperty: new Property( true ), // is the track enabled?
      startDrag: function() {}, // called when a drag sequence starts
      endDrag: function() {}, // called when a drag sequence ends
      snapValue: null, // if specified, slider will snap to this value on end drag
      constrainValue: function( value ) { return value; }, // called before valueProperty is set

      // phet-io
      tandem: Tandem.tandemRequired()

    }, options );

    // @private
    this.size = options.size;
    this.enabledProperty = options.enabledProperty;

    // @public
    this.valueToPosition = valueToPosition;
    this.snapValue = options.snapValue;

    // @private - Represents the disabled range of the slider, always visible and always the full range
    // of the slider so that when the enabled range changes we see the enabled sub-range on top of the
    // full range of the slider.
    this.disabledTrack = new Rectangle( 0, 0, this.size.width, this.size.height, {
      fill: options.fillDisabled,
      stroke: options.stroke,
      lineWidth: options.lineWidth,
      cornerRadius: options.cornerRadius,
      cursor: 'default'
    } );
    this.addChild( this.disabledTrack );

    // @private - Will change size depending on the enabled range of the slider.  On top so that we can see
    // the enabled sub-range of the slider.
    this.enabledTrack = new Rectangle( 0, 0, this.size.width, this.size.height, {
      fill: options.fillEnabled,
      stroke: options.stroke,
      lineWidth: options.lineWidth,
      cornerRadius: options.cornerRadius
    } );
    this.addChild( this.enabledTrack );

    // click in the track to change the value, continue dragging if desired
    var handleTrackEvent = function( event, trail ) {
      if ( self.enabledProperty.get() ) {
        var transform = trail.subtrailTo( self ).getTransform();
        var x = transform.inversePosition2( event.pointer.point ).x;
        var value = self.valueToPosition.inverse( x );
        var newValue = options.constrainValue( value );
        valueProperty.set( newValue );
      }
    };

    var trackInputListener = new SimpleDragHandler( {
      tandem: options.tandem.createTandem( 'trackInputListener' ),

      start: function( event, trail ) {
        if ( self.enabledProperty.get() ) {
          options.startDrag();
          handleTrackEvent( event, trail );
        }
      },

      drag: function( event, trail ) {

        // Reuse the same handleTrackEvent but make sure the startedCallbacks call is made before the value changes
        handleTrackEvent( event, trail );
      },

      end: function() {
        if ( self.enabledProperty.get() ) {
          if ( typeof self.snapValue === 'number' ) {
            snapToValue( self.snapValue );
          }
          options.endDrag();
        }
      }
    } );
    this.enabledTrack.addInputListener( trackInputListener );

    // enable/disable
    var enabledObserver = function( enabled ) {
      self.enabledTrack.visible = enabled;
      if ( !enabled ) {
        if ( trackInputListener.dragging ) { trackInputListener.endDrag(); }
      }
    };
    this.enabledProperty.link( enabledObserver ); // must be unlinked in disposeHSliderTrack

    // @private Called by dispose
    this.disposeHSliderTrack = function() {
      self.enabledProperty.unlink( enabledObserver );
      trackInputListener.dispose();
    };

    this.mutate( {
      phetioType: THSliderTrack,
      tandem: options.tandem
    } );
  }

  sun.register( 'HSliderTrack', HSliderTrack );

  inherit( Node, HSliderTrack, {

    // @public - ensures that this object is eligible for GC
    dispose: function() {
      this.disposeHSliderTrack();
      Node.prototype.dispose.call( this );
    },

    /**
     * Update the dimensions of the enabled track.
     *
     * @param  {number} minX - x value for the min position of the enabled range of the track
     * @param  {number} maxX - x value for the max position of the enabled range of the track
     */
    updateEnabledTrackWidth: function( minX, maxX ) {
      var enabledWidth = maxX - minX;
      this.enabledTrack.setRect( minX, 0, enabledWidth, this.size.height );
    }
  } );

  return HSliderTrack;
} );
// Copyright 2013-2014, University of Colorado Boulder

/**
 * Function for doing a linear mapping between two domains ('a' and 'b').
 * <p>
 * Example usage:
 * <code>
 * var f = new dot.LinearFunction( 0, 100, 0, 200 );
 * f( 50 ); // 100
 * f.inverse( 100 ); // 50
 * </code>
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'DOT/LinearFunction',['require','DOT/dot','DOT/Util'],function( require ) {
  'use strict';

  var dot = require( 'DOT/dot' );

  // modules
  require( 'DOT/Util' );

  /**
   * @param {number} a1
   * @param {number} a2
   * @param {number} b1
   * @param {number} b2
   * @param {boolean} [clamp] - clamp the result to the provided ranges, false by default
   * @constructor
   */
  function LinearFunction( a1, a2, b1, b2, clamp ) {

    clamp = _.isUndefined( clamp ) ? false : clamp;

    /**
     * Linearly interpolate two points and evaluate the line equation for a third point.
     * f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>
     * Optionally clamp the result to the range [b1,b2].
     *
     * @private
     *
     * @param {number} a1
     * @param {number} a2
     * @param {number} b1
     * @param {number} b2
     * @param {number} a3
     * @param {boolean} clamp
     * @returns {number}
     */
    var map = function( a1, a2, b1, b2, a3, clamp ) {
      var b3 = dot.Util.linear( a1, a2, b1, b2, a3 );
      if ( clamp ) {
        var max = Math.max( b1, b2 );
        var min = Math.min( b1, b2 );
        b3 = dot.Util.clamp( b3, min, max );
      }
      return b3;
    };

    /**
     * Maps from a to b.
     * @public
     *
     * @param {number} a3
     * @returns {number}
     */
    var evaluate = function( a3 ) {
      return map( a1, a2, b1, b2, a3, clamp );
    };


    /**
     * Maps from b to a
     * @public
     *
     * @param {number} b3
     * @returns {number}
     */
    evaluate.inverse = function( b3 ) {
      return map( b1, b2, a1, a2, b3, clamp );
    };

    return evaluate; // return the evaluation function, so we use sites look like: f(a) f.inverse(b)
  }

  dot.register( 'LinearFunction', LinearFunction );

  return LinearFunction;
} );

// Copyright 2017, University of Colorado Boulder

/**
 * PhET-iO wrapper type for Range.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'DOT/TRange',['require','DOT/dot','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/assertions/assertInstanceOf'],function( require ) {
  'use strict';

  // modules
  var dot = require( 'DOT/dot' );

  // phet-io modules
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );

  /**
   * Wrapper type for phet/dot's Range
   * @param {Range} range
   * @param {string} phetioID
   * @constructor
   */
  function TRange( range, phetioID ) {
    assertInstanceOf( range, phet.dot.Range );
    TObject.call( this, range, phetioID );
  }

  phetioInherit( TObject, 'TRange', TRange, {}, {
    documentation: 'A range',

    /**
     * Decodes a state into a Range.
     * @param {Object} stateObject
     * @returns {Range}
     */
    fromStateObject: function( stateObject ) {
      return new phet.dot.Range( stateObject.min, stateObject.max );
    },

    /**
     * Encodes a Range instance to a state.
     * @param {Range} instance
     * @returns {Object}
     */
    toStateObject: function( instance ) {
      return { min: instance.min, max: instance.max };
    }
  } );

  dot.register( 'TRange', TRange );

  return TRange;
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/THSlider',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );

  /**
   * Wrapper type for phet/sun's HSlider class.
   * @param slider
   * @param phetioID
   * @constructor
   */
  function THSlider( slider, phetioID ) {
    TNode.call( this, slider, phetioID );
    assertInstanceOf( slider, phet.sun.HSlider );
  }

  phetioInherit( TNode, 'THSlider', THSlider, {

    setMajorTicksVisible: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( visible ) {
        this.instance.setMajorTicksVisible( visible );
      },
      documentation: 'Set whether the major tick marks should be shown'
    },

    setMinorTicksVisible: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( visible ) {
        this.instance.setMinorTicksVisible( visible );
      },
      documentation: 'Set whether the minor tick marks should be shown'
    }
  }, {
    documentation: 'A traditional slider component, with a knob and possibly tick marks'
  } );

  sun.register( 'THSlider', THSlider );

  return THSlider;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Horizontal slider.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/HSlider',['require','DOT/Dimension2','SUN/HSliderThumb','SUN/HSliderTrack','PHET_CORE/inherit','DOT/LinearFunction','SCENERY/nodes/Node','SCENERY/nodes/Path','AXON/Property','KITE/Shape','SCENERY/nodes/Rectangle','SCENERY/overlays/FocusOverlay','PHETCOMMON/util/StringUtils','SUN/sun','TANDEM/Tandem','SCENERY/input/SimpleDragHandler','SCENERY/input/Input','DOT/Util','DOT/TRange','SUN/THSlider','ifphetio!PHET_IO/types/TBoolean'],function( require ) {
  'use strict';

  // modules
  var Dimension2 = require( 'DOT/Dimension2' );
  var HSliderThumb = require( 'SUN/HSliderThumb' );
  var HSliderTrack = require( 'SUN/HSliderTrack' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearFunction = require( 'DOT/LinearFunction' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Property = require( 'AXON/Property' );
  var Shape = require( 'KITE/Shape' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var FocusOverlay = require( 'SCENERY/overlays/FocusOverlay' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
  var Input = require( 'SCENERY/input/Input' );
  var Util = require( 'DOT/Util' );
  var TRange = require( 'DOT/TRange' );

  // phet-io modules
  var THSlider = require( 'SUN/THSlider' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );

  /**
   * @param {Property.<number>} valueProperty
   * @param { {min:number, max:number} } range
   * @param {Object} [options]
   * @constructor
   */
  function HSlider( valueProperty, range, options ) {

    var self = this;
    Node.call( this );

    // Add tandems to default Properties, but only if we know they will be needed
    if ( options && !options.enabledProperty && options.tandem ) {
      options.enabledProperty = new Property( true, {
        tandem: options.tandem.createTandem( 'enabledProperty' ),
        phetioValueType: TBoolean
      } );
    }
    if ( options && !options.enabledRangeProperty && options.tandem ) {
      options.enabledRangeProperty = new Property( range, {
        tandem: options.tandem.createTandem( 'enabledRangeProperty' ),
        phetioValueType: TRange
      } );
    }

    options = _.extend( {

      // track
      trackSize: new Dimension2( 100, 5 ),
      trackFillEnabled: 'white',
      trackFillDisabled: 'gray',
      trackStroke: 'black',
      trackLineWidth: 1,
      trackCornerRadius: 0,

      // {Node} optional thumb, replaces the default.
      // Client is responsible for highlighting, disabling and pointer areas.
      // The thumb is positioned based on its center and hence can have its origin anywhere
      thumbNode: null,

      // Options for the default thumb, ignored if thumbNode is set
      thumbSize: new Dimension2( 22, 45 ),
      thumbFillEnabled: 'rgb(50,145,184)',
      thumbFillHighlighted: 'rgb(71,207,255)',
      thumbFillDisabled: '#F0F0F0',
      thumbStroke: 'black',
      thumbLineWidth: 1,
      thumbYOffset: 0, // center of the thumb is vertically offset by this amount from the center of the track
      thumbCenterLineStroke: 'white',
      thumbTouchAreaXDilation: 11,
      thumbTouchAreaYDilation: 11,
      thumbMouseAreaXDilation: 0,
      thumbMouseAreaYDilation: 0,

      // ticks
      tickLabelSpacing: 6,
      majorTickLength: 25,
      majorTickStroke: 'black',
      majorTickLineWidth: 1,
      minorTickLength: 10,
      minorTickStroke: 'black',
      minorTickLineWidth: 1,

      // other
      cursor: 'pointer',
      enabledProperty: new Property( true ),
      enabledRangeProperty: new Property( range ), // controls the portion of the slider that is enabled
      snapValue: null, // if specified, slider will snap to this value on end drag
      startDrag: function() {}, // called when a drag sequence starts
      endDrag: function() {}, // called when a drag sequence ends
      constrainValue: function( value ) { return value; }, // called before valueProperty is set

      // a11y
      tagName: 'input',
      inputType: 'range',
      ariaRole: 'slider', // required for NVDA to read the value text correctly, see https://github.com/phetsims/a11y-research/issues/51
      accessibleValuePattern: '{{value}}', // {string} if you want units or additional content, add to pattern
      accessibleDecimalPlaces: 0, // number of decimal places for the value read by assistive technology
      keyboardStep: ( range.max - range.min ) / 20,
      shiftKeyboardStep: ( range.max - range.min ) / 100,
      pageKeyboardStep: ( range.max - range.min ) / 10,
      focusHighlightLineWidth: 4,

      // phet-io
      tandem: Tandem.tandemRequired(),
      phetioType: THSlider
    }, options );

    // @public
    this.enabledProperty = options.enabledProperty;
    this.enabledRangeProperty = options.enabledRangeProperty;

    // @private options needed by prototype functions that add ticks
    this.tickOptions = _.pick( options, 'tickLabelSpacing',
      'majorTickLength', 'majorTickStroke', 'majorTickLineWidth',
      'minorTickLength', 'minorTickStroke', 'minorTickLineWidth' );

    // @private
    this._snapValue = options.snapValue;

    // @private (a11y) - delta for the valueProperty when using keyboard to interact with slider
    this._keyboardStep = options.keyboardStep;

    // @private (a11y) - delta or the valueProperty when holding shift and using the keyboard to interact with
    // the slider
    this._shiftKeyboardStep = options.shiftKeyboardStep;
    this._pageKeyboardStep = options.pageKeyboardStep;

    // @private ticks are added to these parents, so they are behind the knob
    this.majorTicksParent = new Node();
    this.minorTicksParent = new Node();
    this.addChild( this.majorTicksParent );
    this.addChild( this.minorTicksParent );

    // @private mapping between value and track position
    this.valueToPosition = new LinearFunction( range.min, range.max, 0, options.trackSize.width, true /* clamp */ );

    // snap to a value if value is within range, used by HSlider and HSliderTrack
    var snapToValue = function( value ) {
      if ( value <= range.max && value >= range.min ) {
        valueProperty.set( value );
      }
      else {
        throw new Error( 'value is out of range: ' + value );
      }
    };

    // @private track
    this.track = new HSliderTrack( valueProperty, this.valueToPosition, snapToValue, {

      // propagate options that are specific to HSliderTrack
      size: options.trackSize,
      fillEnabled: options.trackFillEnabled,
      fillDisabled: options.trackFillDisabled,
      stroke: options.trackStroke,
      lineWidth: options.trackLineWidth,
      cornerRadius: options.trackCornerRadius,
      enabledProperty: options.enabledProperty,
      startDrag: options.startDrag,
      endDrag: options.endDrag,
      snapValue: options.snapValue,
      constrainValue: options.constrainValue,

      // phet-io
      tandem: options.tandem.createTandem( 'track' )
    } );
    this.track.centerX = this.valueToPosition( ( range.max + range.min ) / 2 );

    // The thumb of the slider
    var thumb = options.thumbNode || new HSliderThumb( this.enabledProperty, {

      // propagate options that are specific to HSliderThumb
      size: options.thumbSize,
      fillEnabled: options.thumbFillEnabled,
      fillHighlighted: options.thumbFillHighlighted,
      fillDisabled: options.thumbFillDisabled,
      stroke: options.thumbStroke,
      lineWidth: options.thumbLineWidth,
      centerLineStroke: options.thumbCenterLineStroke,
      tandem: options.tandem.createTandem( 'thumb' )
    } );

    // Dilate the local bounds horizontally so that it extends beyond where the thumb can reach.  This prevents layout
    // asymmetry when the slider thumb is off the edges of the track.  See https://github.com/phetsims/sun/issues/282
    this.track.localBounds = this.track.localBounds.dilatedX( thumb.width / 2 );

    // Add the track
    this.addChild( this.track );

    // do this outside of options hash, so that it applied to both default and custom thumbs
    thumb.centerY = this.track.centerY + options.thumbYOffset;
    this.addChild( thumb );

    // touchArea for the default thumb. If a custom thumb is provided, the client is responsible for its touchArea.
    if ( !options.thumbNode && ( options.thumbTouchAreaXDilation || options.thumbTouchAreaYDilation ) ) {
      thumb.touchArea = thumb.localBounds.dilatedXY( options.thumbTouchAreaXDilation, options.thumbTouchAreaYDilation );
    }

    // mouseArea for the default thumb. If a custom thumb is provided, the client is responsible for its mouseArea.
    if ( !options.thumbNode && ( options.thumbMouseAreaXDilation || options.thumbMouseAreaYDilation ) ) {
      thumb.mouseArea = thumb.localBounds.dilatedXY( options.thumbMouseAreaXDilation, options.thumbMouseAreaYDilation );
    }

    // update value when thumb is dragged
    var clickXOffset = 0; // x-offset between initial click and thumb's origin
    var thumbInputListener = new SimpleDragHandler( {

      tandem: options.tandem.createTandem( 'thumbInputListener' ),

      allowTouchSnag: true,

      start: function( event, trail ) {
        if ( self.enabledProperty.get() ) {
          options.startDrag();
          var transform = trail.subtrailTo( self ).getTransform();

          // Determine the offset relative to the center of the thumb
          clickXOffset = transform.inversePosition2( event.pointer.point ).x - thumb.centerX;
        }
      },

      drag: function( event, trail ) {
        if ( self.enabledProperty.get() ) {
          var transform = trail.subtrailTo( self ).getTransform(); // we only want the transform to our parent
          var x = transform.inversePosition2( event.pointer.point ).x - clickXOffset;
          var newValue = self.valueToPosition.inverse( x );

          valueProperty.set( options.constrainValue( newValue ) );
        }
      },

      end: function() {
        if ( self.enabledProperty.get() ) {
          if ( typeof self._snapValue === 'number' ) {
            snapToValue( self._snapValue );
          }
          options.endDrag();
        }
      }
    } );
    thumb.addInputListener( thumbInputListener );

    // enable/disable
    var enabledObserver = function( enabled ) {
      self.cursor = self.enabledProperty.get() ? options.cursor : 'default';
      if ( !enabled ) {
        if ( thumbInputListener.dragging ) { thumbInputListener.endDrag(); }
      }
      self.pickable = enabled;
    };
    this.enabledProperty.link( enabledObserver ); // must be unlinked in disposeHSlider

    // a11y - custom focus highlight that surrounds and moves with the thumb
    this.focusHighlight = Rectangle.bounds( thumb.bounds.dilated( 5 ), {
      stroke: FocusOverlay.innerFocusColor,
      lineWidth: options.focusHighlightLineWidth
    } );

    // update thumb location when value changes
    var valueObserver = function( value ) {
      thumb.centerX = self.valueToPosition( value );
      self.focusHighlight.centerX = thumb.centerX;
    };
    valueProperty.link( valueObserver ); // must be unlinked in disposeHSlider

    // when the enabled range changes, the value to position linear function must change as well
    var enabledRangeObserver = function( enabledRange ) {

      assert && assert( enabledRange.min >= range.min && enabledRange.max <= range.max, 'enabledRange is out of range' );

      var initialValueToPosition = new LinearFunction( range.min, range.max, 0, options.trackSize.width, true /* clamp */ );
      var min = initialValueToPosition( enabledRange.min );
      var max = initialValueToPosition( enabledRange.max );

      // update the geometry of the enabled track
      self.track.updateEnabledTrackWidth( min, max );

      // update the function that maps value to position for the track and the slider
      self.valueToPosition = new LinearFunction( enabledRange.min, enabledRange.max, min, max, true /* clamp */ );
      self.track.valueToPosition = self.valueToPosition;

      // clamp the value to the enabled range if it changes
      valueProperty.set( Util.clamp( valueProperty.value, enabledRange.min, enabledRange.max ) );
    };
    this.enabledRangeProperty.link( enabledRangeObserver ); // needs to be unlinked in dispose function

    this.mutate( options );

    // a11y - Implements the keyboard interaction for a typical HTML range slider - browsers place limitations
    // on the interaction when the slider range is not evently divisible by the step size.  Rather
    // than allow the browser to natively change the valueProperty with an input event, we decided to roll our
    // own implementation, but keep the general behavior the same.
    var accessibleInputListener = this.addAccessibleInputListener( {
      keydown: function( event ) {
        var code = event.keyCode;

        if ( self.enabledProperty.get() ) {

          // Prevent default so browser doesn't change input value automatically
          if ( Input.isRangeKey( code ) ) {
            event.preventDefault();
          }

          var newValue = valueProperty.get();
          if ( code === Input.KEY_END || code === Input.KEY_HOME ) {

            // on 'end' and 'home' snap to max and min of enabled range respectively (this is typical browser
            // behavior for sliders)
            if ( code === Input.KEY_END ) {
              newValue = self.enabledRange.max;
            }
            else if ( code === Input.KEY_HOME ) {
              newValue = self.enabledRange.min;
            }
          }
          else {
            var stepSize;
            if ( code === Input.KEY_PAGE_UP || code === Input.KEY_PAGE_DOWN ) {

              // on page up and page down, the default step size is 1/10 of the range (this is typical browser behavior)
              stepSize = options.pageKeyboardStep;

              if ( code === Input.KEY_PAGE_UP ) {
                newValue = valueProperty.get() + stepSize;
              }
              else if ( code === Input.KEY_PAGE_DOWN ) {
                newValue = valueProperty.get() - stepSize;
              }
            }
            else if ( Input.isArrowKey( code ) ) {

              // if the shift key is pressed down, modify the step size (this is atypical browser behavior for sliders)
              stepSize = event.shiftKey ? self.shiftKeyboardStep : self.keyboardStep;
              //

              if ( code === Input.KEY_RIGHT_ARROW || code === Input.KEY_UP_ARROW ) {
                newValue = valueProperty.get() + stepSize;
              }
              else if ( code === Input.KEY_LEFT_ARROW || code === Input.KEY_DOWN_ARROW ) {
                newValue = valueProperty.get() - stepSize;
              }

              // round the value to the nearest keyboard step
              newValue = Util.roundSymmetric( newValue / stepSize ) * stepSize;

              // it is possible to pass a value in either direction due to rounding, go up or down a step if we have
              // passed the nearest step
              if ( Util.toFixedNumber( Math.abs( newValue - valueProperty.get() ), 5 ) > stepSize ) {
                newValue += ( newValue > valueProperty.get() ) ? ( -1 * stepSize ) : stepSize;
              }
            }

            // limit the value to the enabled range
            newValue = Util.clamp( newValue, self.enabledRange.min, self.enabledRange.max );
          }

          // optionally constrain the value further
          valueProperty.set( options.constrainValue( newValue ) );
        }
      }
    } );


    // a11y - when the property changes, be sure to update the accessible input value and
    // aria-valuetext for assistive, which is read by assistive technology when the value changes
    var accessiblePropertyListener = function( value ) {
      self.inputValue = value;

      // format the value text for reading
      var formattedValue = Util.toFixed( value, options.accessibleDecimalPlaces );
      var valueText = StringUtils.fillIn( options.accessibleValuePattern, {
        value: formattedValue
      } );
      self.setAccessibleAttribute( 'aria-valuetext', valueText );
    };

    valueProperty.link( accessiblePropertyListener );

    // @private Called by dispose
    this.disposeHSlider = function() {
      thumb.dispose && thumb.dispose(); // in case a custom thumb is provided via options.thumbNode that doesn't implement dispose
      self.track.dispose();
      valueProperty.unlink( valueObserver );
      self.enabledRangeProperty.unlink( enabledRangeObserver );
      self.enabledProperty.unlink( enabledObserver );
      self.removeAccessibleInputListener( accessibleInputListener );
      valueProperty.unlink( accessiblePropertyListener );

      thumbInputListener.dispose();
    };
  }

  sun.register( 'HSlider', HSlider );

  inherit( Node, HSlider, {

    // @public - ensures that this object is eligible for GC
    dispose: function() {
      this.disposeHSlider();
      Node.prototype.dispose.call( this );
    },

    /**
     * Adds a major tick mark.
     * @param {number} value
     * @param {Node} [label] optional
     * @public
     */
    addMajorTick: function( value, label ) {
      this.addTick( this.majorTicksParent, value, label,
        this.tickOptions.majorTickLength, this.tickOptions.majorTickStroke, this.tickOptions.majorTickLineWidth );
    },

    /**
     * Adds a minor tick mark.
     * @param {number} value
     * @param {Node} [label] optional
     * @public
     */
    addMinorTick: function( value, label ) {
      this.addTick( this.minorTicksParent, value, label,
        this.tickOptions.minorTickLength, this.tickOptions.minorTickStroke, this.tickOptions.minorTickLineWidth );
    },

    /*
     * Adds a tick mark above the track.
     * @param {Node} parent
     * @param {number} value
     * @param {Node} [label] optional
     * @param {number} length
     * @param {number} stroke
     * @param {number} lineWidth
     * @private
     */
    addTick: function( parent, value, label, length, stroke, lineWidth ) {
      var labelX = this.valueToPosition( value );
      // ticks
      var tick = new Path( new Shape()
          .moveTo( labelX, this.track.top )
          .lineTo( labelX, this.track.top - length ),
        { stroke: stroke, lineWidth: lineWidth } );
      parent.addChild( tick );
      // label
      if ( label ) {
        parent.addChild( label );
        label.centerX = tick.centerX;
        label.bottom = tick.top - this.tickOptions.tickLabelSpacing;
      }
    },

    // @public
    setEnabled: function( enabled ) { this.enabledProperty.value = enabled; },
    set enabled( value ) { this.setEnabled( value ); },

    // @public
    getEnabled: function() { return this.enabledProperty.value; },
    get enabled() { return this.getEnabled(); },

    // @public
    setEnabledRange: function( enabledRange ) { this.enabledRangeProperty.value = enabledRange; },
    set enabledRange( range ) { this.setEnabledRange( range ); },

    // @public
    getEnabledRange: function() { return this.enabledRangeProperty.value; },
    get enabledRange() { return this.getEnabledRange(); },

    // @public
    setSnapValue: function( snapValue ) {
      this._snapValue = snapValue;
      this.track.snapValue = snapValue;
    },
    set snapValue( snapValue ) { this.setSnapValue( snapValue ); },

    // @public
    getSnapValue: function() { return this._snapValue; },
    get snapValue() { return this.getSnapValue(); },

    // @public
    setKeyboardStep: function( keyboardStep ) {
      this._keyboardStep = keyboardStep;
    },
    set keyboardStep( keyboardStep ) { this.setKeyboardStep( keyboardStep ); },

    // @public
    getKeyboardStep: function() {
      return this._keyboardStep;
    },
    get keyboardStep() { return this.getKeyboardStep(); },

    // @public
    setShiftKeyboardStep: function( shiftKeyboardStep ) {
      this._shiftKeyboardStep = shiftKeyboardStep;
    },
    set shiftKeyboardStep( shiftKeyboardStep ) { this.setShiftKeyboardStep( shiftKeyboardStep ); },

    // @public
    getShiftKeyboardStep: function() {
      return this._shiftKeyboardStep;
    },
    get shiftKeyboardStep() { return this.getShiftKeyboardStep(); },

    // @public
    getPageKeyboardStep: function() {
      return this._pageKeyboardStep;
    },
    get pageKeyboardStep() { return this.getPageKeyboardStep(); },

    // @public
    setPageKeyboardStep: function( pageKeyboardStep ) {
      this._pageKeyboardStep = pageKeyboardStep;
    },
    set pageKeyboardStep( pageKeyboardStep ) { this.setPageKeyboardStep( pageKeyboardStep ); },

    // @public - Sets visibility of major ticks.
    setMajorTicksVisible: function( visible ) {
      this.majorTicksParent.visible = visible;
    },
    set majorTicksVisible( value ) { this.setMajorTicksVisible( value ); },

    // @public - Gets visibility of major ticks.
    getMajorTicksVisible: function() {
      return this.majorTicksParent.visible;
    },
    get majorTicksVisible() { return this.getMajorTicksVisible(); },

    // @public - Sets visibility of minor ticks.
    setMinorTicksVisible: function( visible ) {
      this.minorTicksParent.visible = visible;
    },
    set minorTicksVisible( value ) { this.setMinorTicksVisible( value ); },

    // @public - Gets visibility of minor ticks.
    getMinorTicksVisible: function() {
      return this.minorTicksParent.visible;
    },
    get minorTicksVisible() { return this.getMinorTicksVisible(); }
  } );

  return HSlider;
} );

// Copyright 2017, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SCENERY_PHET/TNumberDisplay',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * Wrapper type for phet/scenery-phet's NumberDisplay class.
   * @param numberControl
   * @param phetioID
   * @constructor
   */
  function TNumberDisplay( numberControl, phetioID ) {
    TNode.call( this, numberControl, phetioID );
    assertInstanceOf( numberControl, phet.sceneryPhet.NumberDisplay );
  }

  phetioInherit( TNode, 'TNumberControl', TNumberDisplay, {}, {
    documentation: 'A numeric readout with a background'
  } );

  sceneryPhet.register( 'TNumberDisplay', TNumberDisplay );

  return TNumberDisplay;
} );
// Copyright 2015-2017, University of Colorado Boulder

/**
 * Displays a Property of type {number} in a background rectangle.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/NumberDisplay',['require','SCENERY_PHET/PhetFont','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/RichText','PHETCOMMON/util/StringUtils','SCENERY/nodes/Text','DOT/Util','SCENERY_PHET/sceneryPhet','TANDEM/Tandem','SCENERY_PHET/TNumberDisplay'],function( require ) {
  'use strict';

  // modules
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var RichText = require( 'SCENERY/nodes/RichText' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TNumberDisplay = require( 'SCENERY_PHET/TNumberDisplay' );

  // valid values for options.align
  var ALIGN_VALUES = [ 'center', 'left', 'right' ];

  /**
   * @param {Property.<number>} numberProperty
   * @param {Range} numberRange
   * @param {Object} [options]
   * @constructor
   */
  function NumberDisplay( numberProperty, numberRange, options ) {

    options = _.extend( {
      align: 'right', // see ALIGN_VALUES

      /// {string} Pattern used to format the value. Must contain '{0}'.
      // If you want units or other verbiage, add them to the pattern, e.g. '{0} L'
      valuePattern: '{0}',
      useRichText: false,
      font: new PhetFont( 20 ),
      decimalPlaces: 0,
      xMargin: 8,
      yMargin: 2,
      cornerRadius: 0,
      numberFill: 'black',
      numberMaxWidth: 200,
      backgroundFill: 'white',
      backgroundStroke: 'lightGray',
      backgroundLineWidth: 1,
      tandem: Tandem.tandemRequired(),
      phetioType: TNumberDisplay
    }, options );

    // validate options
    assert && assert( _.includes( ALIGN_VALUES, options.align ), 'invalid align: ' + options.align );

    var self = this;

    // determine the widest value
    var minString = Util.toFixed( numberRange.min, options.decimalPlaces );
    var maxString = Util.toFixed( numberRange.max, options.decimalPlaces );
    var widestString = StringUtils.format( options.valuePattern, ( ( minString.length > maxString.length ) ? minString : maxString ) );

    // value
    var Constructor = options.useRichText ? RichText : Text;
    this.valueNode = new Constructor( widestString, {
      font: options.font,
      fill: options.numberFill,
      maxWidth: options.numberMaxWidth,
      tandem: options.tandem.createTandem( 'valueNode' )
    } );

    // @private background
    this.backgroundNode = new Rectangle( 0, 0, this.valueNode.width + 2 * options.xMargin, this.valueNode.height + 2 * options.yMargin, {
      cornerRadius: options.cornerRadius,
      fill: options.backgroundFill,
      stroke: options.backgroundStroke,
      lineWidth: options.backgroundLineWidth
    } );
    this.valueNode.centerY = this.backgroundNode.centerY;

    options.children = [ this.backgroundNode, this.valueNode ];

    // display the value
    var numberObserver = function( value ) {

      // update the value
      self.valueNode.text = StringUtils.format( options.valuePattern, Util.toFixed( value, options.decimalPlaces ) );

      // horizontally align value in background
      if ( options.align === 'center' ) {
        self.valueNode.centerX = self.backgroundNode.centerX;
      }
      else if ( options.align === 'left' ) {
        self.valueNode.left = self.backgroundNode.left + options.xMargin;
      }
      else { // right
        self.valueNode.right = self.backgroundNode.right - options.xMargin;
      }
    };
    numberProperty.link( numberObserver );

    // @private called by dispose
    this.disposeNumberDisplay = function() {
      numberProperty.unlink( numberObserver );
    };

    Node.call( this, options );
  }

  sceneryPhet.register( 'NumberDisplay', NumberDisplay );

  return inherit( Node, NumberDisplay, {

    // @public
    dispose: function() {
      this.disposeNumberDisplay();
      Node.prototype.dispose.call( this );
    },

    /**
     * Sets the number text font.
     * @param {Font} font
     * @public
     */
    setNumberFont: function( font ) {
      this.valueNode.font = font;
    },
    set numberFont( value ) { this.setNumberFont( value ); },

    /**
     * Sets the number text fill.
     * @param {Color|string} fill
     * @public
     */
    setNumberFill: function( fill ) {
      this.valueNode.fill = fill;
    },
    set numberFill( value ) { this.setNumberFill( value ); },

    /**
     * Sets the background fill.
     * @param {Color|string} fill
     * @public
     */
    setBackgroundFill: function( fill ) {
      this.backgroundNode.fill = fill;
    },
    set backgroundFill( value ) { this.setBackgroundFill( value ); },

    /**
     * Sets the background stroke.
     * @param {Color|string} stroke
     * @public
     */
    setBackgroundStroke: function( stroke ) {
      this.backgroundNode.stroke = stroke;
    },
    set backgroundStroke( value ) { this.setBackgroundStroke( value ); }
  } );
} );

// Copyright 2017, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SCENERY_PHET/TNumberControl',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * Wrapper type for phet/scenery-phet's NumberControl class.
   * @param numberControl
   * @param phetioID
   * @constructor
   */
  function TNumberControl( numberControl, phetioID ) {
    TNode.call( this, numberControl, phetioID );
    assertInstanceOf( numberControl, phet.sceneryPhet.NumberControl );
  }

  phetioInherit( TNode, 'TNumberControl', TNumberControl, {}, {
    documentation: 'A number control with a title, slider and +/- buttons'
  } );

  sceneryPhet.register( 'TNumberControl', TNumberControl );

  return TNumberControl;
} );
// Copyright 2015-2017, University of Colorado Boulder

/**
 * Control for changing a Property of type {number}.
 * Consists of a labeled value, slider and arrow buttons.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/NumberControl',['require','SUN/buttons/ArrowButton','SCENERY/util/Color','DOT/Dimension2','SCENERY/nodes/HBox','SUN/HSlider','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/NumberDisplay','SCENERY_PHET/PhetFont','AXON/Property','SCENERY_PHET/sceneryPhet','TANDEM/Tandem','SCENERY/nodes/Text','DOT/Util','SCENERY/nodes/VBox','SCENERY_PHET/TNumberControl'],function( require ) {
  'use strict';

  // modules
  var ArrowButton = require( 'SUN/buttons/ArrowButton' );
  var Color = require( 'SCENERY/util/Color' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var HSlider = require( 'SUN/HSlider' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var NumberDisplay = require( 'SCENERY_PHET/NumberDisplay' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Property = require( 'AXON/Property' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var TNumberControl = require( 'SCENERY_PHET/TNumberControl' );

  /**
   * @param {string} title
   * @param {Property.<number>} numberProperty
   * @param {Range} numberRange
   * @param {Object} [options]
   * @constructor
   */
  function NumberControl( title, numberProperty, numberRange, options ) {

    options = _.extend( {

      startCallback: function() {}, // called when interaction begins
      endCallback: function() {}, // called when interaction ends
      enabledProperty: new Property( true ), // {Property.<boolean>} is this control enabled?
      disabledOpacity: 0.5, // {number} opacity used to make the control look disabled

      // title
      titleFont: new PhetFont( 12 ),
      titleMaxWidth: null, // {null|string} maxWidth to use for title, to constrain width for i18n

      // value
      valueFont: new PhetFont( 12 ),
      valueAlign: 'right',
      valueMaxWidth: null, // {null|string} maxWidth to use for value display, to constrain width for i18n
      valueXMargin: 8,
      valueYMargin: 2,
      valueBackgroundStroke: 'lightGray',
      valueBackgroundLineWidth: 1,
      valueBackgroundCornerRadius: 0,
      decimalPlaces: 0,
      useRichText: false,

      // {string} Pattern used to format the value. Must contain '{0}'.
      // If you want units or other verbiage, add them to the pattern, e.g. '{0} L'
      valuePattern: '{0}',

      // arrow buttons
      delta: 1,

      // With the exception of startDrag and endDrag (use startCallback and endCallback respectively),
      // all HSlider options may be used. These are the ones that NumberControl overrides:
      trackSize: new Dimension2( 180, 3 ),
      thumbSize: new Dimension2( 17, 34 ),
      majorTickLength: 20,
      minorTickStroke: 'rgba( 0, 0, 0, 0.3 )',

      // other slider options that are specific to NumberControl
      majorTicks: [], // array of objects with these fields: { value: {number}, label: {Node} }
      minorTickSpacing: 0, // zero indicates no minor ticks

      // A {function} that handles layout of subcomponents.
      // It has signature function( titleNode, numberDisplay, slider, leftArrowButton, rightArrowButton )
      // and returns a Node. If you want to customize the layout, use one of the predefined creators
      // (see createLayoutFunction*) or create your own function.
      layoutFunction: NumberControl.createLayoutFunction1(),

      // scale factor applied to the arrow buttons
      arrowButtonScale: 0.85,

      // phet-io
      tandem: Tandem.tandemRequired(),
      phetioType: TNumberControl
    }, options );

    // highlight color for thumb defaults to a brighter version of the thumb color
    if ( options.thumbFillEnabled && !options.thumbFillHighlighted ) {
      options.thumbFillHighlighted = Color.toColor( options.thumbFillEnabled ).brighterColor();
    }

    // constrain the slider value to the provided range and the same delta as the arrow buttons
    options.constrainValue = options.constrainValue || function( value ) {
        var newValue = Util.roundSymmetric( value / options.delta ) * options.delta;
        return numberRange.constrainValue( newValue );
      };

    // validate options
    assert && assert( !options.startDrag, 'use options.startCallback instead of options.startDrag' );
    assert && assert( !options.endDrag, 'use options.endCallback instead of options.endDrag' );
    assert && assert( options.disabledOpacity > 0 && options.disabledOpacity < 1, 'invalid disabledOpacity: ' + options.disabledOpacity );

    var self = this;

    var delta = options.delta; // to improve readability

    var titleNode = new Text( title, {
      font: options.titleFont,
      maxWidth: options.titleMaxWidth,
      tandem: options.tandem.createTandem( 'titleNode' )
    } );

    var numberDisplay = new NumberDisplay( numberProperty, numberRange, {
      useRichText: options.useRichText,
      valuePattern: options.valuePattern,
      font: options.valueFont,
      align: options.valueAlign,
      decimalPlaces: options.decimalPlaces,
      xMargin: options.valueXMargin,
      yMargin: options.valueYMargin,
      backgroundStroke: options.valueBackgroundStroke,
      backgroundLineWidth: options.valueBackgroundLineWidth,
      cornerRadius: options.valueBackgroundCornerRadius,
      maxWidth: options.valueMaxWidth,
      tandem: options.tandem.createTandem( 'numberDisplay' )
    } );

    var arrowButtonOptions = {
      delta: options.delta,
      startCallback: options.startCallback,
      endCallback: options.endCallback,
      scale: options.arrowButtonScale
    };

    var leftArrowButton = new ArrowButton( 'left', function() {
      var value = numberProperty.get() - delta;
      value = Util.roundSymmetric( value / delta ) * delta; // constrain to delta
      value = Math.max( value, numberRange.min ); // constrain to range
      numberProperty.set( value );
    }, _.extend( {
      tandem: options.tandem.createTandem( 'leftArrowButton' )
    }, arrowButtonOptions ) );

    var rightArrowButton = new ArrowButton( 'right', function() {
      var value = numberProperty.get() + delta;
      value = Util.roundSymmetric( value / delta ) * delta; // constrain to delta
      value = Math.min( value, numberRange.max ); // constrain to range
      numberProperty.set( value );
    }, _.extend( {
      tandem: options.tandem.createTandem( 'rightArrowButton' )
    }, arrowButtonOptions ) );

    var arrowEnabledListener = function( value ) {
      leftArrowButton.enabled = ( value > numberRange.min );
      rightArrowButton.enabled = ( value < numberRange.max );
    };
    numberProperty.link( arrowEnabledListener );

    var slider = new HSlider( numberProperty, numberRange, _.extend(
      // prevent supertype options from being passed, see https://github.com/phetsims/scenery-phet/issues/255
      _.omit( options, Node.prototype._mutatorKeys ),
      {
        // Use these more general callback options, because the same callbacks apply to the arrow buttons,
        // where it makes no sense to call them startDrag and endDrag.
        startDrag: options.startCallback,
        endDrag: options.endCallback,
        tandem: options.tandem.createTandem( 'slider' )
      } ) );

    // major ticks
    var majorTicks = options.majorTicks;
    for ( var i = 0; i < majorTicks.length; i++ ) {
      slider.addMajorTick( majorTicks[ i ].value, majorTicks[ i ].label );
    }

    // minor ticks, exclude values where we already have major ticks
    if ( options.minorTickSpacing > 0 ) {
      for ( var minorTickValue = numberRange.min; minorTickValue <= numberRange.max; ) {
        if ( !_.find( majorTicks, function( majorTick ) { return majorTick.value === minorTickValue; } ) ) {
          slider.addMinorTick( minorTickValue );
        }
        minorTickValue += options.minorTickSpacing;
      }
    }

    options.children = [
      options.layoutFunction( titleNode, numberDisplay, slider, leftArrowButton, rightArrowButton )
    ];
    Node.call( this, options );

    // enabled/disable this control
    this.enabledProperty = options.enabledProperty; // @public
    var enabledObserver = function( enabled ) {
      self.pickable = enabled;
      self.opacity = enabled ? 1.0 : options.disabledOpacity;
      //TODO if !enabled, cancel any interaction that is in progress, see scenery#218
    };
    this.enabledProperty.link( enabledObserver );

    // @private
    this.disposeNumberControl = function() {

      numberDisplay.dispose();
      leftArrowButton.dispose();
      rightArrowButton.dispose();
      slider.dispose();

      numberProperty.unlink( arrowEnabledListener );
      self.enabledProperty.unlink( enabledObserver );
    };
  }

  sceneryPhet.register( 'NumberControl', NumberControl );

  return inherit( VBox, NumberControl, {

    // @public
    dispose: function() {
      this.disposeNumberControl();
      VBox.prototype.dispose.call( this );
    },

    // @public
    setEnabled: function( enabled ) { this.enabledProperty.set( enabled ); },
    set enabled( value ) { this.setEnabled( value ); },

    // @public
    getEnabled: function() { return this.enabledProperty.get(); },
    get enabled() { return this.getEnabled(); }

  }, {

    /**
     * Creates a NumberControl with default tick marks for min and max values.
     * @param {string} label
     * @param {Property.<number>} property
     * @param {Range} range
     * @param {Object} [options]
     * @returns {NumberControl}
     * @static
     * @public
     */
    withMinMaxTicks: function( label, property, range, options ) {

      options = _.extend( {
        tickLabelFont: new PhetFont( 12 )
      }, options );

      options.majorTicks = [
        { value: range.min, label: new Text( range.min, { font: options.tickLabelFont } ) },
        { value: range.max, label: new Text( range.max, { font: options.tickLabelFont } ) }
      ];

      return new NumberControl( label, property, range, options );
    },

    /**
     * Creates one of the pre-defined layout functions that can be used for options.layoutFunction.
     * Arranges subcomponents like this:
     *
     *  title number
     *  < ------|------ >
     *
     * @param {Object} [options]
     * @returns {function}
     * @public
     * @static
     */
    createLayoutFunction1: function( options ) {

      options = _.extend( {
        align: 'center', // {string} horizontal alignment of rows, 'left'|'right'|'center'
        titleXSpacing: 5, // {number} horizontal spacing between title and number
        arrowButtonsXSpacing: 15, // {number} horizontal spacing between arrow buttons and slider
        ySpacing: 5 // {number} vertical spacing between rows
      }, options );

      return function( titleNode, numberDisplay, slider, leftArrowButton, rightArrowButton ) {
        return new VBox( {
          align: options.align,
          spacing: options.ySpacing,
          children: [
            new HBox( {
              spacing: options.titleXSpacing,
              children: [ titleNode, numberDisplay ]
            } ),
            new HBox( {
              spacing: options.arrowButtonsXSpacing,
              resize: false, // prevent slider from causing a resize when thumb is at min or max
              children: [ leftArrowButton, slider, rightArrowButton ]
            } )
          ]
        } );
      };
    },

    /**
     * Creates one of the pre-defined layout functions that can be used for options.layoutFunction.
     * Arranges subcomponents like this:
     *
     *  title < number >
     *  ------|------
     *
     * @param {Object} [options]
     * @returns {function}
     * @public
     * @static
     */
    createLayoutFunction2: function( options ) {

      options = _.extend( {
        align: 'center', // {string} horizontal alignment of rows, 'left'|'right'|'center'
        xSpacing: 5, // {number} horizontal spacing in top row
        ySpacing: 5 // {number} vertical spacing between rows
      }, options );

      return function( titleNode, numberDisplay, slider, leftArrowButton, rightArrowButton ) {
        return new VBox( {
          align: options.align,
          spacing: options.ySpacing,
          resize: false, // prevent slider from causing a resize when thumb is at min or max
          children: [
            new HBox( {
              spacing: options.xSpacing,
              children: [ titleNode, leftArrowButton, numberDisplay, rightArrowButton ]
            } ),
            slider
          ]
        } );
      };
    },

    /**
     * Creates one of the pre-defined layout functions that can be used for options.layoutFunction.
     * Arranges subcomponents like this:
     *
     *  title
     *  < number >
     *  -------|-------
     *
     * @param {Object} [options]
     * @returns {function}
     * @public
     * @static
     */
    createLayoutFunction3: function( options ) {

      options = _.extend( {
        alignTitle: 'center', // {string} horizontal alignment of title, relative to slider, 'left'|'right'|'center'
        alignNumber: 'center', // {string} horizontal alignment of number display, relative to slider, 'left'|'right'|'center'
        xSpacing: 5, // {number} horizontal spacing between arrow buttons and slider
        ySpacing: 5 // {number} vertical spacing between rows
      }, options );

      return function( titleNode, numberDisplay, slider, leftArrowButton, rightArrowButton ) {
        return new VBox( {
          spacing: options.ySpacing,
          resize: false, // prevent slider from causing a resize when thumb is at min or max
          align: options.alignTitle,
          children: [
            titleNode,
            new VBox( {
              spacing: options.ySpacing,
              resize: false, // prevent slider from causing a resize when thumb is at min or max
              align: options.alignNumber,
              children: [
                new HBox( {
                  spacing: options.xSpacing,
                  children: [ leftArrowButton, numberDisplay, rightArrowButton ]
                } ),
                slider
              ]
            } )
          ]
        } );
      };
    }
  } );
} );

// Copyright 2017, University of Colorado Boulder

/**
 * NumberControl with custom Pendulum Lab options
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PENDULUM_LAB/common/view/PendulumNumberControl',['require','SCENERY/nodes/AlignBox','SCENERY/nodes/AlignGroup','SCENERY/util/Color','DOT/Dimension2','SCENERY/nodes/HBox','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/NumberControl','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY/nodes/Text','DOT/Util'],function( require ) {
  'use strict';

  // modules
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var AlignGroup = require( 'SCENERY/nodes/AlignGroup' );
  var Color = require( 'SCENERY/util/Color' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var NumberControl = require( 'SCENERY_PHET/NumberControl' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );

  /**
   * @constructor
   *
   * @param {string} title
   * @param {Property.<number>} property
   * @param {Range} range
   * @param {string} pattern
   * @param {Object} [options]
   */
  function PendulumNumberControl( title, property, range, pattern, color, options ) {
    options = _.extend( {
      excludeTweakers: false,
      alternateSlider: null,
      hasReadoutProperty: null,
      minTick: null,
      maxTick: null,
      sliderPadding: 0
    }, options );

    var numberControlOptions = _.extend( {
      titleFont: PendulumLabConstants.TITLE_FONT_BOLD,
      valueFont: PendulumLabConstants.READOUT_FONT,
      titleMaxWidth: 70,
      valuePattern: pattern,
      valueMaxWidth: 100,
      decimalPlaces: 2,
      delta: 0.01,
      layoutFunction: function( titleNode, numberDisplay, slider, leftArrowButton, rightArrowButton ) {
        var bottomBox = new HBox( {
          resize: false, // prevent slider from causing resize?
          spacing: 5,
          children: options.excludeTweakers ? [ slider ] : [
            leftArrowButton,
            slider,
            rightArrowButton
          ]
        } );
        var bottomContent = bottomBox;
        if ( options.alternateSlider ) {
          var alternateSlider = options.alternateSlider;
          bottomContent = new Node( {
            children: [
              bottomBox,
              alternateSlider
            ]
          } );
          alternateSlider.maxWidth = bottomBox.width;
          alternateSlider.center = bottomBox.center;
          alternateSlider.onStatic( 'visibility', function() {
            bottomBox.visible = !alternateSlider.visible;
          } );
        }
        var group = new AlignGroup( { matchHorizontal: false } );
        var titleBox = new AlignBox( titleNode, {
          group: group
        } );
        var numberBox = new AlignBox( numberDisplay, {
          group: group
        } );
        titleBox.bottom = numberBox.bottom = bottomContent.top - 5;
        titleBox.left = bottomContent.left - options.sliderPadding;
        numberBox.right = bottomContent.right + options.sliderPadding;
        var node = new Node( { children: [ bottomContent, titleBox, numberBox ] } );
        if ( options.hasReadoutProperty ) {
          options.hasReadoutProperty.link( function( hasReadout ) {
            numberBox.visible = hasReadout;
          } );
        }
        return node;
      },
      useRichText: true,
      majorTickLength: 5,
      arrowButtonScale: 0.56,
      constrainValue: function( value ) {
        return Util.roundSymmetric( value * 10 ) / 10;
      },
      thumbSize: PendulumLabConstants.THUMB_SIZE,
      thumbTouchAreaXDilation: PendulumLabConstants.THUMB_TOUCH_AREA_X_DILATION,
      thumbTouchAreaYDilation: PendulumLabConstants.THUMB_TOUCH_AREA_Y_DILATION,
      thumbFillEnabled: color,
      thumbFillHighlighted: Color.toColor( color ).colorUtilsBrighter( 0.6 ),
      majorTicks: [ {
        value: range.min,
        label: new Text( options.minTick || range.min, { font: PendulumLabConstants.TICK_FONT, maxWidth: 50 } )
      }, {
        value: range.max,
        label: new Text( options.maxTick || range.max, { font: PendulumLabConstants.TICK_FONT, maxWidth: 50 } )
      } ]
    }, options );

    var trackWidth = 500;
    var testControl = new NumberControl( title, property, range, _.extend( {}, numberControlOptions, {
      trackSize: new Dimension2( trackWidth, PendulumLabConstants.TRACK_HEIGHT )
    } ) );

    var testWidth = testControl.width;
    testControl.dispose();

    NumberControl.call( this, title, property, range, _.extend( {}, numberControlOptions, {
      trackSize: new Dimension2( trackWidth + PendulumLabConstants.RIGHT_CONTENT_WIDTH - testWidth, PendulumLabConstants.TRACK_HEIGHT )
    } ) );
  }

  pendulumLab.register( 'PendulumNumberControl', PendulumNumberControl );

  return inherit( NumberControl, PendulumNumberControl );
} );


define("string!PENDULUM_LAB/friction",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/friction");});


define("string!PENDULUM_LAB/lots",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/lots");});


define("string!PENDULUM_LAB/none",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/none");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Friction slider node in 'Pendulum lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/common/view/FrictionSliderNode',['require','AXON/BooleanProperty','AXON/DynamicProperty','PHET_CORE/inherit','SCENERY/nodes/Node','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','PENDULUM_LAB/common/view/PendulumNumberControl','AXON/Property','DOT/Range','SCENERY/nodes/Text','DOT/Util','string!PENDULUM_LAB/friction','string!PENDULUM_LAB/lots','string!PENDULUM_LAB/none'],function( require ) {
  'use strict';

  // modules
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var DynamicProperty = require( 'AXON/DynamicProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PendulumNumberControl = require( 'PENDULUM_LAB/common/view/PendulumNumberControl' );
  var Property = require( 'AXON/Property' );
  var Range = require( 'DOT/Range' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );

  // strings
  var frictionString = require( 'string!PENDULUM_LAB/friction' );
  var lotsString = require( 'string!PENDULUM_LAB/lots' );
  var noneString = require( 'string!PENDULUM_LAB/none' );

  /**
   * Converts the numerical value of the slider to friction, does not assign to friction property
   * @private
   *
   * @param {number} sliderValue
   * @returns {number}
   */
  function sliderValueToFriction( sliderValue ) {
    return 0.0005 * ( Math.pow( 2, sliderValue ) - 1 );
  }

  /**
   * Converts the numerical value of the friction to a slider value, does not assign to slider property
   * @private
   *
   * @param {number}friction
   * @returns {number}
   */
  function frictionToSliderValue( friction ) {
    return Util.roundSymmetric( Math.log( friction / 0.0005 + 1 ) / Math.LN2 );
  }

  /**
   * @constructor
   *
   * @param {Property.<number>} frictionProperty - Property to update by slider.
   * @param {Range} frictionRange - Possible range of frictionProperty value.
   * @param {Object} [options]
   */
  function FrictionSliderNode( frictionProperty, frictionRange, options ) {

    var sliderValueProperty = new DynamicProperty( new Property( frictionProperty ), {
      bidirectional: true,
      map: frictionToSliderValue,
      inverseMap: sliderValueToFriction
    } );

    // range the slider can have
    var sliderValueRange = new Range( frictionToSliderValue( frictionRange.min ), frictionToSliderValue( frictionRange.max ) );

    var numberControl = new PendulumNumberControl( frictionString, sliderValueProperty, sliderValueRange, '{0}', 'rgb(50,145,184)', {
      hasReadoutProperty: new BooleanProperty( false ),
      thumbFillEnabled: '#00C4DF',
      thumbFillHighlighted: '#71EDFF',
      excludeTweakers: true,
      sliderPadding: 14,

      minorTickLength: 5,
      majorTickLength: 10,
      constrainValue: function( value ) {
        return Util.roundSymmetric( value );
      },

      majorTicks: [
        {
          value: sliderValueRange.min,
          label: new Text( noneString, { font: PendulumLabConstants.TICK_FONT, maxWidth: 50 } )
        }, {
          value: sliderValueRange.getCenter(),
          label: null
        }, {
          value: sliderValueRange.max,
          label: new Text( lotsString, { font: PendulumLabConstants.TICK_FONT, maxWidth: 50 } )
        }
      ],

      minorTickSpacing: sliderValueRange.getLength() / 10
    } );

    // describes the panel box containing the friction slider
    Node.call( this, _.extend( {
      children: [ numberControl ]
    }, options ) );
  }

  pendulumLab.register( 'FrictionSliderNode', FrictionSliderNode );

  return inherit( Node, FrictionSliderNode );
} );

// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/TComboBox',['require','SCENERY/nodes/TNode','SUN/sun','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );
  var sun = require( 'SUN/sun' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * Wrapper type for phet/sun's ComboBox class.
   * @param comboBox
   * @param phetioID
   * @constructor
   */
  function TComboBox( comboBox, phetioID ) {

    // assert && assert( !!phetioValueType, 'phetioValueType should be defined' );
    assertInstanceOf( comboBox, phet.sun.ComboBox );
    TNode.call( this, comboBox, phetioID );

    toEventOnEmit(
      comboBox.startedCallbacksForComboBoxDismissedEmitter,
      comboBox.endedCallbacksForComboBoxDismissedEmitter,
      'user',
      phetioID,
      this.constructor,
      'popupHidden' );

    toEventOnEmit(
      comboBox.startedCallbacksForComboBoxPopupShownEmitter,
      comboBox.endedCallbacksForComboBoxPopupShownEmitter,
      'user',
      phetioID,
      this.constructor,
      'popupShown' );
  }

  phetioInherit( TNode, 'TComboBox', TComboBox, {}, {
    documentation: 'A traditional combo box',
    events: [ 'fired', 'popupShown', 'popupHidden' ]
  } );

  sun.register( 'TComboBox', TComboBox );

  return TComboBox;


} );


// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */
define( 'SUN/TComboBoxItemNode',['require','SCENERY/nodes/TNode','SUN/sun','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );
  var sun = require( 'SUN/sun' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * Wrapper type for phet/sun's ComboBox class.
   * @param comboBoxItemNode
   * @param phetioID
   * @constructor
   */
  function TComboBoxItemNode( comboBoxItemNode, phetioID ) {

    assertInstanceOf( comboBoxItemNode, phet.sun.ComboBox.ItemNode );
    TNode.call( this, comboBoxItemNode, phetioID );

    assert && assert( comboBoxItemNode.phetioValueType, 'Each item node must have a phetioValueType.' );

    toEventOnEmit( comboBoxItemNode.startedCallbacksForItemFiredEmitter, comboBoxItemNode.endedCallbacksForItemFiredEmitter, 'user', phetioID, this.constructor, 'fired', function( selection ) {
      return { value: comboBoxItemNode.phetioValueType.toStateObject( selection ) };
    } );
  }

  phetioInherit( TNode, 'TComboBoxItemNode', TComboBoxItemNode, {}, {
    documentation: 'A traditional item node for a combo box',
    events: [ 'fired' ]
  } );

  sun.register( 'TComboBoxItemNode', TComboBoxItemNode );

  return TComboBoxItemNode;

} );
// Copyright 2013-2016, University of Colorado Boulder

/**
 * Scenery-based combo box. Composed of a button and a list of items.
 * The list of items is displayed when the button is pressed, and dismissed an item is selected
 * or the user clicks outside the list.  The list can be displayed either above or below the button.
 *
 * An item in the combo box has 2 properties: {Node} node, {*} value.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/ComboBox',['require','PHET_CORE/inherit','AXON/Emitter','SCENERY/nodes/Node','AXON/Property','SCENERY/nodes/Rectangle','KITE/Shape','SUN/sun','DOT/Vector2','TANDEM/Tandem','SCENERY/nodes/Line','SCENERY/nodes/Path','SUN/TComboBox','SUN/TComboBoxItemNode'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Vector2 = require( 'DOT/Vector2' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Line = require( 'SCENERY/nodes/Line' );
  var Path = require( 'SCENERY/nodes/Path' );
  var TComboBox = require( 'SUN/TComboBox' );
  var TComboBoxItemNode = require( 'SUN/TComboBoxItemNode' );

  /**
   * @param {*[]} items - see ComboBox.createItem
   * @param {Property} property
   * @param {Node} listParent node that will be used as the list's parent, use this to ensuring that the list is in front of everything else
   * @param {Object} [options] object with optional properties
   * @constructor
   */
  function ComboBox( items, property, listParent, options ) {

    var self = this;

    options = _.extend( {

      labelNode: null, // optional label, placed to the left of the combo box
      labelXSpacing: 10, // horizontal space between label and combo box
      enabledProperty: new Property( true ),
      disabledOpacity: 0.5, // {number} opacity used to make the control look disabled

      // button
      buttonFill: 'white',
      buttonStroke: 'black',
      buttonLineWidth: 1,
      buttonCornerRadius: 8,
      buttonXMargin: 10,
      buttonYMargin: 4,

      // list
      listPosition: 'below', // where the list is positioned relative to the button, either 'below' or 'above'
      listYMargin: 4,
      listFill: 'white',
      listStroke: 'black',
      listLineWidth: 1,
      listCornerRadius: 5,

      // items
      itemXMargin: 6,
      itemYMargin: 6, // Vertical margin applied to the top and bottom of each item in the popup list.
      itemHighlightFill: 'rgb(245,245,245)',
      itemHighlightStroke: null,
      itemHighlightLineWidth: 1,

      // tandem
      tandem: Tandem.tandemRequired(),
      phetioType: TComboBox
    }, options );

    // validate option values
    assert && assert( options.disabledOpacity > 0 && options.disabledOpacity < 1, 'invalid disabledOpacity: ' + options.disabledOpacity );

    Node.call( self );

    this.enabledProperty = options.enabledProperty; // @public

    this.startedCallbacksForComboBoxDismissedEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForComboBoxDismissedEmitter = new Emitter( { indicateCallbacks: false } );
    this.startedCallbacksForComboBoxPopupShownEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForComboBoxPopupShownEmitter = new Emitter( { indicateCallbacks: false } );

    // optional label
    if ( options.labelNode !== null ) {
      self.addChild( options.labelNode );
    }

    // determine uniform dimensions for button and list items (including margins)
    var itemWidth = Math.max.apply( Math, _.map( items, 'node.width' ) ) + 2 * options.itemXMargin;
    var itemHeight = Math.max.apply( Math, _.map( items, 'node.height' ) ) + 2 * options.itemYMargin;

    // list
    var listWidth = itemWidth + ( 2 * options.buttonXMargin );
    var listHeight = ( items.length * itemHeight ) + ( 2 * options.listYMargin );
    var listNode = new Rectangle( 0, 0, listWidth, listHeight, {
      cornerRadius: options.listCornerRadius,
      fill: options.listFill,
      stroke: options.listStroke,
      lineWidth: options.listLineWidth,
      visible: false
      // Not instrumented for PhET-iO because the list's location isn't valid until it has been popped up.
      // See https://github.com/phetsims/phet-io/issues/1102
    } );
    listParent.addChild( listNode );

    //TODO move these to ComboBoxItemNode
    // how to highlight an item in the list
    var highlightItem = function( itemNode ) {
      itemNode.fill = options.itemHighlightFill;
      itemNode.stroke = options.itemHighlightStroke;
    };
    var unhighlightItem = function( itemNode ) {
      itemNode.fill = null;
      itemNode.stroke = null;
    };

    // listener that we'll attach to each item in the list
    var itemListener = {
      enter: function( event ) {
        highlightItem( event.currentTarget );
      },
      exit: function( event ) {
        unhighlightItem( event.currentTarget );
      },
      down: function( event ) {
        event.abort(); // prevent click-to-dismiss on the list
      },
      up: function( event ) {
        // {ComboBoxItemNode}
        var selectedItemNode = event.currentTarget;

        selectedItemNode.startedCallbacksForItemFiredEmitter.emit1( selectedItemNode.item.value );

        unhighlightItem( selectedItemNode );
        listNode.visible = false; // close the list, do this before changing property value, in case it's expensive
        display.removeInputListener( clickToDismissListener ); // remove the click-to-dismiss listener
        event.abort(); // prevent nodes (eg, controls) behind the list from receiving the event
        property.value = selectedItemNode.item.value; // set the property

        selectedItemNode.endedCallbacksForItemFiredEmitter.emit1( selectedItemNode.item.value );

      }
    };

    // populate list with items
    items.forEach( function( item, index ) {
      var itemNodeOptions = _.extend( {
        left: options.buttonXMargin,
        top: options.listYMargin + ( index * itemHeight ),
        cursor: 'pointer',
        inputListeners: [ itemListener ]
      }, item.options );

      // Create tandems for each ComboBoxItemNode
      var itemNodeTandem = null;

      // For 'phet-io' brand, the tandems for items must be provided.  For other brands, the tandems are not required
      // and are filled in with substitutes so the tandems are still defined.
      if ( Tandem.validationEnabled() ) {
        assert && assert( itemNodeOptions.tandemName, 'For instrumented ComboBoxes, ItemNodes must have a tandemName' );
      }
      itemNodeTandem = options.tandem.createTandem( itemNodeOptions.tandemName || 'comboBoxItemNode' );
      itemNodeOptions.tandem = itemNodeTandem;
      itemNodeOptions.phetioValueType = property.phetioValueType;

      // Create the list item node itself
      listNode.addChild( new ComboBoxItemNode( item, itemWidth, itemHeight, options.itemXMargin, itemNodeOptions ) );
    } );

    // button, will be set to correct value when property observer is registered
    var buttonNode = new ButtonNode( new ComboBoxItemNode( items[ 0 ], itemWidth, itemHeight, options.itemXMargin, {
      tandem: options.tandem.createTandem( 'buttonNode', { enabled: false } ),
      phetioValueType: property.phetioValueType
    } ), options );
    self.addChild( buttonNode );

    //TODO handle scale and rotation
    // Handles the coordinate transform required to make the list pop up near the button.
    var moveList = function() {
      var pButtonGlobal;
      var pButtonLocal;
      if ( options.listPosition === 'above' ) {
        pButtonGlobal = self.localToGlobalPoint( new Vector2( buttonNode.left, buttonNode.top ) );
        pButtonLocal = listParent.globalToLocalPoint( pButtonGlobal );
        listNode.left = pButtonLocal.x;
        listNode.bottom = pButtonLocal.y;
      }
      else {
        pButtonGlobal = self.localToGlobalPoint( new Vector2( buttonNode.left, buttonNode.bottom ) );
        pButtonLocal = listParent.globalToLocalPoint( pButtonGlobal );
        listNode.left = pButtonLocal.x;
        listNode.top = pButtonLocal.y;
      }
    };

    /**
     * Because clickToDismissListener is added to the scene, it receives the 'down' event that
     * buttonNode received to register the listener. This is because scenery propagates events
     * up the event trail, and the scene is further up the trail than the button.  This flag
     * is used to ignore the first 'down' event, which is the one that the button received.
     * If we don't do this, then we never see the list because it is immediately popped down.
     * This behavior is may change, and is being discussed in scenery#58.
     */
    var enableClickToDismissListener;
    var display; // store the display that clickToDismissListener is added to, because the scene may change, see sun#14

    // listener for 'click outside to dismiss'
    var clickToDismissListener = {
      down: function() {
        if ( enableClickToDismissListener ) {

          self.startedCallbacksForComboBoxDismissedEmitter.emit();

          display.removeInputListener( clickToDismissListener );
          listNode.visible = false;

          self.endedCallbacksForComboBoxDismissedEmitter.emit();
        }
        else {
          enableClickToDismissListener = true;
        }
      }
    };

    // button interactivity
    buttonNode.cursor = 'pointer';
    buttonNode.addInputListener( {
      down: function() {
        if ( !listNode.visible ) {
          self.startedCallbacksForComboBoxPopupShownEmitter.emit();

          moveList();
          listNode.moveToFront();
          listNode.visible = true;
          enableClickToDismissListener = false;
          display = self.getUniqueTrail().rootNode().getRootedDisplays()[ 0 ];
          display.addInputListener( clickToDismissListener );

          self.endedCallbacksForComboBoxPopupShownEmitter.emit();
        }
      }
    } );

    // layout
    if ( options.labelNode ) {
      buttonNode.left = options.labelNode.right + options.labelXSpacing;
      buttonNode.centerY = options.labelNode.centerY;
    }

    // when property changes, update button
    var propertyObserver = function( value ) {
      var item = _.find( items, function( item ) {
        return item.value === value;
      } );
      buttonNode.setItemNode( new ComboBoxItemNode( item, itemWidth, itemHeight, options.itemXMargin, {
        tandem: options.tandem.createTandem( 'buttonNode', { enabled: false } ),
        phetioValueType: property.phetioValueType
      } ) );
    };
    property.link( propertyObserver );

    this.mutate( options );

    // enable/disable the combo box
    var enabledObserver = function( enabled ) {
      self.pickable = enabled;
      self.opacity = enabled ? 1.0 : options.disabledOpacity;
    };
    this.enabledProperty.link( enabledObserver );

    // @private called by dispose
    this.disposeComboBox = function() {
      self.enabledProperty.unlink( enabledObserver );

      // Unregister itemNode tandems as well
      for ( var i = 0; i < listNode.children.length; i++ ) {
        listNode.children[ i ].dispose();
      }
      buttonNode.dispose();
      property.unlink( propertyObserver );
    };
  }

  sun.register( 'ComboBox', ComboBox );

  inherit( Node, ComboBox, {

    // @public - Provide dispose() on the prototype for ease of subclassing.
    dispose: function() {
      this.disposeComboBox();
      Node.prototype.dispose.call( this );
    },

    // @public
    setEnabled: function( enabled ) { this.enabledProperty.value = enabled; },
    set enabled( value ) { this.setEnabled( value ); },

    // @public
    getEnabled: function() { return this.enabledProperty.value; },
    get enabled() { return this.getEnabled(); }
  } );

  /**
   * Creates a combo box item.
   * This exists primarily to document the structure of an item.
   * @param {Node} node
   * @param {*} value
   * @param {Object} [options] For PhET-iO instrumented simulations, the following must be supplied:
   *                             tandemName: {string} - the suffix applied to button tandems
   *                           No other options are supported.
   * @returns {object}
   * @public
   */
  ComboBox.createItem = function( node, value, options ) {
    return { node: node, value: value, options: options };
  };

  /**
   * The button that is clicked to show the list of items.
   * @param {Node} itemNode
   * @param {Object} [options]
   * @constructor
   */
  function ButtonNode( itemNode, options ) {

    options = _.extend( {
      tandem: Tandem.tandemRequired(), // For PhET-iO instrumented simulations, this must be supplied

      // these options are passed in from ComboBox options
      listPosition: 'below',
      buttonFill: 'white',
      buttonStroke: 'black',
      buttonLineWidth: 1,
      buttonCornerRadius: 8,
      buttonXMargin: 10,
      buttonYMargin: 4

    }, options );

    Node.call( this );

    // up or down arrow
    var arrow = new Path( null, {
      fill: 'black',
      tandem: options.tandem.createTandem( 'arrow' )
    } );
    var arrowWidth = 0.5 * itemNode.height;
    var arrowHeight = arrowWidth * Math.sqrt( 3 ) / 2; // height of equilateral triangle
    if ( options.listPosition === 'above' ) {
      arrow.shape = new Shape().moveTo( 0, arrowHeight ).lineTo( arrowWidth / 2, 0 ).lineTo( arrowWidth, arrowHeight ).close(); // up arrow
    }
    else {
      arrow.shape = new Shape().moveTo( 0, 0 ).lineTo( arrowWidth, 0 ).lineTo( arrowWidth / 2, arrowHeight ).close(); // down arrow
    }

    // button background
    var width = itemNode.width + ( 4 * options.buttonXMargin ) + arrow.width;
    var height = itemNode.height + ( 2 * options.buttonYMargin );
    var background = new Rectangle( 0, 0, width, height, {
      cornerRadius: options.buttonCornerRadius,
      fill: options.buttonFill,
      stroke: options.buttonStroke,
      lineWidth: options.buttonLineWidth
    } );

    // vertical separator to left of arrow
    var separator = new Line( 0, 0, 0, height, {
      stroke: 'black',
      lineWidth: options.buttonLineWidth,
      tandem: options.tandem.createTandem( 'separator' )
    } );

    // parent for the selected item node
    var selectedItemParent = new Node( {
      tandem: options.tandem.createTandem( 'selectedItemParent' )
    } );

    // rendering order
    this.addChild( background );
    this.addChild( arrow );
    this.addChild( separator );
    this.addChild( selectedItemParent );

    // @private
    this.setItemNode = function( itemNode ) {
      // Dispose any existing item, see https://github.com/phetsims/sun/issues/299
      while ( selectedItemParent.children.length ) {
        var lastNode = selectedItemParent.children[ 0 ];
        selectedItemParent.removeChild( lastNode );
        lastNode.dispose();
      }
      selectedItemParent.addChild( itemNode );
      itemNode.left = options.buttonXMargin;
      itemNode.top = options.buttonYMargin;
    };
    this.setItemNode( itemNode );

    // layout
    separator.left = itemNode.right + options.buttonXMargin;
    separator.top = background.top;
    arrow.left = separator.right + options.buttonXMargin;
    arrow.centerY = background.centerY;

    this.disposeButtonNode = function() {
      options.tandem.createTandem( 'separator' ).removeInstance( separator );
      options.tandem.createTandem( 'arrow' ).removeInstance( arrow );
      options.tandem.createTandem( 'selectedItemParent' ).removeInstance( selectedItemParent );
      itemNode.dispose();
    };
  }

  sun.register( 'ComboBox.ButtonNode', ButtonNode );

  inherit( Node, ButtonNode, {
    dispose: function() {
      this.disposeButtonNode();
      Node.prototype.dispose.call( this );
    }
  } );

  /**
   * A wrapper around the combo box item, adds margins, etc.
   * @param {Object} item - see ComboBox.createItem
   * @param {number} width
   * @param {number} height
   * @param {number} xMargin
   * @param {Object} [options]
   * @constructor
   * @private
   */
  function ComboBoxItemNode( item, width, height, xMargin, options ) {
    // @private {Node} - Holds our item.node, and positions it in the correct location. We don't want to mutate the
    //                   item's node itself.
    this.itemWrapper = new Node( {
      children: [ item.node ],
      pickable: false,
      x: xMargin,
      centerY: height / 2
    } );

    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      phetioType: TComboBoxItemNode,
      children: [ this.itemWrapper ]
    }, options );


    this.item = item;
    this.phetioValueType = options.phetioValueType;

    this.startedCallbacksForItemFiredEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForItemFiredEmitter = new Emitter( { indicateCallbacks: false } );

    Rectangle.call( this, 0, 0, width, height, options );
  }

  sun.register( 'ComboBox.ItemNode', ComboBoxItemNode );

  inherit( Rectangle, ComboBoxItemNode, {
    /**
     * Disposes the item.
     * @public
     */
    dispose: function() {
      this.itemWrapper.dispose();

      Rectangle.prototype.dispose.call( this );
    }
  } );

  return ComboBox;
} );

define("string!PENDULUM_LAB/gravitationalAccelerationPattern",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/gravitationalAccelerationPattern");});


define("string!PENDULUM_LAB/whatIsTheValueOfGravity",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/whatIsTheValueOfGravity");});


define("string!PENDULUM_LAB/gravity",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/gravity");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Gravity slider and body list node in 'Pendulum lab' simulation.
 * Tweakers can be added using special function.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/common/view/GravityControlNode',['require','PENDULUM_LAB/common/model/Body','SUN/ComboBox','AXON/DerivedProperty','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','PENDULUM_LAB/common/view/PendulumNumberControl','PHETCOMMON/util/StringUtils','SCENERY/nodes/Text','DOT/Util','SCENERY/nodes/VBox','string!PENDULUM_LAB/lots','string!PENDULUM_LAB/none','string!PENDULUM_LAB/gravitationalAccelerationPattern','string!PENDULUM_LAB/whatIsTheValueOfGravity','string!PENDULUM_LAB/gravity'],function( require ) {
  'use strict';

  // modules
  var Body = require( 'PENDULUM_LAB/common/model/Body' );
  var ComboBox = require( 'SUN/ComboBox' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PendulumNumberControl = require( 'PENDULUM_LAB/common/view/PendulumNumberControl' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );
  var VBox = require( 'SCENERY/nodes/VBox' );

  // strings
  var lotsString = require( 'string!PENDULUM_LAB/lots' );
  var noneString = require( 'string!PENDULUM_LAB/none' );
  var gravitationalAccelerationPatternString = require( 'string!PENDULUM_LAB/gravitationalAccelerationPattern' );
  var whatIsTheValueOfGravityString = require( 'string!PENDULUM_LAB/whatIsTheValueOfGravity' );
  var gravityString = require( 'string!PENDULUM_LAB/gravity' );

  /**
   * @constructor
   *
   * @param {Property.<number>} gravityProperty - Property to update by slider.
   * @param {Range} gravityRange - Range of gravity property.
   * @param {Property.<Body>} bodyProperty - Property to update by combo box.
   * @param {Node} popupLayer
   * @param {Object} [options]
   */
  function GravityControlNode( gravityProperty, gravityRange, bodyProperty, popupLayer, options ) {
    options = _.extend( {
      useTextSliderLabels: true
    }, options );

    var labelPattern = StringUtils.fillIn( gravitationalAccelerationPatternString, {
      gravity: '{0}'
    } );

    var comboBoxItems = Body.BODIES.map( function( body ) {
      return {
        node: new Text( body.title, {
          font: PendulumLabConstants.GRAVITY_COMBO_FONT,
          maxWidth: 50
        } ),
        value: body
      };
    } );

    var comboBox = new ComboBox( comboBoxItems, bodyProperty, popupLayer, {
      buttonCornerRadius: 3,
      buttonYMargin: 0,
      itemYMargin: 3,
      listYMargin: 3
    } );

    var questionText = new Text( whatIsTheValueOfGravityString, { font: PendulumLabConstants.VALUE_OF_GRAVITY_FONT } );

    bodyProperty.link( function( body ) {
      questionText.visible = body === Body.PLANET_X;
    } );

    var numberControl = new PendulumNumberControl( gravityString, gravityProperty, gravityRange, labelPattern, 'rgb(50,145,184)', {
      hasReadoutProperty: new DerivedProperty( [ bodyProperty ], function( body ) {
        return !options.useTextSliderLabels && body !== Body.PLANET_X;
      } ),
      minTick: options.useTextSliderLabels ? noneString : null,
      maxTick: options.useTextSliderLabels ? lotsString : null,
      thumbFillEnabled: '#00C4DF',
      thumbFillHighlighted: '#71EDFF',
      alternateSlider: questionText,
      excludeTweakers: options.useTextSliderLabels,
      sliderPadding: options.useTextSliderLabels ? 14 : 0,
      // See https://github.com/phetsims/pendulum-lab/issues/183 for rounding
      constrainValue: function( value ) {
        return Util.roundSymmetric( value * 2 ) / 2;
      },
    } );

    VBox.call( this, _.extend( {
      spacing: 5,
      children: [ numberControl, comboBox ]
    }, options ) );
  }

  pendulumLab.register( 'GravityControlNode', GravityControlNode );

  return inherit( VBox, GravityControlNode );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Length/mass panel and gravity/friction panel
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/GlobalControlPanel',['require','PENDULUM_LAB/common/view/FrictionSliderNode','PENDULUM_LAB/common/view/GravityControlNode','PHET_CORE/inherit','SUN/Panel','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY/nodes/VBox'],function( require ) {
  'use strict';

  // modules
  var FrictionSliderNode = require( 'PENDULUM_LAB/common/view/FrictionSliderNode' );
  var GravityControlNode = require( 'PENDULUM_LAB/common/view/GravityControlNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Panel = require( 'SUN/Panel' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var VBox = require( 'SCENERY/nodes/VBox' );

  /**
   * @constructor
   *
   * @param {PendulumLabModel} model - Main model of pendulum lab simulation.
   * @param {Node} popupLayer
   * @param {boolean} hasGravityTweakers
   */
  function GlobalControlPanel( model, popupLayer, hasGravityTweakers ) {

    var gravityControlNode = new GravityControlNode( model.gravityProperty, model.gravityRange, model.bodyProperty, popupLayer, {
      useTextSliderLabels: !hasGravityTweakers
    } );
    var frictionSlider = new FrictionSliderNode( model.frictionProperty, model.frictionRange );

    var content = new VBox( {
      spacing: 10,
      children: [
        gravityControlNode,
        frictionSlider
      ]
    } );

    Panel.call( this, content, PendulumLabConstants.PANEL_OPTIONS );
  }

  pendulumLab.register( 'GlobalControlPanel', GlobalControlPanel );

  return inherit( Panel, GlobalControlPanel );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Pendulum node in 'Pendulum Lab' simulation.
 * Contains pendula and threads. Pendula always above threads.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/PendulaNode',['require','SCENERY_PHET/ArrowNode','DOT/Bounds2','SCENERY/util/Color','DOT/Dimension2','PHET_CORE/inherit','SCENERY/nodes/Line','SCENERY/util/LinearGradient','SCENERY/nodes/Node','PENDULUM_LAB/common/model/Pendulum','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','AXON/Property','SCENERY/nodes/Rectangle','SCENERY/input/SimpleDragHandler','SCENERY/nodes/Text','DOT/Util','DOT/Vector2'],function( require ) {
  'use strict';

  // modules
  var ArrowNode = require( 'SCENERY_PHET/ArrowNode' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Color = require( 'SCENERY/util/Color' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'SCENERY/nodes/Line' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Pendulum = require( 'PENDULUM_LAB/common/model/Pendulum' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Property = require( 'AXON/Property' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );
  var Vector2 = require( 'DOT/Vector2' );

  // constants
  var ARROW_HEAD_WIDTH = 12;
  var ARROW_TAIL_WIDTH = 6;
  var ARROW_SIZE_DEFAULT = 25;
  var RECT_SIZE = new Dimension2( 73, 98 );

  /**
   * @constructor
   *
   * @param {Array.<Pendulum>} pendula - Array of pendulum models.
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Object} [options]
   */
  function PendulaNode( pendula, modelViewTransform, options ) {
    var self = this;

    options = _.extend( {
      preventFit: true
    }, options );

    Node.call( this, options );

    var viewOriginPosition = modelViewTransform.modelToViewPosition( Vector2.ZERO );

    // @public {startDrag: {function}, computeDistance: {function}} - To identify how close a draggable object is.
    this.draggableItems = [];

    var pendulumNodes = [];
    var velocityArrows = [];
    var accelerationArrows = [];

    pendula.forEach( function( pendulum, pendulumIndex ) {
      var massToScale = function( mass ) {
        // height/width/depth of mass scale by cube-root to maintain density
        return 0.3 + 0.4 * Math.sqrt( mass / 1.5 );
      };

      // create the visual representation of a rod that joins the fulcrum point to the bob
      // initially set to be vertical
      var solidLine = new Line( 0, 0, 0, modelViewTransform.modelToViewDeltaY( pendulum.lengthProperty.value ), {
        stroke: 'black',
        pickable: false
      } );

      // create the visual representation of a pendulum bob (a rectangle with a string and a line across the rectangle)
      var pendulumRect = new Node( {
        children: [
          new Rectangle( -RECT_SIZE.width / 2, -RECT_SIZE.height / 2, RECT_SIZE.width, RECT_SIZE.height, {
            fill: new LinearGradient( -RECT_SIZE.width / 2, 0, RECT_SIZE.width / 2, 0 ).addColorStop( 0, Color.toColor( pendulum.color ).colorUtilsBrighter( 0.4 ) )
                                                                                       .addColorStop( 0.2, Color.toColor( pendulum.color ).colorUtilsBrighter( 0.9 ) )
                                                                                       .addColorStop( 0.7, pendulum.color )
          } ),
          new Text( ( pendulumIndex + 1 ).toString(), {
            font: PendulumLabConstants.PENDULUM_LABEL_FONT,
            fill: 'white',
            centerY: RECT_SIZE.height / 4,
            centerX: 0,
            pickable: false
          } ),
          new Line( -RECT_SIZE.width / 2, 0, RECT_SIZE.width / 2, 0, {
            stroke: 'black',
            lineCap: 'butt',
            pickable: false
          } )
        ]
      } );

      // create the visual representation of a pendulum (bob + rod)
      var pendulumNode = new Node( {
        cursor: 'pointer',
        children: [
          solidLine,
          pendulumRect
        ]
      } );

      // add velocity arrows if necessary
      if ( options.isVelocityVisibleProperty ) {
        var velocityArrow = new ArrowNode( 0, 0, 0, 0, {
          pickable: false,
          fill: PendulumLabConstants.VELOCITY_ARROW_COLOR,
          tailWidth: ARROW_TAIL_WIDTH,
          headWidth: ARROW_HEAD_WIDTH
        } );
        velocityArrows.push( velocityArrow );

        // no need to unlink, present for the lifetime of the sim
        Property.multilink( [ pendulum.isVisibleProperty, options.isVelocityVisibleProperty, pendulum.velocityProperty ], function( pendulumVisible, velocityVisible, velocity ) {
          velocityArrow.visible = pendulumVisible && velocityVisible;
          // update the size of the arrow
          if ( velocityArrow.visible ) {
            var position = modelViewTransform.modelToViewPosition( pendulum.positionProperty.value );
            velocityArrow.setTailAndTip( position.x,
              position.y,
              position.x + ARROW_SIZE_DEFAULT * velocity.x,
              position.y - ARROW_SIZE_DEFAULT * velocity.y );
          }
        } );
      }


      // add acceleration arrows if necessary
      if ( options.isAccelerationVisibleProperty ) {
        // create acceleration arrow
        var accelerationArrow = new ArrowNode( 0, 0, 0, 0, {
          pickable: false,
          fill: PendulumLabConstants.ACCELERATION_ARROW_COLOR,
          tailWidth: ARROW_TAIL_WIDTH,
          headWidth: ARROW_HEAD_WIDTH
        } );
        accelerationArrows.push( accelerationArrow );

        // no need to unlink, present for the lifetime of the sim
        Property.multilink( [ pendulum.isVisibleProperty, options.isAccelerationVisibleProperty, pendulum.accelerationProperty ], function( pendulumVisible, accelerationVisible, acceleration ) {
          accelerationArrow.visible = pendulumVisible && accelerationVisible;
          if ( accelerationArrow.visible ) {
            var position = modelViewTransform.modelToViewPosition( pendulum.positionProperty.value );
            accelerationArrow.setTailAndTip( position.x,
              position.y,
              position.x + ARROW_SIZE_DEFAULT * acceleration.x,
              position.y - ARROW_SIZE_DEFAULT * acceleration.y );
          }
        } );
      }

      pendulumNodes.push( pendulumNode );

      // add drag events
      var angleOffset;
      var dragListener = new SimpleDragHandler( {
        allowTouchSnag: true,

        // determine the position of where the pendulum is dragged.
        start: function( event ) {
          var dragAngle = modelViewTransform.viewToModelPosition( self.globalToLocalPoint( event.pointer.point ) ).angle() + Math.PI / 2;
          angleOffset = pendulum.angleProperty.value - dragAngle;

          pendulum.isUserControlledProperty.value = true;
        },

        // set the angle of the pendulum depending on where it is dragged to.
        drag: function( event ) {
          var dragAngle = modelViewTransform.viewToModelPosition( self.globalToLocalPoint( event.pointer.point ) ).angle() + Math.PI / 2;
          var continuousAngle = Pendulum.modAngle( angleOffset + dragAngle );

          // Round angles to nearest degree, see https://github.com/phetsims/pendulum-lab/issues/195
          var roundedAngleDegrees = Util.roundSymmetric( Util.toDegrees( continuousAngle ) );

          // Don't allow snapping to 180, see https://github.com/phetsims/pendulum-lab/issues/195
          if ( Math.abs( roundedAngleDegrees ) === 180 ) {
            roundedAngleDegrees = ( roundedAngleDegrees > 0 ? 1 : -1 ) * 179;
          }

          var roundedAngle = Util.toRadians( roundedAngleDegrees );
          pendulum.angleProperty.value = roundedAngle;
        },

        // release user control
        end: function() {
          pendulum.isUserControlledProperty.value = false;
        }
      } );

      // add a drag listener
      pendulumRect.addInputListener( dragListener );
      self.draggableItems.push( {
        startDrag: dragListener.startDrag.bind( dragListener ),
        computeDistance: function( globalPoint ) {
          if ( pendulum.isUserControlledProperty.value || !pendulum.isVisibleProperty.value ) {
            return Number.POSITIVE_INFINITY;
          }
          else {
            var cursorModelPosition = modelViewTransform.viewToModelPosition( self.globalToLocalPoint( globalPoint ) );
            cursorModelPosition.rotate( -pendulum.angleProperty.value ).add( new Vector2( 0, pendulum.lengthProperty.value ) ); // rotate/length so (0,0) would be mass center
            var massViewWidth = modelViewTransform.viewToModelDeltaX( RECT_SIZE.width * massToScale( pendulum.massProperty.value ) );
            var massViewHeight = modelViewTransform.viewToModelDeltaX( RECT_SIZE.height * massToScale( pendulum.massProperty.value ) );
            var massBounds = new Bounds2( -massViewWidth / 2, -massViewHeight / 2, massViewWidth / 2, massViewHeight / 2 );
            return Math.sqrt( massBounds.minimumDistanceToPointSquared( cursorModelPosition ) );
          }
        }
      } );

      // update pendulum rotation, pendulum.angleProperty.value is radians
      // we are using an inverted modelViewTransform, hence we multiply the view angle by minus one
      pendulum.angleProperty.link( function( angle ) {
        pendulumNode.rotation = -angle;
        pendulumNode.translation = viewOriginPosition;
      } );

      // update pendulum components position
      pendulum.lengthProperty.link( function( length ) {
        var viewPendulumLength = modelViewTransform.modelToViewDeltaX( length );

        pendulumRect.setY( viewPendulumLength );
        solidLine.setY2( viewPendulumLength );
      } );

      // update rectangle size
      pendulum.massProperty.link( function( mass ) {
        pendulumRect.setScaleMagnitude( massToScale( mass ) );
      } );

      // update visibility
      pendulum.isVisibleProperty.linkAttribute( pendulumNode, 'visible' );
    } );

    this.children = pendulumNodes.concat( velocityArrows ).concat( accelerationArrows );
  }

  pendulumLab.register( 'PendulaNode', PendulaNode );

  return inherit( Node, PendulaNode );
} );


define("string!PENDULUM_LAB/length",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/length");});


define("string!PENDULUM_LAB/mass",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/mass");});


define("string!PENDULUM_LAB/metersPattern",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/metersPattern");});


define("string!PENDULUM_LAB/kilogramsPattern",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/kilogramsPattern");});

// Copyright 2017, University of Colorado Boulder

/**
 * Panel with length/mass controls for all available pendula
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'PENDULUM_LAB/common/view/PendulumControlPanel',['require','PHET_CORE/inherit','SCENERY/nodes/Line','SUN/Panel','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','PENDULUM_LAB/common/view/PendulumNumberControl','PHETCOMMON/util/StringUtils','SCENERY/nodes/VBox','string!PENDULUM_LAB/length','string!PENDULUM_LAB/mass','string!PENDULUM_LAB/metersPattern','string!PENDULUM_LAB/kilogramsPattern'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'SCENERY/nodes/Line' );
  var Panel = require( 'SUN/Panel' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PendulumNumberControl = require( 'PENDULUM_LAB/common/view/PendulumNumberControl' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var VBox = require( 'SCENERY/nodes/VBox' );

  // strings
  var lengthString = require( 'string!PENDULUM_LAB/length' );
  var massString = require( 'string!PENDULUM_LAB/mass' );
  var metersPatternString = require( 'string!PENDULUM_LAB/metersPattern' );
  var kilogramsPatternString = require( 'string!PENDULUM_LAB/kilogramsPattern' );

  /**
   * @constructor
   *
   * @param {Array.<Pendulum>} pendula
   * @param {Property.<number>} numberOfPendulaProperty
   */
  function PendulumControlPanel( pendula, numberOfPendulaProperty ) {

    var content = new VBox( {
      spacing: 16
    } );

    var separator = new Line( {
      stroke: 'rgb(160,160,160)',
      lineWidth: 0.3,
      x2: PendulumLabConstants.RIGHT_CONTENT_WIDTH
    } );

    var pendulumSliderGroups = pendula.map( function( pendulum ) {
      var pendulumNumberString = '' + ( pendulum.index + 1 );
      var lengthTitle = StringUtils.fillIn( lengthString, {
        pendulumNumber: pendulumNumberString
      } );
      var massTitle = StringUtils.fillIn( massString, {
        pendulumNumber: pendulumNumberString
      } );

      var lengthPattern = StringUtils.fillIn( metersPatternString, { meters: '{0}' } );
      var massPattern = StringUtils.fillIn( kilogramsPatternString, { kilograms: '{0}' } );

      return new VBox( {
        spacing: 14,
        align: 'left',
        children: [
          new PendulumNumberControl( lengthTitle, pendulum.lengthProperty, pendulum.lengthRange, lengthPattern, pendulum.color ),
          new PendulumNumberControl( massTitle, pendulum.massProperty, pendulum.massRange, massPattern, pendulum.color )
        ]
      } );
    } );

    numberOfPendulaProperty.link( function( numberOfPendula ) {
      content.children = numberOfPendula === 1 ? [
        pendulumSliderGroups[ 0 ]
      ] : [
        pendulumSliderGroups[ 0 ],
        separator,
        pendulumSliderGroups[ 1 ]
      ];
    } );

    Panel.call( this, content, PendulumLabConstants.PANEL_OPTIONS );
  }

  pendulumLab.register( 'PendulumControlPanel', PendulumControlPanel );

  return inherit( Panel, PendulumControlPanel );
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * A drag handler for something that has a location and is constrained to some (optional) bounds.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SCENERY_PHET/input/MovableDragHandler',['require','DOT/Bounds2','PHET_CORE/inherit','PHETCOMMON/view/ModelViewTransform2','SCENERY/input/SimpleDragHandler','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var Bounds2 = require( 'DOT/Bounds2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Property.<Vector2>} locationProperty - in model coordinate frame
   * @param {Object} [options]
   * @constructor
   */
  function MovableDragHandler( locationProperty, options ) {

    var self = this;

    options = _.extend( {
      dragBounds: Bounds2.EVERYTHING, // {Bounds2} dragging will be constrained to these bounds, in model coordinate frame
      modelViewTransform: ModelViewTransform2.createIdentity(), // {ModelViewTransform2} defaults to identity
      startDrag: function( event ) {},  // use this to do something at the start of dragging, like moving a node to the foreground
      onDrag: function( event ) {}, // use this to do something every time drag is called, such as notify that a user has modified the position
      endDrag: function( event ) {},  // use this to do something at the end of dragging, like 'snapping'
      allowTouchSnag: true, // Override this with false to prevent touch snagging.

      // MovableDragHandler defaults to using event.currentTarget for its reference coordinate frame, but
      // the target can be overridden here. This is useful when you need to attach a listener to a sub-component
      // of a node hierarchy
      targetNode: null,
      tandem: Tandem.tandemRequired()
    }, options );

    this.locationProperty = locationProperty; // @private
    this._dragBounds = options.dragBounds.copy(); // @private
    this._modelViewTransform = options.modelViewTransform; // @private

    var startOffset; // where the drag started relative to locationProperty, in parent view coordinates

    // @private - note where the drag started
    this.movableDragHandlerStart = function( event, trail ) {

      options.startDrag( event );

      // Note the options.startDrag can change the locationProperty, so read it again above, see https://github.com/phetsims/scenery-phet/issues/157
      var location = self._modelViewTransform.modelToViewPosition( locationProperty.get() );
      if ( options.targetNode ) {
        startOffset = options.targetNode.globalToParentPoint( event.pointer.point );
      }
      else {
        // See https://github.com/phetsims/beers-law-lab/issues/197, the Trail provided looks buggy (missing last node)
        startOffset = trail.globalToLocalPoint( event.pointer.point );
      }
      startOffset = startOffset.minus( location );
    };

    // @private - change the location, adjust for starting offset, constrain to drag bounds
    this.movableDragHandlerDrag = function( event, trail ) {
      var parentPoint;
      if ( options.targetNode ) {
        parentPoint = options.targetNode.globalToParentPoint( event.pointer.point );
      }
      else {
        // See https://github.com/phetsims/beers-law-lab/issues/197, the Trail provided looks buggy (missing last node)
        parentPoint = trail.globalToLocalPoint( event.pointer.point );
      }
      parentPoint = parentPoint.minus( startOffset );
      var location = self._modelViewTransform.viewToModelPosition( parentPoint );
      location = self._dragBounds.closestPointTo( location );

      locationProperty.set( location );

      options.onDrag( event );
    };

    // @private
    this.movableDragHandlerEnd = function( event, trail ) {
      options.endDrag( event );
    };

    SimpleDragHandler.call( this, {
      tandem: options.tandem,
      allowTouchSnag: options.allowTouchSnag,
      start: this.movableDragHandlerStart,
      drag: this.movableDragHandlerDrag,
      end: this.movableDragHandlerEnd
    } );
  }

  sceneryPhet.register( 'MovableDragHandler', MovableDragHandler );

  // MovableDragHandler extends SimpleDragHandler to facilitate phet-io instrumentation.  If no tandem is provided,
  // then no additional work is done.
  return inherit( SimpleDragHandler, MovableDragHandler, {

    /**
     * Sets the dragBounds.
     * In addition, it forces the location to be within the bounds.
     * @param {Bounds2} dragBounds
     * @public
     */
    setDragBounds: function( dragBounds ) {
      this._dragBounds = dragBounds.copy();
      this.constrainToBounds();
    },
    set dragBounds( value ) { this.setDragBounds( value ); },

    /**
     * Gets the dragBounds. Clients should not mutate the value returned.
     * @returns {Bounds2}
     * @public
     */
    getDragBounds: function() {
      return this._dragBounds;
    },
    get dragBounds() { return this.getDragBounds(); },

    /**
     * If the location is outside of the drag bounds, change it to lie to the closest in-bounds point.
     * @public
     */
    constrainToBounds: function() {
      this.locationProperty.set( this._dragBounds.closestPointTo( this.locationProperty.get() ) );
    },

    /**
     * Sets the modelViewTransform.
     * @param {ModelViewTransform2} modelViewTransform
     * @public
     */
    setModelViewTransform: function( modelViewTransform ) {
      this._modelViewTransform = modelViewTransform;
    },
    set modelViewTransform( modelViewTransform ) { this.setModelViewTransform( modelViewTransform ); },

    /**
     * Gets the modelViewTransform. Clients should not mutate the value returned.
     * @returns {ModelViewTransform2}
     * @public
     */
    getModelViewTransform: function() {
      return this._modelViewTransform;
    },
    get modelViewTransform() { return this.getModelViewTransform(); },

    /**
     * Forward an event from another listener to this one, useful when dragging an icon from a toolbox.
     * @param event
     * @public
     */
    handleForwardedStartEvent: function( event, trail ) {
      this.movableDragHandlerStart( event, trail );
    },

    /**
     * Forward an event from another listener to this one, useful when dragging an icon from a toolbox.
     * @param event
     * @public
     */
    handleForwardedDragEvent: function( event, trail ) {
      this.movableDragHandlerDrag( event, trail );
    },

    /**
     * Forward an event from another listener to this one, useful when dragging an icon from a toolbox.
     * @param event
     * @public
     */
    handleForwardedEndEvent: function( event, trail ) {
      this.movableDragHandlerEnd( event, trail );
    }
  } );
} );

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Visual representation of a ruler.
 * Lots of options, see default options in constructor.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/RulerNode',['require','PHET_CORE/inherit','SCENERY_PHET/PhetFont','SCENERY_PHET/sceneryPhet','KITE/Shape','TANDEM/Tandem','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/nodes/Rectangle','SCENERY/nodes/Text'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Shape = require( 'KITE/Shape' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Text = require( 'SCENERY/nodes/Text' );

  // constants
  var DEFAULT_FONT = new PhetFont( 18 );

  /**
   * @param {number} rulerWidth  distance between left-most and right-most tick, insets will be added to this
   * @param {number} rulerHeight
   * @param {number} majorTickWidth
   * @param {string[]} majorTickLabels
   * @param {string} units
   * @param {Object} [options]
   * @constructor
   */
  function RulerNode( rulerWidth, rulerHeight, majorTickWidth, majorTickLabels, units, options ) {

    // default options
    options = _.extend( {
      // body of the ruler
      backgroundFill: 'rgb(236, 225, 113)',
      backgroundStroke: 'black',
      backgroundLineWidth: 1,
      insetsWidth: 14, // space between the ends of the ruler and the first and last tick marks

      // major tick options
      majorTickFont: DEFAULT_FONT,
      majorTickHeight: ( 0.4 * rulerHeight ) / 2,
      majorTickStroke: 'black',
      majorTickLineWidth: 1,

      // minor tick options
      minorTickFont: DEFAULT_FONT,
      minorTickHeight: ( 0.2 * rulerHeight ) / 2,
      minorTickStroke: 'black',
      minorTickLineWidth: 1,
      minorTicksPerMajorTick: 0,

      // units options
      unitsFont: DEFAULT_FONT,
      unitsMajorTickIndex: 0, // units will be place to the right of this major tick
      unitsSpacing: 3, // horizontal space between the tick label and the units

      // appearance options
      tickMarksOnTop: true,
      tickMarksOnBottom: true,

      // phet-io
      tandem: Tandem.tandemRequired()
    }, options );

    // things you're likely to mess up, add more as needed
    assert && assert( Math.floor( rulerWidth / majorTickWidth ) + 1 === majorTickLabels.length ); // do we have enough major tick labels?
    assert && assert( options.unitsMajorTickIndex < majorTickLabels.length );
    assert && assert( options.majorTickHeight < rulerHeight / 2 );
    assert && assert( options.minorTickHeight < rulerHeight / 2 );

    Node.call( this, { tandem: options.tandem.createSupertypeTandem() } );

    // background
    var backgroundNode = new Rectangle( 0, 0, rulerWidth + ( 2 * options.insetsWidth ), rulerHeight, {
      fill: options.backgroundFill,
      stroke: options.backgroundStroke,
      lineWidth: options.backgroundLineWidth,
      tandem: options.tandem.createTandem( 'backgroundNode' )
    } );
    this.addChild( backgroundNode );

    // Lay out tick marks from left to right
    var minorTickWidth = majorTickWidth / ( options.minorTicksPerMajorTick + 1 );
    var numberOfTicks = Math.floor( rulerWidth / minorTickWidth ) + 1;
    var x = options.insetsWidth;
    var majorTickIndex = 0;

    // Minimize number of nodes by using one path for each type of tick line
    var majorTickLinesShape = new Shape();
    var minorTickLinesShape = new Shape();

    // Units label, which is positioned and (if necessary) scaled later
    var unitsLabel = new Text( units, {
      font: options.unitsFont,
      pickable: false,
      tandem: options.tandem.createTandem( 'unitsLabel' )
    } );
    var unitsLabelMaxWidth = Number.POSITIVE_INFINITY;
    this.addChild( unitsLabel );

    var majorTickLabelsGroupTandem = options.tandem.createGroupTandem( 'majorTickLabels' );

    for ( var i = 0; i < numberOfTicks; i++ ) {

      if ( i % ( options.minorTicksPerMajorTick + 1 ) === 0 ) {  // assumes that the first (leftmost) tick is a major tick

        // Major tick

        // Create the tick label regardless of whether we add it, since it's required to layout the units label
        var majorTickLabel = majorTickLabels[ majorTickIndex ];
        var majorTickLabelNode = new Text( majorTickLabel, {
          font: options.majorTickFont,
          centerX: x,
          centerY: backgroundNode.centerY,
          pickable: false,
          tandem: majorTickLabelsGroupTandem.createNextTandem()
        } );

        // Only add a major tick at leftmost or rightmost end if the insetsWidth is nonzero
        if ( options.insetsWidth !== 0 || ( i !== 0 && i !== numberOfTicks - 1 ) ) {

          // label, only added as a child if it's non-empty (and non-null)
          if ( majorTickLabel ) {
            this.addChild( majorTickLabelNode );
          }

          // line
          if ( options.tickMarksOnTop ) {
            majorTickLinesShape.moveTo( x, 0 ).lineTo( x, options.majorTickHeight );
          }
          if ( options.tickMarksOnBottom ) {
            majorTickLinesShape.moveTo( x, rulerHeight - options.majorTickHeight ).lineTo( x, rulerHeight );
          }
        }

        // Position the units label
        if ( majorTickIndex === options.unitsMajorTickIndex ) {
          unitsLabel.left = majorTickLabelNode.right + options.unitsSpacing;
          unitsLabel.y = majorTickLabelNode.y;
        }
        else if ( majorTickIndex > options.unitsMajorTickIndex && unitsLabelMaxWidth === Number.POSITIVE_INFINITY && majorTickLabelNode.width > 0 ) {
          // make sure the units label fits between the tick mark labels
          if ( unitsLabel.right > ( majorTickLabelNode.left - options.unitsSpacing ) ) {
            unitsLabelMaxWidth = majorTickLabelNode.left - options.unitsSpacing - unitsLabel.left;
            assert && assert( unitsLabelMaxWidth > 0, 'space for units label is negative or zero' );
            unitsLabel.maxWidth = unitsLabelMaxWidth;
          }
        }

        majorTickIndex++;
      }
      else {
        // Minor tick
        // Only add a minor tick at leftmost or rightmost end if the insetsWidth is nonzero
        if ( options.insetsWidth !== 0 || ( i !== 0 && i !== numberOfTicks - 1 ) ) {
          if ( options.tickMarksOnTop ) {
            minorTickLinesShape.moveTo( x, 0 ).lineTo( x, options.minorTickHeight );
          }
          if ( options.tickMarksOnBottom ) {
            minorTickLinesShape.moveTo( x, rulerHeight - options.minorTickHeight ).lineTo( x, rulerHeight );
          }
        }
      }
      x += minorTickWidth;
    }

    // Handle the case where the units label extends off the edge of the ruler.  This is kind of a corner case, but was
    // seen when testing long strings on Pendulum Lab.
    if ( unitsLabel.bounds.maxX > backgroundNode.bounds.maxX - options.unitsSpacing ) {
      unitsLabelMaxWidth = ( backgroundNode.bounds.maxX - options.unitsSpacing ) - unitsLabel.x;
      unitsLabel.scale( unitsLabelMaxWidth / unitsLabel.width );
    }

    // Major tick lines
    this.addChild( new Path( majorTickLinesShape, {
      stroke: options.majorTickStroke,
      lineWidth: options.majorTickLineWidth,
      pickable: false,
      tandem: options.tandem.createTandem( 'majorTickLinesNode' )
    } ) );

    // Minor tick lines
    this.addChild( new Path( minorTickLinesShape, {
      stroke: options.minorTickStroke,
      lineWidth: options.minorTickLineWidth,
      pickable: false,
      tandem: options.tandem.createTandem( 'minorTickLinesNode' )
    } ) );

    this.mutate( options );
  }

  sceneryPhet.register( 'RulerNode', RulerNode );

  return inherit( Node, RulerNode );
} );


define("string!PENDULUM_LAB/rulerUnits",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/rulerUnits");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 *  Ruler node in 'Pendulum Lab' simulation.
 *  Ruler is rotated 90 degrees.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/PendulumLabRulerNode',['require','PHET_CORE/inherit','SCENERY_PHET/input/MovableDragHandler','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY_PHET/RulerNode','string!PENDULUM_LAB/rulerUnits'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var MovableDragHandler = require( 'SCENERY_PHET/input/MovableDragHandler' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var RulerNode = require( 'SCENERY_PHET/RulerNode' );

  // strings
  var rulerUnitsString = require( 'string!PENDULUM_LAB/rulerUnits' );

  // constants
  var RULER_HEIGHT = 34;
  var TICK_INTERVAL = 5; // tick interval in cm

  /**
   * @constructor
   *
   * @param {Ruler} ruler - Model for ruler.
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Bounds2} layoutBounds - Bounds of screen view
   */
  function PendulumLabRulerNode( ruler, modelViewTransform, layoutBounds ) {
    var self = this;

    // create tick labels
    var tickLabel;
    var rulerTicks = [ '' ]; // zero tick is not labeled
    for ( var currentTick = TICK_INTERVAL; currentTick < ruler.length * 100; currentTick += TICK_INTERVAL ) {
      // if the current tick is a multiple of twice the Tick interval then label it as such otherwise it is not labeled.
      tickLabel = currentTick % ( 2 * TICK_INTERVAL ) ? '' : currentTick.toString();
      rulerTicks.push( tickLabel );
    }
    rulerTicks.push( '' ); // last tick is not labeled

    // define ruler params in view coordinates
    var rulerWidth = modelViewTransform.modelToViewDeltaX( ruler.length );
    var tickWidth = rulerWidth / ( rulerTicks.length - 1 );

    RulerNode.call( this, rulerWidth, RULER_HEIGHT, tickWidth, rulerTicks, rulerUnitsString, {
      backgroundFill: 'rgb( 237, 225, 121 )',
      cursor: 'pointer',
      insetsWidth: 0,
      majorTickFont: PendulumLabConstants.RULER_FONT,
      majorTickHeight: 12,
      minorTickHeight: 6,
      unitsFont: PendulumLabConstants.RULER_FONT,
      unitsMajorTickIndex: rulerTicks.length - 3,
      minorTicksPerMajorTick: 4,
      tickMarksOnBottom: false
    } );

    // make it a vertical ruler
    this.rotate( Math.PI / 2 );

    // @public
    this.movableDragHandler = new MovableDragHandler( ruler.locationProperty, {
      dragBounds: layoutBounds.erodedXY( this.width / 2, this.height / 2 )
    } );

    // add drag and drop events
    this.addInputListener( this.movableDragHandler );

    // add update of node location
    ruler.locationProperty.lazyLink( function( location ) {
      // because it's initially null, and will be null on a reset
      if ( location ) {
        self.center = location;
      }
    } );

    // set visibility observer
    ruler.isVisibleProperty.linkAttribute( this, 'visible' );
  }

  pendulumLab.register( 'PendulumLabRulerNode', PendulumLabRulerNode );

  return inherit( RulerNode, PendulumLabRulerNode );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Period trace node in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/PeriodTraceNode',['require','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','PENDULUM_LAB/pendulumLab','KITE/Shape','DOT/Vector2'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var Shape = require( 'KITE/Shape' );
  var Vector2 = require( 'DOT/Vector2' );

  // constants
  var DEFAULT_TRACE_STEP = 10; // in pixels - JO: No it's not pixels. At all...

  /**
   * @constructor
   *
   * @param {Pendulum} pendulum
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Object} [options]
   */
  function PeriodTraceNode( pendulum, modelViewTransform, options ) {
    var self = this;

    Node.call( this, _.extend( {
      pickable: false,
      rotation: Math.PI / 2,
      preventFit: true,
      translation: modelViewTransform.modelToViewPosition( Vector2.ZERO )
    }, options ) );

    var isCompleted = false; // flag to control completing of trace view

    var baseColor = new Color( pendulum.color );

    // @private {Pendulum}
    this.pendulum = pendulum;

    // @private {Color}
    this.traceColor = baseColor.copy();

    // @private {number} - The opacity of the trace (not using Node opacity for performance reasons)
    this.colorAlpha = 1;

    // @private {number|null} - If a number, the speed at which things fade out.
    this.fadeOutSpeed = null;

    // create trace path path
    var pathNode = new Path( null, {
      stroke: this.traceColor,
      lineWidth: 2
    } );
    self.addChild( pathNode );

    // reset the path
    var resetPath = function() {
      pathNode.setShape( null );
      isCompleted = false;
      self.colorAlpha = 1;
      self.traceColor.set( baseColor );
      self.fadeOutSpeed = null;
    };

    // draw the path based on the state of the pendulum
    var updateShape = function() {
      var periodTrace = pendulum.periodTrace;
      var numberOfPoints = periodTrace.numberOfPointsProperty.value;

      if ( numberOfPoints > 0 ) { // 0 means we just started the trace
        var shape = new Shape(); // create the new shape

        // trace length is how far away from the pivot the trace will show up.
        var traceLength = modelViewTransform.modelToViewDeltaX( pendulum.lengthProperty.value * 3.2 / 4 - 0.1 / 2 );

        // traceStep is how the distance between two line of the trace
        var traceStep = DEFAULT_TRACE_STEP;
        if ( traceStep * 4 > traceLength ) {
          traceStep = traceLength / 4;
        }

        // draw first arc
        if ( numberOfPoints > 1 ) {
          shape.arc( 0, 0, traceLength, 0, -periodTrace.firstAngle, !periodTrace.counterClockwise );
          shape.lineTo( ( traceLength - traceStep ) * Math.cos( -periodTrace.firstAngle ), (traceLength - traceStep) * Math.sin( -periodTrace.firstAngle ) );

          // draw second arc
          if ( numberOfPoints > 2 ) {
            shape.arc( 0, 0, traceLength - traceStep, -periodTrace.firstAngle, -periodTrace.secondAngle, periodTrace.counterClockwise );
            shape.lineTo( ( traceLength - 2 * traceStep ) * Math.cos( -periodTrace.secondAngle ), (traceLength - 2 * traceStep) * Math.sin( -periodTrace.secondAngle ) );

            // draw third arc
            if ( numberOfPoints > 3 ) {
              shape.arc( 0, 0, traceLength - 2 * traceStep, -periodTrace.secondAngle, 0, !periodTrace.counterClockwise );
              isCompleted = true;
              self.fadeOutSpeed = 1 / ( 3 * pendulum.getApproximatePeriod() / 2 );
            }
            else {
              shape.arc( 0, 0, traceLength - 2 * traceStep, -periodTrace.secondAngle, -pendulum.angleProperty.value, !periodTrace.counterClockwise );
            }
          }
          else {
            shape.arc( 0, 0, traceLength - traceStep, -periodTrace.firstAngle, -pendulum.angleProperty.value, periodTrace.counterClockwise );
          }
        }
        else {
          shape.arc( 0, 0, traceLength, 0, -pendulum.angleProperty.value, !periodTrace.counterClockwise );
        }
        pathNode.setShape( shape );
      }
    };

    // update path shape
    pendulum.angleProperty.link( function() {
      if ( pathNode.visible && !isCompleted ) {
        updateShape();
      }
    } );

    // update visibility of path node
    pendulum.periodTrace.isVisibleProperty.linkAttribute( pathNode, 'visible' );

    // clear trace if path points were removed
    pendulum.periodTrace.numberOfPointsProperty.lazyLink( function( numberNew, numberPrev ) {
      if ( numberNew < numberPrev ) {
        resetPath();
      }
    } );
  }

  pendulumLab.register( 'PeriodTraceNode', PeriodTraceNode );

  return inherit( Node, PeriodTraceNode, {
    /**
     * Steps the view.
     * @public
     *
     * @param {number} dt
     */
    step: function( dt ) {
      if ( this.fadeOutSpeed ) {
        this.colorAlpha = Math.max( 0, this.colorAlpha - this.fadeOutSpeed * dt );
        this.traceColor.alpha = this.colorAlpha;

        if ( this.colorAlpha === 0 ) {
          this.pendulum.periodTrace.onFaded();
          this.fadeOutSpeed = null;
        }
      }
    }
  } );
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * A node which always fills the entire screen, no matter what the transform is.
 * Used for showing an overlay on the screen e.g., when a popup dialog is shown.
 * This can fade the background to focus on the dialog/popup as well as intercept mouse events for dismissing the dialog/popup.
 * Note: This is currently implemented using large numbers, it should be rewritten to work in any coordinate frame, possibly using kite.Shape.plane()
 * TODO: Implement using infinite geometry
 *
 * @author Sam Reid
 */

define( 'SCENERY/nodes/Plane',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Rectangle'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );

  var Rectangle = require( 'SCENERY/nodes/Rectangle' );

  /**
   * @public
   * @constructor
   * @extends Rectangle
   *
   * @param {Object} [options] Passed to Rectangle. See Rectangle for more documentation
   */
  function Plane( options ) {
    Rectangle.call( this, -2000, -2000, 6000, 6000, options );
  }

  scenery.register( 'Plane', Plane );

  return inherit( Rectangle, Plane );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Icons for one or two pendula.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/PendulaIcons',['require','SCENERY/nodes/AlignBox','DOT/Bounds2','SCENERY/util/Color','SCENERY/nodes/Line','SCENERY/util/LinearGradient','SCENERY/nodes/Node','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY/nodes/Rectangle','DOT/Util'],function( require ) {
  'use strict';

  // modules
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Color = require( 'SCENERY/util/Color' );
  var Line = require( 'SCENERY/nodes/Line' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Node = require( 'SCENERY/nodes/Node' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Util = require( 'DOT/Util' );

  // constants
  var ICON_SIZE = 35;

  /**
   * Creates a small node showing a single pendulum.
   * @private
   *
   * @param {number} lineLength
   * @param {number} angle
   * @param {number} rectHeight
   * @param {string} rectColor
   * @returns {Node}
   */
  function createMiniPendulum( lineLength, angle, rectHeight, rectColor ) {
    var rectWidth = rectHeight * 0.8;
    var rectGradient = new LinearGradient( -rectWidth / 2, 0, rectWidth / 2, 0 )
      .addColorStop( 0, Color.toColor( rectColor ).colorUtilsBrighter( 0.2 ) )
      .addColorStop( 0.2, Color.toColor( rectColor ).colorUtilsBrighter( 0.7 ) )
      .addColorStop( 0.7, rectColor );
    return new Node( {
      children: [
        // string
        new Line( 0, 0, 0, lineLength, {
          stroke: 'black',
          rotation: angle
        } ),
        // mass
        new Rectangle( -rectWidth / 2, lineLength, rectWidth, rectHeight, {
          stroke: 'black',
          fill: rectGradient,
          rotation: angle
        } )
      ]
    } );
  }

  var firstPendulumNode = createMiniPendulum( ICON_SIZE * 0.6, Util.toRadians( -10 ), ICON_SIZE * 0.4, PendulumLabConstants.FIRST_PENDULUM_COLOR );
  var secondPendulumNode = createMiniPendulum( ICON_SIZE * 0.5, Util.toRadians( 20 ), ICON_SIZE * 0.25, PendulumLabConstants.SECOND_PENDULUM_COLOR );
  var iconBounds = new Bounds2( 0, 0, ICON_SIZE, ICON_SIZE );

  var PendulaIcons = {
    // @public {Node} - Icon with just one pendulum
    ONE_PENDULUM_ICON: new AlignBox( new Node( {
      children: [ firstPendulumNode ]
    } ), {
      alignBounds: iconBounds,
      pickable: false
    } ),
    // @public {Node} - Icon with both pendula
    TWO_PENDULA_ICON: new AlignBox( new Node( {
      children: [ firstPendulumNode, secondPendulumNode ]
    } ), {
      alignBounds: iconBounds,
      pickable: false
    } )
  };

  pendulumLab.register( 'PendulaIcons', PendulaIcons );

  return PendulaIcons;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * A derived property that maps sticky toggle button model states to the values needed by the button view.
 */
define( 'SUN/buttons/ToggleButtonInteractionStateProperty',['require','AXON/DerivedProperty','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {ButtonModel} buttonModel
   * @constructor
   */
  function ToggleButtonInteractionStateProperty( buttonModel ) {

    DerivedProperty.call(
      this,
      [ buttonModel.overProperty, buttonModel.downProperty, buttonModel.enabledProperty ],
      function( over, down, enabled ) {
        return !enabled ? 'disabled' :
               over && !(down ) ? 'over' :
               down ? 'pressed' :
               'idle';
      }
    );
  }

  sun.register( 'ToggleButtonInteractionStateProperty', ToggleButtonInteractionStateProperty );

  return inherit( DerivedProperty, ToggleButtonInteractionStateProperty );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Model for a toggle button that changes value on each "up" event when the button is released.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author John Blanco (PhET Interactive Simulations)
 */
define( 'SUN/buttons/ToggleButtonModel',['require','SUN/buttons/ButtonModel','AXON/Emitter','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var ButtonModel = require( 'SUN/buttons/ButtonModel' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {Object} valueOff - value when the button is in the off state
   * @param {Object} valueOn - value when the button is in the on state
   * @param {Property} property - axon Property that can be either valueOff or valueOn.
   * @constructor
   */
  function ToggleButtonModel( valueOff, valueOn, property ) {

    var self = this;

    // @private
    this.valueOff = valueOff;
    this.valueOn = valueOn;
    this.valueProperty = property;

    ButtonModel.call( this );

    // phet-io support
    this.startedCallbacksForToggledEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForToggledEmitter = new Emitter( { indicateCallbacks: false } );

    // Behaves like a push button (with fireOnDown:false), but toggles its state when the button is released.
    var downListener = function( down ) {
      if ( self.enabledProperty.get() && self.overProperty.get() ) {
        if ( !down ) {
          self.toggle();
        }
      }
    };
    this.downProperty.link( downListener ); // @private

    // @private - dispose items specific to this instance
    this.disposeToggleButtonModel = function() {
      self.downProperty.unlink( downListener );
    };
  }

  sun.register( 'ToggleButtonModel', ToggleButtonModel );

  return inherit( ButtonModel, ToggleButtonModel, {

    // @public
    dispose: function() {
      this.disposeToggleButtonModel();
      ButtonModel.prototype.dispose.call( this );
    },

    // @public
    toggle: function() {
      assert && assert( this.valueProperty.value === this.valueOff || this.valueProperty.value === this.valueOn );
      var oldValue = this.valueProperty.value;
      var newValue = this.valueProperty.value === this.valueOff ? this.valueOn : this.valueOff;
      this.startedCallbacksForToggledEmitter.emit2( oldValue, newValue );
      this.valueProperty.value = newValue;
      this.endedCallbacksForToggledEmitter.emit();
    }
  } );
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/buttons/TToggleButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOfTypes','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOfTypes = require( 'ifphetio!PHET_IO/assertions/assertInstanceOfTypes' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * Wrapper type for phet/sun's ToggleButton class.
   * @param {ToggleButton} toggleButton
   * @param {string} phetioID
   * @constructor
   */
  function TToggleButton( toggleButton, phetioID ) {
    var validateTandems = phet.phetio && phet.phetio.queryParameters.phetioValidateTandems;
    assert && assert( !!toggleButton.phetioValueType || !validateTandems, 'toggleButton.phetioValueType must be specified' );
    TNode.call( this, toggleButton, phetioID );
    assertInstanceOfTypes( toggleButton, [
      phet.sun.RectangularToggleButton,
      phet.sun.RoundStickyToggleButton,
      phet.sun.RoundToggleButton
    ] );

    // Both StickyToggleButtonModel and ToggleButtonModel send the args in this order: oldValue, newValue
    toEventOnEmit(
      toggleButton.toggleButtonModel.startedCallbacksForToggledEmitter,
      toggleButton.toggleButtonModel.endedCallbacksForToggledEmitter,
      'user', phetioID, this.constructor, 'toggled',
      function( oldValue, newValue ) {
        return {
          oldValue: toggleButton.phetioValueType.toStateObject( oldValue ),
          newValue: toggleButton.phetioValueType.toStateObject( newValue )
        };
      }
    );
  }

  phetioInherit( TNode, 'TToggleButton', TToggleButton, {}, {
    documentation: 'A button that toggles state (in/out) when pressed',
    events: [ 'toggled' ]
  } );


  sun.register( 'TToggleButton', TToggleButton );

  return TToggleButton;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * A round toggle button that switches the value of a property between 2 values.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RoundToggleButton',['require','PHET_CORE/inherit','SUN/buttons/RoundButtonView','SUN/sun','SUN/buttons/ToggleButtonInteractionStateProperty','SUN/buttons/ToggleButtonModel','TANDEM/Tandem','SUN/buttons/TToggleButton'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var RoundButtonView = require( 'SUN/buttons/RoundButtonView' );
  var sun = require( 'SUN/sun' );
  var ToggleButtonInteractionStateProperty = require( 'SUN/buttons/ToggleButtonInteractionStateProperty' );
  var ToggleButtonModel = require( 'SUN/buttons/ToggleButtonModel' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TToggleButton = require( 'SUN/buttons/TToggleButton' );

  /**
   * @param {Object} valueOff - value when the button is in the off state
   * @param {Object} valueOn - value when the button is in the on state
   * @param {Property} property - axon Property that can be either valueOff or valueOn
   * @param {Object} [options]
   * @constructor
   */
  function RoundToggleButton( valueOff, valueOn, property, options ) {

    var self = this;

    // Tandem support
    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      phetioType: TToggleButton,

      // a11y
      tagName: 'input',
      inputType: 'button'
    }, options );

    // @public, (read-only) (phet-io)
    this.toggleButtonModel = new ToggleButtonModel( valueOff, valueOn, property );
    this.phetioValueType = property.phetioValueType;

    RoundButtonView.call( this, this.toggleButtonModel, new ToggleButtonInteractionStateProperty( this.toggleButtonModel ), options );

    // @private (a11y) - toggle the button when we receive the accessible click event
    this.accessibleClickListener = this.addAccessibleInputListener( {
      click: function ( event ) {
        self.toggleButtonModel.toggle();
      }
    } );
  }

  sun.register( 'RoundToggleButton', RoundToggleButton );

  return inherit( RoundButtonView, RoundToggleButton, {

    // @public
    dispose: function() {
      this.removeAccessibleInputListener( this.accessibleClickListener );
      this.toggleButtonModel.dispose(); //TODO this fails with assertions enabled, see sun#212
      RoundButtonView.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Shows one node if the property is true or another node if the property is false.
 * Used to indicate boolean state.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/ToggleNode',['require','PHET_CORE/inherit','TANDEM/Tandem','SCENERY/nodes/Node','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Node = require( 'SCENERY/nodes/Node' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {Node} trueNode
   * @param {Node} falseNode
   * @param {Property.<boolean>} booleanProperty
   * @param {Object} [options]
   * @constructor
   */
  function ToggleNode( trueNode, falseNode, booleanProperty, options ) {

    options = _.extend( {
      tandem: Tandem.tandemRequired()
    }, options );
    Node.call( this );

    // align centers of the nodes, see https://github.com/phetsims/sun/issues/272
    falseNode.center = trueNode.center;

    this.addChild( falseNode );
    this.addChild( trueNode );

    booleanProperty.link( function( value ) {
      trueNode.setVisible( value );
      falseNode.setVisible( !value );

      // a11y - toggle visibility of accessible content for assistive technologies
      trueNode.setAccessibleContentDisplayed( value );
      falseNode.setAccessibleContentDisplayed( !value );
    } );

    this.mutate( options );
  }

  sun.register( 'ToggleNode', ToggleNode );

  return inherit( Node, ToggleNode );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * This toggle button uses a boolean property and a trueNode and falseNode to display its content.
 */
define( 'SUN/buttons/BooleanRoundToggleButton',['require','PHET_CORE/inherit','SUN/buttons/RoundToggleButton','SUN/sun','SUN/ToggleNode','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var RoundToggleButton = require( 'SUN/buttons/RoundToggleButton' );
  var sun = require( 'SUN/sun' );
  var ToggleNode = require( 'SUN/ToggleNode' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Node} trueNode
   * @param {Node} falseNode
   * @param {Property.<boolean>} booleanProperty
   * @param {Object} [options]
   * @constructor
   */
  function BooleanRoundToggleButton( trueNode, falseNode, booleanProperty, options ) {

    options = _.extend( {
      tandem: Tandem.tandemRequired()
    }, options );

    //TODO ToggleNode links to booleanProperty, must be cleaned up in dispose
    assert && assert( !options.content, 'options.content cannot be set' );
    options.content = new ToggleNode( trueNode, falseNode, booleanProperty, {
      tandem: options.tandem.createTandem( 'toggleNode' )
    } );

    RoundToggleButton.call( this, false, true, booleanProperty, options );
  }

  sun.register( 'BooleanRoundToggleButton', BooleanRoundToggleButton );

  return inherit( RoundToggleButton, BooleanRoundToggleButton );
} );

// Copyright 2014-2017, University of Colorado Boulder

/**
 * Play pause button for starting/stopping the sim.  Often appears at the bottom center of the screen.
 * Generated programmatically using RoundPushButton (as opposed to using raster images).
 *
 * @author Sam Reid
 */

define( 'SCENERY_PHET/buttons/PlayPauseButton',['require','PHET_CORE/inherit','SUN/buttons/BooleanRoundToggleButton','KITE/Shape','SCENERY/nodes/Path','SCENERY/nodes/Circle','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var BooleanRoundToggleButton = require( 'SUN/buttons/BooleanRoundToggleButton' );
  var Shape = require( 'KITE/Shape' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  var DEFAULT_RADIUS = 28;

  /**
   * @param {Property.<boolean>} runningProperty property that represents whether the sim is paused or not
   * @param {Object} [options] node options
   * @constructor
   */
  function PlayPauseButton( runningProperty, options ) {

    options = _.extend( {
      radius: DEFAULT_RADIUS
    }, options );

    // play and pause symbols are sized relative to the radius
    var triangleHeight = options.radius;
    var triangleWidth = options.radius * 0.8;
    var barWidth = options.radius * 0.2;
    var barHeight = triangleHeight;
    var playPath = new Path( new Shape().moveTo( 0, triangleHeight / 2 ).lineTo( triangleWidth, 0 ).lineTo( 0, -triangleHeight / 2 ).close(), { fill: 'black' } );

    var pauseIconShape = new Shape()
      .rect( 0, 0, barWidth, barHeight )
      .rect( 2 * barWidth, 0, barWidth, barHeight );
    var pausePath = new Path( pauseIconShape, { fill: 'black' } );

    // put the play and pause symbols inside circles so they have the same bounds,
    // otherwise ToggleNode will re-adjust their positions relative to each other
    var playCircle = new Circle( options.radius );
    playPath.centerX = options.radius * 0.05; // move to right slightly since we don't want it exactly centered
    playPath.centerY = 0;
    playCircle.addChild( playPath );

    var pausedCircle = new Circle( options.radius );
    pausePath.centerX = 0;
    pausePath.centerY = 0;
    pausedCircle.addChild( pausePath );

    BooleanRoundToggleButton.call( this, pausedCircle, playCircle, runningProperty, options );
  }

  sceneryPhet.register( 'PlayPauseButton', PlayPauseButton );

  return inherit( BooleanRoundToggleButton, PlayPauseButton );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Defines the appearance of the radio buttons, see RadioButtonGroup.js. This file is designed to be used by
 * RadioButtonGroup and RadioButtonGroupMember internally, so you should not need use it outside of these files.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Aaron Davis (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RadioButtonGroupAppearance',['require','SCENERY/util/Color','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var sun = require( 'SUN/sun' );

  // constants
  var DISABLED_OPACITY = 0.3;

  /**
   * Strategy for buttons that look flat, i.e. no shading or highlighting, but
   * that change color on mouseover, press, etc.
   *
   * @param {Node} button
   * @param {Property} interactionStateProperty
   * @param {Property} baseColorProperty
   * @param {Object} [options]
   * @constructor
   */
  var DefaultRadioButtonsAppearance = function( button, interactionStateProperty, baseColorProperty, options ) {

    // TODO: Changes were made to the appearance strategies to support dynamic changes of the base color, see
    // https://github.com/phetsims/sun/issues/138.  This feature has not yet been implemented in this appearance
    // strategy, please add it if you need it.
    function handleBaseColorChanged() {
      assert && assert( false, 'Dynamic base color not yet implemented in this appearance strategy.' );
    }

    baseColorProperty.lazyLink( handleBaseColorChanged );

    // Set up variables needed to create the various fills and strokes
    var baseColor = Color.toColor( baseColorProperty.value );
    var disabledBaseColor = Color.toColor( options.disabledBaseColor );
    var deselectedStroke = Color.toColor( options.deselectedStroke );

    // Create the fills and strokes used for various button states
    var disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
    var overStroke = options.overStroke ? options.overStroke : deselectedStroke.colorUtilsDarker( 0.4 );
    var overFill = options.overFill ? options.overFill : baseColor.colorUtilsBrighter( 0.4 );
    var pressedFill = baseColor.colorUtilsDarker( 0.4 );

    button.cachedPaints = [
      baseColor, overFill, disabledBaseColor, pressedFill,
      options.deselectedStroke, overStroke, options.selectedStroke, disabledStroke
    ];

    function handleInteractionStateChanged( state ) {
      switch( state ) {

        case 'deselected':
          button.fill = baseColor;
          button.stroke = options.deselectedStroke;
          button.lineWidth = options.deselectedLineWidth;
          button.opacity = options.deselectedButtonOpacity;
          break;

        // mouseover for deselected buttons
        case 'over':
          button.fill = overFill;
          button.stroke = overStroke;
          button.lineWidth = ( options.overLineWidth ) ? options.overLineWidth : options.deselectedLineWidth;
          button.opacity = options.overButtonOpacity;
          break;

        case 'selected':
          button.fill = baseColor;
          button.stroke = options.selectedStroke;
          button.lineWidth = options.selectedLineWidth;
          button.opacity = options.selectedButtonOpacity;
          break;

        case 'disabled-deselected':
          button.fill = disabledBaseColor;
          button.stroke = disabledStroke;
          button.lineWidth = options.deselectedLineWidth;
          button.opacity = options.deselectedButtonOpacity;
          break;

        case 'disabled-selected':
          button.fill = disabledBaseColor;
          button.stroke = disabledStroke;
          button.lineWidth = options.selectedLineWidth;
          button.opacity = options.selectedButtonOpacity;
          break;

        case 'pressed':
          button.fill = pressedFill;
          button.stroke = options.deselectedStroke;
          button.lineWidth = options.deselectedLineWidth;
          button.opacity = options.selectedButtonOpacity;
          break;

        default:
          throw new Error( 'unsupported state: ' + state );
      }
    }

    interactionStateProperty.link( handleInteractionStateChanged );

    // add dispose function
    this.dispose = function() {
      baseColorProperty.unlink( handleBaseColorChanged );
      interactionStateProperty.unlink( handleInteractionStateChanged );
    };
  };

  /**
   * Strategy for changing the button content opacity for each of the different states:
   * mouseover, selected, deselected, and disabled
   *
   * @param {Node} content
   * @param {Property} interactionStateProperty
   * @param {Object} [options]
   * @constructor
   * @public
   */
  var ContentAppearanceStrategy = function( content, interactionStateProperty, options ) {

    // The button is not the parent of the content, therefore it is necessary to set the opacity on the content separately
    function handleInteractionStateChanged( state ) {
      if ( content !== null ) {
        switch( state ) {

          case 'deselected':
            content.opacity = options.deselectedContentOpacity;
            break;

          // mouseover for deselected buttons
          case 'over':
            content.opacity = options.overContentOpacity;
            break;

          case 'selected':
            content.opacity = options.selectedContentOpacity;
            break;

          case 'disabled-deselected':
            content.opacity = DISABLED_OPACITY;
            break;

          case 'disabled-selected':
            content.opacity = DISABLED_OPACITY;
            break;

          case 'pressed':
            content.opacity = options.deselectedContentOpacity;
            break;

          default:
            throw new Error( 'unsupported state: ' + state );
        }
      }
    }

    interactionStateProperty.link( handleInteractionStateChanged );

    // add a disposal function
    this.dispose = function() {
      interactionStateProperty.unlink( handleInteractionStateChanged );
    };
  };

  var RadioButtonGroupAppearance = {
    defaultRadioButtonsAppearance: DefaultRadioButtonsAppearance,
    contentAppearanceStrategy: ContentAppearanceStrategy
  };

  sun.register( 'RadioButtonGroupAppearance', RadioButtonGroupAppearance );

  return RadioButtonGroupAppearance;

} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Model for a RadioButtonGroupMember in RadioButtonGroup. This model is designed to be used inside
 * RadioButtonGroupMember only, so there should be no need to use it outside of RadioButtonGroupMember.
 *
 * @author Aaron Davis (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RadioButtonGroupMemberModel',['require','SUN/buttons/ButtonModel','AXON/Emitter','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var ButtonModel = require( 'SUN/buttons/ButtonModel' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {Property} selectorProperty - the property for the RadioButtonGroup that determines which button is selected
   * @param {Object} selectedValue - the value that selectorProperty takes when this particular SingleRadioButton is selected
   * @constructor
   */
  function RadioButtonGroupMemberModel( selectorProperty, selectedValue ) {

    ButtonModel.call( this );

    var self = this;

    this.selectedValue = selectedValue;
    this.selectorProperty = selectorProperty;
    this.startedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );

    // @public (read only) - fire on up if the button is enabled, public for use in the accessibility tree
    this.fire = function() {
      if ( self.enabledProperty.get() ) {
        self.startedCallbacksForFiredEmitter.emit1( selectedValue );
        selectorProperty.set( selectedValue );
        self.endedCallbacksForFiredEmitter.emit();
      }
    };
    this.downProperty.onValue( false, function() {
      if ( self.overProperty.get() ) {
        self.fire();
      }
    } );
  }

  sun.register( 'RadioButtonGroupMemberModel', RadioButtonGroupMemberModel );

  return inherit( ButtonModel, RadioButtonGroupMemberModel );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * A derived property that maps radio button group member model states to the values
 * needed by the button view.
 */
define( 'SUN/buttons/RadioButtonInteractionStateProperty',['require','AXON/DerivedProperty','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';

  // modules
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );

  /**
   * @param {ButtonModel} buttonModel
   * @constructor
   */
  function RadioButtonInteractionStateProperty( buttonModel ) {

    DerivedProperty.call(
      this,
      [ buttonModel.overProperty, buttonModel.downProperty, buttonModel.enabledProperty, buttonModel.selectorProperty ],
      function( over, down, enabled, propertyValue ) {
        var isSelected = ( propertyValue === buttonModel.selectedValue );
        return !enabled && isSelected ? 'disabled-selected' :
               !enabled ? 'disabled-deselected' :
               over && !(down || isSelected) ? 'over' :
               over && down ? 'pressed' :
               isSelected ? 'selected' :
               'deselected';
      } );
  }

  sun.register( 'RadioButtonInteractionStateProperty', RadioButtonInteractionStateProperty );

  return inherit( DerivedProperty, RadioButtonInteractionStateProperty );
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/TRadioButtonGroupMember',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/toEventOnEmit','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * Wrapper type for phet/sun's RadioButton class.
   * @param {RadioButtonGroupMember} radioButton
   * @param {String} phetioID
   * @constructor
   */
  function TRadioButtonGroupMember( radioButton, phetioID ) {
    if ( Tandem.validationEnabled() ) {
      assert && assert( !!radioButton.phetioValueType, 'phetioValueType must be defined' );
    }
    assertInstanceOf( radioButton, phet.sun.RadioButtonGroupMember );
    TNode.call( this, radioButton, phetioID );

    toEventOnEmit(
      radioButton.radioButtonGroupMemberModel.startedCallbacksForFiredEmitter,
      radioButton.radioButtonGroupMemberModel.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired',
      function( value ) {
        return { value: radioButton.phetioValueType.toStateObject( value ) };
      }
    );
  }

  phetioInherit( TNode, 'TRadioButtonGroupMember', TRadioButtonGroupMember, {}, {
    documentation: 'A traditional radio button',
    events: [ 'fired' ]
  } );

  sun.register( 'TRadioButtonGroupMember', TRadioButtonGroupMember );

  return TRadioButtonGroupMember;
} );


// Copyright 2014-2015, University of Colorado Boulder

/**
 * A single radio button. This class is designed to be part of a RadioButtonGroup and there should be no need to use it
 * outside of RadioButtonGroup. It is called RadioButtonGroupMember to differentiate from RadioButton, which already
 * exists.
 *
 * @author Aaron Davis (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RadioButtonGroupMember',['require','SCENERY/util/Color','SUN/ColorConstants','PHET_CORE/inherit','SUN/buttons/RectangularButtonView','SUN/buttons/RadioButtonGroupAppearance','SUN/buttons/RadioButtonGroupMemberModel','SUN/buttons/RadioButtonInteractionStateProperty','SUN/sun','TANDEM/Tandem','SUN/TRadioButtonGroupMember'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var ColorConstants = require( 'SUN/ColorConstants' );
  var inherit = require( 'PHET_CORE/inherit' );
  var RectangularButtonView = require( 'SUN/buttons/RectangularButtonView' );
  var RadioButtonGroupAppearance = require( 'SUN/buttons/RadioButtonGroupAppearance' );
  var RadioButtonGroupMemberModel = require( 'SUN/buttons/RadioButtonGroupMemberModel' );
  var RadioButtonInteractionStateProperty = require( 'SUN/buttons/RadioButtonInteractionStateProperty' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TRadioButtonGroupMember = require( 'SUN/TRadioButtonGroupMember' );

  /**
   * @param {Property} property axon property that can take on a set of values, one for each radio button in the group
   * @param {Object} value value when this radio button is selected
   * @param {Object} [options]
   * @constructor
   */
  function RadioButtonGroupMember( property, value, options ) {

    var self = this;

    options = _.extend( {
      // The fill for the rectangle behind the radio buttons.  Default color is bluish color, as in the other button library.
      baseColor: ColorConstants.LIGHT_BLUE,
      disabledBaseColor: ColorConstants.LIGHT_GRAY,

      // Opacity can be set separately for the buttons and button content.
      selectedButtonOpacity: 1,
      deselectedButtonOpacity: 0.6,
      selectedContentOpacity: 1,
      deselectedContentOpacity: 0.6,
      overButtonOpacity: 0.8,
      overContentOpacity: 0.8,

      selectedStroke: 'black',
      deselectedStroke: new Color( 50, 50, 50 ),
      selectedLineWidth: 1.5,
      deselectedLineWidth: 1,

      // The following options specify highlight behavior overrides, leave as null to get the default behavior
      // Note that highlighting applies only to deselected buttons
      overFill: null,
      overStroke: null,
      overLineWidth: null,

      // The default appearances use the color values specified above, but other appearances could be specified for more
      // customized behavior.  Generally setting the color values above should be enough to specify the desired look.
      buttonAppearanceStrategy: RadioButtonGroupAppearance.defaultRadioButtonsAppearance,
      contentAppearanceStrategy: RadioButtonGroupAppearance.contentAppearanceStrategy,

      // a11y
      tagName: 'input',
      inputType: 'radio',

      tandem: Tandem.tandemRequired(),
      phetioType: TRadioButtonGroupMember
    }, options );

    assert && assert( !options.hasOwnProperty( 'phetioValueType' ), 'phetioValueType should be provided by the property and not through options.' );

    // @public (phet-io)
    this.radioButtonGroupMemberModel = new RadioButtonGroupMemberModel( property, value );
    this.phetioValueType = property.phetioValueType;

    // @public for use in RadioButtonGroup for managing the labels
    this.interactionStateProperty = new RadioButtonInteractionStateProperty( this.radioButtonGroupMemberModel );

    RectangularButtonView.call( this, this.radioButtonGroupMemberModel, this.interactionStateProperty, options );

    // a11y - on reception of a change event, update the Property value
    var accessibleChangeListener = this.addAccessibleInputListener( {
      change: function( event ) {
        property.set( value );
      }
    } );

    // a11y - Specify the default value for assistive technology, this attribute is needed in addition to 
    // the 'checked' property to mark this element as the default selection since 'checked' may be set before
    // we are finished adding RadioButtonGroupMembers to the RadioButtonGroup.
    if ( property.value === value ) {
      this.setAccessibleAttribute( 'checked', 'checked' );
    }

    // a11y - when the property changes, make sure the correct radio button is marked as 'checked' so that this button
    // receives focus on 'tab'
    var accessibleCheckedListener = function( newValue ) {
      self.accessibleChecked = newValue === value;
    };
    property.link( accessibleCheckedListener );

    // @private
    this.disposeRadioButtonGroupMember = function() {
      self.removeAccessibleInputListener( accessibleChangeListener );
      property.unlink( accessibleChangeListener );
    };
  }

  sun.register( 'RadioButtonGroupMember', RadioButtonGroupMember );

  return inherit( RectangularButtonView, RadioButtonGroupMember, {

    /**
     * Ensure eligibility for garbage collection.
     * 
     * @public
     */
    dispose: function() {
      this.disposeRadioButtonGroupMember();
      RectangularButtonView.prototype.dispose && RectangularButtonView.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Radio buttons. See ButtonsView for example usage.
 *
 * This type creates a group of radio buttons in either a horizontal or vertical formation.
 * Each button inherits from RectangularButtonView, and can take a Scenery Node as its content.
 * A typical use case is when you want to have different modes of a view to select from. Typically,
 * RadioButtonGroup radio buttons display some kind of icon or image, but that is not mandatory.
 *
 * @author Aaron Davis (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RadioButtonGroup',['require','SCENERY/util/Color','SUN/ColorConstants','PHET_CORE/inherit','SCENERY/nodes/LayoutBox','AXON/Property','SUN/buttons/RadioButtonGroupAppearance','SUN/buttons/RadioButtonGroupMember','SCENERY/nodes/Rectangle','KITE/Shape','SUN/sun','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var ColorConstants = require( 'SUN/ColorConstants' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LayoutBox = require( 'SCENERY/nodes/LayoutBox' );
  var Property = require( 'AXON/Property' );
  var RadioButtonGroupAppearance = require( 'SUN/buttons/RadioButtonGroupAppearance' );
  var RadioButtonGroupMember = require( 'SUN/buttons/RadioButtonGroupMember' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );

  // constants
  var BUTTON_CONTENT_X_ALIGN_VALUES = [ 'center', 'left', 'right' ];
  var BUTTON_CONTENT_Y_ALIGN_VALUES = [ 'center', 'top', 'bottom' ];

  // a11y - integer to allow distinct name attributes for each set of RadioButtonGroupMembers, increments with each
  // instantiation of RadioButtonGroup
  var instanceCount = 0;

  /**
   * RadioButtonGroup constructor.
   *
   * @param {Property} property
   * @param {Array} contentArray an array of objects that have two keys each: value and node the node key holds a
   * scenery Node that is the content for a given radio button. the value key should hold the value that the property
   * takes on for the corresponding node to be selected. Optionally, these objects can have an attribute 'label', which
   * is a {Node} used to label the button.
   * @param {Object} [options]
   * @constructor
   */
  function RadioButtonGroup( property, contentArray, options ) {
    options = _.extend( {
      tandem: Tandem.tandemRequired(),

      // a11y
      tagName: 'fieldset'
    }, options );

    // increment instance count
    instanceCount++;

    assert && assert( !options.hasOwnProperty( 'children' ), 'Cannot pass in children to a RadioButtonGroup, ' +
                                                             'create siblings in the parent node instead' );

    // make sure every object in the content array has properties 'node' and 'value'
    assert && assert( _.every( contentArray, function( obj ) {
      return obj.hasOwnProperty( 'node' ) && obj.hasOwnProperty( 'value' );
    } ), 'contentArray must be an array of objects with properties "node" and "value"' );

    var i; // for loops

    // make sure that each value passed into the contentArray is unique
    var uniqueValues = [];
    for ( i = 0; i < contentArray.length; i++ ) {
      if ( uniqueValues.indexOf( contentArray[ i ].value ) < 0 ) {
        uniqueValues.push( contentArray[ i ].value );
      }
      else {
        throw new Error( 'Duplicate value: "' + contentArray[ i ].value + '" passed into RadioButtonGroup.js' );
      }
    }

    // make sure that the property passed in currently has a value from the contentArray
    if ( uniqueValues.indexOf( property.get() ) === -1 ) {
      throw new Error( 'The property passed in to RadioButtonGroup has an illegal value "' + property.get() +
                       '" that is not present in the contentArray' );
    }

    var defaultOptions = {

      // LayoutBox options (super class of RadioButtonGroup)
      spacing: 10,
      orientation: 'vertical',

      enabledProperty: new Property( true ), // whether or not the set of radio buttons as a whole is enabled

      // The fill for the rectangle behind the radio buttons.  Default color is bluish color, as in the other button library.
      baseColor: ColorConstants.LIGHT_BLUE,
      disabledBaseColor: ColorConstants.LIGHT_GRAY,

      // Opacity can be set separately for the buttons and button content.
      selectedButtonOpacity: 1,
      deselectedButtonOpacity: 0.6,
      selectedContentOpacity: 1,
      deselectedContentOpacity: 0.6,
      overButtonOpacity: 0.8,
      overContentOpacity: 0.8,

      selectedStroke: 'black',
      deselectedStroke: new Color( 50, 50, 50 ),
      selectedLineWidth: 1.5,
      deselectedLineWidth: 1,

      // The following options specify highlight behavior overrides, leave as null to get the default behavior
      // Note that highlighting applies only to deselected buttons
      overFill: null,
      overStroke: null,
      overLineWidth: null,

      // These margins are *within* each button
      buttonContentXMargin: 5,
      buttonContentYMargin: 5,

      // alignment of the content nodes *within* each button
      buttonContentXAlign: 'center', // {string} see BUTTON_CONTENT_X_ALIGN_VALUES
      buttonContentYAlign: 'center', // {string} see BUTTON_CONTENT_Y_ALIGN_VALUES

      // TouchArea expansion
      touchAreaXDilation: 0,
      touchAreaYDilation: 0,

      // MouseArea expansion
      mouseAreaXDilation: 0,
      mouseAreaYDilation: 0,

      //The radius for each button
      cornerRadius: 4,

      // How far from the button the text label is (only applies if labels are passed in)
      labelSpacing: 0,

      // Which side of the button the label will appear, options are 'top', 'bottom', 'left', 'right'
      // (only applies if labels are passed in)
      labelAlign: 'bottom',

      // The default appearances use the color values specified above, but other appearances could be specified for more
      // customized behavior.  Generally setting the color values above should be enough to specify the desired look.
      buttonAppearanceStrategy: RadioButtonGroupAppearance.defaultRadioButtonsAppearance,
      contentAppearanceStrategy: RadioButtonGroupAppearance.contentAppearanceStrategy
    };

    options = _.extend( _.clone( defaultOptions ), options );

    assert && assert( _.includes( BUTTON_CONTENT_X_ALIGN_VALUES, options.buttonContentXAlign ),
      'invalid buttonContentXAlign: ' + options.buttonContentXAlign );
    assert && assert( _.includes( BUTTON_CONTENT_Y_ALIGN_VALUES, options.buttonContentYAlign ),
      'invalid buttonContentYAlign: ' + options.buttonContentYAlign );

    // make a copy of the options to pass to individual buttons that includes all default options but not scenery options
    var buttonOptions = _.pick( options, _.keys( defaultOptions ) );

    // calculate the maximum width and height of the content so we can make all radio buttons the same size
    var widestContentWidth = _.maxBy( contentArray, function( content ) { return content.node.width; } ).node.width;
    var tallestContentHeight = _.maxBy( contentArray, function( content ) { return content.node.height; } ).node.height;

    // make sure all radio buttons are the same size and create the RadioButtons
    var buttons = [];
    var button;
    for ( i = 0; i < contentArray.length; i++ ) {

      assert && assert( !contentArray[ i ].hasOwnProperty( 'phetioValueType' ), 'phetioValueType should be provided by ' +
                                                                                'the property passed to the ' +
                                                                                'RadioButtonGroup constructor' );

      assert && assert( !contentArray[ i ].tandem, 'content arrays should not have tandem instances, they should use ' +
                                                   'tandemName instead' );

      if ( Tandem.validationEnabled() ) {
        assert && assert( contentArray[ i ].tandemName, 'In PhET-iO mode, radio button group members must have a provided tandem' );
      }

      var radioButton = new RadioButtonGroupMember( property, contentArray[ i ].value, _.extend( {
        content: contentArray[ i ].node,
        xMargin: options.buttonContentXMargin,
        yMargin: options.buttonContentYMargin,
        xAlign: options.buttonContentXAlign,
        yAlign: options.buttonContentYAlign,
        minWidth: widestContentWidth + 2 * options.buttonContentXMargin,
        minHeight: tallestContentHeight + 2 * options.buttonContentYMargin,

        // Pass through the tandem given the tandemName, but also support uninstrumented simulations
        tandem: options.tandem.createTandem( contentArray[ i ].tandemName || ('radioButtonGroupMember' + i) )
      }, buttonOptions ) );

      // a11y - so the browser and assistive technology recognizes that these buttons are in the same group
      radioButton.setAccessibleAttribute( 'name', 'radioButtonGroup' + instanceCount + 'Member' );

      // ensure the buttons don't resize when selected vs unselected by adding a rectangle with the max size
      var maxLineWidth = Math.max( options.selectedLineWidth, options.deselectedLineWidth );
      var maxButtonWidth = maxLineWidth + widestContentWidth + options.buttonContentXMargin * 2;
      var maxButtonHeight = maxLineWidth + tallestContentHeight + options.buttonContentYMargin * 2;
      var boundingRect = new Rectangle( 0, 0, maxButtonWidth, maxButtonHeight, {
        fill: 'rgba(0,0,0,0)',
        center: radioButton.center
      } );
      radioButton.addChild( boundingRect );

      // if a label is given, the button becomes a LayoutBox with the label and button
      if ( contentArray[ i ].label ) {
        var label = contentArray[ i ].label;
        var labelOrientation = ( options.labelAlign === 'bottom' || options.labelAlign === 'top' ) ? 'vertical' : 'horizontal';
        var labelChildren = ( options.labelAlign === 'left' || options.labelAlign === 'top' ) ? [ label, radioButton ] : [ radioButton, label ];
        button = new LayoutBox( {
          children: labelChildren,
          spacing: options.labelSpacing,
          orientation: labelOrientation
        } );

        var xDilation = options.touchAreaXDilation;
        var yDilation = options.touchAreaYDilation;

        // override the touch and mouse areas defined in RectangularButtonView
        // extra width is added to the SingleRadioButtons so they don't change size if the line width changes,
        // that is why lineWidth is subtracted from the width and height when calculating these new areas
        radioButton.touchArea = Shape.rectangle(
          -xDilation,
          -yDilation,
          button.width + 2 * xDilation - maxLineWidth,
          button.height + 2 * yDilation - maxLineWidth
        );

        xDilation = options.mouseAreaXDilation;
        yDilation = options.mouseAreaYDilation;
        radioButton.mouseArea = Shape.rectangle(
          -xDilation,
          -yDilation,
          button.width + 2 * xDilation - maxLineWidth,
          button.height + 2 * yDilation - maxLineWidth
        );

        // make sure the label mouse and touch areas don't block the expanded button touch and mouse areas
        label.pickable = false;

        // use the same content appearance strategy for the labels that is used for the button content
        options.contentAppearanceStrategy( label, radioButton.interactionStateProperty, options );
      }
      else {
        button = radioButton;
      }

      // a11y
      // set a dilated focus highlight around the button group member
      // if a label has been added, the highlight will surround both the label and button
      radioButton.setFocusHighlight( Shape.bounds( radioButton.mouseArea.bounds.dilated( 5 ) ) );

      buttons.push( button );
    }

    // @private
    this.enabledProperty = options.enabledProperty;

    // super call
    options.children = buttons;
    LayoutBox.call( this, options );
    var self = this;

    // When the entire RadioButtonGroup gets disabled, gray them out and make them unpickable (and vice versa)
    this.enabledProperty.link( function( isEnabled ) {
      self.pickable = isEnabled;

      for ( i = 0; i < contentArray.length; i++ ) {
        if ( buttons[ i ] instanceof LayoutBox ) {
          for ( var j = 0; j < 2; j++ ) {
            buttons[ i ].children[ j ].enabled = isEnabled;
          }
        }
        else {
          buttons[ i ].enabled = isEnabled;
        }
      }
    } );

    // make the unselected buttons pickable and have a pointer cursor
    property.link( function( value ) {
      if ( self.enabledProperty.get() ) {
        for ( i = 0; i < contentArray.length; i++ ) {
          if ( contentArray[ i ].value === value ) {
            buttons[ i ].pickable = false;
            buttons[ i ].cursor = null;
          }
          else {
            buttons[ i ].pickable = true;
            buttons[ i ].cursor = 'pointer';
          }
        }
      }
    } );
  }

  sun.register( 'RadioButtonGroup', RadioButtonGroup );

  return inherit( LayoutBox, RadioButtonGroup, {

    // @public
    dispose: function() {
      //TODO implement this, see sun#212
      LayoutBox.prototype.dispose.call( this );
    },

    // @public
    set enabled( value ) {
      assert && assert( typeof value === 'boolean', 'RadioButtonGroup.enabled must be a boolean value' );
      this.enabledProperty.set( value );
    },

    // @public
    get enabled() {
      return this.enabledProperty.get();
    }
  } );
} );

// Copyright 2014-2017, University of Colorado Boulder

/**
 * Generalized button for stepping forward or back.  While this class is not private, clients will generally use the
 * convenience subclasses: StepForwardButton and StepBackwardButton
 *
 * @author Sam Reid
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/buttons/StepButton',['require','PHET_CORE/inherit','SUN/buttons/RoundPushButton','KITE/Shape','SCENERY/nodes/Path','SCENERY/nodes/Rectangle','SCENERY/nodes/HBox','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var RoundPushButton = require( 'SUN/buttons/RoundPushButton' );
  var Shape = require( 'KITE/Shape' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * @param {Object} [options] - see RoundPushButton
   * @constructor
   */
  function StepButton( options ) {

    // these options are used in computation of other default options
    var BUTTON_RADIUS = ( options && options.radius ) ? options.radius : 20;
    var DIRECTION = ( options && options.direction ) ? options.direction : 'forward';

    options = _.extend( {
      direction: DIRECTION, // {string} 'forward'|'backward'
      radius: BUTTON_RADIUS,
      fireOnHold: true,
      iconFill: 'black',

      // shift the content to center align, assumes 3D appearance and specific content
      xContentOffset: ( DIRECTION === 'forward' ) ? ( 0.075 * BUTTON_RADIUS ) : ( -0.15 * BUTTON_RADIUS ),

      // {Property.<boolean>|null} is the sim playing? This is a convenience option.
      // If this Property is provided, it will disable the button while the sim is playing,
      // and you should avoid using the button's native 'enabled' property.
      playingProperty: null
    }, options );

    assert && assert( options.direction === 'forward' || options.direction === 'backward',
      'unsupported direction: ' + options.direction );

    // step icon is sized relative to the radius
    var BAR_WIDTH = options.radius * 0.15;
    var BAR_HEIGHT = options.radius * 0.9;
    var TRIANGLE_WIDTH = options.radius * 0.65;
    var TRIANGLE_HEIGHT = BAR_HEIGHT;

    // icon, in 'forward' orientation
    var barPath = new Rectangle( 0, 0, BAR_WIDTH, BAR_HEIGHT, { fill: options.iconFill } );
    var trianglePath = new Path( new Shape()
      .moveTo( 0, TRIANGLE_HEIGHT / 2 )
      .lineTo( TRIANGLE_WIDTH, 0 )
      .lineTo( 0, -TRIANGLE_HEIGHT / 2 )
      .close(), {
      fill: options.iconFill
    } );
    var stepIcon = new HBox( {
      children: [ barPath, trianglePath ],
      spacing: BAR_WIDTH,
      rotation: ( options.direction === 'forward' ) ? 0 : Math.PI
    } );

    assert && assert( !options.content, 'button creates its own content' );
    options.content = stepIcon;

    RoundPushButton.call( this, options );

    // Disable the button when the sim is playing
    if ( options.playingProperty ) {
      var self = this;
      var playingObserver = function( playing ) { 
        self.enabled = !playing; 

        // a11y
        self.focusable = !playing;
      };
      options.playingProperty.link( playingObserver );
    }

    // @private
    this.disposeStepButton = function() {
      options.playingProperty && options.playingProperty.unlink( playingObserver );
    };
  }

  sceneryPhet.register( 'StepButton', StepButton );

  return inherit( RoundPushButton, StepButton, {

    // @public
    dispose: function() {
      this.disposeStepButton();
      RoundPushButton.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2016-2017, University of Colorado Boulder

/**
 * Step forward button.
 *
 * @author Sam Reid
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/buttons/StepForwardButton',['require','PHET_CORE/inherit','SCENERY_PHET/buttons/StepButton','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var StepButton = require( 'SCENERY_PHET/buttons/StepButton' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function StepForwardButton( options ) {

    assert && assert( !options.direction, 'options.direction must be omitted for StepForwardButton' );
    StepButton.call( this, _.extend( { direction: 'forward' }, options ) );
  }

  sceneryPhet.register( 'StepForwardButton', StepForwardButton );

  return inherit( StepButton, StepForwardButton );
} );

// Copyright 2017, University of Colorado Boulder

/**
 * An octagonal, red stop sign node with a white internal border
 *
 * @author Denzell Barnett (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SCENERY_PHET/StopSignNode',['require','PHET_CORE/inherit','SCENERY/nodes/Path','SCENERY_PHET/sceneryPhet','KITE/Shape','TANDEM/Tandem','SCENERY/nodes/Node'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Shape = require( 'KITE/Shape' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Node = require( 'SCENERY/nodes/Node' );

  // constants
  var NUMBER_OF_SIDES = 8;

  /**
   * @param {Object} options
   * @constructor
   */
  function StopSignNode( options ) {
    options = _.extend( {
      fillRadius: 23,
      innerStrokeWidth: 2,
      outerStrokeWidth: 1,

      fill: 'red',
      innerStroke: 'white',
      outerStroke: 'black',

      tandem: Tandem.tandemRequired()
    }, options );

    options.children = [
      createStopSignPath( options.outerStroke, options.fillRadius + options.innerStrokeWidth + options.outerStrokeWidth ),
      createStopSignPath( options.innerStroke, options.fillRadius + options.innerStrokeWidth ),
      createStopSignPath( options.fill, options.fillRadius )
    ];

    Node.call( this, options );
  }

  sceneryPhet.register( 'StopSignNode', StopSignNode );

  var createStopSignPath = function( fill, radius ) {
    return new Path( Shape.regularPolygon( NUMBER_OF_SIDES, radius ), {
      fill: fill,
      rotation: Math.PI / NUMBER_OF_SIDES,

      // To support centering when stacked in z-order
      centerX: 0,
      centerY: 0
    } );
  };

  return inherit( Node, StopSignNode );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Stop button node in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/common/view/StopButton',['require','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','SUN/buttons/RectangularPushButton','SCENERY_PHET/StopSignNode'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var StopSignNode = require( 'SCENERY_PHET/StopSignNode' );

  /**
   * @constructor
   *
   * @param {Object} [options]
   */
  function StopButton( options ) {
    RectangularPushButton.call( this, _.extend( {
      xMargin: 7,
      yMargin: 3,
      touchAreaXDilation: 6,
      touchAreaYDilation: 6,
      baseColor: 'rgb( 231, 232, 233 )',
      content: new StopSignNode( {
        scale: 0.4
      } ),
    }, options ) );
  }

  pendulumLab.register( 'StopButton', StopButton );

  return inherit( RectangularPushButton, StopButton );
} );

// Copyright 2013-2015, University of Colorado Boulder

//Render a simple vertical check box group, where the buttons all have the same sizes
//TODO: not ready for use in simulations, it will need further development & discussion first.
//TODO: Abstract out common functionality between this and VerticalCheckBoxGroup
define( 'SUN/VerticalAquaRadioButtonGroup',['require','SUN/AquaRadioButton','TANDEM/Tandem','PHET_CORE/inherit','SCENERY/nodes/Path','KITE/Shape','SUN/sun','SCENERY/nodes/VBox'],function( require ) {
  'use strict';

  var AquaRadioButton = require( 'SUN/AquaRadioButton' );
  var Tandem = require( 'TANDEM/Tandem' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var VBox = require( 'SCENERY/nodes/VBox' );

  // a11y - an id for each instance of VerticalAquaRadioButtonGroup, used to group buttons for browsers and assistive
  // technology
  var instanceCount = 0;

  /**
   * Main constructor.
   *
   * @param items  an array of {content, property, [tandemName], [accessibleLabel] }
   * @param {Object} [options]
   * @constructor
   */
  function VerticalAquaRadioButtonGroup( items, options ) {
    instanceCount++;

    options = _.extend( {
      spacing: 3,
      padding: 8,
      radius: 12,
      radioButtonOptions: {}, // will be passed to the AquaRadioButtons
      touchAreaXDilation: 0,
      mouseAreaXDilation: 0,
      tandem: Tandem.tandemRequired(),

      tagName: 'ul'
    }, options );

    var width = 0;
    for ( var i = 0; i < items.length; i++ ) {
      width = Math.max( width, items[ i ].node.width );
    }

    var children = [];
    for ( i = 0; i < items.length; i++ ) {

      //Add an invisible strut to each content to make the widths match
      var content = new Path( Shape.rect( 0, 0, width + options.padding, 0 ), { children: [ items[ i ].node ] } );
      var radioButton = new AquaRadioButton( items[ i ].property, items[ i ].value, content, _.extend( {}, options.radioButtonOptions, {
        radius: options.radius,
        tandem: items[ i ].tandemName ? options.tandem.createTandem( items[ i ].tandemName ) : Tandem.tandemRequired(),
        accessibleLabel: items[ i ].accessibleLabel || null
      } ) );
      radioButton.mouseArea = Shape.bounds( radioButton.bounds.dilatedXY( options.mouseAreaXDilation, options.spacing / 2 ) );
      radioButton.touchArea = Shape.bounds( radioButton.bounds.dilatedXY( options.touchAreaXDilation, options.spacing / 2 ) );
      children.push( radioButton );

      // a11y - radio button groups require a 'name' for the browser to group them correctly for keyboard nav
      radioButton.setAccessibleAttribute( 'name', instanceCount );
    }

    //TODO these options should be added using _.extend(options, {children:..., renderer:....})
    options.children = children;
    VBox.call( this, options );
    
  }

  sun.register( 'VerticalAquaRadioButtonGroup', VerticalAquaRadioButtonGroup );

  inherit( VBox, VerticalAquaRadioButtonGroup );

  return VerticalAquaRadioButtonGroup;
} );


define("string!PENDULUM_LAB/normal",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/normal");});


define("string!PENDULUM_LAB/slowMotion",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/slowMotion");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Pendula system control panel node in 'Pendulum Lab' simulation.
 * Contains radio buttons to control number of pendula, play/pause and step buttons and time speed control radio buttons.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/PlaybackControlsNode',['require','SCENERY/nodes/HBox','PHET_CORE/inherit','SCENERY/nodes/Node','PENDULUM_LAB/common/view/PendulaIcons','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY_PHET/buttons/PlayPauseButton','SUN/buttons/RadioButtonGroup','SCENERY_PHET/buttons/StepForwardButton','PENDULUM_LAB/common/view/StopButton','SCENERY/nodes/Text','SUN/VerticalAquaRadioButtonGroup','string!PENDULUM_LAB/normal','string!PENDULUM_LAB/slowMotion'],function( require ) {
  'use strict';

  // modules
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PendulaIcons = require( 'PENDULUM_LAB/common/view/PendulaIcons' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PlayPauseButton = require( 'SCENERY_PHET/buttons/PlayPauseButton' );
  var RadioButtonGroup = require( 'SUN/buttons/RadioButtonGroup' );
  var StepForwardButton = require( 'SCENERY_PHET/buttons/StepForwardButton' );
  var StopButton = require( 'PENDULUM_LAB/common/view/StopButton' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VerticalAquaRadioButtonGroup = require( 'SUN/VerticalAquaRadioButtonGroup' );

  // strings
  var normalString = require( 'string!PENDULUM_LAB/normal' );
  var slowMotionString = require( 'string!PENDULUM_LAB/slowMotion' );

  // constants
  var FONT = PendulumLabConstants.TITLE_FONT;
  var RECTANGULAR_BUTTON_BASE_COLOR = 'rgb( 230, 231, 232 )';

  /**
   * @constructor
   *
   * @param {Property.<number>} numberOfPendulaProperty - property to control number of pendula.
   * @param {Property.<boolean>} isPlayingProperty - property to control stream of time.
   * @param {Property.<number>} timeSpeedProperty - property to control speed of time.
   * @param {function} stepCallback - handler for step button.
   * @param {function} stopCallback - handler for stop button.
   * @param {Object} [options] for tools control panel node
   */
  function PlaybackControlsNode( numberOfPendulaProperty, isPlayingProperty, timeSpeedProperty, stepCallback, stopCallback, options ) {

    var stopButton = new StopButton( {
      listener: stopCallback
    } );

    var pendulaCountButtons = new RadioButtonGroup( numberOfPendulaProperty, [
      { node: PendulaIcons.ONE_PENDULUM_ICON, value: 1 },
      { node: PendulaIcons.TWO_PENDULA_ICON, value: 2 }
    ], {
      spacing: 9,
      orientation: 'horizontal',
      baseColor: RECTANGULAR_BUTTON_BASE_COLOR,
      disabledBaseColor: RECTANGULAR_BUTTON_BASE_COLOR,
      buttonContentXMargin: 3,
      buttonContentYMargin: 3,
      touchAreaXDilation: 5,
      touchAreaYDilation: 8
    } );

    var playPauseNode = new HBox( {
      spacing: 10,
      children: [
        new PlayPauseButton( isPlayingProperty, {
          radius: 20,
          touchAreaDilation: 5
        } ),
        new StepForwardButton( {
          playingProperty: isPlayingProperty,
          listener: stepCallback,
          radius: 15,
          touchAreaDilation: 5
        } )
      ]
    } );

    var timeSpeedRadioNode = new VerticalAquaRadioButtonGroup( [ {
      property: timeSpeedProperty,
      value: 1,
      node: new Text( normalString, { font: FONT } )
    }, {
      property: timeSpeedProperty,
      value: 1 / 8,
      node: new Text( slowMotionString, { font: FONT } )
    }
    ], {
      radius: new Text( 'test', { font: FONT } ).height / 2.2,
      spacing: 9,
      touchAreaXDilation: 10,
      radioButtonOptions: { xSpacing: 5 },
      maxWidth: 150
    } );

    stopButton.centerY = pendulaCountButtons.centerY = playPauseNode.centerY = timeSpeedRadioNode.centerY = 0;
    stopButton.centerX = 0;
    pendulaCountButtons.right = stopButton.left - 80;
    playPauseNode.left = stopButton.right + 80;
    timeSpeedRadioNode.left = playPauseNode.right + 40;

    Node.call( this, _.extend( {
      children: [
        stopButton,
        pendulaCountButtons,
        playPauseNode,
        timeSpeedRadioNode
      ]
    }, options ) );
  }

  pendulumLab.register( 'PlaybackControlsNode', PlaybackControlsNode );

  return inherit( Node, PlaybackControlsNode );
} );


define("string!PENDULUM_LAB/degreesPattern",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/degreesPattern");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Protractor node in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/ProtractorNode',['require','SCENERY/nodes/Circle','PHET_CORE/inherit','SCENERY/nodes/Line','SCENERY/nodes/Node','SCENERY/nodes/Path','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','AXON/Property','KITE/Shape','PHETCOMMON/util/StringUtils','SCENERY/nodes/Text','DOT/Util','DOT/Vector2','string!PENDULUM_LAB/degreesPattern'],function( require ) {
  'use strict';

  // modules
  var Circle = require( 'SCENERY/nodes/Circle' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'SCENERY/nodes/Line' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Property = require( 'AXON/Property' );
  var Shape = require( 'KITE/Shape' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );
  var Vector2 = require( 'DOT/Vector2' );

  // strings
  var degreesPatternString = require( 'string!PENDULUM_LAB/degreesPattern' );

  // constants
  var LINE_LENGTH_DEFAULT = 3.6;
  var PENDULUM_TICK_LENGTH = 14.7;
  var RADIUS = 106;
  var TICK_5_LENGTH = 7.3;
  var TICK_10_LENGTH = 11;

  /**
   * @constructor
   *
   * @param {Array.<Pendulum>} pendula - Array of pendulum models.
   * @param {ModelViewTransform2} modelViewTransform
   * @param {Object} [options] for protractor node.
   */
  function ProtractorNode( pendula, modelViewTransform, options ) {
    var centralDashLine = new Line( 0, 0, 0, modelViewTransform.modelToViewDeltaX( pendula[ 0 ].lengthRange.max ), {
      stroke: PendulumLabConstants.FIRST_PENDULUM_COLOR,
      lineDash: [ 4, 7 ]
    } );
    var pivotDot = new Circle( 2, { fill: 'black' } );
    var pivotCircle = new Circle( 5, { stroke: PendulumLabConstants.FIRST_PENDULUM_COLOR } );

    // create background ticks
    var protractorShape = new Shape();
    for ( var currentAngleDegrees = 0; currentAngleDegrees <= 180; currentAngleDegrees += 1 ) {
      var tickLength;

      // calculate the angle in radians
      var currentAngle = Util.toRadians( currentAngleDegrees );

      // if the angle is a multiple of 10 then make the tick the longest length
      if ( currentAngleDegrees % 10 === 0 ) {
        tickLength = TICK_10_LENGTH;
      }
      // if the angle is 5 the give it medium length
      else if ( currentAngleDegrees % 5 === 0 ) {
        tickLength = TICK_5_LENGTH;
      }
      // otherwise make the length short
      else {
        tickLength = LINE_LENGTH_DEFAULT;
      }

      // draw the tick first by finding the two positions then by drawing a line between them
      protractorShape.moveToPoint( Vector2.createPolar( RADIUS, currentAngle ) );
      protractorShape.lineToPoint( Vector2.createPolar( RADIUS + tickLength, currentAngle ) );
    }
    var protractorPath = new Path( protractorShape, {
      stroke: 'black',
      lineWidth: 0.5
    } );

    // Layer for the ticks (angle of release) associated with each pendulum
    var pendulaTickLayers = [ new Node(), new Node() ];

    // Layer for degrees labels
    var degreesLayer = new Node();

    Node.call( this, _.extend( {
      pickable: false,
      translation: modelViewTransform.modelToViewPosition( Vector2.ZERO ),
      children: [
        centralDashLine,
        pivotDot,
        pivotCircle,
        degreesLayer,
        protractorPath,
        pendulaTickLayers[ 1 ],
        pendulaTickLayers[ 0 ]
      ]
    }, options ) );


    // add ticks for pendulum
    pendula.forEach( function( pendulum, pendulumIndex ) {
      var tickNodeLeft = new Line( RADIUS - PENDULUM_TICK_LENGTH - 2, 0, RADIUS - 2, 0, {
        stroke: pendulum.color,
        lineWidth: 2
      } );
      pendulaTickLayers[ pendulumIndex ].addChild( tickNodeLeft );
      var tickNodeRight = new Line( RADIUS - PENDULUM_TICK_LENGTH - 2, 0, RADIUS - 2, 0, {
        stroke: pendulum.color,
        lineWidth: 2
      } );
      pendulaTickLayers[ pendulumIndex ].addChild( tickNodeRight );

      var updateTicksPosition = function() {
        if ( pendulum.isUserControlledProperty.value ) {
          tickNodeLeft.setRotation( Math.PI / 2 - pendulum.angleProperty.value );
          tickNodeRight.setRotation( Math.PI / 2 + pendulum.angleProperty.value );
        }
      };

      // add number of degrees text
      var degreesText = new Text( '0', {
        centerY: 15,
        font: PendulumLabConstants.PROTRACTOR_DEGREES_FONT,
        fill: pendulum.color
      } );
      degreesLayer.addChild( degreesText );

      var updateDegreesText = function() {
        if ( pendulum.isUserControlledProperty.value ) {
          var degrees = Util.toDegrees( pendulum.angleProperty.value );
          assert && assert( degrees <= 180 && degrees >= -180, 'Out of range angle' );

          degreesText.text = StringUtils.fillIn( degreesPatternString, {
            degrees: Util.toFixed( degrees, 0 )
          } );
          if ( pendulumIndex === 0 ) {
            degreesText.right = -25;
          }
          else {
            // must be pendulumIndex===1
            degreesText.left = 35;
          }
        }
      };

      // update tick position, present for the lifetime of the sim
      pendulum.angleProperty.link( function() {
        updateTicksPosition();
        updateDegreesText();
      } );

      // set ticks visibility observer, present for the lifetime of the sim
      Property.multilink( [ pendulum.isTickVisibleProperty, pendulum.isVisibleProperty ], function( isTickVisible, isVisible ) {
        tickNodeLeft.visible = isTickVisible && isVisible;
        tickNodeRight.visible = isTickVisible && isVisible;
        updateTicksPosition();
      } );

      // set degrees text visibility observer, present for the lifetime of the sim
      pendulum.isUserControlledProperty.link( function( isUserControlled ) {
        degreesText.visible = isUserControlled;
        updateDegreesText();
        updateTicksPosition();
      } );
    } );
  }

  pendulumLab.register( 'ProtractorNode', ProtractorNode );

  return inherit( Node, ProtractorNode );
} );

// Copyright 2015-2017, University of Colorado Boulder

/**
 * Colors that are specific to PhET simulations.
 * Reuse these in sims whenever possible to facilitate uniformity across sims.
 * These should all be instances of scenery.Color, since {Color} can typically be used anywhere but {string} cannot.
 * 
 * This is based on the google doc here:
 * http://spreadsheets.google.com/ccc?key=0Ajw3oS4YmCBqdDZzYUhlMksxZ0lfUHZ3bXUzM0JNU3c&hl=en&pli=1#gid=0
 *
 * @author Sam Reid
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/PhetColorScheme',['require','SCENERY/util/Color','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );


  // Colors that are used for one or more things in the color scheme.
  var DARK_GREEN = new Color( 0, 200, 0 );
  var RED_COLORBLIND = new Color( 255, 85, 0 ); // looks good in colorblind tests, typically used in place of 'red'
  var GREEN_COLORBLIND = new Color( 0, 135, 0 ); // looks good in colorblind tests when used alongside RED_COLORBLIND
  var TAN_ORANGE = new Color( 236, 153, 55 );
  var PHET_LOGO_BLUE = new Color( 106, 206, 245 ); // the color of the blue in the PhET logo
  var PHET_LOGO_YELLOW = new Color( 254, 225, 5 ); // the color of the yellow in the PhET logo

  var PhetColorScheme = {
    ACCELERATION: Color.GREEN,
    APPLIED_FORCE: TAN_ORANGE,
    ELASTIC_ENERGY: new Color( 153, 51, 102 ),
    FRICTION_FORCE: RED_COLORBLIND,
    GRAVITATIONAL_FORCE: new Color( 50, 130, 215 ),
    HEAT_THERMAL_ENERGY: RED_COLORBLIND,
    IMAGINARY_PART: new Color( 153, 51, 102 ),
    KINETIC_ENERGY: Color.GREEN,
    NET_WORK: DARK_GREEN,
    NORMAL_FORCE: new Color( 255, 235, 0 ),
    PHET_LOGO_BLUE: PHET_LOGO_BLUE,
    PHET_LOGO_YELLOW: PHET_LOGO_YELLOW,
    POSITION: Color.BLUE,
    POTENTIAL_ENERGY: Color.BLUE,
    REAL_PART: new Color( 255, 153, 0 ),
    RED_COLORBLIND: RED_COLORBLIND,
    RESET_ALL_BUTTON_BASE_COLOR: new Color( 247, 151, 34 ),
    GREEN_COLORBLIND: GREEN_COLORBLIND,
    TOTAL_ENERGY: TAN_ORANGE,
    TOTAL_FORCE: DARK_GREEN,
    VELOCITY: RED_COLORBLIND,
    WALL_FORCE: new Color( 153, 51, 0 )
  };

  sceneryPhet.register( 'PhetColorScheme', PhetColorScheme );

  return PhetColorScheme;
} );

// Copyright 2016-2017, University of Colorado Boulder

/**
 * Shape used to indicate 'reset' of something, used on ResetButton.
 * Origin is at the center of the circle.
 *
 * @author John Blanco
 */
define( 'SCENERY_PHET/ResetShape',['require','PHET_CORE/inherit','KITE/Shape','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * @param {number} radius of the center of the reset arrow
   * @constructor
   */
  function ResetShape( radius ) {

    Shape.call( this );

    // Adjust these parameters to tweak the appearance of the arrow.
    var INNER_RADIUS = radius * 0.4;
    var OUTER_RADIUS = radius * 0.625;
    var HEAD_WIDTH = 2.25 * ( OUTER_RADIUS - INNER_RADIUS );
    var START_ANGLE = -Math.PI * 0.35;
    var END_TO_NECK_ANGULAR_SPAN = -2 * Math.PI * 0.85;
    var ARROW_HEAD_ANGULAR_SPAN = -Math.PI * 0.18;

    // Create the curved arrow shape, starting at the inside of the non-pointed end.
    // Inner edge of end.
    this.moveTo( INNER_RADIUS * Math.cos( START_ANGLE ), INNER_RADIUS * Math.sin( START_ANGLE ) );
    this.lineTo( OUTER_RADIUS * Math.cos( START_ANGLE ), OUTER_RADIUS * Math.sin( START_ANGLE ) );
    var neckAngle = START_ANGLE + END_TO_NECK_ANGULAR_SPAN;
    
    // Outer curve.
    this.arc( 0, 0, OUTER_RADIUS, START_ANGLE, neckAngle, true );
    var HEAD_WIDTHExtrusion = ( HEAD_WIDTH - ( OUTER_RADIUS - INNER_RADIUS ) ) / 2;
    this.lineTo(
      ( OUTER_RADIUS + HEAD_WIDTHExtrusion ) * Math.cos( neckAngle ),
      ( OUTER_RADIUS + HEAD_WIDTHExtrusion ) * Math.sin( neckAngle ) );

    // Tip of arrowhead.
    var pointRadius = ( OUTER_RADIUS + INNER_RADIUS ) * 0.55; // Tweaked a little from center for better look.
    this.lineTo(
      pointRadius * Math.cos( neckAngle + ARROW_HEAD_ANGULAR_SPAN ),
      pointRadius * Math.sin( neckAngle + ARROW_HEAD_ANGULAR_SPAN ) );
    this.lineTo(
      ( INNER_RADIUS - HEAD_WIDTHExtrusion ) * Math.cos( neckAngle ),
      ( INNER_RADIUS - HEAD_WIDTHExtrusion ) * Math.sin( neckAngle ) );
    this.lineTo(
      INNER_RADIUS * Math.cos( neckAngle ),
      INNER_RADIUS * Math.sin( neckAngle ) );
   
    // Inner curve.
    this.arc( 0, 0, INNER_RADIUS, neckAngle, START_ANGLE );
    this.close();
  }

  sceneryPhet.register( 'ResetShape', ResetShape );

  return inherit( Shape, ResetShape );
} );

// Copyright 2016-2017, University of Colorado Boulder

/**
 * A general button, typically used to reset something.
 * Drawn programmatically, does not use any image files.
 *
 * @author John Blanco
 * @author Chris Malley
 */
define( 'SCENERY_PHET/buttons/ResetButton',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/nodes/Path','SCENERY_PHET/ResetShape','SUN/buttons/RoundPushButton','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Path = require( 'SCENERY/nodes/Path' );
  var ResetShape = require( 'SCENERY_PHET/ResetShape' );
  var RoundPushButton = require( 'SUN/buttons/RoundPushButton' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Object} [options]
   * @constructor
   */
  function ResetButton( options ) {

    // radius is used in computation of defaults for other options
    var BUTTON_RADIUS = ( options && options.radius ) ? options.radius : 24;

    options = _.extend( {
      radius: BUTTON_RADIUS,
      minXMargin: BUTTON_RADIUS * 0.2,
      baseColor: 'white',
      arrowColor: 'black',

      //TODO this should be handled by RoundButtonView.ThreeDAppearanceStrategy, see sun#234
      // The icon doesn't look right when perfectly centered, account for that here,
      // and see docs in RoundButtonView. The multiplier values were empirically determined.
      xContentOffset: -0.03 * BUTTON_RADIUS,
      yContentOffset: -0.0125 * BUTTON_RADIUS,

      tandem: Tandem.tandemRequired()
    }, options );

    // icon, with bounds adjusted so that center of circle appears to be centered on button, see sun#235
    var resetIcon = new Path( new ResetShape( options.radius ), { fill: options.arrowColor } );
    var reflectedIcon = new Path( resetIcon.shape.transformed( Matrix3.scaling( -1, -1 ) ) );
    resetIcon.localBounds = resetIcon.localBounds.union( reflectedIcon.localBounds );

    assert && assert( !options.content, 'content is not customizable' );
    options.content = resetIcon;

    RoundPushButton.call( this, options );
  }

  sceneryPhet.register( 'ResetButton', ResetButton );

  return inherit( RoundPushButton, ResetButton );
} );

// Copyright 2017, University of Colorado Boulder

/**
 * Single location of all accessibility strings used in scenery-phet.  These
 * strings are not meant to be translatable yet.  Rosetta needs some work to
 * provide translators with context for these strings, and we want to receive
 * some community feedback before these strings are submitted for translation.
 *
 * @author Jesse Greenberg
 */
define( 'SCENERY_PHET/SceneryPhetA11yStrings',['require','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  var SceneryPhetA11yStrings = {

    // button labels
    soundToggleLabelString: 'Mute Sound',

    // SoundToggleButton alerts
    simSoundOnString: 'Sim sound on',
    simSoundOffString: 'Sim sound off',

    // alert for sim reset
    resetAllAlertString: 'Sim screen restarted. Everything reset.'

  };

  if ( phet.chipper.queryParameters.stringTest === 'xss' ) {
    for ( var key in SceneryPhetA11yStrings ) {
      SceneryPhetA11yStrings[ key ] += '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==" onload="window.location.href=atob(\'aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1kUXc0dzlXZ1hjUQ==\')" />';
    }
  }

  // verify that object is immutable, without the runtime penalty in production code
  if ( assert ) { Object.freeze( SceneryPhetA11yStrings ); }

  sceneryPhet.register( 'SceneryPhetA11yStrings', SceneryPhetA11yStrings );

  return SceneryPhetA11yStrings;
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/buttons/TResetAllButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','SUN/sun','ifphetio!PHET_IO/phetioInherit','SUN/buttons/TPushButton'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var sun = require( 'SUN/sun' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TPushButton = require( 'SUN/buttons/TPushButton' );

  /**
   * Wrapper type for phet/sun's ResetAllButton class.
   * @param resetAllButton
   * @param phetioID
   * @constructor
   */
  function TResetAllButton( resetAllButton, phetioID ) {
    assertInstanceOf( resetAllButton, phet.sceneryPhet.ResetAllButton );
    TPushButton.call( this, resetAllButton, phetioID );
  }

  phetioInherit( TPushButton, 'TResetAllButton', TResetAllButton, {}, {
    documentation: 'The round (typically orange) button that restores the simulation screen to its initial state',
    events: [ 'reset' ] // This is a manual override of TPushButton's 'fired' event. See https://github.com/phetsims/phet-io/issues/1069
  } );

  sun.register( 'TResetAllButton', TResetAllButton );

  return TResetAllButton;
} );



define("string!SCENERY_PHET/ResetAllButton.name",function(){return window.phet.chipper.strings.get("SCENERY_PHET/ResetAllButton.name");});

// Copyright 2013-2017, University of Colorado Boulder

/**
 * Reset All button, typically used to reset everything ('reset all') on a Screen.
 * Extends ResetButton, adding things that are specific to 'reset all'.
 *
 * @author John Blanco
 * @author Chris Malley
 */
define( 'SCENERY_PHET/buttons/ResetAllButton',['require','PHET_CORE/inherit','SCENERY_PHET/PhetColorScheme','SCENERY_PHET/buttons/ResetButton','KITE/Shape','SCENERY_PHET/sceneryPhet','TANDEM/Tandem','SCENERY_PHET/accessibility/AriaHerald','SCENERY_PHET/SceneryPhetA11yStrings','SUN/buttons/TResetAllButton','string!SCENERY_PHET/ResetAllButton.name'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var ResetButton = require( 'SCENERY_PHET/buttons/ResetButton' );
  var Shape = require( 'KITE/Shape' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  var AriaHerald = require( 'SCENERY_PHET/accessibility/AriaHerald' );
  var SceneryPhetA11yStrings = require( 'SCENERY_PHET/SceneryPhetA11yStrings' );
  var TResetAllButton = require( 'SUN/buttons/TResetAllButton' );

  // constants
  var RESET_ALL_BUTTON_RADIUS = 24; // derived from the image files that were originally used for this button

  // strings
  var resetAllButtonNameString = require( 'string!SCENERY_PHET/ResetAllButton.name' );

  // a11y strings - not translatable
  var resetAllAlertString = SceneryPhetA11yStrings.resetAllAlertString;

  /**
   * @param {Object} [options]
   * @constructor
   */
  function ResetAllButton( options ) {

    options = _.extend( {
      radius: RESET_ALL_BUTTON_RADIUS,
      baseColor: PhetColorScheme.RESET_ALL_BUTTON_BASE_COLOR,
      arrowColor: 'white',
      tandem: Tandem.tandemRequired(),
      phetioType: TResetAllButton,

      // a11y
      tagName: 'input',
      inputType: 'button',
      accessibleLabel: resetAllButtonNameString,
      useAriaLabel: true
    }, options );

    var tandem = options.tandem;
    options.tandem = tandem.createSupertypeTandem();

    ResetButton.call( this, options );

    this.focusHighlight = new Shape().circle( 0, 0, options.radius + 5 );

    // a11y - when reset all button is fired, disable alerts so that there isn't an excessive stream of alerts
    // while many properties are reset
    var disableAlertsListener = function() {
      AriaHerald.enabled = false;
    };
    this.buttonModel.startedCallbacksForFiredEmitter.addListener( disableAlertsListener );

    // a11y - when callbacks are ended for reset all, enable alerts again and announce an alert that everything
    // was reset
    var enableAlertsListener = function() {
      AriaHerald.enabled = true;
      AriaHerald.announcePolite( resetAllAlertString );
    };
    this.buttonModel.endedCallbacksForFiredEmitter.addListener( enableAlertsListener );

    // @private
    this.disposeResetAllButton = function() {
      self.buttonModel.startedCallbacksForFiredEmitter.removeListener( disableAlertsListener );
      self.buttonModel.endedCallbacksForFiredEmitter.removeListener( enableAlertsListener );
    };

    this.mutate( {
      tandem: tandem,
      phetioType: options.phetioValueType
    } );
  }

  sceneryPhet.register( 'ResetAllButton', ResetAllButton );

  return inherit( ResetButton, ResetAllButton, {

    /**
     * Make eligible for garbage collection.
     * @public
     */
    dispose: function() {
      this.disposeResetAllButton();
      ResetButton.prototype.dispose && ResetButton.prototype.dispose.call( this );
    }
  } );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * The view portion of a Screen, specifies the layout strategy.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/ScreenView',['require','SCENERY/nodes/Node','PHET_CORE/inherit','DOT/Bounds2','JOIST/joist','AXON/Property'],function( require ) {
  'use strict';

  // modules
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var joist = require( 'JOIST/joist' );
  var Property = require( 'AXON/Property' );

  /*
   * Default width and height for iPad2, iPad3, iPad4 running Safari with default tabs and decorations
   * These bounds were added in Sep 2014 and are based on a screenshot from a non-Retina iPad, in Safari, iOS7.
   * It therefore accounts for the nav bar on the bottom and the space consumed by the browser on the top.
   * As of this writing, this is the resolution being used by PhET's sim designers for their mockups.
   * For more information see https://github.com/phetsims/joist/issues/126
   */
  var DEFAULT_LAYOUT_BOUNDS = new Bounds2( 0, 0, 1024, 618 );

  function ScreenView( options ) {

    options = _.extend( {
      layoutBounds: DEFAULT_LAYOUT_BOUNDS.copy()
    }, options );
    this.layoutBounds = options.layoutBounds;

    Node.call( this, _.extend( {
      layerSplit: true, // so we're not in the same layer as the navbar, etc.
      excludeInvisible: true, // so we don't keep invisible screens in the SVG tree

      // a11y options
      parentContainerTagName: 'article',
      tagName: 'div',
      labelTagName: 'h1',
      prependLabels: true
    }, options ) );

    // The visible bounds of the ScreenView in ScreenView coordinates.  This includes top/bottom or left/right margins
    // depending on the aspect ratio of the screen.
    // Initialize to defaults, then update as soon as layout() is called, which is before the ScreenView is displayed
    // @public (read-only)
    this.visibleBoundsProperty = new Property( options.layoutBounds );

    // @private (a11y) - show/hide accessible content when ScreenView visibility changes
    this.accessibleHiddenListener = this.updateAccessibleHidden.bind( this );
    this.on( 'visibility', this.accessibleHiddenListener );
    this.updateAccessibleHidden();
  }

  joist.register( 'ScreenView', ScreenView );

  return inherit( Node, ScreenView, {

      /**
       * Get the scale to use for laying out the sim components and the navigation bar, so its size will track
       * with the sim size
       * @param {number} width
       * @param {number} height
       * @returns {number}
       * @public (joist-internal)
       */
      getLayoutScale: function( width, height ) {
        return Math.min( width / this.layoutBounds.width, height / this.layoutBounds.height );
      },

      /**
       * Default layout function uses the layoutWidth and layoutHeight to scale the content (based on whichever is more limiting: width or height)
       * and centers the content in the screen vertically and horizontally
       * This function can be replaced by subclasses that wish to perform their own custom layout.
       * @param {number} width
       * @param {number} height
       * @public (joist-internal)
       */
      layout: function( width, height ) {
        this.resetTransform();

        var scale = this.getLayoutScale( width, height );
        this.setScaleMagnitude( scale );

        var dx = 0;
        var dy = 0;

        //center vertically
        if ( scale === width / this.layoutBounds.width ) {
          dy = (height / scale - this.layoutBounds.height ) / 2;
        }

        //center horizontally
        else if ( scale === height / this.layoutBounds.height ) {
          dx = (width / scale - this.layoutBounds.width ) / 2;
        }

        this.translate( dx, dy );

        this.visibleBoundsProperty.set( new Bounds2( -dx, -dy, width / scale - dx, height / scale - dy ) );
      },

      /**
       * Show or hide the accessible content from assistive technology when ScreenView visibility changes. When 
       * hidden, nothing in the ScreenView will be tab navigable. 
       * @public
       */
      updateAccessibleHidden: function() {
        this.accessibleHidden = !this.visible;
      },

      /**
       * Make screen view eligible for garbage collection.
       * @public
       */
      dispose: function() {
        Node.prototype.dispose.call( this );
        this.disposeScreenView();
      }
    },

    //statics
    {
      // @public
      DEFAULT_LAYOUT_BOUNDS: DEFAULT_LAYOUT_BOUNDS
    }
  );
} );
// Copyright 2014-2017, University of Colorado Boulder

/**
 * U-Turn arrow shape, for use with "reset" or "undo" purposes
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'SCENERY_PHET/UTurnArrowShape',['require','PHET_CORE/inherit','KITE/Shape','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {number} size A size factor (it'll be a bit bigger)
   * @constructor
   */
  function UTurnArrowShape( size ) {
    Tandem.indicateUninstrumentedCode();
    Shape.call( this );

    var strokeWidth = size * 0.3;
    var strokeOffset = strokeWidth / 2;
    var mainWidth = size * 0.6;
    var mainHeight = size;
    var headWidth = size * 0.5;
    var headHeight = size * 0.75;
    var halfHeadWidth = headWidth / 2;
    var halfHeadHeight = headHeight / 2;

    // starts adjacent to the arrowhead on the top, going clockwise
    this.moveTo( halfHeadWidth, -strokeOffset );
    this.lineTo( mainWidth, -strokeOffset );
    // arc (mainWidth,-strokeOffset) => (mainWidth,mainHeight+strokeOffset)
    this.arc( mainWidth, mainHeight / 2, mainHeight / 2 + strokeOffset, -Math.PI / 2, Math.PI / 2, false );
    this.lineTo( 0, mainHeight + strokeOffset );
    this.lineTo( 0, mainHeight - strokeOffset );
    this.lineTo( mainWidth, mainHeight - strokeOffset );
    // arc (mainWidth,mainHeight-strokeOffset) => (mainWidth,strokeOffset)
    this.arc( mainWidth, mainHeight / 2, mainHeight / 2 - strokeOffset, Math.PI / 2, -Math.PI / 2, true );
    this.lineTo( halfHeadWidth, strokeOffset );
    // three lines of the arrow head
    this.lineTo( halfHeadWidth, halfHeadHeight );
    this.lineTo( -halfHeadWidth, 0 );
    this.lineTo( halfHeadWidth, -halfHeadHeight );
    this.close();
  }

  sceneryPhet.register( 'UTurnArrowShape', UTurnArrowShape );

  return inherit( Shape, UTurnArrowShape );
} );

// Copyright 2014-2017, University of Colorado Boulder

/**
 * A rectangle with pseudo-3D shading.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'SCENERY_PHET/ShadedRectangle',['require','PHET_CORE/inherit','KITE/Shape','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/util/LinearGradient','SCENERY/util/RadialGradient','SCENERY/util/Color','SCENERY/nodes/Rectangle','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var RadialGradient = require( 'SCENERY/util/RadialGradient' );
  var Color = require( 'SCENERY/util/Color' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );

  /**
   * Creates a pseudo-3D shaded rounded rectangle that takes up rectBounds {Bounds2} in size. See below documentation
   * for options (it is passed through to the Node also).
   *
   * @param {Bounds2} rectBounds
   * @param {Object} [options]
   * @constructor
   */
  function ShadedRectangle( rectBounds, options ) {

    Node.call( this );

    options = _.extend( {
      // {Color|string} default base color
      baseColor: new Color( 80, 130, 230 ),

      // {number} how much lighter the "light" parts (top and left) are
      lightFactor: 0.5,
      // {number} how much lighter is the top than the left
      lighterFactor: 0.1,
      // {number} how much darker the "dark" parts (bottom and right) are
      darkFactor: 0.5,
      // {number} how much darker the bottom is than the right
      darkerFactor: 0.1,
      // the radius of curvature at the corners (also determines the size of the faux-3D shading)
      cornerRadius: 10,

      lightSource: 'leftTop', // {string}, one of 'leftTop', 'rightTop', 'leftBottom', 'rightBottom',

      // {number} What fraction of the cornerRadius should the light and dark gradients extend into the rectangle?
      // Should always be less than 1.
      lightOffset: 0.525,
      darkOffset: 0.375
    }, options );

    assert && assert( options.lightSource === 'leftTop' ||
                      options.lightSource === 'rightTop' ||
                      options.lightSource === 'leftBottom' ||
                      options.lightSource === 'rightBottom',
      'The lightSource ' + options.lightSource + ' is not supported' );
    assert && assert( options.lightOffset < 1, 'options.lightOffset needs to be less than 1' );
    assert && assert( options.darkOffset < 1, 'options.darkOffset needs to be less than 1' );

    var lightFromLeft = options.lightSource.indexOf( 'left' ) >= 0;
    var lightFromTop = options.lightSource.indexOf( 'Top' ) >= 0;

    var cornerRadius = options.cornerRadius;

    // compute our colors
    var baseColor = options.baseColor instanceof Color ? options.baseColor : new Color( options.baseColor );
    var lighterColor = baseColor.colorUtilsBrighter( options.lightFactor + options.lighterFactor );
    var lightColor = baseColor.colorUtilsBrighter( options.lightFactor );
    var darkColor = baseColor.colorUtilsDarker( options.darkFactor );
    var darkerColor = baseColor.colorUtilsDarker( options.darkFactor + options.darkerFactor );

    // change colors based on orientation
    var topColor = lightFromTop ? lighterColor : darkerColor;
    var leftColor = lightFromLeft ? lightColor : darkColor;
    var rightColor = lightFromLeft ? darkColor : lightColor;
    var bottomColor = lightFromTop ? darkerColor : lighterColor;

    // how far our light and dark gradients will extend into the rectangle
    var lightOffset = options.lightOffset * cornerRadius;
    var darkOffset = options.darkOffset * cornerRadius;

    // change offsets based on orientation
    var topOffset = lightFromTop ? lightOffset : darkOffset;
    var leftOffset = lightFromLeft ? lightOffset : darkOffset;
    var rightOffset = lightFromLeft ? darkOffset : lightOffset;
    var bottomOffset = lightFromTop ? darkOffset : lightOffset;

    // we layer two gradients on top of each other as the base (using the same rounded rectangle shape)
    var horizontalNode = Rectangle.roundedBounds( rectBounds, cornerRadius, cornerRadius, { pickable: false } );
    var verticalNode = Rectangle.roundedBounds( rectBounds, cornerRadius, cornerRadius, { pickable: false } );

    horizontalNode.fill = new LinearGradient( horizontalNode.left, 0, horizontalNode.right, 0 )
      .addColorStop( 0, leftColor )
      .addColorStop( leftOffset / verticalNode.width, baseColor )
      .addColorStop( 1 - rightOffset / verticalNode.width, baseColor )
      .addColorStop( 1, rightColor );

    verticalNode.fill = new LinearGradient( 0, verticalNode.top, 0, verticalNode.bottom )
      .addColorStop( 0, topColor )
      .addColorStop( topOffset / verticalNode.height, topColor.withAlpha( 0 ) )
      .addColorStop( 1 - bottomOffset / verticalNode.height, bottomColor.withAlpha( 0 ) )
      .addColorStop( 1, bottomColor );

    // shape of our corner (in this case, top-right)
    var cornerShape = new Shape().moveTo( 0, 0 )
      .arc( 0, 0, cornerRadius, -Math.PI / 2, 0, false )
      .close();
    // rotation needed to move the cornerShape into the proper orientation as the light corner (Math.PI more for dark corner)
    var lightCornerRotation = {
      leftTop:     -Math.PI / 2,
      rightTop: 0,
      rightBottom: Math.PI / 2,
      leftBottom: Math.PI
    }[ options.lightSource ];

    var innerBounds = rectBounds.eroded( cornerRadius );

    // since both the top and left are "lighter", we have a rounded gradient along that corner
    var lightCorner = new Path( cornerShape, {
      x: lightFromLeft ? innerBounds.minX : innerBounds.maxX,
      y: lightFromTop ? innerBounds.minY : innerBounds.maxY,
      rotation: lightCornerRotation,
      fill: new RadialGradient( 0, 0, 0, 0, 0, cornerRadius )
        .addColorStop( 0, baseColor )
        .addColorStop( 1 - lightOffset / cornerRadius, baseColor )
        .addColorStop( 1, lighterColor ),
      pickable: false
    } );

    // since both the bottom and right are "darker", we have a rounded gradient along that corner
    var darkCorner = new Path( cornerShape, {
      x: lightFromLeft ? innerBounds.maxX : innerBounds.minX,
      y: lightFromTop ? innerBounds.maxY : innerBounds.minY,
      rotation: lightCornerRotation + Math.PI, // opposite direction from our light corner
      fill: new RadialGradient( 0, 0, 0, 0, 0, cornerRadius )
        .addColorStop( 0, baseColor )
        .addColorStop( 1 - darkOffset / cornerRadius, baseColor )
        .addColorStop( 1, darkerColor ),
      pickable: false
    } );

    // the stroke around the outside
    var panelStroke = Rectangle.roundedBounds( rectBounds, cornerRadius, cornerRadius, {
      stroke: rightColor.withAlpha( 0.4 )
    } );

    // layout
    this.addChild( horizontalNode );
    this.addChild( verticalNode );
    this.addChild( lightCorner );
    this.addChild( darkCorner );
    this.addChild( panelStroke ); // NOTE: this is the pickable child used for hit testing. Ensure something is pickable.

    this.mutate( options );
  }

  sceneryPhet.register( 'ShadedRectangle', ShadedRectangle );

  return inherit( Node, ShadedRectangle );
} );


// Copyright 2014-2015, University of Colorado Boulder

/**
 * A rectangular toggle button that switches the value of a property between 2 values.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/buttons/RectangularToggleButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularButtonView','SUN/sun','SUN/buttons/ToggleButtonInteractionStateProperty','SUN/buttons/ToggleButtonModel','TANDEM/Tandem','SUN/buttons/TToggleButton'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var RectangularButtonView = require( 'SUN/buttons/RectangularButtonView' );
  var sun = require( 'SUN/sun' );
  var ToggleButtonInteractionStateProperty = require( 'SUN/buttons/ToggleButtonInteractionStateProperty' );
  var ToggleButtonModel = require( 'SUN/buttons/ToggleButtonModel' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TToggleButton = require( 'SUN/buttons/TToggleButton' );

  /**
   * @param {Object} valueOff - value when the button is in the off state
   * @param {Object} valueOn - value when the button is in the on state
   * @param {Property} property - axon Property that can be either valueOff or valueOn
   * @param {Object} [options]
   * @constructor
   */
  function RectangularToggleButton( valueOff, valueOn, property, options ) {

    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      phetioType: TToggleButton
    }, options );


    // @public (phet-io)
    this.toggleButtonModel = new ToggleButtonModel( valueOff, valueOn, property, options );
    this.phetioValueType = property.phetioValueType;
    RectangularButtonView.call( this, this.toggleButtonModel, new ToggleButtonInteractionStateProperty( this.toggleButtonModel ), options );
  }

  sun.register( 'RectangularToggleButton', RectangularToggleButton );

  return inherit( RectangularButtonView, RectangularToggleButton );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * This toggle button uses a boolean property and a trueNode and falseNode to display its content.
 */
define( 'SUN/buttons/BooleanRectangularToggleButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularToggleButton','SUN/sun','SUN/ToggleNode','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var RectangularToggleButton = require( 'SUN/buttons/RectangularToggleButton' );
  var sun = require( 'SUN/sun' );
  var ToggleNode = require( 'SUN/ToggleNode' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Node} trueNode
   * @param {Node} falseNode
   * @param booleanProperty
   * @param {Object} [options]
   * @constructor
   */
  function BooleanRectangularToggleButton( trueNode, falseNode, booleanProperty, options ) {

    options = _.extend( { tandem: Tandem.tandemRequired() }, options );

    //TODO ToggleNode links to booleanProperty, must be cleaned up in dispose
    assert && assert( !options.content, 'options.content cannot be set' );
    options.content = new ToggleNode( trueNode, falseNode, booleanProperty, {
      tandem: options.tandem.createTandem( 'toggleNode' )
    } );

    RectangularToggleButton.call( this, false, true, booleanProperty, options );
  }

  sun.register( 'BooleanRectangularToggleButton', BooleanRectangularToggleButton );

  return inherit( RectangularToggleButton, BooleanRectangularToggleButton );
} );

// Copyright 2014-2017, University of Colorado Boulder

/**
 * Copyright 2002-2013, University of Colorado
 * Timer Node.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Anton Ulyanov (Mlearner)
 */

define( 'SCENERY_PHET/TimerNode',['require','PHET_CORE/inherit','DOT/Bounds2','KITE/Shape','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/util/Color','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','SCENERY_PHET/PhetFont','SCENERY_PHET/UTurnArrowShape','SCENERY_PHET/ShadedRectangle','SUN/buttons/RectangularPushButton','SUN/buttons/BooleanRectangularToggleButton','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Shape = require( 'KITE/Shape' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Color = require( 'SCENERY/util/Color' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Text = require( 'SCENERY/nodes/Text' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var UTurnArrowShape = require( 'SCENERY_PHET/UTurnArrowShape' );
  var ShadedRectangle = require( 'SCENERY_PHET/ShadedRectangle' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var BooleanRectangularToggleButton = require( 'SUN/buttons/BooleanRectangularToggleButton' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   *
   * @param {Property.<number>} secondsProperty
   * @param {Property.<boolean>} runningProperty
   * @param {Object} [options]
   * @constructor
   */
  function TimerNode( secondsProperty, runningProperty, options ) {
    Tandem.indicateUninstrumentedCode();
    options = _.extend( {
      iconColor: '#333',
      buttonBaseColor: '#DFE0E1',
      touchAreaDilation: 10,
      //tandem: Tandem.required()
    }, options );

    Node.call( this, _.extend( { cursor: 'pointer' }, options ) );

    /*---------------------------------------------------------------------------*
     * Readout text
     *----------------------------------------------------------------------------*/
    var bigReadoutText = new Text( timeToBigString( 0 ), {
      font: new PhetFont( 20 )
    } );
    var smallReadoutText = new Text( timeToSmallString( 0 ), {
      font: new PhetFont( 15 ),
      left: bigReadoutText.right
    } );
    // aligns the baselines of the big and small text
    smallReadoutText.bottom = smallReadoutText.bounds.maxY - bigReadoutText.bounds.minY;
    bigReadoutText.top = 0;
    var readoutText = new Node( {
      children: [
        bigReadoutText,
        smallReadoutText
      ],
      pickable: false
    } );
    readoutText.centerX = 0;

    /*---------------------------------------------------------------------------*
     * Readout background
     *----------------------------------------------------------------------------*/
    var textBackground = Rectangle.roundedBounds( readoutText.bounds.dilatedXY( 5, 2 ), 5, 5, {
      fill: '#fff',
      stroke: 'rgba(0,0,0,0.5)',
      pickable: false
    } );

    var paddingBetweenItems = 6;
    var minimumButtonWidth = ( textBackground.width - paddingBetweenItems ) / 2 - 1; // -1 due to the stroke making it look mis-aligned

    /*---------------------------------------------------------------------------*
     * Buttons
     *----------------------------------------------------------------------------*/
    var resetAllShape = new UTurnArrowShape( 10 );
    var playPauseHeight = resetAllShape.bounds.height;
    var playPauseWidth = playPauseHeight;
    var halfPlayStroke = 0.05 * playPauseWidth;
    var playOffset = 0.15 * playPauseWidth;
    var playShape = new Shape().moveTo( playPauseWidth - halfPlayStroke * 0.5 - playOffset, 0 )
      .lineTo( halfPlayStroke * 1.5 + playOffset, playPauseHeight / 2 - halfPlayStroke - playOffset )
      .lineTo( halfPlayStroke * 1.5 + playOffset, -playPauseHeight / 2 + halfPlayStroke + playOffset )
      .close().getOffsetShape( -playOffset );
    // a stop symbol (square)
    var pauseShape = Shape.bounds( new Bounds2( 0, -playPauseHeight / 2, playPauseWidth, playPauseHeight / 2 ).eroded( playPauseWidth * 0.1 ) );

    var resetButton = new RectangularPushButton( {
      listener: function resetTimer() {
        runningProperty.set( false );
        secondsProperty.set( 0 );
      },
      content: new Path( resetAllShape, {
        fill: options.iconColor
      } ),
      baseColor: options.buttonBaseColor,
      minWidth: minimumButtonWidth
    } );

    var playPauseButton = new BooleanRectangularToggleButton(
      new Path( pauseShape, { fill: options.iconColor } ),
      new Path( playShape, {
        stroke: options.iconColor,
        fill: '#eef',
        lineWidth: halfPlayStroke * 2
      } ), runningProperty, {
        baseColor: options.buttonBaseColor,
        minWidth: minimumButtonWidth
      } );

    /*---------------------------------------------------------------------------*
     * Layout
     *----------------------------------------------------------------------------*/
    var container = new Node();
    container.addChild( resetButton );
    container.addChild( playPauseButton );
    container.addChild( textBackground );
    container.addChild( readoutText );

    resetButton.right = -paddingBetweenItems / 2;
    playPauseButton.left = paddingBetweenItems / 2;
    resetButton.top = textBackground.bottom + paddingBetweenItems;
    playPauseButton.top = textBackground.bottom + paddingBetweenItems;

    var panelPad = 8;
    container.left = panelPad;
    container.top = panelPad;

    /*---------------------------------------------------------------------------*
     * Panel background
     *----------------------------------------------------------------------------*/
    var roundedRectangle = new ShadedRectangle( container.bounds.dilated( panelPad ), {
      baseColor: new Color( 80, 130, 230 ),
      cornerRadius: 10
    } );
    roundedRectangle.touchArea = roundedRectangle.localBounds.dilated( options.touchAreaDilation );
    this.addChild( roundedRectangle );
    this.addChild( container );

    /*---------------------------------------------------------------------------*
     * Control logic
     *----------------------------------------------------------------------------*/
    var updateTime = function updateTime( value ) {
      bigReadoutText.text = timeToBigString( value );
      smallReadoutText.text = timeToSmallString( value );
      resetButton.enabled = value > 0;
    };
    secondsProperty.link( updateTime );

    /*---------------------------------------------------------------------------*
     * Target for drag listeners
     *----------------------------------------------------------------------------*/
    this.dragTarget = roundedRectangle;

    this.disposeTimerNode = function() {
      secondsProperty.unlink( updateTime );
      resetButton.dispose();
      playPauseButton.dispose();
    };
  }

  sceneryPhet.register( 'TimerNode', TimerNode );

  // the full-sized minutes and seconds string
  function timeToBigString( timeInSeconds ) {
    var minutes = Math.floor( timeInSeconds / 60 ) % 60;
    var seconds = Math.floor( timeInSeconds ) % 60;
    if ( seconds < 10 ) {
      seconds = '0' + seconds;
    }
    if ( minutes < 10 ) {
      minutes = '0' + minutes;
    }
    return minutes + ':' + seconds;
  }

  // the smaller hundredths-of-a-second string
  function timeToSmallString( timeInSeconds ) {
    var centiseconds = Math.floor( timeInSeconds % 1 * 100 );
    if ( centiseconds < 10 ) {
      centiseconds = '0' + centiseconds;
    }
    return '.' + centiseconds;
  }

  return inherit( Node, TimerNode, {
    // @public - Provide dispose() on the prototype for ease of subclassing.
    dispose: function() {
      this.disposeTimerNode();
    }
  } );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Stopwatch node in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/StopwatchNode',['require','PHET_CORE/inherit','SCENERY_PHET/input/MovableDragHandler','PENDULUM_LAB/pendulumLab','SCENERY_PHET/TimerNode'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var MovableDragHandler = require( 'SCENERY_PHET/input/MovableDragHandler' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var TimerNode = require( 'SCENERY_PHET/TimerNode' );

  /**
   * @constructor
   *
   * @param {Stopwatch} stopwatch - Model of stopwatch.
   * @param {Bounds2} layoutBounds - Bounds of screen view.
   */
  function StopwatchNode( stopwatch, layoutBounds ) {
    var self = this;
    TimerNode.call( this, stopwatch.elapsedTimeProperty, stopwatch.isRunningProperty, { touchAreaDilation: 5 } );

    // @public
    this.movableDragHandler = new MovableDragHandler( stopwatch.locationProperty, {
      dragBounds: layoutBounds.erodedXY( this.width / 2, this.height / 2 )
    } );

    // add drag and drop events
    this.addInputListener( this.movableDragHandler );

    // add update of node location
    stopwatch.locationProperty.lazyLink( function( location ) {
      // because it's initially null, and will be null on a reset
      if ( location ) {
        self.center = location;
      }
    } );

    // set visibility observer
    stopwatch.isVisibleProperty.linkAttribute( this, 'visible' );
  }

  pendulumLab.register( 'StopwatchNode', StopwatchNode );

  return inherit( TimerNode, StopwatchNode );
} );

// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/TCheckBox',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TFunctionWrapper','ifphetio!PHET_IO/toEventOnEmit','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );

  /**
   * Wrapper type for phet/sun's CheckBox class.
   * @param checkBox
   * @param phetioID
   * @constructor
   */
  function TCheckBox( checkBox, phetioID ) {
    assertInstanceOf( checkBox, phet.sun.CheckBox );
    TNode.call( this, checkBox, phetioID );

    toEventOnEmit(
      checkBox.startedCallbacksForToggledEmitter,
      checkBox.endedCallbacksForToggledEmitter,
      'user',
      phetioID,
      this.constructor,
      'toggled',
      function( oldValue, newValue ) {
        return {
          oldValue: oldValue,
          newValue: newValue
        };
      } );
  }

  phetioInherit( TNode, 'TCheckBox', TCheckBox, {

    link: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [ TBoolean ] ) ],
      implementation: function( listener ) {
        this.instance.checkBoxValueProperty.link( listener );
      },
      documentation: 'Link a listener to the underlying checked TProperty.  The listener receives an immediate callback ' +
                     'with the current value (true/false)'
    },

    setChecked: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( checked ) {
        this.instance.checkBoxValueProperty.set( checked );
      },
      documentation: 'Sets whether the checkbox is checked or not'
    },

    isChecked: {
      returnType: TBoolean,
      parameterTypes: [],
      implementation: function() {
        return this.instance.checkBoxValueProperty.get();
      },
      documentation: 'Returns true if the checkbox is checked, false otherwise'
    }
  }, {
    documentation: 'A traditional checkbox',
    events: [ 'toggled' ]
  } );

  sun.register( 'TCheckBox', TCheckBox );

  return TCheckBox;
} );


// Copyright 2013-2015, University of Colorado Boulder

/**
 * Check box.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/CheckBox',['require','SCENERY/input/ButtonListener','SUN/FontAwesomeNode','AXON/Emitter','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SUN/sun','SCENERY/nodes/Text','TANDEM/Tandem','SUN/TCheckBox'],function( require ) {
  'use strict';

  // modules
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sun = require( 'SUN/sun' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );

  // phet-io modules
  var TCheckBox = require( 'SUN/TCheckBox' );

  // constants
  var DISABLED_OPACITY = 0.3;

  /**
   * @param {Node} content
   * @param {Property.<boolean>} property
   * @constructor
   * @param {Object} [options]
   */
  function CheckBox( content, property, options ) {

    // @public (phet-io) Store for dispose();  Use a unique name to reduce the risk of collisions with parent/child classes
    // Made public for PhET-iO so that clients can access the checkbox value and change it through the PhET-iO API
    this.checkBoxValueProperty = property;

    options = _.extend( {
      spacing: 5,
      boxWidth: 21,
      cursor: 'pointer',
      checkBoxColor: 'black',
      checkBoxColorBackground: 'white',
      tandem: Tandem.tandemRequired(),
      phetioType: TCheckBox,

      // a11y
      tagName: 'input',
      inputType: 'checkbox',

      /*
       * {function( {Node} checkBox, {boolean} enabled ) }
       * Strategy for controlling the check box's appearance, excluding any content.
       * This can be a stock strategy from this file or custom.
       * To create a custom one, model it off of the stock strategies defined in this file.
       */
      checkBoxAppearanceStrategy: CheckBox.fadeCheckBoxWhenDisabled,

      /*
       * {function( {Node} content, {boolean} enabled )}
       * Strategy for controlling the appearance of the content based on the check box's state.
       * This can be a stock strategy from this file, or custom.
       * To create a custom one, model it off of the stock version(s) defined in this file.
       */
      contentAppearanceStrategy: CheckBox.fadeContentWhenDisabled
    }, options );

    var self = this;

    Node.call( this );

    this.content = content; // @private
    this.checkBoxAppearanceStrategy = options.checkBoxAppearanceStrategy; // @private
    this.contentAppearanceStrategy = options.contentAppearanceStrategy; // @private

    this._enabled = true; // @private

    // Emitters for the PhET-iO data stream
    this.startedCallbacksForToggledEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForToggledEmitter = new Emitter( { indicateCallbacks: false } );

    // @private - Create the background.  Until we are creating our own shapes, just put a rectangle behind the font
    // awesome check box icons.
    this.backgroundNode = new Rectangle( 0, -options.boxWidth, options.boxWidth * 0.95, options.boxWidth * 0.95,
      options.boxWidth * 0.2, options.boxWidth * 0.2, {
        fill: options.checkBoxColorBackground
      } );

    // @private
    this.uncheckedNode = new FontAwesomeNode( 'check_empty', {
      fill: options.checkBoxColor
    } );
    var iconScale = options.boxWidth / this.uncheckedNode.width;
    this.uncheckedNode.scale( iconScale );

    // @private
    this.checkedNode = new FontAwesomeNode( 'check_square_o', {
      scale: iconScale,
      fill: options.checkBoxColor
    } );

    // @private
    this.checkBoxNode = new Node( { children: [ this.backgroundNode, this.checkedNode, this.uncheckedNode ] } );

    this.addChild( this.checkBoxNode );
    this.addChild( content );

    content.left = this.checkedNode.right + options.spacing;
    content.centerY = this.checkedNode.centerY;

    // put a rectangle on top of everything to prevent dead zones when clicking
    this.addChild( new Rectangle( this.left, this.top, this.width, this.height ) );

    content.pickable = false; // since there's a pickable rectangle on top of content

    // @private interactivity
    this.fire = function() {
      if ( self._enabled ) {
        var oldValue = property.value;
        var newValue = !property.value;
        self.startedCallbacksForToggledEmitter.emit2( oldValue, newValue );
        property.value = newValue;
        self.endedCallbacksForToggledEmitter.emit();
      }
    };

    // @private
    this.checkBoxButtonListener = new ButtonListener( {
      fire: this.fire
    } );
    this.addInputListener( this.checkBoxButtonListener );

    // @private (a11y) - fire the listener when checkbox is clicked with keyboard or assistive technology
    this.changeListener = this.addAccessibleInputListener( {
      change: this.fire
    } );

    // @private - sync with property
    this.checkBoxCheckedListener = function( checked ) {
      self.checkedNode.visible = checked;
      self.uncheckedNode.visible = !checked;
    };
    property.link( this.checkBoxCheckedListener );

    // Apply additional options
    this.mutate( options );
  }

  sun.register( 'CheckBox', CheckBox );

  inherit( Node, CheckBox, {

    // @public
    dispose: function() {
      this.checkBoxValueProperty.unlink( this.checkBoxCheckedListener );
      this.removeInputListener( this.checkBoxButtonListener );
      this.removeAccessibleInputListener( this.changeListener );
      Node.prototype.dispose.call( this );
    },

    /**
     *  Sets the background color of the check box.
     *  @param {Color|String} value
     *  @public
     */
    setCheckBoxColorBackground: function( value ) { this.backgroundNode.fill = value; },
    set checkBoxColorBackground( value ) { this.setCheckBoxColorBackground( value ); },

    /**
     * Gets the background color of the check box.
     * @returns {Color|String}
     * @public
     */
    getCheckboxColorBackground: function() { return this.backgroundNode.fill; },
    get checkBoxColorBackground() { return this.getCheckboxColorBackground(); },

    /**
     *  Sets the color of the check box.
     *  @param {Color|String} value
     *  @public
     */
    setCheckBoxColor: function( value ) { this.checkedNode.fill = this.uncheckedNode.fill = value; },
    set checkBoxColor( value ) { this.setCheckBoxColor( value ); },

    /**
     * Gets the color of the check box.
     * @returns {Color|String}
     * @public
     */
    getCheckboxColor: function() { return this.checkedNode.fill; },
    get checkBoxColor() { return this.getCheckboxColor(); },

    /**
     * Sets whether the check box is enabled.
     * @param {boolean} value
     * @public
     */
    setEnabled: function( value ) {
      this._enabled = this.pickable = value;
      this.checkBoxAppearanceStrategy( this.checkBoxNode, value );
      this.contentAppearanceStrategy( this.content, value );
    },
    set enabled( value ) { this.setEnabled( value ); },

    /**
     * Is the check box enabled?
     * @returns {boolean}
     * @public
     */
    getEnabled: function() { return this._enabled; },
    get enabled() { return this.getEnabled(); }

  }, {

    /**
     * Default for options.checkBoxAppearanceStrategy, fades the check box by changing opacity.
     * @param {Node} checkBoxNode the check box
     * @param {boolean} enabled
     * @static
     * @public
     */
    fadeCheckBoxWhenDisabled: function( checkBoxNode, enabled ) {
      checkBoxNode.opacity = enabled ? 1 : DISABLED_OPACITY;
    },

    /**
     * Default for options.contentAppearanceStrategy, fades the content by changing opacity.
     * @param {Node} content the content that appears next to the check box
     * @param {boolean} enabled
     * @static
     * @public
     */
    fadeContentWhenDisabled: function( content, enabled ) {
      content.opacity = enabled ? 1 : DISABLED_OPACITY;
    },

    /**
     * Factory method, creates a check box with a text label and optional icon.
     * @param {string} text
     * @param {Object} textOptions options passed to scenery.Text constructor
     * @param {Property.<boolean>} property
     * @param {Object} [checkBoxOptions] options passed to CheckBox constructor
     * @returns {CheckBox}
     * @static
     * @public
     */
    createTextCheckBox: function( text, textOptions, property, checkBoxOptions ) {

      textOptions = textOptions || {};

      checkBoxOptions = _.extend( {
        icon: null,  // an optional node, added to the right of the text
        iconSpacing: 15
      }, checkBoxOptions );

      var content = new Node();

      // text
      var textNode = new Text( text, textOptions );
      content.addChild( textNode );

      // optional icon
      if ( checkBoxOptions.icon ) {
        content.addChild( checkBoxOptions.icon );
        //TODO support different layouts of text and image?
        checkBoxOptions.icon.left = textNode.right + checkBoxOptions.iconSpacing;
        checkBoxOptions.icon.centerY = textNode.centerY;
      }

      return new CheckBox( content, property, checkBoxOptions );
    }
  } );

  return CheckBox;
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/TVerticalCheckBoxGroup',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','SUN/sun','ifphetio!PHET_IO/phetioInherit','SCENERY/nodes/TNode'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var sun = require( 'SUN/sun' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  /**
   * Wrapper type for phet/sun's VerticalCheckBoxGroup class.
   * @param verticalCheckBoxGroup
   * @param phetioID
   * @constructor
   */
  function TVerticalCheckBoxGroup( verticalCheckBoxGroup, phetioID ) {
    TNode.call( this, verticalCheckBoxGroup, phetioID );
    assertInstanceOf( verticalCheckBoxGroup, phet.sun.VerticalCheckBoxGroup );
  }

  phetioInherit( TNode, 'TVerticalCheckBoxGroup', TVerticalCheckBoxGroup, {}, {
    documentation: 'A vertical group of checkboxes'
  } );

  sun.register( 'TVerticalCheckBoxGroup', TVerticalCheckBoxGroup );

  return TVerticalCheckBoxGroup;
} );


// Copyright 2013-2015, University of Colorado Boulder

/**
 * A vertical group of check boxes.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'SUN/VerticalCheckBoxGroup',['require','SUN/CheckBox','SCENERY/nodes/HBox','PHET_CORE/inherit','SCENERY/nodes/Path','SCENERY/nodes/Rectangle','KITE/Shape','SUN/sun','SCENERY/nodes/VBox','TANDEM/Tandem','SUN/TVerticalCheckBoxGroup'],function( require ) {
  'use strict';

  var CheckBox = require( 'SUN/CheckBox' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Tandem = require( 'TANDEM/Tandem' );

  // phet-io modules
  var TVerticalCheckBoxGroup = require( 'SUN/TVerticalCheckBoxGroup' );

  /**
   * Main constructor.
   *
   * @param items  an array of {content, property, indent, [tandemName]}
   * @param {Object} [options]
   * @constructor
   */
  function VerticalCheckBoxGroup( items, options ) {

    options = _.extend( {
      spacing: 10, // vertical spacing
      padding: 8, //TODO what is this? It looks like it's added to the right of the check box. Shouldn't this be an x-margin, added to left and right?
      checkBoxColor: 'black',
      align: 'left',
      boxWidth: 21,
      tandem: Tandem.tandemRequired(),
      phetioType: TVerticalCheckBoxGroup
    }, options );

    // compute max width of the items
    var maxWidth = 0;
    for ( var i = 0; i < items.length; i++ ) {
      maxWidth = Math.max( maxWidth, items[ i ].content.width );
    }

    // process each item
    var children = [];
    for ( i = 0; i < items.length; i++ ) {
      (function( i ) {
        var offset = items[ i ].indent || 0;

        //Attach each item to an invisible strut to make the widths match.
        var content = new Path( Shape.rect( 0, 0, maxWidth + options.padding - offset, 0 ), { children: [ items[ i ].content ] } );
        if ( Tandem.validationEnabled() ) {
          assert && assert( items[ i ].tandemName, 'Tandem name must be supplied for phet-io' );
        }
        var checkBox = new CheckBox( content, items[ i ].property, {
          textDescription: items[ i ].label + ': Checkbox (' + 'unchecked' + ')',
          checkBoxColor: options.checkBoxColor,
          boxWidth: options.boxWidth,
          tandem: options.tandem.createTandem( items[ i ].tandemName || 'checkBox' )
        } );
        checkBox.mouseArea = checkBox.touchArea = Shape.bounds( checkBox.bounds.dilatedXY( 5, options.spacing / 2 ) );
        if ( items[ i ].indent ) {
          var hBox = new HBox( {
            children: [ new Rectangle( 0, 0, items[ i ].indent, 1 ), checkBox ]
          } );
          children.push( hBox );
        }
        else {
          var simpleBox = new HBox( { children: [ checkBox ] } );
          children.push( simpleBox );
        }
      })( i );
    }

    options.children = children; //TODO bad form, if options.children was already set, then this will blow it away
    VBox.call( this, options );
  }

  sun.register( 'VerticalCheckBoxGroup', VerticalCheckBoxGroup );

  return inherit( VBox, VerticalCheckBoxGroup );
} );

define("string!PENDULUM_LAB/ruler",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/ruler");});


define("string!PENDULUM_LAB/stopwatch",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/stopwatch");});


define("string!PENDULUM_LAB/periodTimer",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/periodTimer");});


define("string!PENDULUM_LAB/periodTrace",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/periodTrace");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Tools control panel node in 'Pendulum Lab' simulation.
 * Contains check box buttons to control visibility of ruler, stopwatch and period trace tools.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/common/view/ToolsPanel',['require','SCENERY/nodes/AlignBox','PHET_CORE/inherit','SUN/Panel','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY/nodes/Text','SUN/VerticalCheckBoxGroup','string!PENDULUM_LAB/ruler','string!PENDULUM_LAB/stopwatch','string!PENDULUM_LAB/periodTimer','string!PENDULUM_LAB/periodTrace'],function( require ) {
  'use strict';

  // modules
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Panel = require( 'SUN/Panel' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VerticalCheckBoxGroup = require( 'SUN/VerticalCheckBoxGroup' );

  // strings
  var rulerString = require( 'string!PENDULUM_LAB/ruler' );
  var stopwatchString = require( 'string!PENDULUM_LAB/stopwatch' );
  var periodTimerString = require( 'string!PENDULUM_LAB/periodTimer' );
  var periodTraceString = require( 'string!PENDULUM_LAB/periodTrace' );

  // constants
  var TEXT_OPTIONS = {
    font: PendulumLabConstants.TITLE_FONT,
    pickable: false,
    maxWidth: 100
  };

  /**
   * @constructor
   *
   * @param {Property.<boolean>} isRulerProperty - property to control visibility of ruler.
   * @param {Property.<boolean>} isStopwatchProperty - property to control visibility of stopwatch.
   * @param {Property.<boolean>} isPeriodTraceProperty - property to control visibility of period trace tool.
   * @param {boolean} hasPeriodTimer
   * @param {Object} [options]
   */
  function ToolsPanel( isRulerProperty, isStopwatchProperty, isPeriodTraceProperty, hasPeriodTimer, options ) {
    options = _.extend( {}, PendulumLabConstants.PANEL_OPTIONS, options );

    // @private
    this._labels = [
      new Text( rulerString, TEXT_OPTIONS ),
      new Text( stopwatchString, TEXT_OPTIONS ),
      new Text( hasPeriodTimer ? periodTimerString : periodTraceString, TEXT_OPTIONS )
    ];

    var items = [ {
      content: this._labels[ 0 ],
      property: isRulerProperty
    }, {
      content: this._labels[ 1 ],
      property: isStopwatchProperty
    }, {
      content: this._labels[ 2 ],
      property: isPeriodTraceProperty
    } ];

    var content = new AlignBox( new VerticalCheckBoxGroup( items, {
      spacing: PendulumLabConstants.CHECK_RADIO_SPACING,
      boxWidth: this._labels[ 0 ].height
    } ), {
      group: PendulumLabConstants.LEFT_CONTENT_ALIGN_GROUP,
      xAlign: 'left'
    } );

    Panel.call( this, content, options );
  }

  pendulumLab.register( 'ToolsPanel', ToolsPanel );

  return inherit( Panel, ToolsPanel );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Main ScreenView node that contains all other nodes.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/common/view/PendulumLabScreenView',['require','SUN/ClosestDragListener','PENDULUM_LAB/common/view/GlobalControlPanel','PHET_CORE/inherit','SCENERY/nodes/Node','PENDULUM_LAB/common/view/PendulaNode','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','PENDULUM_LAB/common/view/PendulumControlPanel','PENDULUM_LAB/common/view/PendulumLabRulerNode','PENDULUM_LAB/common/view/PeriodTraceNode','SCENERY/nodes/Plane','PENDULUM_LAB/common/view/PlaybackControlsNode','PENDULUM_LAB/common/view/ProtractorNode','SCENERY_PHET/buttons/ResetAllButton','JOIST/ScreenView','PENDULUM_LAB/common/view/StopwatchNode','PENDULUM_LAB/common/view/ToolsPanel','SCENERY/nodes/VBox'],function( require ) {
  'use strict';

  // modules
  var ClosestDragListener = require( 'SUN/ClosestDragListener' );
  var GlobalControlPanel = require( 'PENDULUM_LAB/common/view/GlobalControlPanel' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PendulaNode = require( 'PENDULUM_LAB/common/view/PendulaNode' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PendulumControlPanel = require( 'PENDULUM_LAB/common/view/PendulumControlPanel' );
  var PendulumLabRulerNode = require( 'PENDULUM_LAB/common/view/PendulumLabRulerNode' );
  var PeriodTraceNode = require( 'PENDULUM_LAB/common/view/PeriodTraceNode' );
  var Plane = require( 'SCENERY/nodes/Plane' );
  var PlaybackControlsNode = require( 'PENDULUM_LAB/common/view/PlaybackControlsNode' );
  var ProtractorNode = require( 'PENDULUM_LAB/common/view/ProtractorNode' );
  var ResetAllButton = require( 'SCENERY_PHET/buttons/ResetAllButton' );
  var ScreenView = require( 'JOIST/ScreenView' );
  var StopwatchNode = require( 'PENDULUM_LAB/common/view/StopwatchNode' );
  var ToolsPanel = require( 'PENDULUM_LAB/common/view/ToolsPanel' );
  var VBox = require( 'SCENERY/nodes/VBox' );

  /**
   * @constructor
   *
   * @param {PendulumLabModel} model
   * @param {ModelViewTransform2} modelViewTransform
   */
  function PendulumLabScreenView( model, options ) {
    ScreenView.call( this );

    // @private {PendulumLabModel}
    this.model = model;

    options = _.extend( {
      hasGravityTweakers: false,
      hasPeriodTimer: false
    }, options );

    var modelViewTransform = PendulumLabConstants.MODEL_VIEW_TRANSFORM;

    var pendulaNode = new PendulaNode( model.pendula, modelViewTransform, {
      isAccelerationVisibleProperty: model.isAccelerationVisibleProperty,
      isVelocityVisibleProperty: model.isVelocityVisibleProperty
    } );

    // create drag listener for the pendula
    var backgroundDragNode = new Plane();
    var dragListener = new ClosestDragListener( 0.15, 0 ); // 15cm from mass is OK for touch
    pendulaNode.draggableItems.forEach( function( draggableItem ) {
      dragListener.addDraggableItem( draggableItem );
    } );
    backgroundDragNode.addInputListener( dragListener );

    // @private {PeriodTraceNode}
    this.firstPeriodTraceNode = new PeriodTraceNode( model.pendula[ 0 ], modelViewTransform );
    this.secondPeriodTraceNode = new PeriodTraceNode( model.pendula[ 1 ], modelViewTransform );

    // create protractor node
    var protractorNode = new ProtractorNode( model.pendula, modelViewTransform );

    // create a node to keep track of combo box
    var popupLayer = new Node();

    var pendulumControlPanel = new PendulumControlPanel( model.pendula, model.numberOfPendulaProperty );
    var globalControlPanel = new GlobalControlPanel( model, popupLayer, !!options.hasGravityTweakers );

    // @protected
    this.rightPanelsContainer = new VBox( {
      spacing: PendulumLabConstants.PANEL_PADDING,
      children: [
        pendulumControlPanel,
        globalControlPanel
      ],
      right: this.layoutBounds.right - PendulumLabConstants.PANEL_PADDING,
      top: this.layoutBounds.top + PendulumLabConstants.PANEL_PADDING
    } );

    // create tools control panel (which controls the visibility of the ruler and stopwatch)
    var toolsControlPanelNode = new ToolsPanel( model.ruler.isVisibleProperty,
                                                model.stopwatch.isVisibleProperty,
                                                model.isPeriodTraceVisibleProperty,
                                                options.hasPeriodTimer, {
      maxWidth: 180,
      left: this.layoutBounds.left + PendulumLabConstants.PANEL_PADDING,
      bottom: this.layoutBounds.bottom - PendulumLabConstants.PANEL_PADDING
    } );

    // @protected {Node}
    this.toolsControlPanelNode = toolsControlPanelNode;

    // create pendulum system control panel (controls the length and mass of the pendula)
    var playbackControls = new PlaybackControlsNode( model.numberOfPendulaProperty,
                                                     model.isPlayingProperty,
                                                     model.timeSpeedProperty,
                                                     model.stepManual.bind( model ),
                                                     model.returnPendula.bind( model ), {
      x: this.layoutBounds.centerX,
      bottom: this.layoutBounds.bottom - PendulumLabConstants.PANEL_PADDING
    } );

    // create reset all button
    var resetAllButton = new ResetAllButton( {
      listener: model.reset.bind( model ),
      touchAreaDilation: 6,
      right: this.layoutBounds.right - PendulumLabConstants.PANEL_PADDING,
      bottom: this.layoutBounds.bottom - PendulumLabConstants.PANEL_PADDING
    } );

    // create ruler node
    var rulerNode = new PendulumLabRulerNode( model.ruler, modelViewTransform, this.layoutBounds );
    rulerNode.left = this.layoutBounds.left + PendulumLabConstants.PANEL_PADDING;
    rulerNode.top = this.layoutBounds.top + PendulumLabConstants.PANEL_PADDING;
    model.ruler.setInitialLocationValue( rulerNode.center );

    // @protected
    this.rulerNode = rulerNode;

    // create timer node
    var stopwatchNode = new StopwatchNode( model.stopwatch, this.layoutBounds );
    stopwatchNode.bottom = rulerNode.bottom;
    stopwatchNode.right = Math.max( 167.75, toolsControlPanelNode.right ); // If we are only on this screen
    model.stopwatch.setInitialLocationValue( stopwatchNode.center );

    // @protected
    this.stopwatchNode = stopwatchNode;

    // @protected
    this.arrowsPanelLayer = new Node();
    this.energyGraphLayer = new Node();
    this.periodTimerLayer = new Node();

    var leftFloatingLayer = new Node( {
      children: [
        this.energyGraphLayer, this.arrowsPanelLayer, toolsControlPanelNode
      ]
    } );
    var rightFloatingLayer = new Node( {
      children: [
        this.rightPanelsContainer,
        resetAllButton,
        popupLayer
      ]
    } );

    // Layout for https://github.com/phetsims/pendulum-lab/issues/98
    this.visibleBoundsProperty.lazyLink( function( visibleBounds ) {
      var dx = -visibleBounds.x;
      dx = Math.min( 200, dx );
      leftFloatingLayer.x = -dx;
      rightFloatingLayer.x = dx;
      // set the drag bounds of the ruler and stopwatch
      rulerNode.movableDragHandler.setDragBounds( visibleBounds.erodedXY( rulerNode.width / 2, rulerNode.height / 2 ) );
      stopwatchNode.movableDragHandler.setDragBounds( visibleBounds.erodedXY( stopwatchNode.width / 2, stopwatchNode.height / 2 ) );
    } );

    this.children = [
      backgroundDragNode,
      protractorNode,
      leftFloatingLayer,
      rightFloatingLayer,
      playbackControls,
      this.firstPeriodTraceNode,
      this.secondPeriodTraceNode,
      pendulaNode,
      rulerNode,
      this.periodTimerLayer,
      stopwatchNode
    ];
  }

  pendulumLab.register( 'PendulumLabScreenView', PendulumLabScreenView );

  return inherit( ScreenView, PendulumLabScreenView, {
    /**
     * Steps the view.
     * @public
     *
     * @param {number} dt
     */
    step: function( dt ) {
      if ( this.model.isPlayingProperty.value ) {
        this.firstPeriodTraceNode.step( dt );
        this.secondPeriodTraceNode.step( dt );
      }
    }
  } );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Main view node for Energy screen in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/energy/view/EnergyScreenView',['require','PENDULUM_LAB/energy/view/EnergyBox','PHET_CORE/inherit','AXON/NumberProperty','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','PENDULUM_LAB/common/view/PendulumLabScreenView'],function( require ) {
  'use strict';

  // modules
  var EnergyBox = require( 'PENDULUM_LAB/energy/view/EnergyBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var NumberProperty = require( 'AXON/NumberProperty' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PendulumLabScreenView = require( 'PENDULUM_LAB/common/view/PendulumLabScreenView' );

  /**
   * @constructor
   *
   * @param {PendulumLabModel} model
   */
  function EnergyScreenView( model, options ) {

    PendulumLabScreenView.call( this, model, options );

    // @protected {Property.<number>}
    this.chartHeightProperty = new NumberProperty( 200 );

    // create and add energy graph node to the bottom layer
    var energyGraphNode = new EnergyBox( model, this.chartHeightProperty, {
      left: this.layoutBounds.left + PendulumLabConstants.PANEL_PADDING,
      top: this.layoutBounds.top + PendulumLabConstants.PANEL_PADDING
    } );
    this.energyGraphLayer.addChild( energyGraphNode );

    // @protected {EnergyBox}
    this.energyGraphNode = energyGraphNode;

    // move ruler and stopwatch to the right side
    this.rulerNode.centerX += ( energyGraphNode.width + 10 );
    model.ruler.setInitialLocationValue( this.rulerNode.center );

    this.stopwatchNode.left = this.rulerNode.right + 10;
    model.stopwatch.setInitialLocationValue( this.stopwatchNode.center );

    this.resizeEnergyGraphToFit();
  }

  pendulumLab.register( 'EnergyScreenView', EnergyScreenView );

  return inherit( PendulumLabScreenView, EnergyScreenView, {
    /**
     * Changes the chart height so that the energy graph fits all available size
     * @protected
     */
    resizeEnergyGraphToFit: function() {
      var currentSpace = this.toolsControlPanelNode.top - this.energyGraphNode.bottom;
      var desiredSpace = PendulumLabConstants.PANEL_PADDING;

      this.chartHeightProperty.value += currentSpace - desiredSpace;
    }
  } );
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Canvas drawable for Image nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/ImageCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );

  /**
   * A generated CanvasSelfDrawable whose purpose will be drawing our Image. One of these drawables will be created
   * for each displayed instance of a Image.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function ImageCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'ImageCanvasDrawable', ImageCanvasDrawable );

  inherit( CanvasSelfDrawable, ImageCanvasDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {ImageCanvasDrawable} - For chaining
     */
    initialize: function( renderer, instance ) {
      return this.initializeCanvasSelfDrawable( renderer, instance );
    },

    /**
     * Paints this drawable to a Canvas (the wrapper contains both a Canvas reference and its drawing context).
     * @public
     *
     * Assumes that the Canvas's context is already in the proper local coordinate frame for the node, and that any
     * other required effects (opacity, clipping, etc.) have already been prepared.
     *
     * This is part of the CanvasSelfDrawable API required to be implemented for subtypes.
     *
     * @param {CanvasContextWrapper} wrapper - Contains the Canvas and its drawing context
     * @param {Node} node - Our node that is being drawn
     * @param {Matrix3} matrix - The transformation matrix applied for this node's coordinate system.
     */
    paintCanvas: function( wrapper, node, matrix ) {
      var hasImageOpacity = node._imageOpacity !== 1;

      // Ensure that the image has been loaded by checking whether it has a width or height of 0.
      // See https://github.com/phetsims/scenery/issues/536
      if ( node._image && node._image.width !== 0 && node._image.height !== 0 ) {
        // If we have image opacity, we need to apply the opacity on top of whatever globalAlpha may exist
        if ( hasImageOpacity ) {
          wrapper.context.save();
          wrapper.context.globalAlpha *= node._imageOpacity;
        }

        if ( node._mipmap && node.hasMipmaps() ) {
          var level = node.getMipmapLevel( matrix );
          var canvas = node.getMipmapCanvas( level );
          var multiplier = Math.pow( 2, level );
          wrapper.context.drawImage( canvas, 0, 0, canvas.width * multiplier, canvas.height * multiplier );
        }
        else {
          wrapper.context.drawImage( node._image, 0, 0 );
        }

        if ( hasImageOpacity ) {
          wrapper.context.restore();
        }
      }
    },

    // stateless dirty functions
    markDirtyImage: function() { this.markPaintDirty(); },
    markDirtyMipmap: function() { this.markPaintDirty(); },
    markDirtyImageOpacity: function() { this.markPaintDirty(); }
  } );

  // This sets up ImageCanvasDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( ImageCanvasDrawable );

  return ImageCanvasDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * A mixin to drawables for Image that need to store state about what the current display is currently showing,
 * so that updates to the Image will only be made on attributes that specifically changed (and no change will be
 * necessary for an attribute that changed back to its original/currently-displayed value). Generally, this is used
 * for DOM and SVG drawables.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/ImageStatefulDrawable',['require','SCENERY/scenery'],function( require ) {
  'use strict';

  var scenery = require( 'SCENERY/scenery' );

  var ImageStatefulDrawable = {
    /**
     * Given the type (constructor) of a drawable, we'll mix in a combination of:
     * - initialization/disposal with the *State suffix
     * - mark* methods to be called on all drawables of nodes of this type, that set specific dirty flags
     *
     * This will allow drawables that mix in this type to do the following during an update:
     * 1. Check specific dirty flags (e.g. if the fill changed, update the fill of our SVG element).
     * 2. Call setToCleanState() once done, to clear the dirty flags.
     *
     * @param {function} drawableType - The constructor for the drawable type
     */
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;

      /**
       * Initializes the stateful mixin state, starting its "lifetime" until it is disposed with disposeState().
       * @protected
       *
       * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
       * @param {Instance} instance
       * @returns {ImageStatefulDrawable} - Self reference for chaining
       */
      proto.initializeState = function( renderer, instance ) {
        // @protected {boolean} - Flag marked as true if ANY of the drawable dirty flags are set (basically everything except for transforms, as we
        //                        need to accelerate the transform case.
        this.paintDirty = true;
        this.dirtyImage = true;
        this.dirtyImageOpacity = true;
        this.dirtyMipmap = true;

        return this; // allow for chaining
      };

      /**
       * Disposes the stateful mixin state, so it can be put into the pool to be initialized again.
       * @protected
       */
      proto.disposeState = function() {

      };

      /**
       * A "catch-all" dirty method that directly marks the paintDirty flag and triggers propagation of dirty
       * information. This can be used by other mark* methods, or directly itself if the paintDirty flag is checked.
       * @public (scenery-internal)
       *
       * It should be fired (indirectly or directly) for anything besides transforms that needs to make a drawable
       * dirty.
       */
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };

      proto.markDirtyImage = function() {
        this.dirtyImage = true;
        this.markPaintDirty();
      };

      proto.markDirtyImageOpacity = function() {
        this.dirtyImageOpacity = true;
        this.markPaintDirty();
      };

      proto.markDirtyMipmap = function() {
        this.dirtyMipmap = true;
        this.markPaintDirty();
      };

      /**
       * Clears all of the dirty flags (after they have been checked), so that future mark* methods will be able to flag them again.
       * @public (scenery-internal)
       */
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyImage = false;
        this.dirtyImageOpacity = false;
        this.dirtyMipmap = false;
      };
    }
  };

  scenery.register( 'ImageStatefulDrawable', ImageStatefulDrawable );

  return ImageStatefulDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * DOM drawable for Image nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/ImageDOMDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/DOMSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/ImageStatefulDrawable','SCENERY/util/Util'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var ImageStatefulDrawable = require( 'SCENERY/display/drawables/ImageStatefulDrawable' );
  require( 'SCENERY/util/Util' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepDOMImageElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory

  /**
   * A generated DOMSelfDrawable whose purpose will be drawing our Image. One of these drawables will be created
   * for each displayed instance of a Image.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function ImageDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

scenery.register( 'ImageDOMDrawable', ImageDOMDrawable );

  inherit( DOMSelfDrawable, ImageDOMDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {ImageDOMDrawable} - Self reference for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeDOMSelfDrawable( renderer, instance );

      // Stateful mix-in initialization
      this.initializeState( renderer, instance );

      // only create elements if we don't already have them (we pool visual states always, and depending on the platform may also pool the actual elements to minimize
      // allocation and performance costs)
      if ( !this.domElement ) {
        // @protected {HTMLElement} - Our primary DOM element. This is exposed as part of the DOMSelfDrawable API.
        this.domElement = document.createElement( 'img' );
        this.domElement.style.display = 'block';
        this.domElement.style.position = 'absolute';
        this.domElement.style.pointerEvents = 'none';
        this.domElement.style.left = '0';
        this.domElement.style.top = '0';
      }

      // Whether we have an opacity attribute specified on the DOM element.
      this.hasOpacity = false;

      // Apply CSS needed for future CSS transforms to work properly.
      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );

      return this; // allow for chaining
    },

    /**
     * Updates our DOM element so that its appearance matches our node's representation.
     * @protected
     *
     * This implements part of the DOMSelfDrawable required API for subtypes.
     */
    updateDOM: function() {
      var node = this.node;
      var img = this.domElement;

      if ( this.paintDirty && this.dirtyImage ) {
        // TODO: allow other ways of showing a DOM image?
        img.src = node._image ? node._image.src : '//:0'; // NOTE: for img with no src (but with a string), see http://stackoverflow.com/questions/5775469/whats-the-valid-way-to-include-an-image-with-no-src
      }

      if ( this.dirtyImageOpacity ) {
        if ( node._imageOpacity === 1 ) {
          if ( this.hasOpacity ) {
            this.hasOpacity = false;
            img.style.opacity = '';
          }
        }
        else {
          this.hasOpacity = true;
          img.style.opacity = node._imageOpacity;
        }
      }

      if ( this.transformDirty ) {
        scenery.Util.applyPreparedTransform( this.getTransformMatrix(), this.domElement, this.forceAcceleration );
      }

      // clear all of the dirty flags
      this.setToCleanState();
      this.transformDirty = false;
    },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      this.disposeState();

      if ( !keepDOMImageElements ) {
        this.domElement = null; // clear our DOM reference if we want to toss it
      }

      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  ImageStatefulDrawable.mixin( ImageDOMDrawable );

  // This sets up ImageDOMDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( ImageDOMDrawable );

  return ImageDOMDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * SVG drawable for Image nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/ImageSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','PHET_CORE/platform','SCENERY/display/SVGSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/ImageStatefulDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var platform = require( 'PHET_CORE/platform' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var ImageStatefulDrawable = require( 'SCENERY/display/drawables/ImageStatefulDrawable' );

  // TODO: change this based on memory and performance characteristics of the platform
  var keepSVGImageElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory

  /**
   * A generated SVGSelfDrawable whose purpose will be drawing our Image. One of these drawables will be created
   * for each displayed instance of a Image.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function ImageSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

scenery.register( 'ImageSVGDrawable', ImageSVGDrawable );

  inherit( SVGSelfDrawable, ImageSVGDrawable, {
    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {ImageSVGDrawable} - Self reference for chaining
     */
    initialize: function( renderer, instance ) {
      // Super-type initialization
      this.initializeSVGSelfDrawable( renderer, instance, false, keepSVGImageElements ); // usesPaint: false

      sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' initialized for ' + instance.toString() );
      var self = this;

      // @protected {SVGImageElement} - Sole SVG element for this drawable, implementing API for SVGSelfDrawable
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'image' );
      this.svgElement.setAttribute( 'x', 0 );
      this.svgElement.setAttribute( 'y', 0 );

      // Whether we have an opacity attribute specified on the DOM element.
      this.hasOpacity = false;

      this._usingMipmap = false;
      this._mipmapLevel = -1; // will always be invalidated

      // if mipmaps are enabled, this listener will be added to when our relative transform changes
      this._mipmapTransformListener = this._mipmapTransformListener || function() {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( self.id + ' Transform dirties mipmap' );
          self.markDirtyMipmap();
        };

      this._mipmapListener = this._mipmapListener || function() {
          // sanity check
          self.markDirtyMipmap();

          // update our mipmap usage status
          self.updateMipmapStatus( self.node._mipmap );
        };
      this.node.onStatic( 'mipmap', this._mipmapListener );
      this.updateMipmapStatus( instance.node._mipmap );

      return this;
    },

    /**
     * Updates the SVG elements so that they will appear like the current node's representation.
     * @protected
     *
     * Implements the interface for SVGSelfDrawable (and is called from the SVGSelfDrawable's update).
     */
    updateSVGSelf: function() {
      var image = this.svgElement;

      if ( this.dirtyImage ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Updating dirty image' );
        if ( this.node._image ) {
          // like <image xlink:href='http://phet.colorado.edu/images/phet-logo-yellow.png' x='0' y='0' height='127px' width='242px'/>
          this.updateURL( image, true );
        }
        else {
          image.setAttribute( 'width', '0' );
          image.setAttribute( 'height', '0' );
          image.setAttributeNS( scenery.xlinkns, 'xlink:href', '//:0' ); // see http://stackoverflow.com/questions/5775469/whats-the-valid-way-to-include-an-image-with-no-src
        }
      }
      else if ( this.dirtyMipmap && this.node._image ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Updating dirty mipmap' );
        this.updateURL( image, false );
      }

      if ( this.dirtyImageOpacity ) {
        if ( this.node._imageOpacity === 1 ) {
          if ( this.hasOpacity ) {
            this.hasOpacity = false;
            image.removeAttribute( 'opacity' );
          }
        }
        else {
          this.hasOpacity = true;
          image.setAttribute( 'opacity', this.node._imageOpacity );
        }
      }
    },

    updateURL: function( image, forced ) {
      // determine our mipmap level, if any is used
      var level = -1; // signals a default of "we are not using mipmapping"
      if ( this.node._mipmap ) {
        level = this.node.getMipmapLevel( this.instance.relativeTransform.matrix );
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Mipmap level: ' + level );
      }

      // bail out if we would use the currently-used mipmap level (or none) and there was no image change
      if ( !forced && level === this._mipmapLevel ) {
        return;
      }

      // if we are switching to having no mipmap
      if ( this._mipmapLevel >= 0 && level === -1 ) {
        // IE guard needed since removeAttribute fails, see https://github.com/phetsims/scenery/issues/395
        ( platform.ie9 || platform.ie10 ) ? image.setAttribute( 'transform', '' ) : image.removeAttribute( 'transform' );
      }
      this._mipmapLevel = level;

      if ( this.node._mipmap && this.node.hasMipmaps() ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Setting image URL to mipmap level ' + level );
        var url = this.node.getMipmapURL( level );
        var canvas = this.node.getMipmapCanvas( level );
        image.setAttribute( 'width', canvas.width + 'px' );
        image.setAttribute( 'height', canvas.height + 'px' );
        // Since SVG doesn't support parsing scientific notation (e.g. 7e5), we need to output fixed decimal-point strings.
        // Since this needs to be done quickly, and we don't particularly care about slight rounding differences (it's
        // being used for display purposes only, and is never shown to the user), we use the built-in JS toFixed instead of
        // Dot's version of toFixed. See https://github.com/phetsims/kite/issues/50
        image.setAttribute( 'transform', 'scale(' + Math.pow( 2, level ).toFixed( 20 ) + ')' );
        image.setAttributeNS( scenery.xlinkns, 'xlink:href', url );
      }
      else {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Setting image URL' );
        image.setAttribute( 'width', this.node.getImageWidth() + 'px' );
        image.setAttribute( 'height', this.node.getImageHeight() + 'px' );
        image.setAttributeNS( scenery.xlinkns, 'xlink:href', this.node.getImageURL() );
      }
    },

    updateMipmapStatus: function( usingMipmap ) {
      if ( this._usingMipmap !== usingMipmap ) {
        this._usingMipmap = usingMipmap;

        if ( usingMipmap ) {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Adding mipmap compute/listener needs' );
          this.instance.relativeTransform.addListener( this._mipmapTransformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
          this.instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated
        }
        else {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Removing mipmap compute/listener needs' );
          this.instance.relativeTransform.removeListener( this._mipmapTransformListener );
          this.instance.relativeTransform.removePrecompute();
        }

        // sanity check
        this.markDirtyMipmap();
      }
    },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' disposing' );

      // clean up mipmap listeners and compute needs
      this.updateMipmapStatus( false );
      this.node.offStatic( 'mipmap', this._mipmapListener );

      SVGSelfDrawable.prototype.dispose.call( this );
    }
  } );
  ImageStatefulDrawable.mixin( ImageSVGDrawable );
  // This sets up ImageSVGDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( ImageSVGDrawable );

  return ImageSVGDrawable;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * WebGL drawable for Image nodes.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/display/drawables/ImageWebGLDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','SCENERY/display/Renderer','SCENERY/display/SelfDrawable','SCENERY/display/WebGLSelfDrawable','SCENERY/display/drawables/ImageStatefulDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );
  var ImageStatefulDrawable = require( 'SCENERY/display/drawables/ImageStatefulDrawable' );

  // For alignment, we keep things to 8 components, aligned on 4-byte boundaries.
  // See https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html#//apple_ref/doc/uid/TP40008793-CH107-SW15
  var WEBGL_COMPONENTS = 5; // format [X Y U V A] for 6 vertices

  var VERTEX_0_OFFSET = WEBGL_COMPONENTS * 0;
  var VERTEX_1_OFFSET = WEBGL_COMPONENTS * 1;
  var VERTEX_2_OFFSET = WEBGL_COMPONENTS * 2;
  var VERTEX_3_OFFSET = WEBGL_COMPONENTS * 3;
  var VERTEX_4_OFFSET = WEBGL_COMPONENTS * 4;
  var VERTEX_5_OFFSET = WEBGL_COMPONENTS * 5;

  var VERTEX_X_OFFSET = 0;
  var VERTEX_Y_OFFSET = 1;
  var VERTEX_U_OFFSET = 2;
  var VERTEX_V_OFFSET = 3;
  var VERTEX_A_OFFSET = 4;

  /**
   * A generated WebGLSelfDrawable whose purpose will be drawing our Image. One of these drawables will be created
   * for each displayed instance of an Image.
   * @constructor
   *
   * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
   * @param {Instance} instance
   */
  function ImageWebGLDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }

  scenery.register( 'ImageWebGLDrawable', ImageWebGLDrawable );

  inherit( WebGLSelfDrawable, ImageWebGLDrawable, {
    // TODO: doc
    webglRenderer: Renderer.webglTexturedTriangles,

    /**
     * Initializes this drawable, starting its "lifetime" until it is disposed. This lifecycle can happen multiple
     * times, with instances generally created by the SelfDrawable.Poolable mixin (dirtyFromPool/createFromPool), and
     * disposal will return this drawable to the pool.
     * @public (scenery-internal)
     *
     * This acts as a pseudo-constructor that can be called multiple times, and effectively creates/resets the state
     * of the drawable to the initial state.
     *
     * @param {number} renderer - Renderer bitmask, see Renderer's documentation for more details.
     * @param {Instance} instance
     * @returns {ImageWebGLDrawable} - Self reference for chaining
     */
    initialize: function( renderer, instance ) {
      this.initializeWebGLSelfDrawable( renderer, instance );

      if ( !this.vertexArray ) {
        // for 6 vertices
        this.vertexArray = new Float32Array( WEBGL_COMPONENTS * 6 ); // 5-length components for 6 vertices (2 tris).
      }

      // corner vertices in the relative transform root coordinate space
      this.upperLeft = new Vector2();
      this.lowerLeft = new Vector2();
      this.upperRight = new Vector2();
      this.lowerRight = new Vector2();

      this.xyDirty = true; // is our vertex position information out of date?
      this.uvDirty = true; // is our UV information out of date?
      this.updatedOnce = false;

      // {SpriteSheet.Sprite} exported for WebGLBlock's rendering loop
      this.sprite = null;

      return this;
    },

    onAddToBlock: function( webglBlock ) {
      this.webglBlock = webglBlock; // TODO: do we need this reference?
      this.markDirty();

      this.reserveSprite();
    },

    onRemoveFromBlock: function( webglBlock ) {
      this.unreserveSprite();
    },

    reserveSprite: function() {
      if ( this.sprite ) {
        // if we already reserved a sprite for the image, bail out
        if ( this.sprite.image === this.node._image ) {
          return;
        }
        // otherwise we need to ditch our last reservation before reserving a new sprite
        else {
          this.unreserveSprite();
        }
      }

      // if the width/height isn't loaded yet, we can still use the desired value
      var width = this.node.getImageWidth();
      var height = this.node.getImageHeight();

      // if we have a width/height, we'll load a sprite
      this.sprite = ( width > 0 && height > 0 ) ? this.webglBlock.addSpriteSheetImage( this.node._image, width, height ) : null;

      // full updates on everything if our sprite changes
      this.xyDirty = true;
      this.uvDirty = true;
    },

    unreserveSprite: function() {
      if ( this.sprite ) {
        this.webglBlock.removeSpriteSheetImage( this.sprite );
      }
      this.sprite = null;
    },

    // @override
    markTransformDirty: function() {
      this.xyDirty = true;

      WebGLSelfDrawable.prototype.markTransformDirty.call( this );
    },

    /**
     * A "catch-all" dirty method that directly marks the paintDirty flag and triggers propagation of dirty
     * information. This can be used by other mark* methods, or directly itself if the paintDirty flag is checked.
     * @public (scenery-internal)
     *
     * It should be fired (indirectly or directly) for anything besides transforms that needs to make a drawable
     * dirty.
     */
    markPaintDirty: function() {
      this.xyDirty = true; // vertex positions can depend on image width/height
      this.uvDirty = true;

      this.markDirty();
    },

    update: function() {
      if ( this.dirty ) {
        this.dirty = false;

        // ensure that we have a reserved sprite (part of the spritesheet)
        this.reserveSprite();

        if ( this.dirtyImageOpacity || !this.updatedOnce ) {
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
        }
        this.updatedOnce = true;

        // if we don't have a sprite (we don't have a loaded image yet), just bail
        if ( !this.sprite ) {
          return;
        }

        if ( this.uvDirty ) {
          this.uvDirty = false;

          var uvBounds = this.sprite.uvBounds;

          // TODO: consider reversal of minY and maxY usage here for vertical inverse

          // first triangle UVs
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_U_OFFSET ] = uvBounds.minX; // upper left U
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_V_OFFSET ] = uvBounds.minY; // upper left V
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_U_OFFSET ] = uvBounds.minX; // lower left U
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_V_OFFSET ] = uvBounds.maxY; // lower left V
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_U_OFFSET ] = uvBounds.maxX; // upper right U
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_V_OFFSET ] = uvBounds.minY; // upper right V

          // second triangle UVs
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_U_OFFSET ] = uvBounds.maxX; // upper right U
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_V_OFFSET ] = uvBounds.minY; // upper right V
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_U_OFFSET ] = uvBounds.minX; // lower left U
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_V_OFFSET ] = uvBounds.maxY; // lower left V
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_U_OFFSET ] = uvBounds.maxX; // lower right U
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_V_OFFSET ] = uvBounds.maxY; // lower right V
        }

        if ( this.xyDirty ) {
          this.xyDirty = false;

          var width = this.node.getImageWidth();
          var height = this.node.getImageHeight();

          var transformMatrix = this.instance.relativeTransform.matrix; // with compute need, should always be accurate
          transformMatrix.multiplyVector2( this.upperLeft.setXY( 0, 0 ) );
          transformMatrix.multiplyVector2( this.lowerLeft.setXY( 0, height ) );
          transformMatrix.multiplyVector2( this.upperRight.setXY( width, 0 ) );
          transformMatrix.multiplyVector2( this.lowerRight.setXY( width, height ) );

          // first triangle XYs
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_X_OFFSET ] = this.upperLeft.x;
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_Y_OFFSET ] = this.upperLeft.y;
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_X_OFFSET ] = this.lowerLeft.x;
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_Y_OFFSET ] = this.lowerLeft.y;
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_X_OFFSET ] = this.upperRight.x;
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_Y_OFFSET ] = this.upperRight.y;

          // second triangle XYs
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_X_OFFSET ] = this.upperRight.x;
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_Y_OFFSET ] = this.upperRight.y;
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_X_OFFSET ] = this.lowerLeft.x;
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_Y_OFFSET ] = this.lowerLeft.y;
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_X_OFFSET ] = this.lowerRight.x;
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_Y_OFFSET ] = this.lowerRight.y;
        }
      }
    },

    /**
     * Disposes the drawable.
     * @public
     * @override
     */
    dispose: function() {
      // TODO: disposal of buffers?

      // super
      WebGLSelfDrawable.prototype.dispose.call( this );
    }
  } );
  ImageStatefulDrawable.mixin( ImageWebGLDrawable );
  // This sets up ImageWebGLDrawable.createFromPool/dirtyFromPool and drawable.freeToPool() for the type, so
  // that we can avoid allocations by reusing previously-used drawables.
  SelfDrawable.Poolable.mixin( ImageWebGLDrawable );

  return ImageWebGLDrawable;
} );

// Copyright 2013-2016, University of Colorado Boulder

/**
 * A node that displays a single image either from an actual HTMLImageElement, a URL, a Canvas element, or a mipmap
 * data structure described in the constructor.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

define( 'SCENERY/nodes/Image',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','PHET_CORE/cleanArray','DOT/Bounds2','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/util/SpriteSheet','SCENERY/display/drawables/ImageCanvasDrawable','SCENERY/display/drawables/ImageDOMDrawable','SCENERY/display/drawables/ImageSVGDrawable','SCENERY/display/drawables/ImageWebGLDrawable'],function( require ) {
  'use strict';

  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var SpriteSheet = require( 'SCENERY/util/SpriteSheet' );
  var ImageCanvasDrawable = require( 'SCENERY/display/drawables/ImageCanvasDrawable' );
  var ImageDOMDrawable = require( 'SCENERY/display/drawables/ImageDOMDrawable' );
  var ImageSVGDrawable = require( 'SCENERY/display/drawables/ImageSVGDrawable' );
  var ImageWebGLDrawable = require( 'SCENERY/display/drawables/ImageWebGLDrawable' );

  // Need to poly-fill on some browsers
  var log2 = Math.log2 || function( x ) { return Math.log( x ) / Math.LN2; };

  // Image-specific options that can be passed in the constructor or mutate() call.
  var IMAGE_OPTION_KEYS = [
    'image', // Changes the image displayed, see setImage() for documentation
    'imageOpacity', // Controls opacity of this image (and not children), see setImageOpacity() for documentation
    'initialWidth', // Width of an image not-yet loaded (for layout), see setInitialWidth() for documentation
    'initialHeight', // Height of an image not-yet loaded (for layout), see setInitialHeight() for documentation
    'mipmap', // Whether mipmapped output is supported, see setMipmap() for documentation
    'mipmapBias', // Whether mipmapping tends towards sharp/aliased or blurry, see setMipmapBias() for documentation
    'mipmapInitialLevel', // How many mipmap levels to generate if needed, see setMipmapInitialLevel() for documentation
    'mipmapMaxLevel' // The maximum mipmap level to compute if needed, see setMipmapMaxLevel() for documentation
  ];

  var DEFAULT_OPTIONS = {
    imageOpacity: 1,
    initialWidth: 0,
    initialHeight: 0,
    mipmap: false,
    mipmapBias: 0,
    mipmapInitialLevel: 4,
    mipmapMaxLevel: 5
  };

  /**
   * Constructs an Image node from a particular source.
   * @public
   * @constructor
   * @extends Node
   *
   * IMAGE_OPTION_KEYS (above) describes the available options keys that can be provided, on top of Node's options.
   *
   * @param {string|HTMLImageElement|HTMLCanvasElement|Array} image - See setImage() for details.
   * @param {Object} [options] - Image-specific options are documented in IMAGE_OPTION_KEYS above, and can be provided
   *                             along-side options for Node
   */
  function Image( image, options ) {
    assert && assert( image, 'image should be available' );
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );

    // @private {number} - Internal stateful value, see setInitialWidth() for documentation.
    this._initialWidth = DEFAULT_OPTIONS.initialWidth;

    // @private {number} - Internal stateful value, see setInitialHeight() for documentation.
    this._initialHeight = DEFAULT_OPTIONS.initialHeight;

    // @private {number} - Internal stateful value, see setImageOpacity() for documentation.
    this._imageOpacity = DEFAULT_OPTIONS.imageOpacity;

    // @private {boolean} - Internal stateful value, see setMipmap() for documentation.
    this._mipmap = DEFAULT_OPTIONS.mipmap;

    // @private {number} - Internal stateful value, see setMipmapBias() for documentation.
    this._mipmapBias = DEFAULT_OPTIONS.mipmapBias;

    // @private {number} - Internal stateful value, see setMipmapInitialLevel() for documentation.
    this._mipmapInitialLevel = DEFAULT_OPTIONS.mipmapInitialLevel;

    // @private {number} - Internal stateful value, see setMipmapMaxLevel() for documentation
    this._mipmapMaxLevel = DEFAULT_OPTIONS.mipmapMaxLevel;

    // @private {Array.<HTMLCanvasElement>} - Array of Canvases for each level, constructed internally so that
    //                                        Canvas-based drawables (Canvas, WebGL) can quickly draw mipmaps.
    this._mipmapCanvases = [];

    // @private {Array.<String>} - Array of URLs for each level, where each URL will display an image (and is typically
    //                             a data URI or blob URI), so that we can handle mipmaps in SVG where URLs are
    //                             required.
    this._mipmapURLs = [];

    // @private {Array|null} - Mipmap data if it is passed into our image. Will be stored here for processing
    this._mipmapData = null;

    // @private {function} - Listener for invalidating our bounds whenever an image is invalidated.
    this._imageLoadListener = this.onImageLoad.bind( this );

    // @private {boolean} - Whether our _imageLoadListener has been attached as a listener to the current image.
    this._imageLoadListenerAttached = false;

    // rely on the setImage call from the super constructor to do the setup
    options = extendDefined( {
      image: image
    }, options );

    Node.call( this, options );

    this.invalidateSupportedRenderers();
  }

  scenery.register( 'Image', Image );

  inherit( Node, Image, {
    /**
     * {Array.<string>} - String keys for all of the allowed options that will be set by node.mutate( options ), in the
     * order they will be evaluated in.
     * @protected
     *
     * NOTE: See Node's _mutatorKeys documentation for more information on how this operates, and potential special
     *       cases that may apply.
     */
    _mutatorKeys: IMAGE_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),

    /**
     * {Array.<String>} - List of all dirty flags that should be available on drawables created from this node (or
     *                    subtype). Given a flag (e.g. radius), it indicates the existence of a function
     *                    drawable.markDirtyRadius() that will indicate to the drawable that the radius has changed.
     * @public (scenery-internal)
     * @override
     */
    drawableMarkFlags: Node.prototype.drawableMarkFlags.concat( [ 'image', 'imageOpacity', 'mipmap' ] ),

    /**
     * Sets the current image to be displayed by this Image node.
     * @public
     *
     * We support a few different 'image' types that can be passed in:
     *
     * HTMLImageElement - A normal HTML <img>. If it hasn't been fully loaded yet, Scenery will take care of adding a
     *   listener that will update Scenery with its width/height (and load its data) when the image is fully loaded.
     *   NOTE that if you just created the <img>, it probably isn't loaded yet, particularly in Safari. If the Image
     *   node is constructed with an <img> that hasn't fully loaded, it will have a width and height of 0, which may
     *   cause issues if you are using bounds for layout. Please see initialWidth/initialHeight notes below.
     *
     * URL - Provide a {string}, and Scenery will assume it is a URL. This can be a normal URL, or a data URI, both will
     *   work. Please note that this has the same loading-order issues as using HTMLImageElement, but that it's almost
     *   always guaranteed to not have a width/height when you create the Image node. Note that data URI support for
     *   formats depends on the browser - only JPEG and PNG are supported broadly. Please see initialWidth/initialHeight
     *   notes below.
     *   Additionally, note that if a URL is provided, accessing image.getImage() or image.image will result not in the
     *   original URL (currently), but with the automatically created HTMLImageElement.
     *   TODO: return the original input
     *
     * HTMLCanvasElement - It's possible to pass an HTML5 Canvas directly into the Image node. It will immediately be
     *   aware of the width/height (bounds) of the Canvas, but NOTE that the Image node will not listen to Canvas size
     *   changes. It is assumed that after you pass in a Canvas to an Image node that it will not be modified further.
     *   Additionally, the Image node will only be rendered using Canvas or WebGL if a Canvas is used as input.
     *
     * Mipmap data structure - Image supports a mipmap data structure that provides rasterized mipmap levels. The 'top'
     *   level (level 0) is the entire full-size image, and every other level is twice as small in every direction
     *   (~1/4 the pixels), rounding dimensions up. This is useful for browsers that display the image badly if the
     *   image is too large. Instead, Scenery will dynamically pick the most appropriate size of the image to use,
     *   which improves the image appearance.
     *   The passed in 'image' should be an Array of mipmap objects of the format:
     *   {
     *     img: {HTMLImageElement}, // preferably preloaded, but it isn't required
     *     url: {string}, // URL (usually a data URL) for the image level
     *     width: {number}, // width of the mipmap level, in pixels
     *     height: {number} // height of the mipmap level, in pixels,
     *     canvas: {HTMLCanvasElement} // Canvas element containing the image data for the img.
     *     [updateCanvas]: {function} // If available, should be called before using the Canvas directly.
     *   }
     *   At least one level is required (level 0), and each mipmap level corresponds to the index in the array, e.g.:
     *   [
     *     level 0 (full size, e.g. 100x64)
     *     level 1 (half size, e.g. 50x32)
     *     level 2 (quarter size, e.g. 25x16)
     *     level 3 (eighth size, e.g. 13x8 - note the rounding up)
     *     ...
     *     level N (single pixel, e.g. 1x1 - this is the smallest level permitted, and there should only be one)
     *   ]
     *   Additionally, note that (currently) image.getImage() will return the HTMLImageElement from the first level,
     *   not the mipmap data.
     *   TODO: return the original input
     *
     *  Also note that if the underlying image (like Canvas data) has changed, it is recommended to call
     *  invalidateImage() instead of changing the image reference (calling setImage() multiple times)
     *
     * @param {string|HTMLImageElement|HTMLCanvasElement|Array} image - See documentation above
     * @returns {Image} - Self reference for chaining
     */
    setImage: function( image ) {
      assert && assert( image, 'image should be available' );
      assert && assert( typeof image === 'string' ||
                        image instanceof HTMLImageElement ||
                        image instanceof HTMLCanvasElement ||
                        image instanceof Array, 'image is not of the correct type' );

      // Generally, if a different value for image is provided, it has changed
      var hasImageChanged = this._image !== image;

      // Except in some cases, where the provided image is a string
      if ( hasImageChanged && typeof image === 'string' ) {

        // If our current image has the same .src as the "new" image, it's basically the same (as we promote string
        // images to HTMLImageElements).
        if ( this._image && image === this._image.src ) {
          hasImageChanged = false;
        }

        // If our current mipmap data is the same as the input, then we aren't changing it
        if ( image === this._mipmapData ) {
          hasImageChanged = false;
        }
      }

      if ( hasImageChanged ) {
        // Reset the initial dimensions, since we have a new image that may have different dimensions.
        this._initialWidth = 0;
        this._initialHeight = 0;

        // Don't leak memory by referencing old images
        if ( this._image && this._imageLoadListenerAttached ) {
          this.detachImageLoadListener();
        }

        // clear old mipmap data references
        this._mipmapData = null;

        // Convert string => HTMLImageElement
        if ( typeof image === 'string' ) {
          // create an image with the assumed URL
          var src = image;
          image = document.createElement( 'img' );
          image.src = src;
        }
        // Handle the provided mipmap
        else if ( image instanceof Array ) {
          // mipmap data!
          this._mipmapData = image;
          image = image[ 0 ].img; // presumes we are already loaded

          // force initialization of mipmapping parameters, since invalidateMipmaps() is guaranteed to run below
          this._mipmapInitialLevel = this._mipmapMaxLevel = this._mipmapData.length;
          this._mipmap = true;
        }

        this._image = image;

        // If our image is an HTML image that hasn't loaded yet, attach a load listener.
        if ( this._image instanceof HTMLImageElement && ( !this._image.width || !this._image.height ) ) {
          this.attachImageLoadListener();
        }

        // Try recomputing bounds (may give a 0x0 if we aren't yet loaded)
        this.invalidateImage();
      }
      return this;
    },
    set image( value ) { this.setImage( value ); },

    /**
     * Returns the current image's representation as either a Canvas or img element.
     * @public
     *
     * NOTE: If a URL or mipmap data was provided, this currently doesn't return the original input to setImage(), but
     *       instead provides the mapped result (or first mipmap level's image).
     *       TODO: return the original result instead.
     *
     * @returns {HTMLImageElement|HTMLCanvasElement}
     */
    getImage: function() {
      return this._image;
    },
    get image() { return this.getImage(); },

    /**
     * Triggers recomputation of the image's bounds and refreshes any displays output of the image.
     * @public
     *
     * Generally this can trigger recomputation of mipmaps, will mark any drawables as needing repaints, and will
     * cause a spritesheet change for WebGL.
     *
     * This should be done when the underlying image has changed appearance (usually the case with a Canvas changing,
     * but this is also triggered by our actual image reference changing).
     */
    invalidateImage: function() {
      if ( this._image ) {
        this.invalidateSelf( new Bounds2( 0, 0, this.getImageWidth(), this.getImageHeight() ) );
      }
      else {
        this.invalidateSelf( Bounds2.NOTHING );
      }

      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyImage();
      }

      this.invalidateMipmaps();
      this.invalidateSupportedRenderers();
    },

    /**
     * Recomputes what renderers are supported, given the current image information.
     * @private
     */
    invalidateSupportedRenderers: function() {

      // Canvas is always permitted
      var r = Renderer.bitmaskCanvas;

      // If it fits within the sprite sheet, then WebGL is also permitted
      // If the image hasn't loaded, the getImageWidth/Height will be 0 and this rule would pass.  However, this
      // function will be called again after the image loads, and would correctly invalidate WebGL, if too large to fit
      // in a SpriteSheet
      var fitsWithinSpriteSheet = this.getImageWidth() <= SpriteSheet.MAX_DIMENSION.width &&
                                  this.getImageHeight() <= SpriteSheet.MAX_DIMENSION.height;
      if ( fitsWithinSpriteSheet ) {
        r |= Renderer.bitmaskWebGL;
      }

      // If it is not a canvas, then it can additionally be rendered in SVG or DOM
      if ( !( this._image instanceof HTMLCanvasElement ) ) {
        // assumes HTMLImageElement
        r |= Renderer.bitmaskSVG | Renderer.bitmaskDOM;
      }

      this.setRendererBitmask( r );
    },

    /**
     * Sets the image with additional information about dimensions used before the image has loaded.
     * @public
     *
     * This is essentially the same as setImage(), but also updates the initial dimensions. See setImage()'s
     * documentation for details on the image parameter.
     *
     * NOTE: setImage() will first reset the initial dimensions to 0, which will then be overridden later in this
     *       function. This may trigger bounds changes, even if the previous and next image (and image dimensions)
     *       are the same.
     *
     * @param {string|HTMLImageElement|HTMLCanvasElement|Array} image - See setImage()'s documentation
     * @param {number} width - Initial width of the image. See setInitialWidth() for more documentation
     * @param {number} height - Initial height of the image. See setInitialHeight() for more documentation
     * @returns {Image} - For chaining
     */
    setImageWithSize: function( image, width, height ) {
      // First, setImage(), as it will reset the initial width and height
      this.setImage( image );

      // Then apply the initial dimensions
      this.setInitialWidth( width );
      this.setInitialHeight( height );

      return this;
    },

    /**
     * Sets an opacity that is applied only to this image (will not affect children or the rest of the node's subtree).
     * @public
     *
     * This should generally be preferred over Node's opacity if it has the same result, as modifying this will be much
     * faster, and will not force additional Canvases or intermediate steps in display.
     *
     * @param {number} imageOpacity - Should be a number between 0 (transparent) and 1 (opaque), just like normal
     *                                opacity.
     */
    setImageOpacity: function( imageOpacity ) {
      assert && assert( typeof imageOpacity === 'number', 'imageOpacity was not a number' );
      assert && assert( isFinite( imageOpacity ) && imageOpacity >= 0 && imageOpacity <= 1,
        'imageOpacity out of range: ' + imageOpacity );

      if ( this._imageOpacity !== imageOpacity ) {
        this._imageOpacity = imageOpacity;

        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyImageOpacity();
        }
      }
    },
    set imageOpacity( value ) { this.setImageOpacity( value ); },

    /**
     * Returns the opacity applied only to this image (not including children).
     * @public
     *
     * See setImageOpacity() documentation for more information.
     *
     * @returns {number}
     */
    getImageOpacity: function() {
      return this._imageOpacity;
    },
    get imageOpacity() { return this.getImageOpacity(); },

    /**
     * Provides an initial width for an image that has not loaded yet.
     * @public
     *
     * If the input image hasn't loaded yet, but the (expected) size is known, providing an initialWidth will cause the
     * Image node to have the correct bounds (width) before the pixel data has been fully loaded. A value of 0 will be
     * ignored.
     *
     * This is required for many browsers, as images can show up as a 0x0 (like Safari does for unloaded images).
     *
     * NOTE: setImage will reset this value to 0 (ignored), since it's potentially likely the new image has different
     *       dimensions than the current image.
     *
     * NOTE: If these dimensions end up being different than the actual image width/height once it has been loaded, an
     *       assertion will fail. Only the correct dimensions should be provided. If the width/height is unknown,
     *       please use the localBounds override or a transparent rectangle for taking up the (approximate) bounds.
     *
     * @param {number} width - Expected width of the image's unloaded content
     * @returns {Image} - For chaining
     */
    setInitialWidth: function( width ) {
      assert && assert( typeof width === 'number' &&
                        width >= 0 &&
                        ( width % 1 === 0 ), 'initialWidth should be a non-negative integer' );
      if ( width !== this._initialWidth ) {
        this._initialWidth = width;

        this.invalidateImage();
      }

      return this;
    },
    set initialWidth( value ) { this.setInitialWidth( value ); },

    /**
     * Returns the initialWidth value set from setInitialWidth().
     * @public
     *
     * See setInitialWidth() for more documentation. A value of 0 is ignored.
     *
     * @returns {number}
     */
    getInitialWidth: function() {
      return this._initialWidth;
    },
    get initialWidth() { return this.getInitialWidth(); },

    /**
     * Provides an initial height for an image that has not loaded yet.
     * @public
     *
     * If the input image hasn't loaded yet, but the (expected) size is known, providing an initialWidth will cause the
     * Image node to have the correct bounds (height) before the pixel data has been fully loaded. A value of 0 will be
     * ignored.
     *
     * This is required for many browsers, as images can show up as a 0x0 (like Safari does for unloaded images).
     *
     * NOTE: setImage will reset this value to 0 (ignored), since it's potentially likely the new image has different
     *       dimensions than the current image.
     *
     * NOTE: If these dimensions end up being different than the actual image width/height once it has been loaded, an
     *       assertion will fail. Only the correct dimensions should be provided. If the width/height is unknown,
     *       please use the localBounds override or a transparent rectangle for taking up the (approximate) bounds.
     *
     * @param {number} height - Expected height of the image's unloaded content
     * @returns {Image} - For chaining
     */
    setInitialHeight: function( height ) {
      assert && assert( typeof height === 'number' &&
                        height >= 0 &&
                        ( height % 1 === 0 ), 'initialHeight should be a non-negative integer' );
      if ( height !== this._initialHeight ) {
        this._initialHeight = height;

        this.invalidateImage();
      }

      return this;
    },
    set initialHeight( value ) { this.setInitialHeight( value ); },

    /**
     * Returns the initialHeight value set from setInitialHeight().
     * @public
     *
     * See setInitialHeight() for more documentation. A value of 0 is ignored.
     *
     * @returns {number}
     */
    getInitialHeight: function() {
      return this._initialHeight;
    },
    get initialHeight() { return this.getInitialHeight(); },

    /**
     * Sets whether mipmapping is supported.
     * @public
     *
     * This defaults to false, but is automatically set to true when a mipmap is provided to setImage(). Setting it to
     * true on non-mipmap images will trigger creation of a medium-quality mipmap that will be used.
     *
     * NOTE: This mipmap generation is slow and CPU-intensive. Providing precomputed mipmap resources to an Image node
     *       will be much faster, and of higher quality.
     *
     * @param {boolean} mipmap - Whether mipmapping is supported
     * @returns {Image} - For chaining
     */
    setMipmap: function( mipmap ) {
      assert && assert( typeof mipmap === 'boolean' );

      if ( this._mipmap !== mipmap ) {
        this._mipmap = mipmap;

        this.invalidateMipmaps();
      }

      return this;
    },
    set mipmap( value ) { this.setMipmap( value ); },

    /**
     * Returns whether mipmapping is supported.
     * @public
     *
     * See setMipmap() for more documentation.
     *
     * @returns {boolean}
     */
    isMipmap: function() {
      return this._mipmap;
    },
    get mipmap() { return this.isMipmap(); },

    /**
     * Sets how much level-of-detail is displayed for mipmapping.
     * @public
     *
     * When displaying mipmapped images as output, a certain source level of the mipmap needs to be used. Using a level
     * with too much resolution can create an aliased look (but will generally be sharper). Using a level with too
     * little resolution will be blurrier (but not aliased).
     *
     * The value of the mipmap bias is added on to the computed "ideal" mipmap level, and:
     * - A negative bias will typically increase the displayed resolution
     * - A positive bias will typically decrease the displayed resolution
     *
     * This is done approximately like the following formula:
     *   mipmapLevel = Math.round( computedMipmapLevel + mipmapBias )
     *
     * @param bias
     * @returns {Image} - For chaining
     */
    setMipmapBias: function( bias ) {
      assert && assert( typeof bias === 'number' );

      if ( this._mipmapBias !== bias ) {
        this._mipmapBias = bias;

        this.invalidateMipmaps();
      }

      return this;
    },
    set mipmapBias( value ) { this.setMipmapBias( value ); },

    /**
     * Returns the current mipmap bias.
     * @public
     *
     * See setMipmapBias() for more documentation.
     *
     * @returns {number}
     */
    getMipmapBias: function() {
      return this._mipmapBias;
    },
    get mipmapBias() { return this.getMipmapBias(); },

    /**
     * The number of initial mipmap levels to compute (if Scenery generates the mipmaps by setting mipmap:true on a
     * non-mipmapped input).
     * @public
     *
     * @param {number} level - A non-negative integer representing the number of mipmap levels to precompute.
     * @returns {Image} - For chaining
     */
    setMipmapInitialLevel: function( level ) {
      assert && assert( typeof level === 'number' && level % 1 === 0 && level >= 0,
        'mipmapInitialLevel should be a non-negative integer' );

      if ( this._mipmapInitialLevel !== level ) {
        this._mipmapInitialLevel = level;

        this.invalidateMipmaps();
      }

      return this;
    },
    set mipmapInitialLevel( value ) { this.setMipmapInitialLevel( value ); },

    /**
     * Returns the current initial mipmap level.
     * @public
     *
     * See setMipmapInitialLevel() for more documentation.
     *
     * @returns {number}
     */
    getMipmapInitialLevel: function() {
      return this._mipmapInitialLevel;
    },
    get mipmapInitialLevel() { return this.getMipmapInitialLevel(); },

    /**
     * The maximum (lowest-resolution) level that Scenery will compute if it generates mipmaps (e.g. by setting
     * mipmap:true on a non-mipmapped input).
     * @public
     *
     * The default will precompute all default levels (from mipmapInitialLevel), so that we ideally don't hit mipmap
     * generation during animation.
     *
     * @param {number} level - A non-negative integer representing the maximum mipmap level to compute.
     * @returns {Image} - for Chaining
     */
    setMipmapMaxLevel: function( level ) {
      assert && assert( typeof level === 'number' && level % 1 === 0 && level >= 0,
        'mipmapMaxLevel should be a non-negative integer' );

      if ( this._mipmapMaxLevel !== level ) {
        this._mipmapMaxLevel = level;

        this.invalidateMipmaps();
      }

      return this;
    },
    set mipmapMaxLevel( value ) { this.setMipmapMaxLevel( value ); },

    /**
     * Returns the current maximum mipmap level.
     * @public
     *
     * See setMipmapMaxLevel() for more documentation.
     *
     * @returns {number}
     */
    getMipmapMaxLevel: function() {
      return this._mipmapMaxLevel;
    },
    get mipmapMaxLevel() { return this.getMipmapMaxLevel(); },

    /**
     * Constructs the next available (uncomputed) mipmap level, as long as the previous level was larger than 1x1.
     * @private
     */
    constructNextMipmap: function() {
      var level = this._mipmapCanvases.length;
      var biggerCanvas = this._mipmapCanvases[ level - 1 ];

      // ignore any 1x1 canvases (or smaller?!?)
      if ( biggerCanvas.width * biggerCanvas.height > 2 ) {
        var canvas = document.createElement( 'canvas' );
        canvas.width = Math.ceil( biggerCanvas.width / 2 );
        canvas.height = Math.ceil( biggerCanvas.height / 2 );

        // sanity check
        if ( canvas.width > 0 && canvas.height > 0 ) {
          // Draw half-scale into the smaller Canvas
          var context = canvas.getContext( '2d' );
          context.scale( 0.5, 0.5 );
          context.drawImage( biggerCanvas, 0, 0 );

          this._mipmapCanvases.push( canvas );
          this._mipmapURLs.push( canvas.toDataURL() );
        }
      }
    },

    /**
     * Triggers recomputation of mipmaps (as long as mipmapping is enabled)
     * @private
     */
    invalidateMipmaps: function() {
      // Clean output arrays
      cleanArray( this._mipmapCanvases );
      cleanArray( this._mipmapURLs );

      if ( this._image && this._mipmap ) {
        // If we have mipmap data as an input
        if ( this._mipmapData ) {
          for ( var k = 0; k < this._mipmapData.length; k++ ) {
            var url = this._mipmapData[ k ].url;
            this._mipmapURLs.push( url );
            this._mipmapData[ k ].updateCanvas && this._mipmapData[ k ].updateCanvas();
            this._mipmapCanvases.push( this._mipmapData[ k ].canvas );
          }
        }
        // Otherwise, we have an image (not mipmap) as our input, so we'll need to construct mipmap levels.
        else {
          var baseCanvas = document.createElement( 'canvas' );
          baseCanvas.width = this.getImageWidth();
          baseCanvas.height = this.getImageHeight();

          // if we are not loaded yet, just ignore
          if ( baseCanvas.width && baseCanvas.height ) {
            var baseContext = baseCanvas.getContext( '2d' );
            baseContext.drawImage( this._image, 0, 0 );

            this._mipmapCanvases.push( baseCanvas );
            this._mipmapURLs.push( baseCanvas.toDataURL() );

            var level = 0;
            while ( ++level < this._mipmapInitialLevel ) {
              this.constructNextMipmap();
            }
          }

          var stateLen = this._drawables.length;
          for ( var i = 0; i < stateLen; i++ ) {
            this._drawables[ i ].markDirtyMipmap();
          }
        }
      }

      this.trigger0( 'mipmap' );
    },

    /**
     * Returns the desired mipmap level (0-indexed) that should be used for the particular relative transform.
     * @public (scenery-internal)
     *
     * @param {Matrix3} matrix - The relative transformation matrix of the node.
     */
    getMipmapLevel: function( matrix ) {
      assert && assert( this._mipmap, 'Assumes mipmaps can be used' );

      // a sense of "average" scale, which should be exact if there is no asymmetric scale/shear applied
      var scale = ( Math.sqrt( matrix.m00() * matrix.m00() + matrix.m10() * matrix.m10() ) +
                    Math.sqrt( matrix.m01() * matrix.m01() + matrix.m11() * matrix.m11() ) ) / 2;
      scale *= ( window.devicePixelRatio || 1 ); // for retina-like devices

      assert && assert( typeof scale === 'number' && scale > 0, 'scale should be a positive number' );

      // If we are shown larger than scale, ALWAYS choose the highest resolution
      if ( scale >= 1 ) {
        return 0;
      }

      var level = log2( 1 / scale ); // our approximate level of detail
      level = Math.round( level + this._mipmapBias - 0.7 ); // convert to an integer level (-0.7 is a good default)

      if ( level < 0 ) {
        level = 0;
      }
      if ( level > this._mipmapMaxLevel ) {
        level = this._mipmapMaxLevel;
      }

      // If necessary, do lazy construction of the mipmap level
      if ( this.mipmap && !this._mipmapCanvases[ level ] ) {
        var currentLevel = this._mipmapCanvases.length - 1;
        while ( ++currentLevel <= level ) {
          this.constructNextMipmap();
        }
        // Sanity check, since constructNextMipmap() may have had to bail out. We had to compute some, so use the last
        return Math.min( level, this._mipmapCanvases.length - 1 );
      }
      // Should already be constructed, or isn't needed
      else {
        return level;
      }
    },

    /**
     * Returns a matching Canvas element for the given level-of-detail.
     * @public (scenery-internal)
     *
     * @param {number} level - Non-negative integer representing the mipmap level
     * @returns {HTMLCanvasElement} - Matching <canvas> for the level of detail
     */
    getMipmapCanvas: function( level ) {
      assert && assert( typeof level === 'number' &&
                        level >= 0 &&
                        level < this._mipmapCanvases.length &&
                        ( level % 1 ) === 0 );

      // Sanity check to make sure we have copied the image data in if necessary.
      if ( this._mipmapData ) {
        // level may not exist (it was generated), and updateCanvas may not exist
        this._mipmapData[ level ] && this._mipmapData[ level ].updateCanvas && this._mipmapData[ level ].updateCanvas();
      }
      return this._mipmapCanvases[ level ];
    },

    /**
     * Returns a matching URL string for an image for the given level-of-detail.
     * @public (scenery-internal)
     *
     * @param {number} level - Non-negative integer representing the mipmap level
     * @returns {string} - Matching data URL for the level of detail
     */
    getMipmapURL: function( level ) {
      assert && assert( typeof level === 'number' &&
                        level >= 0 &&
                        level < this._mipmapCanvases.length &&
                        ( level % 1 ) === 0 );

      return this._mipmapURLs[ level ];
    },

    /**
     * Returns whether there are mipmap levels that have been computed.
     * @public (scenery-internal)
     *
     * @returns {boolean}
     */
    hasMipmaps: function() {
      return this._mipmapCanvases.length > 0;
    },

    /**
     * Returns the width of the displayed image (not related to how this node is transformed).
     * @public
     *
     * NOTE: If the image is not loaded and an initialWidth was provided, that width will be used.
     *
     * @returns {number}
     */
    getImageWidth: function() {
      var detectedWidth = this._mipmapData ? this._mipmapData[ 0 ].width : ( this._image.naturalWidth || this._image.width );
      if ( detectedWidth === 0 ) {
        return this._initialWidth; // either 0 (default), or the overridden value
      }
      else {
        assert && assert( this._initialWidth === 0 || this._initialWidth === detectedWidth, 'Bad Image.initialWidth' );

        return detectedWidth;
      }
    },
    get imageWidth() { return this.getImageWidth(); },

    /**
     * Returns the height of the displayed image (not related to how this node is transformed).
     * @public
     *
     * NOTE: If the image is not loaded and an initialHeight was provided, that height will be used.
     *
     * @returns {number}
     */
    getImageHeight: function() {
      var detectedHeight = this._mipmapData ? this._mipmapData[ 0 ].height : ( this._image.naturalHeight || this._image.height );
      if ( detectedHeight === 0 ) {
        return this._initialHeight; // either 0 (default), or the overridden value
      }
      else {
        assert && assert( this._initialHeight === 0 || this._initialHeight === detectedHeight, 'Bad Image.initialHeight' );

        return detectedHeight;
      }
    },
    get imageHeight() { return this.getImageHeight(); },

    /**
     * If our provided image is an HTMLImageElement, returns its URL (src).
     * @public (scenery-internal)
     *
     * @returns {string}
     */
    getImageURL: function() {
      assert && assert( this._image instanceof HTMLImageElement, 'Only supported for HTML image elements' );

      return this._image.src;
    },

    /**
     * Whether this Node itself is painted (displays something itself).
     * @public
     * @override
     *
     * @returns {boolean}
     */
    isPainted: function() {
      // Always true for Image nodes
      return true;
    },

    /**
     * Draws the current Node's self representation, assuming the wrapper's Canvas context is already in the local
     * coordinate frame of this node.
     * @protected
     * @override
     *
     * @param {CanvasContextWrapper} wrapper
     * @param {Matrix3} matrix - The transformation matrix already applied to the context.
     */
    canvasPaintSelf: function( wrapper, matrix ) {
      //TODO: Have a separate method for this, instead of touching the prototype. Can make 'this' references too easily.
      ImageCanvasDrawable.prototype.paintCanvas( wrapper, this, matrix );
    },

    /**
     * Creates a DOM drawable for this Image.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {DOMSelfDrawable}
     */
    createDOMDrawable: function( renderer, instance ) {
      return ImageDOMDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a SVG drawable for this Image.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {SVGSelfDrawable}
     */
    createSVGDrawable: function( renderer, instance ) {
      return ImageSVGDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a Canvas drawable for this Image.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {CanvasSelfDrawable}
     */
    createCanvasDrawable: function( renderer, instance ) {
      return ImageCanvasDrawable.createFromPool( renderer, instance );
    },

    /**
     * Creates a WebGL drawable for this Image.
     * @public (scenery-internal)
     * @override
     *
     * @param {number} renderer - In the bitmask format specified by Renderer, which may contain additional bit flags.
     * @param {Instance} instance - Instance object that will be associated with the drawable
     * @returns {WebGLSelfDrawable}
     */
    createWebGLDrawable: function( renderer, instance ) {
      return ImageWebGLDrawable.createFromPool( renderer, instance );
    },

    /**
     * Attaches our on-load listener to our current image.
     * @private
     */
    attachImageLoadListener: function() {
      assert && assert( !this._imageLoadListenerAttached, 'Should only be attached to one thing at a time' );

      if ( !this._isDisposed ) {
        this._image.addEventListener( 'load', this._imageLoadListener );
        this._imageLoadListenerAttached = true;
      }
    },

    /**
     * Detaches our on-load listener from our current image.
     * @private
     */
    detachImageLoadListener: function() {
      assert && assert( this._imageLoadListenerAttached, 'Needs to be attached first to be detached.' );

      this._image.removeEventListener( 'load', this._imageLoadListener );
      this._imageLoadListenerAttached = false;
    },

    /**
     * Called when our image has loaded (it was not yet loaded with then listener was added)
     * @private
     */
    onImageLoad: function() {
      assert && assert( this._imageLoadListenerAttached, 'If onImageLoad is firing, it should be attached' );

      this.invalidateImage();
      this.detachImageLoadListener();
    },

    /**
     * Disposes the path, releasing image listeners if needed (and preventing new listeners from being added).
     * @public
     * @override
     */
    dispose: function() {
      if ( this._image && this._imageLoadListenerAttached ) {
        this.detachImageLoadListener();
      }

      Node.prototype.dispose.call( this );
    }
  } );

  /**
   * Creates an SVG image element with a given URL and dimensions
   * @public
   *
   * @param {string} url - The URL for the image
   * @param {number} width - Non-negative integer for the image's width
   * @param {number} height - Non-negative integer for the image's height
   * @returns {SVGImageElement}
   */
  Image.createSVGImage = function( url, width, height ) {
    assert && assert( typeof url === 'string', 'Requires the URL as a string' );
    assert && assert( typeof width === 'number' && isFinite( width ) && width >= 0 && ( width % 1 ) === 0,
      'width should be a non-negative finite integer' );
    assert && assert( typeof height === 'number' && isFinite( height ) && height >= 0 && ( height % 1 ) === 0,
      'height should be a non-negative finite integer' );

    var element = document.createElementNS( scenery.svgns, 'image' );
    element.setAttribute( 'x', 0 );
    element.setAttribute( 'y', 0 );
    element.setAttribute( 'width', width + 'px' );
    element.setAttribute( 'height', height + 'px' );
    element.setAttributeNS( scenery.xlinkns, 'xlink:href', url );

    return element;
  };

  /**
   * Creates an object suitable to be passed to Image as a mipmap (from a Canvas)
   * @public
   *
   * @param {HTMLCanvasElement} baseCanvas
   * @returns {Array}
   */
  Image.createFastMipmapFromCanvas = function( baseCanvas ) {
    var mipmaps = [];

    var baseURL = baseCanvas.toDataURL();
    var baseImage = new window.Image();
    baseImage.src = baseURL;

    // base level
    mipmaps.push( {
      img: baseImage,
      url: baseURL,
      width: baseCanvas.width,
      height: baseCanvas.height
    } );

    var largeCanvas = baseCanvas;
    while ( largeCanvas.width >= 2 && largeCanvas.height >= 2 ) {
      // smaller level
      var mipmap = {};

      // draw half-size
      var canvas = document.createElement( 'canvas' );
      canvas.width = mipmap.width = Math.ceil( largeCanvas.width / 2 );
      canvas.height = mipmap.height = Math.ceil( largeCanvas.height / 2 );
      var context = canvas.getContext( '2d' );
      context.setTransform( 0.5, 0, 0, 0.5, 0, 0 );
      context.drawImage( largeCanvas, 0, 0 );

      // set up the image and url
      mipmap.canvas = canvas;
      mipmap.url = canvas.toDataURL();
      mipmap.img = new window.Image();
      mipmap.img.src = mipmap.url;
      largeCanvas = canvas;

      mipmaps.push( mipmap );
    }

    return mipmaps;
  };

  // @public {Object} - Initial values for most Node mutator options
  Image.DEFAULT_OPTIONS = _.extend( {}, Node.DEFAULT_OPTIONS, DEFAULT_OPTIONS );

  return Image;
} );

// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'JOIST/TScreen',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','JOIST/joist','ifphetio!PHET_IO/types/TObject'],function( require ) {
  'use strict';

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var joist = require( 'JOIST/joist' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );

  /**
   * Wrapper type for phet/joist's Screen class.
   * @param screen
   * @param phetioID
   * @constructor
   */
  function TScreen( screen, phetioID ) {
    assertInstanceOf( screen, phet.joist.Screen );
    TObject.call( this, screen, phetioID );
  }

  phetioInherit( TObject, 'TScreen', TScreen, {}, {
    documentation: 'A single screen for a PhET simulation'
  } );

  joist.register( 'TScreen', TScreen );

  return TScreen;
} );
// Copyright 2013-2016, University of Colorado Boulder

/**
 * A Screen is the largest chunk of a simulation. (Java sims used the term Module, but that term
 * is too overloaded to use with JavaScript and Git.)
 * <p>
 * When creating a Sim, Screens are supplied as the arguments. They can be specified as object literals or through instances of this class.
 * This class may centralize default behavior or state for Screens in the future, but right now it only allows you to create
 * Sims without using named parameter object literals.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/Screen',['require','DOT/Dimension2','PHET_CORE/inherit','JOIST/joist','SCENERY/nodes/Path','AXON/Property','SCENERY/nodes/Rectangle','KITE/Shape','TANDEM/Tandem','JOIST/TScreen','ifphetio!PHET_IO/types/TBoolean'],function( require ) {
  'use strict';

  // modules
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Property = require( 'AXON/Property' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TScreen = require( 'JOIST/TScreen' );

  // phet-io modules
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );

  // constants
  var MINIMUM_HOME_SCREEN_ICON_SIZE = new Dimension2( 548, 373 );
  var MINIMUM_NAVBAR_ICON_SIZE = new Dimension2( 147, 100 );
  var NAVBAR_ICON_ASPECT_RATIO = MINIMUM_NAVBAR_ICON_SIZE.width / MINIMUM_NAVBAR_ICON_SIZE.height;
  var HOME_SCREEN_ICON_ASPECT_RATIO = MINIMUM_HOME_SCREEN_ICON_SIZE.width / MINIMUM_HOME_SCREEN_ICON_SIZE.height;
  var ICON_ASPECT_RATIO_TOLERANCE = 5E-3; // how close to the ideal aspect ratio an icon must be

  // Home screen and navigation bar icons must have the same aspect ratio, see https://github.com/phetsims/joist/issues/76
  assert && assert( Math.abs( HOME_SCREEN_ICON_ASPECT_RATIO - HOME_SCREEN_ICON_ASPECT_RATIO ) < ICON_ASPECT_RATIO_TOLERANCE,
    'MINIMUM_HOME_SCREEN_ICON_SIZE and MINIMUM_NAVBAR_ICON_SIZE must have the same aspect ratio' );

  /**
   * @param {function} createModel
   * @param {function:Object } createView - function( model )
   * @param {Object} [options]
   * @constructor
   */
  function Screen( createModel, createView, options ) {

    options = _.extend( {

      // {string|null} name of the sim, as displayed to the user.
      // For single-screen sims, there is no home screen or navigation bar, and null is OK.
      // For multi-screen sims, this must be provided.
      name: null,

      // {Property.<Color|string>} background color of the Screen
      backgroundColorProperty: new Property( 'white' ),

      // {Node} icon shown on the home screen.
      // For single-screen sims, there is no home screen and the default is OK.
      homeScreenIcon: new Rectangle( 0, 0, MINIMUM_HOME_SCREEN_ICON_SIZE.width, MINIMUM_HOME_SCREEN_ICON_SIZE.height, {
        fill: 'white',
        stroke: 'black'
      } ),

      // {Node|null} icon shown in the navigation bar. If null, then the home screen icon will be used, scaled to fit.
      navigationBarIcon: null,

      // dt cap in seconds, see https://github.com/phetsims/joist/issues/130
      maxDT: 0.5,

      tandem: Tandem.tandemRequired()
    }, options );

    // navigationBarIcon defaults to homeScreenIcon, and will be scaled down
    if ( !options.navigationBarIcon ) {
      options.navigationBarIcon = options.homeScreenIcon;
    }

    // Validate icon sizes
    validateIconSize( options.homeScreenIcon, MINIMUM_HOME_SCREEN_ICON_SIZE, HOME_SCREEN_ICON_ASPECT_RATIO, 'homeScreenIcon' );
    validateIconSize( options.navigationBarIcon, MINIMUM_NAVBAR_ICON_SIZE, NAVBAR_ICON_ASPECT_RATIO, 'navigationBarIcon' );

    // @private (read-only, joist)
    this.tandem = options.tandem;

    assert && assert( !options.backgroundColor, 'Please provide backgroundColorProperty instead' );

    // @public
    this.backgroundColorProperty = options.backgroundColorProperty;

    // @public (read-only)
    this.name = options.name;
    this.homeScreenIcon = options.homeScreenIcon;
    this.navigationBarIcon = options.navigationBarIcon;

    // @public (read-only, joist)
    this.maxDT = options.maxDT;

    // @private
    this.createModel = createModel;
    this.createView = createView;

    // Construction of the model and view are delayed and controlled to enable features like
    // a) faster loading when only loading certain screens
    // b) showing a loading progress bar <not implemented>
    this._model = null; // @private
    this._view = null;  // @private

    // @public {Property.<boolean>} indicates whether the Screen is active. Clients can read this, joist sets it.
    // To prevent potential visual glitches, the value should change only while the screen's view is invisible.
    // That is: transitions from false to true before a Screen becomes visible, and from true to false after a Screen becomes invisible.
    this.activeProperty = new Property( false, {
      tandem: options.tandem.createTandem( 'activeProperty' ),
      phetioValueType: TBoolean,
      phetioInstanceDocumentation: 'this Property is read-only, do not attempt to set its value'
    } );

    var self = this;
    assert && this.activeProperty.lazyLink( function( isActive ) {

      // In phet-io mode, the state of a sim can be set without a deterministic order. The activeProperty could be
      // changed before the view's visibility is set.
      if ( !phet.phetio ) {
        assert( self._view, 'isActive should not change before the Screen view has been initialized' );
        assert( !self._view.isVisible(), 'isActive should not change while the Screen view is visible' );
      }
    } );

    options.tandem.addInstance( this, TScreen );
  }

  joist.register( 'Screen', Screen );

  /**
   * Convenience function to validate the sizes for the home screen icon and navigation bar icon.
   * @param {Node} icon - the icon to validate
   * @param {Dimension2} minimumSize - the minimum allowed size for the icon
   * @param {number} aspectRatio - the required aspect ratio
   * @param {string} name - the name of the icon type (for assert messages)
   */
  var validateIconSize = function( icon, minimumSize, aspectRatio, name ) {
    assert && assert( icon.width >= minimumSize.width, name + ' is too small: ' + icon.width );
    assert && assert( icon.height >= minimumSize.height, name + ' is too small: ' + icon.height );

    // Validate home screen aspect ratio
    var actualAspectRatio = icon.width / icon.height;
    assert && assert(
      Math.abs( aspectRatio - actualAspectRatio ) < ICON_ASPECT_RATIO_TOLERANCE,
      name + ' has invalid aspect ratio: ' + actualAspectRatio
    );
  };

  /**
   * For showing ScreenView layoutBounds with 'dev' query parameter.
   * @param {Bounds2} layoutBounds
   * @returns {Node}
   */
  var devCreateLayoutBoundsNode = function( layoutBounds ) {
    return new Path( Shape.bounds( layoutBounds ), {
      stroke: 'red',
      lineWidth: 3,
      pickable: false
    } );
  };

  /**
   * For showing ScreenView layoutBounds with 'showVisibleBounds' query parameter.
   * @param {ScreenView} screenView
   * @returns {Node}
   */
  var devCreateVisibleBoundsNode = function( screenView ) {
    var path = new Path( Shape.bounds( screenView.visibleBoundsProperty.value ), {
      stroke: 'blue',
      lineWidth: 6,
      pickable: false
    } );
    screenView.visibleBoundsProperty.link( function( visibleBounds ) {
      path.shape = Shape.bounds( visibleBounds );
    } );
    return path;
  };

  return inherit( Object, Screen, {

    // @public
    reset: function() {
      // Background color not reset, as it's a responsibility of the code that changes the property
    },

    // @public - Returns the model (if it has been constructed)
    get model() {
      assert && assert( this._model, 'Model has not yet been constructed' );
      return this._model;
    },

    // @public - Returns the view (if it has been constructed)
    get view() {
      assert && assert( this._view, 'View has not yet been constructed' );
      return this._view;
    },

    /**
     * Initialize the model.  Clients should use either this or initializeModelAndView
     * Clients may want to use this method to gain more control over the creation process
     * @public (joist-internal)
     */
    initializeModel: function() {
      assert && assert( this._model === null, 'there was already a model' );
      this._model = this.createModel();
    },

    /**
     * Initialize the view.  Clients should use either this or initializeModelAndView
     * Clients may want to use this method to gain more control over the creation process
     * @public (joist-internal)
     */
    initializeView: function() {
      assert && assert( this._view === null, 'there was already a view' );
      this._view = this.createView( this.model );
      this._view.setVisible( false ); // a Screen is invisible until selected

      // Show the home screen's layoutBounds
      if ( phet.chipper.queryParameters.dev ) {
        this._view.addChild( devCreateLayoutBoundsNode( this._view.layoutBounds ) );
      }

      // For debugging, make it possible to see the visibleBounds.  This is not included with ?dev since
      // it should just be equal to what you see.
      if ( phet.chipper.queryParameters.showVisibleBounds ) {
        this._view.addChild( devCreateVisibleBoundsNode( this._view ) );
      }
    },

    // Initialize both the model and view
    initializeModelAndView: function() {
      this.initializeModel();
      this.initializeView();
    }
  }, {

    // @public
    MINIMUM_HOME_SCREEN_ICON_SIZE: MINIMUM_HOME_SCREEN_ICON_SIZE,

    // @public
    MINIMUM_NAVBAR_ICON_SIZE: MINIMUM_NAVBAR_ICON_SIZE
  } );
} );

define("string!PENDULUM_LAB/screen.energy",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/screen.energy");});

// Copyright 2013-2015, University of Colorado Boulder

define( '../../chipper/js/requirejs-plugins/getProjectURL',[],function() {
  'use strict';

  return function( name, parentRequire ) {
    //trim the ? suffix, resolve on the last / (could later be converted to :)
    var url = parentRequire.toUrl( name.substring( 0, name.indexOf( '/' ) ) );

    return (url.indexOf( '?' ) >= 0 ? url.substring( 0, url.indexOf( '?' ) ) : url) + '/../';
  };
} );
// Copyright 2015, University of Colorado Boulder

/* eslint-env browser, node */


(function( global ) {

  /**
   * Takes in a mipmap object with data/width/height and returns another mipmap object with data/width/height that is
   * downscaled by a factor of 2. Needs to round the width/height up to include all of the image (if it's not a
   * power of 2).
   *
   * mipmap.data should be array-accessible with bytes (typed array, Buffer, etc.)
   *
   * Handles alpha blending of 4 pixels into 1, and does so with the proper gamma corrections so that we only add/blend
   * colors in the linear sRGB colorspace.
   *
   * @param {Object} mipmap - Mipmap object with { data: {Buffer}, width: {number}, height: {number} }
   * @param {function} createData - function( width, height ), creates an array-accessible data container, Buffer
   *                                for Node.js, or presumably a typed array otherwise, with 4*width*height components
   *
   * @author Jonathan Olson <jonathan.olson@colorado.edu>
   */
  function mipmapDownscale( mipmap, createData ) {
    // array index constants for the channels
    var R = 0;
    var G = 1;
    var B = 2;
    var A = 3;

    // hard-coded gamma (assuming the exponential part of the sRGB curve as a simplification)
    var GAMMA = 2.2;

    // dimension handling for the larger image
    var width = mipmap.width;
    var height = mipmap.height;
    var data = mipmap.data;

    function inside( row, col ) {
      return row < height && col < width;
    }

    // grabbing pixel data for a row/col, applying corrections into the [0,1] range.
    function pixel( row, col ) {
      if ( !inside( row, col ) ) {
        return [ 0, 0, 0, 0 ];
      }
      var index = 4 * ( row * width + col );
      return [
        // maps to [0,1]
        Math.pow( data[ index + R ] / 255, GAMMA ), // red
        Math.pow( data[ index + G ] / 255, GAMMA ), // green
        Math.pow( data[ index + B ] / 255, GAMMA ), // blue
        Math.pow( data[ index + A ] / 255, GAMMA ) // alpha
      ];
    }

    // dimension h andling for the smaller downscaled image
    var smallWidth = Math.ceil( width / 2 );
    var smallHeight = Math.ceil( height / 2 );
    var smallData = createData( smallWidth, smallHeight );

    function smallPixel( row, col ) {
      return 4 * ( row * smallWidth + col );
    }

    // for each pixel in our downscaled image
    for ( var row = 0; row < height; row++ ) {
      for ( var col = 0; col < width; col++ ) {
        // Original pixel values for the quadrant
        var p1 = pixel( 2 * row, 2 * col ); // upper-left
        var p2 = pixel( 2 * row, 2 * col + 1 ); // upper-right
        var p3 = pixel( 2 * row + 1, 2 * col ); // lower-left
        var p4 = pixel( 2 * row + 1, 2 * col + 1 ); // lower-right
        var output = [ 0, 0, 0, 0 ];

        var alphaSum = p1[ A ] + p2[ A ] + p3[ A ] + p4[ A ];

        // blending of pixels, weighted by alphas
        output[ R ] = ( p1[ R ] * p1[ A ] + p2[ R ] * p2[ A ] + p3[ R ] * p3[ A ] + p4[ R ] * p4[ A ] ) / alphaSum;
        output[ G ] = ( p1[ G ] * p1[ A ] + p2[ G ] * p2[ A ] + p3[ G ] * p3[ A ] + p4[ G ] * p4[ A ] ) / alphaSum;
        output[ B ] = ( p1[ B ] * p1[ A ] + p2[ B ] * p2[ A ] + p3[ B ] * p3[ A ] + p4[ B ] * p4[ A ] ) / alphaSum;
        output[ A ] = alphaSum / 4; // average of alphas

        // convert back into [0,255] range with reverse corrections, and store in our buffer
        var outputIndex = smallPixel( row, col );
        smallData[ outputIndex + R ] = Math.floor( Math.pow( output[ R ], 1 / GAMMA ) * 255 );
        smallData[ outputIndex + G ] = Math.floor( Math.pow( output[ G ], 1 / GAMMA ) * 255 );
        smallData[ outputIndex + B ] = Math.floor( Math.pow( output[ B ], 1 / GAMMA ) * 255 );
        smallData[ outputIndex + A ] = Math.floor( Math.pow( output[ A ], 1 / GAMMA ) * 255 );
      }
    }

    return {
      data: smallData,
      width: smallWidth,
      height: smallHeight
    };
  }

  // browser require.js-compatible definition
  global.define && global.define( function() {
    return mipmapDownscale;
  } );

  // Node.js-compatible definition
  if ( typeof module !== 'undefined' ) {
    module.exports = mipmapDownscale;
  }
})( this );

define("../../chipper/js/common/mipmapDownscale", function(){});

// Copyright 2015, University of Colorado Boulder

/**
 * Registers the license entry for a media file by adding it to global.phet.chipper.licenseEntries.
 * Also verifies that the file's license is "acceptable" (as defined in isAcceptableLicenseEntry below).
 * Intended to be called by media plugins at the time that media files are loaded.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( '../../chipper/js/requirejs-plugins/registerLicenseEntry',[],function() {
  'use strict';

  /**
   * Determines whether a license entry is compatible with a brand's licensing policies.
   * @param {Object} entry - see getLicenseEntry.js
   * @param {string} brand - the string for the selected brand, such as 'phet'
   * @returns {boolean}
   */
  function isCompatibleLicenseEntry( entry, brand ) {
    if ( brand === 'phet' || brand === 'phet-io' ) {

      // PhET-specific brands have these licensing policies
      // Un-annotated entries are not acceptable
      return entry && ( entry.projectURL === 'http://phet.colorado.edu' ||
                        entry.license === 'Public Domain' ||
                        entry.license === 'NASA' );
    }
    else {

      // non-PhET brands have no licensing policies, so all entries are compatible
      return true;
    }
  }

  /**
   * Determines whether a license entry is "acceptable".  A license entry is acceptable if the entry is compatible with
   * the licensing polices for the specified brand, or if the entry has an "exception" field explaining why the
   * licensing policies can be ignored.
   *
   * @param {string} name - name of the resource whose license entry is being checked
   * @param {Object} entry - see getLicenseEntry.js
   * @param {string} brand - the string for the selected brand, such as 'phet'
   * @returns {boolean}
   */
  function isAcceptableLicenseEntry( name, entry, brand ) {
    var acceptable = isCompatibleLicenseEntry( entry, brand ) || (entry && !!entry.exception);
    if ( acceptable && entry && !!entry.exception ) {
      var warningMessage = 'license exception for ' + name + ': ' + entry.exception;

      // use grunt.log if it's available
      if ( global.phet.chipper.grunt ) {
        global.phet.chipper.grunt.log.warn( warningMessage );
      }
      else {
        console.log( 'WARNING: ' + warningMessage );
      }
    }
    return acceptable;
  }

  /**
   * Registers the license entry for a media file.
   * Intended to be called by media plugins.
   *
   * @param {string} name - the symbolic media filename as supplied to the plugin, e.g. JOHN_TRAVOLTAGE/arm.png
   * @param {Object} licenseEntry - license entry for the media file, documented in getLicenseEntry.js
   * @param {string} brand - the string for the selected brand, such as 'phet'
   * @param {string} mediaType - the type of media and name of the media subdirectory ('audio'|'image'|'mipmap'|...)
   * @param {function} onload - a function that conforms to the requirejs onload API
   */
  function registerLicenseEntry( name, licenseEntry, brand, mediaType, onload ) {
    if ( isAcceptableLicenseEntry( name, licenseEntry, brand ) ) {
      global.phet.chipper.licenseEntries = global.phet.chipper.licenseEntries || {}; // initialize if this is the first entry
      global.phet.chipper.licenseEntries[ mediaType ] = global.phet.chipper.licenseEntries[ mediaType ] || {};
      global.phet.chipper.licenseEntries[ mediaType ][ name ] = licenseEntry;
      onload( null );
    }
    else {
      onload.error( new Error( 'unacceptable license entry for ' + name ) );
    }
  }

  return registerLicenseEntry;
} );
// Copyright 2015, University of Colorado Boulder

/**
 * Retrieves the license entry for a media file from license.json.
 * This file is used when loading media files (images, audio,...) via media plugins.
 *
 * A license entry for a media file is found in a license.json file that is in
 * the same directory as the media file. A license entry has the following fields:
 *
 * text - copyright statement or "Public Domain"
 * projectURL - the URL for the resource
 * license - the name of license, such as "Public Domain"
 * notes - additional helpful information about the resource, or ""
 * exception - [optional] description of why the file is being used despite the fact that it doesn't match PhET's licensing policy
 *
 * For an example, see any of the license.json files in a PhET simulation's images directory.
 *
 * @author Sam Reid
 */

/* eslint-env browser, node */


(function() {

  /**
   * Retrieves the license entry for a media file from license.json.
   *
   * @param {string} absolutePath - the path for the media file
   * @returns {Object|null} the entry from the license.json file, null if there is no entry
   *
   * @private
   */
  function getLicenseEntry( absolutePath ) {

    var lastSlashIndex = absolutePath.lastIndexOf( '/' );
    var prefix = absolutePath.substring( 0, lastSlashIndex );
    var licenseFilename = prefix + '/license.json'; // license.json is a sibling of the media file
    var mediaFilename = absolutePath.substring( lastSlashIndex + 1 ); // field name in license.json

    // read license.json
    var fileContents = global.phet.chipper.fs.readFileSync( licenseFilename, 'utf8' );
    var json = null;
    try {
      json = JSON.parse( fileContents );
    }
    catch( err ) {
      if ( err instanceof SyntaxError ) {
        // default message is incomprehensible, see chipper#449
        throw new Error( 'syntax error in ' + licenseFilename + ': ' + err.message );
      }
      else {
        throw err;
      }
    }

    // get the media file's license entry
    var entry = json[ mediaFilename ];
    if ( !entry ) {
      return null; // Not annotated in file
    }
    return entry;
  }

  // browser require.js-compatible definition
  if ( typeof define !== 'undefined' ) {
    define( '../../chipper/js/common/getLicenseEntry',[],function() {
      return getLicenseEntry;
    } );
  }

  // Node.js-compatible definition
  if ( typeof module !== 'undefined' ) {
    module.exports = getLicenseEntry;
  }
})();
define('mipmap',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});

define("mipmap!PENDULUM_LAB/energy-screen-icon.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["PENDULUM_LAB/energy-screen-icon.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Energy screen.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/energy/EnergyScreen',['require','PENDULUM_LAB/energy/model/EnergyModel','PENDULUM_LAB/energy/view/EnergyScreenView','SCENERY/nodes/Image','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','AXON/Property','JOIST/Screen','string!PENDULUM_LAB/screen.energy','mipmap!PENDULUM_LAB/energy-screen-icon.png'],function( require ) {
  'use strict';

  // modules
  var EnergyModel = require( 'PENDULUM_LAB/energy/model/EnergyModel' );
  var EnergyScreenView = require( 'PENDULUM_LAB/energy/view/EnergyScreenView' );
  var Image = require( 'SCENERY/nodes/Image' );
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Property = require( 'AXON/Property' );
  var Screen = require( 'JOIST/Screen' );

  // strings
  var screenEnergyString = require( 'string!PENDULUM_LAB/screen.energy' );

  // images
  var energyImage = require( 'mipmap!PENDULUM_LAB/energy-screen-icon.png' );

  /**
   * @constructor
   */
  function EnergyScreen() {

    var options = {
      name: screenEnergyString,
      backgroundColorProperty: new Property( PendulumLabConstants.BACKGROUND_COLOR ),
      homeScreenIcon: new Image( energyImage )
    };

    Screen.call( this,
      function() { return new EnergyModel(); },
      function( model ) { return new EnergyScreenView( model ); },
      options
    );
  }

  pendulumLab.register( 'EnergyScreen', EnergyScreen );

  return inherit( Screen, EnergyScreen );
} );


define("string!PENDULUM_LAB/screen.intro",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/screen.intro");});


define("mipmap!PENDULUM_LAB/intro-navbar-icon.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["PENDULUM_LAB/intro-navbar-icon.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );


define("mipmap!PENDULUM_LAB/intro-screen-icon.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["PENDULUM_LAB/intro-screen-icon.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Intro screen.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/intro/IntroScreen',['require','SCENERY/nodes/Image','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','PENDULUM_LAB/common/model/PendulumLabModel','PENDULUM_LAB/common/view/PendulumLabScreenView','AXON/Property','JOIST/Screen','string!PENDULUM_LAB/screen.intro','mipmap!PENDULUM_LAB/intro-navbar-icon.png','mipmap!PENDULUM_LAB/intro-screen-icon.png'],function( require ) {
  'use strict';

  // modules
  var Image = require( 'SCENERY/nodes/Image' );
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PendulumLabModel = require( 'PENDULUM_LAB/common/model/PendulumLabModel' );
  var PendulumLabScreenView = require( 'PENDULUM_LAB/common/view/PendulumLabScreenView' );
  var Property = require( 'AXON/Property' );
  var Screen = require( 'JOIST/Screen' );

  // strings
  var screenIntroString = require( 'string!PENDULUM_LAB/screen.intro' );

  // images
  var introNavbarImage = require( 'mipmap!PENDULUM_LAB/intro-navbar-icon.png' );
  var introScreenImage = require( 'mipmap!PENDULUM_LAB/intro-screen-icon.png' );

  /**
   * @constructor
   */
  function IntroScreen() {

    var options = {
      name: screenIntroString,
      backgroundColorProperty: new Property( PendulumLabConstants.BACKGROUND_COLOR ),
      homeScreenIcon: new Image( introScreenImage ),
      navigationBarIcon: new Image( introNavbarImage )
    };

    Screen.call( this,
      function() { return new PendulumLabModel(); },
      function( model ) { return new PendulumLabScreenView( model ); },
      options
    );
  }

  pendulumLab.register( 'IntroScreen', IntroScreen );

  return inherit( Screen, IntroScreen );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Period timer model in 'Pendulum Lab' simulation.
 * Calculates the period for the active pendulum, in addition to the normal trace.
 *
 * @author Andrey Zelenkov (MLearner)
 */
define( 'PENDULUM_LAB/lab/model/PeriodTimer',['require','AXON/DerivedProperty','PHET_CORE/inherit','AXON/NumberProperty','AXON/Property','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/model/Stopwatch'],function( require ) {
  'use strict';

  // modules
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var NumberProperty = require( 'AXON/NumberProperty' );
  var Property = require( 'AXON/Property' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var Stopwatch = require( 'PENDULUM_LAB/common/model/Stopwatch' );

  /**
   * @constructor
   *
   * @param {Array.<Pendulum>} pendula - Array of pendulum models.
   * @param {Property.<boolean>} isVisibleProperty
   */
  function PeriodTimer( pendula, isVisibleProperty ) {
    var self = this;

    Stopwatch.call( this, isVisibleProperty.value );

    // Forward our invisibleProperty over to the MovableComponent visibility.
    isVisibleProperty.linkAttribute( this.isVisibleProperty, 'value' );

    // @public {Property.<number>}
    this.activePendulumIndexProperty = new NumberProperty( 0 ); // Start with the first pendulum

    // @public {Property.<pendulum>} - The active pendulum that we'll record the period/trace on.
    this.activePendulumProperty = new DerivedProperty( [ this.activePendulumIndexProperty ], function( index ) {
      return pendula[ index ];
    } );

    // @private {Array.<Pendulum>}
    this.pendula = pendula;

    Property.multilink( [ this.isRunningProperty, this.isVisibleProperty ], function( isRunning, isVisible ) {
      if ( isRunning && isVisible ) {
        // clear time when timer revert to init state
        self.elapsedTimeProperty.value = 0;

        // reset and show trace path
        self.clear();
        self.activePendulumProperty.value.periodTrace.isVisibleProperty.value = true;
      }
      else if ( isVisible ) {
        // clear path if it wasn't finished
        if ( self.activePendulumProperty.value.periodTrace.numberOfPointsProperty.value < 4 ) {
          self.clear();
        }

        // hide path if it wasn't started
        if ( self.activePendulumProperty.value.periodTrace.numberOfPointsProperty.value === 0 ) {
          self.activePendulumProperty.value.periodTrace.isVisibleProperty.value = false;
        }
      }
      else if ( isRunning ) {
        self.isRunningProperty.value = false;
      }
      else {
        self.clear();
        self.activePendulumProperty.value.periodTrace.isVisibleProperty.value = false;
      }
    } );

    // create listeners
    var pathListeners = [];
    pendula.forEach( function( pendulum, pendulumIndex ) {
      pendulum.periodTrace.isVisibleProperty.value = false;

      function clearIfActive() {
        if ( self.activePendulumProperty.value === pendulum ) {
          self.clear();
        }
      }

      pendulum.lengthProperty.lazyLink( clearIfActive );
      pendulum.gravityProperty.lazyLink( clearIfActive );
      pendulum.isUserControlledProperty.lazyLink( clearIfActive );

      pendulum.periodTrace.elapsedTimeProperty.lazyLink( function( time ) {
        if ( pendulum === self.activePendulumProperty.value && self.isRunningProperty.value ) {
          self.elapsedTimeProperty.value = time;
        }
      } );

      pathListeners[ pendulumIndex ] = function() {
        if ( pendulum.periodTrace.numberOfPointsProperty.value === 4 && self.isRunningProperty.value ) {
          self.isRunningProperty.value = false;
        }
      };
    } );

    // add path listeners
    self.activePendulumProperty.value.periodTrace.numberOfPointsProperty.link( pathListeners[ this.activePendulumIndexProperty.value ] );
    self.activePendulumIndexProperty.lazyLink( function( index, oldIndex ) {
      self.clear();

      self.pendula[ oldIndex ].periodTrace.isVisibleProperty.value = false;
      self.pendula[ oldIndex ].periodTrace.numberOfPointsProperty.unlink( pathListeners[ oldIndex ] );

      self.pendula[ index ].periodTrace.numberOfPointsProperty.link( pathListeners[ index ] );
      self.pendula[ index ].periodTrace.isVisibleProperty.value = self.isRunningProperty.value;
    } );
  }

  pendulumLab.register( 'PeriodTimer', PeriodTimer );

  return inherit( Stopwatch, PeriodTimer, {
    /**
     * Resets the PeriodTimer
     * @public
     */
    reset: function() {
      Stopwatch.prototype.reset.call( this );
      this.activePendulumIndexProperty.reset();
    },

    /**
     * Clears the timer and period traces
     * @private
     */
    clear: function() {
      // resetting the timer
      this.elapsedTimeProperty.value = 0;

      // clearing the period traces
      if ( !this.isRunningProperty.value ) {
        this.activePendulumProperty.value.periodTrace.isVisibleProperty.value = false;
      }
      this.pendula.forEach( function( pendulum ) {
        pendulum.periodTrace.resetPathPoints();
      } );
    },
    /**
     * Stops the period timer and clear the trace
     * @public
     */
    stop: function() {
      if ( this.isRunningProperty.value === true ) {
        this.clear();
      }
    }
  } );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Main model constructor for Lab screen in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/lab/model/LabModel',['require','AXON/BooleanProperty','PENDULUM_LAB/energy/model/EnergyModel','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/lab/model/PeriodTimer'],function( require ) {
  'use strict';

  // modules
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var EnergyModel = require( 'PENDULUM_LAB/energy/model/EnergyModel' );
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PeriodTimer = require( 'PENDULUM_LAB/lab/model/PeriodTimer' );

  /**
   * @constructor
   *
   * @param {Object} [options]
   */
  function LabModel( options ) {
    options = _.extend( {
      hasPeriodTimer: true,
      energyBoxExpanded: false
    }, options );

    EnergyModel.call( this, options );

    // add properties to control visibility of arrows
    this.isVelocityVisibleProperty = new BooleanProperty( false );
    this.isAccelerationVisibleProperty = new BooleanProperty( false );

    // model for period trace
    this.periodTimer = new PeriodTimer( this.pendula, this.isPeriodTraceVisibleProperty );
  }

  pendulumLab.register( 'LabModel', LabModel );

  return inherit( EnergyModel, LabModel, {
    /**
     * Returns the pendula to rest.
     * @public
     * @override
     */
    returnPendula: function() {
      EnergyModel.prototype.returnPendula.call( this );

      this.periodTimer.isRunningProperty.value = false;
    },

    /**
     * Reset function that resets the pendula, settings, and period timer settings and default location
     * @public
     */
    reset: function() {
      EnergyModel.prototype.reset.call( this );

      this.isVelocityVisibleProperty.reset();
      this.isAccelerationVisibleProperty.reset();

      // reset period trace model
      this.periodTimer.reset();
    }
  } );
} );


define("string!PENDULUM_LAB/acceleration",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/acceleration");});


define("string!PENDULUM_LAB/velocity",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/velocity");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Arrow control panel node in 'Pendulum Lab' simulation.
 * Contains check box buttons to control visibility of velocity and acceleration arrows.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/lab/view/ArrowVisibilityPanel',['require','SCENERY/nodes/AlignBox','SCENERY/nodes/AlignGroup','SCENERY_PHET/ArrowNode','SUN/CheckBox','SCENERY/nodes/HBox','PHET_CORE/inherit','SUN/Panel','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','AXON/Property','SCENERY/nodes/Text','SCENERY/nodes/VBox','string!PENDULUM_LAB/acceleration','string!PENDULUM_LAB/velocity'],function( require ) {
  'use strict';

  // modules
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var AlignGroup = require( 'SCENERY/nodes/AlignGroup' );
  var ArrowNode = require( 'SCENERY_PHET/ArrowNode' );
  var CheckBox = require( 'SUN/CheckBox' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Panel = require( 'SUN/Panel' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Property = require( 'AXON/Property' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VBox = require( 'SCENERY/nodes/VBox' );

  // strings
  var accelerationString = require( 'string!PENDULUM_LAB/acceleration' );
  var velocityString = require( 'string!PENDULUM_LAB/velocity' );

  /**
   * @constructor
   *
   * @param {Property.<boolean>} isVelocityVisibleProperty - Visibility of velocity arrows.
   * @param {Property.<boolean>} isAccelerationVisibleProperty - Visibility of acceleration arrows.
   * @param {Object} [options]
   */
  function ArrowVisibilityPanel( isVelocityVisibleProperty, isAccelerationVisibleProperty, options ) {
    options = _.extend( {}, PendulumLabConstants.PANEL_OPTIONS, options );

    var textOptions = {
      font: PendulumLabConstants.TITLE_FONT,
      maxWidth: 80
    };
    var textHeight = new Text( 'not visible', textOptions ).height;

    var textGroup = new AlignGroup();
    function createCheckBoxContent( labelString, color ) {
      return new HBox( {
        children: [
          new AlignBox( new Text( labelString, textOptions ), { group: textGroup, xAlign: 'left' } ),
          new ArrowNode( 0, 0, 22, 0, {
            fill: color,
            centerY: 0,
            tailWidth: 6,
            headWidth: 12
          } )
        ],
        pickable: false
      } );
    }
    // We'll dynamically adjust the spacings in these, so that the full CheckBox expands to the desired size.
    var velocityContent = createCheckBoxContent( velocityString, PendulumLabConstants.VELOCITY_ARROW_COLOR );
    var accelerationContent = createCheckBoxContent( accelerationString, PendulumLabConstants.ACCELERATION_ARROW_COLOR );

    // Currently no better way to handle the fluid layout with checkboxes than to determine the amount of additional
    // space it takes up when it has no spacing (and then add spacing to fit).
    var tmpCheckBox = new CheckBox( velocityContent, new Property( true ), {
      boxWidth: textHeight
    } );
    var widthWithoutSpacing = tmpCheckBox.width;
    tmpCheckBox.dispose();

    var content = new VBox( {
      spacing: PendulumLabConstants.CHECK_RADIO_SPACING
    } );

    // Whenever the amount of width available changes, we need to recreate the check boxes
    PendulumLabConstants.LEFT_CONTENT_ALIGN_GROUP.maxWidthProperty.link( function( width ) {
      // Properly remove any old check boxes
      content.children.forEach( function( child ) {
        child.dispose();
      } );

      var spacing = width - widthWithoutSpacing;

      // Create new check boxes with the proper spacing. CheckBox currently doesn't support resizing content.
      velocityContent.spacing = spacing;
      content.addChild( new CheckBox( velocityContent, isVelocityVisibleProperty, {
        boxWidth: textHeight
      } ) );

      accelerationContent.spacing = spacing;
      content.addChild( new CheckBox( accelerationContent, isAccelerationVisibleProperty, {
        boxWidth: textHeight
      } ) );
    } );

    Panel.call( this, content, options );
  }

  pendulumLab.register( 'ArrowVisibilityPanel', ArrowVisibilityPanel );

  return inherit( Panel, ArrowVisibilityPanel );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * On/off switch, similar to iOS' UISwitch, used in iOS `'Settings' app.
 * Off (false) is to the left, on (true) is to the right.
 *
 * Interaction behavior is as follows:
 * Drag the thumb to change the value, or click anywhere to toggle the value.
 * If you click without dragging, it's a toggle.
 * If you drag but don't cross the midpoint of the track, then it's a toggle.
 * If you drag past the midpoint of the track, releasing the thumb snaps to whichever end the thumb is closest to.
 * If you drag the thumb far enough to the side (outside of the switch), it will immediately toggle the model behavior.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Jonathan Olson (PhET Interactive Simulations)
 */
define( 'SUN/OnOffSwitch',['require','DOT/Dimension2','DOT/Vector2','DOT/Util','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','KITE/Shape','SCENERY/input/SimpleDragHandler','SUN/sun','TANDEM/Tandem','AXON/Emitter'],function( require ) {
  'use strict';

  // modules
  var Dimension2 = require( 'DOT/Dimension2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Util = require( 'DOT/Util' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Emitter = require( 'AXON/Emitter' );

  /**
   * @param {Property.<boolean>} onProperty
   * @param {Object} [options]
   * @constructor
   */
  function OnOffSwitch( onProperty, options ) {

    options = _.extend( {

      size: new Dimension2( 60, 30 ), // if you want the thumb to be a circle, use width that is 2x height
      cursor: 'pointer',

      // controls the behavior of when model value changes occur during dragging (if any)
      // null (default: triggers model changes when thumb is dragged far enough to the side, similar to iOS)
      // true: triggers model changes whenever the thumb crosses sides
      // false: only trigger model changes until release
      toggleWhileDragging: null,

      // number of view-space units the drag needs to cover to be considered a "drag" instead of a "click/tap"
      dragThreshold: 3,

      // number of thumb-widths outside the normal range past where the model value will change
      toggleThreshold: 1,

      // thumb
      thumbFill: 'white',
      thumbStroke: 'black',
      thumbTouchAreaXDilation: 8,
      thumbTouchAreaYDilation: 8,
      thumbMouseAreaXDilation: 0,
      thumbMouseAreaYDilation: 0,

      // track
      trackOffFill: 'white', // track fill when onProperty is false
      trackOnFill: 'rgb(0,200,0)', // track fill when onProperty is true
      trackStroke: 'black',

      tandem: Tandem.tandemRequired()
    }, options );

    var self = this;
    Node.call( this );

    // track that the thumb slides in
    var cornerRadius = options.size.height / 2;
    var trackNode = this.trackNode = new Rectangle( 0, 0, options.size.width, options.size.height, cornerRadius, cornerRadius, {
      fill: options.trackOffFill,
      stroke: options.trackStroke,
      cachedPaints: [ options.trackOnFill, options.trackOffFill ]
    } );
    this.addChild( trackNode );

    // thumb (aka knob)
    var thumbNode = this.thumbNode = new Rectangle( 0, 0, 0.5 * options.size.width, options.size.height, cornerRadius, cornerRadius, {
      fill: options.thumbFill,
      stroke: options.thumbStroke
    } );
    this.addChild( thumbNode );

    // thumb touchArea
    if ( options.thumbTouchAreaXDilation || options.thumbTouchAreaYDilation ) {
      thumbNode.touchArea = Shape.roundRect(
        -options.thumbTouchAreaXDilation, -options.thumbTouchAreaYDilation,
        ( 0.5 * options.size.width ) + ( 2 * options.thumbTouchAreaXDilation ),
        options.size.height + ( 2 * options.thumbTouchAreaYDilation), cornerRadius, cornerRadius );
    }

    // thumb mouseArea
    if ( options.thumbMouseAreaXDilation || options.thumbMouseAreaYDilation ) {
      thumbNode.mouseArea = Shape.roundRect(
        -options.thumbMouseAreaXDilation, -options.thumbMouseAreaYDilation,
        ( 0.5 * options.size.width ) + ( 2 * options.thumbMouseAreaXDilation ),
        options.size.height + ( 2 * options.thumbMouseAreaYDilation ), cornerRadius, cornerRadius );
    }

    // move thumb to on or off position
    var updateThumb = function( on ) {
      if ( on ) {
        thumbNode.right = options.size.width;
        trackNode.fill = options.trackOnFill;
      }
      else {
        thumbNode.left = 0;
        trackNode.fill = options.trackOffFill;
      }
    };

    // sync with onProperty
    onProperty.link( updateThumb.bind( this ) );

    // thumb interactivity
    var dragThresholdSquared = options.dragThreshold * options.dragThreshold; // comparing squared magnitudes is a bit faster
    var accumulatedDelta = new Vector2(); // stores how far we are from where our drag started, in our local coordinate frame
    var passedDragThreshold = false; // whether we have dragged far enough to be considered for "drag" behavior (pick closest side), or "tap" behavior (toggle)

    this.startedCallbacksForToggled = new Emitter();
    this.endedCallbacksForToggled = new Emitter();
    this.addInputListener( new SimpleDragHandler( {
      tandem: options.tandem.createTandem( 'simpleDragHandler' ),

      // only touch to snag when over the thumb (don't snag on the track itself)
      allowTouchSnag: function( evt ) {
        return _.includes( evt.trail.nodes, thumbNode );
      },

      start: function( evt, trail ) {
        // resets our state
        accumulatedDelta.setXY( 0, 0 ); // reset it mutably (less allocation)
        passedDragThreshold = false;
      },

      drag: function( evt, trail ) {
        // center the thumb on the pointer's x-coordinate if possible (but clamp to left and right ends)
        var viewPoint = evt.currentTarget.globalToLocalPoint( evt.pointer.point );
        var halfThumbWidth = thumbNode.width / 2;
        thumbNode.centerX = Util.clamp( viewPoint.x, halfThumbWidth, options.size.width - halfThumbWidth );

        // whether the thumb is dragged outside of the possible range far enough beyond our threshold to potentially
        // trigger an immediate model change
        var isDraggedOutside = viewPoint.x < ( 1 - 2 * options.toggleThreshold ) * halfThumbWidth ||
                               viewPoint.x > ( -1 + 2 * options.toggleThreshold ) * halfThumbWidth + options.size.width;

        var value = self.thumbPositionToValue(); // value represented by the current thumb position

        // track fill changes based on the thumb positions
        trackNode.fill = value ? options.trackOnFill : options.trackOffFill;

        if ( options.toggleWhileDragging === true || ( isDraggedOutside && options.toggleWhileDragging === null ) ) {

          // TODO: A way to distinguish between drag-to-toggle vs click-to-toggle

          // Only signify a change if the value actually changed to avoid duplicate messages in the PhET-iO Event
          // stream, see https://github.com/phetsims/phet-io/issues/369
          var changed = onProperty.get() !== value;
          if ( changed ) {
            self.startedCallbacksForToggled.emit2( !value, value );
            onProperty.set( value );
            self.endedCallbacksForToggled.emit();
          }
        }
      },

      end: function( evt, trail ) {
        var oldValue = onProperty.get();

        // if moved past the threshold, choose value based on the side, otherwise just toggle
        var newValue = passedDragThreshold ? self.thumbPositionToValue() : !onProperty.get();

        self.startedCallbacksForToggled.emit2( oldValue, newValue );

        onProperty.set( newValue );

        // update the thumb location (sanity check that it's here, only needs to be run if passedDragThreshold===true)
        updateThumb( onProperty.get() );

        self.startedCallbacksForToggled.emit();
      },

      translate: function( params ) {
        accumulatedDelta.add( params.delta );
        passedDragThreshold = passedDragThreshold || ( accumulatedDelta.magnitudeSquared() > dragThresholdSquared );
      }
    } ) );

    this.mutate( options );
  }

  sun.register( 'OnOffSwitch', OnOffSwitch );

  return inherit( Node, OnOffSwitch, {
    /*
     * Converts the thumb position to a boolean on/off value.
     * Off (false) is to the left, on (true) is to the right.
     */
    thumbPositionToValue: function() {
      return this.thumbNode.centerX > this.trackNode.centerX;
    }
  } );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Control for switching between 2 choices (A & B).
 * Choice 'A' is to the left of the switch, choice 'B' is to the right.
 * This decorates OnOffProperty, the iOS-like on/off switch.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SUN/ABSwitch',['require','SCENERY/input/ButtonListener','DOT/Dimension2','PHET_CORE/inherit','SCENERY/nodes/Line','SCENERY/util/LinearGradient','SCENERY/nodes/Node','SUN/OnOffSwitch','AXON/Property','SUN/sun','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'SCENERY/nodes/Line' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Node = require( 'SCENERY/nodes/Node' );
  var OnOffSwitch = require( 'SUN/OnOffSwitch' );
  var Property = require( 'AXON/Property' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Property.<*>} property stores the value of the current choice
   * @param {*} valueA value for choice 'A'
   * @param {Node} labelA label for choice 'A'
   * @param {*} valueB value for choice 'B'
   * @param {Node} labelB label for choice 'B'
   * @param {Object} [options]
   * @constructor
   */
  function ABSwitch( property, valueA, labelA, valueB, labelB, options ) {

    // default option values
    options = _.extend( {
      switchSize: new Dimension2( 60, 30 ),
      xSpacing: 8,
      cursor: 'pointer',
      centerOnButton: false,

      // uses opacity as the default method of indicating whether a {Node} label is {boolean} enabled
      setEnabled: function( label, enabled ) { label.opacity = enabled ? 1.0 : 0.5; },

      // pointer areas for thumb
      thumbTouchAreaXDilation: 8,
      thumbTouchAreaYDilation: 8,
      thumbMouseAreaXDilation: 0,
      thumbMouseAreaYDilation: 0,
      tandem: Tandem.tandemRequired()
    }, options );

    var defaultTrackFill = new LinearGradient( 0, 0, 0, options.switchSize.height ).addColorStop( 0, 'rgb(40,40,40)' ).addColorStop( 1, 'rgb(200,200,200)' );
    options.trackFillA = options.trackFillA || defaultTrackFill;
    options.trackFillB = options.trackFillB || defaultTrackFill;
    options.thumbFill = options.thumbFill ||
                        new LinearGradient( 0, 0, 0, options.switchSize.height ).addColorStop( 0, 'white' ).addColorStop( 1, 'rgb(200,200,200)' );

    Node.call( this );

    // property for adapting to OnOffSwitch. 'true' is 'B', the object on the 'on' end of the OnOffSwitch.
    var onProperty = new Property( valueB === property.get() );

    var onOffSwitch = new OnOffSwitch( onProperty, {
      size: options.switchSize,
      cursor: options.cursor,
      thumbFill: options.thumbFill,
      trackOnFill: options.trackFillB,
      trackOffFill: options.trackFillA,
      thumbTouchAreaXDilation: options.thumbTouchAreaXDilation,
      thumbTouchAreaYDilation: options.thumbTouchAreaYDilation,
      thumbMouseAreaXDilation: options.thumbMouseAreaXDilation,
      thumbMouseAreaYDilation: options.thumbMouseAreaYDilation,
      tandem: options.tandem.createTandem( 'onOffSwitch' )
    } );

    // rendering order
    this.addChild( onOffSwitch );
    this.addChild( labelA );
    this.addChild( labelB );

    // layout: 'A' on the left, 'B' on the right
    labelA.right = onOffSwitch.left - options.xSpacing;
    labelA.centerY = onOffSwitch.centerY;
    labelB.left = onOffSwitch.right + options.xSpacing;
    labelB.centerY = onOffSwitch.centerY;

    // add a horizontal strut that will cause the 'centerX' of this node to be at the center of the button
    if ( options.centerOnButton ) {
      var additionalWidth = Math.abs( labelA.width - labelB.width );
      var strut = new Line( 0, 0, this.width + additionalWidth, 0 );
      this.addChild( strut );
      strut.moveToBack();
      if ( labelA.width < labelB.width ) {
        strut.left = labelA.left - ( additionalWidth / 2 );
      }
      else {
        strut.left = labelA.left;
      }
    }

    // sync properties
    property.link( function( object ) {
      onProperty.set( valueB === object );
    } );
    onProperty.link( function( on ) {
      property.set( on ? valueB : valueA );
      if ( options.setEnabled ) {
        options.setEnabled( labelA, !on );
        options.setEnabled( labelB, on );
      }
    } );

    // click on labels to select
    labelA.addInputListener( new ButtonListener( {
      fire: function() { onProperty.set( false ); }
    } ) );
    labelB.addInputListener( new ButtonListener( {
      fire: function() { onProperty.set( true ); }
    } ) );

    this.mutate( options );
  }

  sun.register( 'ABSwitch', ABSwitch );

  return inherit( Node, ABSwitch );
} );


define("string!PENDULUM_LAB/secondsPattern",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/secondsPattern");});


define("string!PENDULUM_LAB/period",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/period");});


define("mipmap!PENDULUM_LAB/period-timer-background.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["PENDULUM_LAB/period-timer-background.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Period trace timer node in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */

define( 'PENDULUM_LAB/lab/view/PeriodTimerNode',['require','SUN/ABSwitch','SCENERY/nodes/AlignBox','SUN/buttons/BooleanRectangularToggleButton','DOT/Bounds2','SCENERY/util/Color','DOT/Dimension2','SCENERY/nodes/HBox','SCENERY/nodes/Image','PHET_CORE/inherit','SCENERY/util/LinearGradient','SCENERY_PHET/input/MovableDragHandler','SCENERY/nodes/Node','SCENERY/nodes/Path','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','SCENERY_PHET/PhetFont','SCENERY/nodes/Rectangle','KITE/Shape','PHETCOMMON/util/StringUtils','SCENERY/nodes/Text','DOT/Util','SCENERY_PHET/UTurnArrowShape','SCENERY/nodes/VBox','DOT/Vector2','string!PENDULUM_LAB/secondsPattern','string!PENDULUM_LAB/period','mipmap!PENDULUM_LAB/period-timer-background.png'],function( require ) {
  'use strict';

  // modules
  var ABSwitch = require( 'SUN/ABSwitch' );
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var BooleanRectangularToggleButton = require( 'SUN/buttons/BooleanRectangularToggleButton' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Color = require( 'SCENERY/util/Color' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var Image = require( 'SCENERY/nodes/Image' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var MovableDragHandler = require( 'SCENERY_PHET/input/MovableDragHandler' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );
  var UTurnArrowShape = require( 'SCENERY_PHET/UTurnArrowShape' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Vector2 = require( 'DOT/Vector2' );

  // strings
  var secondsPatternString = require( 'string!PENDULUM_LAB/secondsPattern' );
  var periodString = require( 'string!PENDULUM_LAB/period' );

  var periodTimerBackgroundImage = require( 'mipmap!PENDULUM_LAB/period-timer-background.png' );

  /**
   * @constructor
   *
   * @param {PeriodTimer} periodTimer - Period timer
   * @param {Property.<boolean>} secondPendulumIsVisibleProperty - Second pendulum visibility property.
   * @param {Bounds2} layoutBounds - Bounds of screen view.
   * @param {Object} [options]
   */
  function PeriodTimerNode( periodTimer, secondPendulumIsVisibleProperty, layoutBounds, options ) {
    var self = this;

    options = _.extend( {
      iconColor: '#333',
      buttonBaseColor: '#DFE0E1',
      cursor: 'pointer'
    }, options );

    Node.call( this, options );

    // creates Uturn arrow on the period timer tool
    var uArrowShape = new UTurnArrowShape( 10 );

    // creates triangle shape on play button by creating three lines at x,y coordinates.
    var playPauseSize = uArrowShape.bounds.height;
    var halfPlayStroke = 0.05 * playPauseSize;
    var playOffset = 0.15 * playPauseSize;
    var playShape = new Shape().moveTo( playPauseSize - halfPlayStroke * 0.5 - playOffset, 0 )
      .lineTo( halfPlayStroke * 1.5 + playOffset, playPauseSize / 2 - halfPlayStroke - playOffset )
      .lineTo( halfPlayStroke * 1.5 + playOffset, -playPauseSize / 2 + halfPlayStroke + playOffset )
      .close().getOffsetShape( -playOffset );

    // creates playPauseButton
    var playPauseButton = new BooleanRectangularToggleButton(
      new Path( uArrowShape, {
        fill: options.iconColor,
        center: Vector2.ZERO,
        pickable: false
      } ),
      new Path( playShape, {
        pickable: false,
        stroke: options.iconColor,
        fill: '#eef',
        lineWidth: halfPlayStroke * 2,
        center: Vector2.ZERO
      } ), periodTimer.isRunningProperty, {
        baseColor: options.buttonBaseColor,
        minWidth: 40
      } );
    playPauseButton.touchArea = playPauseButton.localBounds.dilated( 5 );

    function createPendulumIcon( color, label, padLeft ) {
      var highlightColor = Color.toColor( color ).colorUtilsBrighter( 0.4 );
      var rectBounds = new Bounds2( 0, 0, 17, 20 );
      var icon = new Node( {
        children: [
          Rectangle.bounds( rectBounds, {
            stroke: 'black',
            lineWidth: 0.5,
            fill: new LinearGradient( 0, 0, rectBounds.width, 0 ).addColorStop( 0, color )
                                                                .addColorStop( 0.2, highlightColor )
                                                                .addColorStop( 0.4, color )
                                                                .addColorStop( 1, color )
          } ),
          new Text( label, {
            fill: 'white',
            font: new PhetFont( 14 ),
            center: rectBounds.center
          } )
        ]
      } );

      // Don't pad next to the AB switch, but only away from it
      var touchArea = icon.localBounds.dilated( 5 );
      if ( padLeft ) {
        touchArea.maxX = icon.localBounds.maxX;
      }
      else {
        touchArea.minX = icon.localBounds.minX;
      }
      icon.touchArea = touchArea;
      return icon;
    }

    var firstPendulumIcon = createPendulumIcon( PendulumLabConstants.FIRST_PENDULUM_COLOR, '1', true );
    var secondPendulumIcon = createPendulumIcon( PendulumLabConstants.SECOND_PENDULUM_COLOR, '2', false );

    // creates switch icon for choosing the first or second pendulum
    var graphUnitsSwitch = new ABSwitch( periodTimer.activePendulumIndexProperty, 0, firstPendulumIcon, 1, secondPendulumIcon, {
      xSpacing: 3,
      switchSize: new Dimension2( 25, 12.5 ),
      thumbTouchAreaXDilation: 3.5,
      thumbTouchAreaYDilation: 3.5,
      setEnabled: null // Do not highlight the selected mass more than the other
    } );

    // Switch,Play button, and pendulum icon buttons at the bottom of the period timer tool.
    var periodTimerPendulaSelector = new HBox( {
      spacing: 10,
      children: [ graphUnitsSwitch, playPauseButton ]
    } );

    // Creates time text inside period timer tool.
    var readoutText = new Text( '', {
      font: PendulumLabConstants.PERIOD_TIMER_READOUT_FONT,
      maxWidth: periodTimerPendulaSelector.width * 0.80
    } );
    // present for the lifetime of the sim
    periodTimer.elapsedTimeProperty.link( function updateTime( value ) {
      readoutText.text =  StringUtils.fillIn( secondsPatternString, {
        seconds: Util.toFixed( value, 4 )
      } );
    } );

    // Creates white background behind the time readout text in period timer tool.
    var textBackground = Rectangle.roundedBounds( readoutText.bounds.dilatedXY( 20, 2 ), 5, 5, {
      fill: '#fff',
      stroke: 'rgba(0,0,0,0.5)'
    } );

    // Creates the title, time readout, and period timer pendulum selector as one box in period timer tool.
    var vBox = new VBox( {
      spacing: 5,
      align: 'center',
      children: [
        new Text( periodString, {
          font: PendulumLabConstants.PERIOD_TIMER_TITLE_FONT,
          pickable: false,
          maxWidth: periodTimerPendulaSelector.width
        } ),
        new Node( {
          children: [ textBackground, readoutText ],
          pickable: false,
          maxWidth: periodTimerPendulaSelector.width
        } ),
        periodTimerPendulaSelector
      ]
    } );

    // background image
    var background = new Image( periodTimerBackgroundImage, {
      scale: 0.6,
      center: vBox.center
    } );
    this.addChild( background );

    // adds period timer contents on top of yellow background.
    this.addChild( new AlignBox( vBox, {
      alignBounds: background.bounds
    } ) );

    // switch to second pendulum when it visible only
    // present for the lifetime of the sim
    secondPendulumIsVisibleProperty.link( function( isVisible ) {
      periodTimerPendulaSelector.children = isVisible ? [ graphUnitsSwitch, playPauseButton ] : [ playPauseButton ];
      if ( !isVisible ) {
        periodTimer.activePendulumIndexProperty.value = 0;
      }
    } );

    this.movableDragHandler = new MovableDragHandler( periodTimer.locationProperty, {
      dragBounds: layoutBounds.erodedXY( this.width / 2, this.height / 2 ),
      allowTouchSnag: false
    } );
    // add drag and drop events
    this.addInputListener( this.movableDragHandler );

    // prevent dragging the PeriodTimer from the playPause Button and graphUnitSwitch
    var doNotStartDragListener = {
      down: function( event ) {
        event.handle();
      }
    };
    playPauseButton.addInputListener( doNotStartDragListener );
    graphUnitsSwitch.addInputListener( doNotStartDragListener );

    // add update of node location
    periodTimer.locationProperty.lazyLink( function( location ) {
      // Because location is initialized to be null
      if ( location ) {
        self.center = location;
      }
    } );

    // set visibility observer, present for the lifetime of the sim
    periodTimer.isVisibleProperty.linkAttribute( this, 'visible' );
  }

  pendulumLab.register( 'PeriodTimerNode', PeriodTimerNode );

  return inherit( Node, PeriodTimerNode );
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Main view node for Lab screen in 'Pendulum Lab' simulation.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/lab/view/LabScreenView',['require','PENDULUM_LAB/lab/view/ArrowVisibilityPanel','PENDULUM_LAB/energy/view/EnergyScreenView','PHET_CORE/inherit','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','PENDULUM_LAB/lab/view/PeriodTimerNode'],function( require ) {
  'use strict';

  // modules
  var ArrowVisibilityPanel = require( 'PENDULUM_LAB/lab/view/ArrowVisibilityPanel' );
  var EnergyScreenView = require( 'PENDULUM_LAB/energy/view/EnergyScreenView' );
  var inherit = require( 'PHET_CORE/inherit' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var PeriodTimerNode = require( 'PENDULUM_LAB/lab/view/PeriodTimerNode' );

  /**
   * @constructor
   *
   * @param {PendulumLabModel} model
   */
  function LabScreenView( model ) {
    EnergyScreenView.call( this, model, {
      hasGravityTweakers: true,
      hasPeriodTimer: true
    } );

    // create arrow panel node to the bottom layer
    var arrowsPanelNode = new ArrowVisibilityPanel( model.isVelocityVisibleProperty, model.isAccelerationVisibleProperty, {
      left: this.layoutBounds.left + PendulumLabConstants.PANEL_PADDING,
      top: this.layoutBounds.top + PendulumLabConstants.PANEL_PADDING
    } );
    this.arrowsPanelLayer.addChild( arrowsPanelNode );

    var periodTimerNode = new PeriodTimerNode( model.periodTimer, model.pendula[ 1 ].isVisibleProperty, this.layoutBounds );
    this.periodTimerLayer.addChild( periodTimerNode );

    // layout the nodes
    periodTimerNode.right = this.rightPanelsContainer.left - 10;
    periodTimerNode.centerY = this.stopwatchNode.centerY;
    // move energyGraphNode to the bottom
    this.energyGraphNode.top = arrowsPanelNode.bottom + PendulumLabConstants.PANEL_PADDING;

    model.periodTimer.setInitialLocationValue( periodTimerNode.center );

    // set dynamical dragBounds to keep the periodTimer within the visibleBounds
    this.visibleBoundsProperty.link( function( visibleBounds ) {
      periodTimerNode.movableDragHandler.dragBounds = visibleBounds.erodedXY( periodTimerNode.width / 2, periodTimerNode.height / 2 );
    } );

    this.resizeEnergyGraphToFit();
  }

  pendulumLab.register( 'LabScreenView', LabScreenView );

  return inherit( EnergyScreenView, LabScreenView );
} );


define("string!PENDULUM_LAB/screen.lab",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/screen.lab");});


define("mipmap!PENDULUM_LAB/lab-navbar-icon.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["PENDULUM_LAB/lab-navbar-icon.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );


define("mipmap!PENDULUM_LAB/lab-screen-icon.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["PENDULUM_LAB/lab-screen-icon.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Lab screen.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'PENDULUM_LAB/lab/LabScreen',['require','SCENERY/nodes/Image','PHET_CORE/inherit','PENDULUM_LAB/lab/model/LabModel','PENDULUM_LAB/lab/view/LabScreenView','PENDULUM_LAB/pendulumLab','PENDULUM_LAB/common/PendulumLabConstants','AXON/Property','JOIST/Screen','string!PENDULUM_LAB/screen.lab','mipmap!PENDULUM_LAB/lab-navbar-icon.png','mipmap!PENDULUM_LAB/lab-screen-icon.png'],function( require ) {
  'use strict';

  // modules
  var Image = require( 'SCENERY/nodes/Image' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LabModel = require( 'PENDULUM_LAB/lab/model/LabModel' );
  var LabScreenView = require( 'PENDULUM_LAB/lab/view/LabScreenView' );
  var pendulumLab = require( 'PENDULUM_LAB/pendulumLab' );
  var PendulumLabConstants = require( 'PENDULUM_LAB/common/PendulumLabConstants' );
  var Property = require( 'AXON/Property' );
  var Screen = require( 'JOIST/Screen' );

  // strings
  var screenLabString = require( 'string!PENDULUM_LAB/screen.lab' );

  // images
  var labNavbarImage = require( 'mipmap!PENDULUM_LAB/lab-navbar-icon.png' );
  var labScreenImage = require( 'mipmap!PENDULUM_LAB/lab-screen-icon.png' );

  /**
   * @constructor
   */
  function LabScreen() {

    var options = {
      name: screenLabString,
      backgroundColorProperty: new Property( PendulumLabConstants.BACKGROUND_COLOR ),
      homeScreenIcon: new Image( labScreenImage ),
      navigationBarIcon: new Image( labNavbarImage )
    };

    Screen.call( this,
      function() { return new LabModel(); },
      function( model ) { return new LabScreenView( model ); },
      options
    );
  }

  pendulumLab.register( 'LabScreen', LabScreen );

  return inherit( Screen, LabScreen );
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Highlight node for navigation bar screen buttons, phet button, etc.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'JOIST/HighlightNode',['require','SCENERY/util/Color','SCENERY/nodes/HBox','PHET_CORE/inherit','SCENERY/util/LinearGradient','SCENERY/nodes/Rectangle','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var joist = require( 'JOIST/joist' );

  /**
   * @param {number} width
   * @param {number} height
   * @param {Object} [options]
   * @constructor
   */
  function HighlightNode( width, height, options ) {

    options = _.extend( {
      fill: 'white',
      highlightWidth: 1,
      pickable: false
    }, options );

    var innerColor = options.fill;
    var outerColor = Color.toColor( innerColor ).withAlpha( 0 ); // transparent

    var barOptions = {
      fill: new LinearGradient( 0, 0, 0, height )
        .addColorStop( 0, outerColor )
        .addColorStop( 0.5, innerColor )
        .addColorStop( 1, outerColor )
    };
    var leftBar = new Rectangle( 0, 0, options.highlightWidth, height, barOptions );
    var rightBar = new Rectangle( 0, 0, options.highlightWidth, height, barOptions );

    options.children = [ leftBar, rightBar ];
    options.spacing = width;
    HBox.call( this, options );
  }

  joist.register( 'HighlightNode', HighlightNode );

  return inherit( HBox, HighlightNode );
} );

// Copyright 2016, University of Colorado Boulder

/**
 * Wrapper type for JustButton
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 * @author Andrea Lin (PhET Interactive Simulations)
 */
define( 'JOIST/TJoistButton',['require','SCENERY/nodes/TNode','JOIST/joist','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );
  var joist = require( 'JOIST/joist' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * @param {JoistButton} joistButton
   * @param {string} phetioID
   * @constructor
   */
  function TJoistButton( joistButton, phetioID ) {
    assertInstanceOf( joistButton, phet.joist.JoistButton );
    TNode.call( this, joistButton, phetioID );

    // Add button fire events to the data stream.
    toEventOnEmit(
      joistButton.buttonModel.startedCallbacksForFiredEmitter,
      joistButton.buttonModel.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired'
    );
  }

  phetioInherit( TNode, 'TJoistButton', TJoistButton, {}, {
    documentation: 'The buttons used in the home screen and navigation bar',
    events: [ 'fired' ]
  } );

  joist.register( 'TJoistButton', TJoistButton );

  return TJoistButton;
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Base class for Joist buttons such as the "home" button and "PhET" button that show custom highlighting on mouseover.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/JoistButton',['require','SCENERY/nodes/Node','PHET_CORE/inherit','KITE/Shape','JOIST/HighlightNode','SUN/buttons/ButtonListener','SUN/buttons/PushButtonInteractionStateProperty','SUN/buttons/PushButtonModel','AXON/Property','JOIST/joist','JOIST/TJoistButton'],function( require ) {
  'use strict';

  // modules
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var HighlightNode = require( 'JOIST/HighlightNode' );
  var ButtonListener = require( 'SUN/buttons/ButtonListener' );
  var PushButtonInteractionStateProperty = require( 'SUN/buttons/PushButtonInteractionStateProperty' );
  var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
  var Property = require( 'AXON/Property' );
  var joist = require( 'JOIST/joist' );
  var TJoistButton = require( 'JOIST/TJoistButton' );

  /**
   * @param {Node} content - the scenery node to render as the content of the button
   * @param {Property.<string>} navigationBarFillProperty - the color of the navbar, as a string.
   * @param {Tandem} tandem
   * @param {Object} [options] Unused in client code.
   * @constructor
   */
  function JoistButton( content, navigationBarFillProperty, tandem, options ) {

    options = _.extend( {
      cursor: 'pointer', // {string}
      listener: null, // {function}

      //Customization for the highlight region, see overrides in HomeButton and PhetButton
      highlightExtensionWidth: 0,
      highlightExtensionHeight: 0,
      highlightCenterOffsetX: 0,
      highlightCenterOffsetY: 0,

      phetioType: TJoistButton
    }, options );

    options.tandem = tandem;

    // @public (phet-io) - Button model
    this.buttonModel = new PushButtonModel( options );

    // Create both highlights and only make the one visible that corresponds to the color scheme
    var createHighlight = function( fill ) {

      return new HighlightNode( content.width + options.highlightExtensionWidth, content.height + options.highlightExtensionHeight, {
        centerX: content.centerX + options.highlightCenterOffsetX,
        centerY: content.centerY + options.highlightCenterOffsetY,
        fill: fill,
        pickable: false
      } );
    };

    // Highlight against the black background
    var brightenHighlight = createHighlight( 'white' );

    // Highlight against the white background
    var darkenHighlight = createHighlight( 'black' );

    Node.call( this, { children: [ content, brightenHighlight, darkenHighlight ] } );

    // Button interactions
    var interactionStateProperty = new PushButtonInteractionStateProperty( this.buttonModel );

    // @protected
    this.interactionStateProperty = interactionStateProperty;

    // Update the highlights based on whether the button is highlighted and whether it is against a light or dark background.
    Property.multilink( [ interactionStateProperty, navigationBarFillProperty ], function( interactionState, navigationBarFill ) {
      var useDarkenHighlight = navigationBarFill !== 'black';
      brightenHighlight.visible = !useDarkenHighlight && (interactionState === 'over' || interactionState === 'pressed');
      darkenHighlight.visible = useDarkenHighlight && (interactionState === 'over' || interactionState === 'pressed');
    } );

    this.addInputListener( new ButtonListener( this.buttonModel ) );

    // eliminate interactivity gap between label and button
    this.mouseArea = this.touchArea = Shape.bounds( this.bounds );

    this.mutate( options );
  }

  joist.register( 'JoistButton', JoistButton );

  return inherit( Node, JoistButton );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * The Home button that appears in the navigation bar.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/HomeButton',['require','SUN/FontAwesomeNode','PHET_CORE/inherit','JOIST/JoistButton','SCENERY/nodes/Node','AXON/Property','SCENERY/nodes/Rectangle','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var JoistButton = require( 'JOIST/JoistButton' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var joist = require( 'JOIST/joist' );

  /**
   * @param {number} navBarHeight
   * @param {Property.<string>} navigationBarFillProperty - the color of the navbar, as a string.
   * @param {Tandem} tandem
   * @param {Object} [options]
   * @constructor
   */
  function HomeButton( navBarHeight, navigationBarFillProperty, tandem, options ) {

    options = _.extend( {
      highlightExtensionWidth: 4,
      listener: null
    }, options );

    var homeIcon = new FontAwesomeNode( 'home' );
    // scale so that the icon is slightly taller than screen button icons, value determined empirically, see joist#127
    homeIcon.setScaleMagnitude( 0.48 * navBarHeight / homeIcon.height );

    // transparent background, size determined empirically so that highlight is the same size as highlight on screen buttons
    var background = new Rectangle( 0, 0, homeIcon.width + 12, navBarHeight );
    homeIcon.center = background.center;

    var content = new Node( { children: [ background, homeIcon ] } );

    JoistButton.call( this, content, navigationBarFillProperty, tandem, options );

    Property.multilink( [ this.interactionStateProperty, navigationBarFillProperty ], function( interactionState, navigationBarFill ) {
      if ( navigationBarFill === 'black' ) {
        homeIcon.fill = interactionState === 'pressed' ? 'gray' : 'white';
      }
      else {
        homeIcon.fill = interactionState === 'pressed' ? '#444' : '#222';
      }
    } );
  }

  joist.register( 'HomeButton', HomeButton );

  return inherit( JoistButton, HomeButton );
} );
// Copyright 2016, University of Colorado Boulder

/**
 * Wrapper type for NavigationBarScreenButton
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'JOIST/TNavigationBarScreenButton',['require','JOIST/joist','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var joist = require( 'JOIST/joist' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * @param {NavigationBarScreenButton} navigationBarScreenButton
   * @param {string} phetioID
   * @constructor
   */
  function TNavigationBarScreenButton( navigationBarScreenButton, phetioID ) {
    assertInstanceOf( navigationBarScreenButton, phet.joist.NavigationBarScreenButton );
    TNode.call( this, navigationBarScreenButton, phetioID );

    // Send a message on the data stream when the button is pressed.
    toEventOnEmit(
      navigationBarScreenButton.buttonModel.startedCallbacksForFiredEmitter,
      navigationBarScreenButton.buttonModel.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired'
    );
  }

  phetioInherit( TNode, 'TNavigationBarScreenButton', TNavigationBarScreenButton, {}, {
    documentation: 'A pressable button in the simulation\'s navigation bar',
    events: [ 'fired' ]
  } );

  joist.register( 'TNavigationBarScreenButton', TNavigationBarScreenButton );

  return TNavigationBarScreenButton;
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Button for a single screen in the navigation bar, shows the text and the navigation bar icon.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'JOIST/NavigationBarScreenButton',['require','SUN/buttons/ButtonListener','AXON/DerivedProperty','JOIST/HighlightNode','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','AXON/Property','SUN/buttons/PushButtonModel','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','DOT/Util','SCENERY/nodes/VBox','JOIST/joist','TANDEM/Tandem','SCENERY_PHET/PhetColorScheme','JOIST/TNavigationBarScreenButton'],function( require ) {
  'use strict';

  // modules
  var ButtonListener = require( 'SUN/buttons/ButtonListener' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var HighlightNode = require( 'JOIST/HighlightNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Property = require( 'AXON/Property' );
  var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var joist = require( 'JOIST/joist' );
  var Tandem = require( 'TANDEM/Tandem' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var TNavigationBarScreenButton = require( 'JOIST/TNavigationBarScreenButton' );

  // constants
  var HIGHLIGHT_SPACING = 4;

  /**
   * Create a nav bar.  Layout assumes all of the screen widths are the same.
   * @param {Property.<string>} navigationBarFillProperty - the color of the navbar, as a string.
   * @param {Property.<number>} screenIndexProperty
   * @param {Array.<Screen>} screens - all of the available sim content screens (excluding the home screen)
   * @param {Screen} screen
   * @param {number} navBarHeight
   * @param {Object} [options]
   * @constructor
   */
  function NavigationBarScreenButton( navigationBarFillProperty, screenIndexProperty, screens, screen, navBarHeight, options ) {

    assert && assert( screen.name, 'name is required for screen ' + screens.indexOf( screen ) );
    assert && assert( screen.navigationBarIcon, 'navigationBarIcon is required for screen ' + screen.name );

    function clicked() {
      screenIndexProperty.value = screens.indexOf( screen );
    }

    options = _.extend( {
      cursor: 'pointer',
      textDescription: screen.name + ' Screen: Button',
      tandem: Tandem.tandemRequired(),
      phetioType: TNavigationBarScreenButton,
      maxButtonWidth: null // {number|null} the maximum width of the button, causes text and/or icon to be scaled down if necessary
    }, options );

    Node.call( this );

    // icon
    var icon = new Node( {
      children: [ screen.navigationBarIcon ], // wrap in case this icon is used in multiple place (eg, home screen and navbar)
      maxHeight: 0.625 * navBarHeight,
      tandem: options.tandem.createTandem( 'icon' )
    } );

    // Is this button's screen selected?
    var selectedProperty = new DerivedProperty( [ screenIndexProperty ], function( screenIndex ) {
      return screenIndex === screens.indexOf( screen );
    } );

    // @public (phet-io) - create the button model, needs to be public so that PhET-iO wrappers can hook up to it if needed
    this.buttonModel = new PushButtonModel( {
      listener: clicked,
      tandem: options.tandem.createTandem( 'buttonModel' )
    } );
    this.addInputListener( new ButtonListener( this.buttonModel ) );

    var text = new Text( screen.name, {
      font: new PhetFont( 10 ),
      tandem: options.tandem.createTandem( 'text' )
    } );

    var box = new VBox( {
      children: [ icon, text ],
      pickable: false,
      spacing: Math.max( 0, 12 - text.height ), // see https://github.com/phetsims/joist/issues/143
      usesOpacity: true, // hint, since we change its opacity
      maxHeight: navBarHeight
    } );

    // add a transparent overlay for input handling and to size touchArea/mouseArea
    var overlay = new Rectangle( 0, 0, box.width, box.height, { center: box.center } );

    // highlights
    var highlightWidth = overlay.width + ( 2 * HIGHLIGHT_SPACING );
    var brightenHighlight = new HighlightNode( highlightWidth, overlay.height, {
      center: box.center,
      fill: 'white'
    } );
    var darkenHighlight = new HighlightNode( highlightWidth, overlay.height, {
      center: box.center,
      fill: 'black'
    } );

    this.addChild( box );
    this.addChild( overlay );
    this.addChild( brightenHighlight );
    this.addChild( darkenHighlight );

    // manage interaction feedback
    Property.multilink( [
      selectedProperty,
      this.buttonModel.downProperty,
      this.buttonModel.overProperty,
      navigationBarFillProperty
    ], function update( selected, down, over, navigationBarFill ) {

      var useDarkenHighlights = ( navigationBarFill !== 'black' );

      // Color match yellow with the PhET Logo
      var selectedTextColor = useDarkenHighlights ? 'black' : PhetColorScheme.PHET_LOGO_YELLOW;
      var unselectedTextColor = useDarkenHighlights ? 'gray' : 'white';

      text.fill = selected ? selectedTextColor : unselectedTextColor;
      box.opacity = selected ? 1.0 : ( down ? 0.65 : 0.5 );
      brightenHighlight.visible = !useDarkenHighlights && ( over || down );
      darkenHighlight.visible = useDarkenHighlights && ( over || down );
    } );

    // Constrain text and icon width, if necessary
    if ( options.maxButtonWidth && ( this.width > options.maxButtonWidth ) ) {

      text.maxWidth = icon.maxWidth = options.maxButtonWidth - ( this.width - box.width );

      // adjust the overlay
      overlay.setRect( 0, 0, box.width, overlay.height );
      overlay.center = box.center;

      // adjust the highlights
      brightenHighlight.spacing = darkenHighlight.spacing = overlay.width + ( 2 * HIGHLIGHT_SPACING );
      brightenHighlight.center = darkenHighlight.center = box.center;

      assert && assert( Util.toFixed( this.width, 0 ) === Util.toFixed( options.maxButtonWidth, 0 ) );
    }
    else {

      // Don't allow the text to grow larger than the icon if changed later on using PhET-iO, see #438
      // Text is allowed to go beyond the bounds of the icon, hence we use `this.width` instead of `icon.width`
      text.maxWidth = this.width;
    }

    this.mutate( options );
  }

  joist.register( 'NavigationBarScreenButton', NavigationBarScreenButton );

  return inherit( Node, NavigationBarScreenButton );
} );


define("string!JOIST/credits.contributors",function(){return window.phet.chipper.strings.get("JOIST/credits.contributors");});


define("string!JOIST/credits.graphicArts",function(){return window.phet.chipper.strings.get("JOIST/credits.graphicArts");});


define("string!JOIST/credits.leadDesign",function(){return window.phet.chipper.strings.get("JOIST/credits.leadDesign");});


define("string!JOIST/credits.qualityAssurance",function(){return window.phet.chipper.strings.get("JOIST/credits.qualityAssurance");});


define("string!JOIST/credits.softwareDevelopment",function(){return window.phet.chipper.strings.get("JOIST/credits.softwareDevelopment");});


define("string!JOIST/credits.team",function(){return window.phet.chipper.strings.get("JOIST/credits.team");});


define("string!JOIST/credits.thanks",function(){return window.phet.chipper.strings.get("JOIST/credits.thanks");});


define("string!JOIST/credits.title",function(){return window.phet.chipper.strings.get("JOIST/credits.title");});


define("string!JOIST/credits.translation",function(){return window.phet.chipper.strings.get("JOIST/credits.translation");});

// Copyright 2015, University of Colorado Boulder

/**
 * Displays the credits section in the About dialog
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/CreditsNode',['require','JOIST/joist','PHET_CORE/inherit','PHETCOMMON/util/StringUtils','SCENERY/nodes/RichText','SCENERY/nodes/Text','SCENERY/nodes/VBox','SCENERY/nodes/VStrut','SCENERY_PHET/PhetFont','string!JOIST/credits.contributors','string!JOIST/credits.graphicArts','string!JOIST/credits.leadDesign','string!JOIST/credits.qualityAssurance','string!JOIST/credits.softwareDevelopment','string!JOIST/credits.team','string!JOIST/credits.thanks','string!JOIST/credits.title','string!JOIST/credits.translation'],function( require ) {
  'use strict';

  // modules
  var joist = require( 'JOIST/joist' );
  var inherit = require( 'PHET_CORE/inherit' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var RichText = require( 'SCENERY/nodes/RichText' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var VStrut = require( 'SCENERY/nodes/VStrut' );
  // var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );

  // strings
  var creditsContributorsString = require( 'string!JOIST/credits.contributors' );
  var creditsGraphicArtsString = require( 'string!JOIST/credits.graphicArts' );
  var creditsLeadDesignString = require( 'string!JOIST/credits.leadDesign' );
  var creditsQualityAssuranceString = require( 'string!JOIST/credits.qualityAssurance' );
  var creditsSoftwareDevelopmentString = require( 'string!JOIST/credits.softwareDevelopment' );
  var creditsTeamString = require( 'string!JOIST/credits.team' );
  var creditsThanksString = require( 'string!JOIST/credits.thanks' );
  var creditsTitleString = require( 'string!JOIST/credits.title' );
  var creditsTranslationString = require( 'string!JOIST/credits.translation' );

  /**
   * Creates node that displays the credits.
   * @param {Object} credits - see implementation herein for supported {string} fields
   * @param {Object} [options]
   * @constructor
   */
  function CreditsNode( credits, options ) {

    options = _.extend( {
      align: 'left',
      spacing: 1,
      maxWidth: 550
    }, options );

    var titleFont = new PhetFont( { size: 14, weight: 'bold' } );
    var font = new PhetFont( 12 );
    var multiLineTextOptions = { font: font, align: 'left', lineWrap: options.maxWidth };
    var children = [];

    // Credits
    children.push( new Text( creditsTitleString, {
      font: titleFont,

      // a11y
      tagName: 'h2',
      accessibleLabel: creditsTitleString
    } ) );
    if ( credits.leadDesign ) {
      children.push( new RichText( StringUtils.format( creditsLeadDesignString, '\u202a' + credits.leadDesign + '\u202c' ), multiLineTextOptions ) );
    }
    if ( credits.softwareDevelopment ) {
      children.push( new RichText( StringUtils.format( creditsSoftwareDevelopmentString, '\u202a' + credits.softwareDevelopment + '\u202c' ), multiLineTextOptions ) );
    }
    if ( credits.team ) {
      children.push( new RichText( StringUtils.format( creditsTeamString, '\u202a' + credits.team + '\u202c' ), multiLineTextOptions ) );
    }
    if ( credits.contributors ) {
      children.push( new RichText( StringUtils.format( creditsContributorsString, '\u202a' + credits.contributors + '\u202c' ), multiLineTextOptions ) );
    }
    if ( credits.qualityAssurance ) {
      children.push( new RichText( StringUtils.format( creditsQualityAssuranceString, '\u202a' + credits.qualityAssurance + '\u202c' ), multiLineTextOptions ) );
    }
    if ( credits.graphicArts ) {
      children.push( new RichText( StringUtils.format( creditsGraphicArtsString, '\u202a' + credits.graphicArts + '\u202c' ), multiLineTextOptions ) );
    }

    //TODO obtain translation credit from strings file, see https://github.com/phetsims/joist/issues/163
    // Translation
    if ( credits.translation ) {
      if ( children.length > 0 ) { children.push( new VStrut( 10 ) ); }
      children.push( new Text( creditsTranslationString, {
        font: titleFont,
        tagName: 'h2',
        accessibleLabel: creditsTranslationString
      } ) );
      children.push( new RichText( credits.translation, multiLineTextOptions ) );
    }

    // Thanks
    if ( credits.thanks ) {
      if ( children.length > 0 ) { children.push( new VStrut( 10 ) ); }
      children.push( new Text( creditsThanksString, {
        font: titleFont,
        tagName: 'h2',
        accessibleLabel: creditsThanksString
      } ) );
      children.push( new RichText( credits.thanks, multiLineTextOptions ) );
    }

    assert && assert( !options.children, 'this node sets its own children' );
    options.children = children;

    VBox.call( this, options );

    this.disposeCreditsNode = function() {
      children.forEach( function( child ) {
        child.dispose && child.dispose();
      } );
    };
  }

  joist.register( 'CreditsNode', CreditsNode );

  return inherit( VBox, CreditsNode, {
    dispose: function() {
      this.disposeCreditsNode();
      VBox.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2014-2015, University of Colorado Boulder

/**
 * Push button with text on a rectangle.
 *
 * @author John Blanco (PhET Interactive Simulations)
 */
define( 'SUN/buttons/TextPushButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularPushButton','SUN/sun','SCENERY/nodes/Text','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var sun = require( 'SUN/sun' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {string} text
   * @param {Object} [options]
   * @constructor
   */
  function TextPushButton( text, options ) {

    options = _.extend( {
      textFill: 'black',
      maxTextWidth: null,
      tandem: Tandem.tandemRequired(),

      // a11y
      accessibleLabel: text
    }, options );

    var textNode = new Text( text, {
      font: options.font,
      fill: options.textFill,
      maxWidth: options.maxTextWidth,
      tandem: options.tandem.createTandem( 'textNode' )
    } );

    RectangularPushButton.call( this, _.extend( { content: textNode }, options ) );
  }

  sun.register( 'TextPushButton', TextPushButton );

  return inherit( RectangularPushButton, TextPushButton );
} );

// Copyright 2015-2017, University of Colorado Boulder

/**
 * A spinnable busy indicator, to indicate something behind the scenes is in progress (but with no indication of how
 * far along it is).
 *
 * The actual rectangles/circles/etc. (called elements in the documentation) stay in fixed positions, but their fill is
 * changed to give the impression of rotation.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'SCENERY_PHET/SpinningIndicatorNode',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/Circle','SCENERY/util/Color','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var Color = require( 'SCENERY/util/Color' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );

  /**
   * @param {Object} options
   * @constructor
   */
  function SpinningIndicatorNode( options ) {
    Tandem.indicateUninstrumentedCode();

    // default options
    options = _.extend( {
      indicatorSize: 15, // {number} - The width/height taken up by the indicator.
      indicatorSpeed: 1, // {number} - A multiplier for how fast/slow the indicator will spin.
      elementFactory: SpinningIndicatorNode.rectangleFactory, // {function( options ) => {Node}} - To create the elements
      elementQuantity: 16, // {number} - How many elements should exist
      activeColor: 'rgba(0,0,0,1)', // {string|Color} - The active "mostly visible" color at the lead.
      inactiveColor: 'rgba(0,0,0,0.15)' // {string|Color} - The inactive "mostly invisible" color at the tail.
    }, options );
    this.options = options;

    Node.call( this, options );

    this.indicatorRotation = Math.PI * 2; // @private Current angle of rotation (starts at 2pi so our modulo opreation is safe below)

    // parse the colors (if necessary) so we can quickly interpolate between the two
    this.activeColor = new Color( options.activeColor ); // @private
    this.inactiveColor = new Color( options.inactiveColor ); // @private

    // @private the angle between each element
    this.angleDelta = 2 * Math.PI / options.elementQuantity;

    // @private create and add all of the elements
    this.elements = [];
    var angle = 0;
    for ( var i = 0; i < options.elementQuantity; i++ ) {
      var element = options.elementFactory( this.options );

      // push the element to the outside of the circle
      element.right = options.indicatorSize / 2;

      // center it vertically, so it can be rotated nicely into place
      element.centerY = 0;

      // rotate each element by its specific angle
      element.rotate( angle, true );

      angle += this.angleDelta;
      this.elements.push( element );
      this.addChild( element );
    }

    this.step( 0 ); // initialize colors
  }

  sceneryPhet.register( 'SpinningIndicatorNode', SpinningIndicatorNode );

  return inherit( Node, SpinningIndicatorNode, {

    // @public
    step: function( dt ) {
      // increment rotation based on DT
      this.indicatorRotation += dt * 10.0 * this.options.indicatorSpeed;

      // update each element
      var angle = this.indicatorRotation;
      for ( var i = 0; i < this.elements.length; i++ ) {
        // a number from 0 (active head) to 1 (inactive tail).
        var ratio = Math.pow( ( angle / ( 2 * Math.PI ) ) % 1, 0.5 );

        // Smoother transition, mapping our ratio from [0,0.2] => [1,0] and [0.2,1] => [0,1].
        // Otherwise, elements can instantly switch from one color to the other, which is visually displeasing.
        if ( ratio < 0.2 ) {
          ratio = 1 - ratio * 5;
        }
        else {
          ratio = ( ratio - 0.2 ) * 10 / 8;
        }

        // Fill it with the interpolated color
        var red = ratio * this.inactiveColor.red + ( 1 - ratio ) * this.activeColor.red;
        var green = ratio * this.inactiveColor.green + ( 1 - ratio ) * this.activeColor.green;
        var blue = ratio * this.inactiveColor.blue + ( 1 - ratio ) * this.activeColor.blue;
        var alpha = ratio * this.inactiveColor.alpha + ( 1 - ratio ) * this.activeColor.alpha;
        this.elements[i].fill = new Color( red, green, blue, alpha );

        // And rotate to the next element (in the opposite direction, so our motion is towards the head)
        angle -= this.angleDelta;
      }
    }
  }, {
    // @static Factory method for creating rectangular-shaped elements, sized to fit.
    rectangleFactory: function( options ) {
      return new Rectangle( 0, 0, options.indicatorSize * 0.175, 1.2 * options.indicatorSize / options.elementQuantity );
    },

    // @static Factory method for creating circle-shaped elements, sized to fit.
    circleFactory: function( options ) {
      return new Circle( 0.8 * options.indicatorSize / options.elementQuantity );
    }
  } );
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Make the package.json contents available to the simulation, so it can access the version, sim name, etc.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/packageJSON',['require','JOIST/joist','text!REPOSITORY/package.json'],function( require ) {
  'use strict';

  // modules
  var joist = require( 'JOIST/joist' );

  // strings
  var packageString = require( 'text!REPOSITORY/package.json' );

  var packageJSON = JSON.parse( packageString );

  packageJSON.version = window.getVersionForBrand( phet.chipper.brand, packageJSON.version );

  joist.register( 'packageJSON', packageJSON );

  return packageJSON;
} );
// Copyright 2015, University of Colorado Boulder

/**
 * Object representing a simulation version, with optional build timestamp information (conceptually part of the version
 * for potential version comparisons).
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/SimVersion',['require','PHET_CORE/inherit','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );

  /**
   * @param {Object} version - major/minor/maintenance are required
   * @constructor
   */
  function SimVersion( version ) {
    assert && assert( version.major !== undefined );
    assert && assert( version.minor !== undefined );
    assert && assert( version.maintenance !== undefined );

    this.major = version.major; // @public - {number} major - Major version number
    this.minor = version.minor; // @public - {number} minor - Major version number
    this.maintenance = version.maintenance; // @public - {number} maintenance - Major version number
    this.suffix = version.suffix; // @public - {string} [suffix] - Optional suffix (like 'dev.3')
    this.buildTimestamp = version.buildTimestamp; // @public - {string} [buildTimestamp] - Optional build timestamp,
                                                  // like '2015-06-12 16:05:03 UTC' (phet.chipper.buildTimestamp)
  }

  joist.register( 'SimVersion', SimVersion );

  return inherit( Object, SimVersion, {

    /**
     * Compares versions, returning -1 if this version is before the passed in version, 0 if equal, or 1 if this version
     * is after.
     *
     * This function only compares major/minor/maintenance, leaving suffix/buildTimestamp comparisons for the client
     * for now.
     *
     * @param {SimVersion} version
     * @public
     */
    compare: function( version ) {
      if ( this.major < version.major ) { return -1; }
      if ( this.major > version.major ) { return 1; }
      if ( this.minor < version.minor ) { return -1; }
      if ( this.minor > version.minor ) { return 1; }
      if ( this.maintenance < version.maintenance ) { return -1; }
      if ( this.maintenance > version.maintenance ) { return 1; }
      return 0; // equal
    },

    /**
     * @returns {boolean|*}
     * @public
     */
    get isSimNotPublished() {
      return this.major < 1 || // e.g. 0.0.0-dev.1
             ( this.major === 1 && // e.g. 1.0.0-dev.1
               this.minor === 0 &&
               this.maintenance === 0 &&
               this.suffix );
    },

    /**
     * @returns {string}
     * @public
     */
    toString: function() {
      return this.major + '.' + this.minor + '.' + this.maintenance + ( this.suffix ? '-' + this.suffix : '' );
    }
  }, {
    /**
     * @param {string} versionString - e.g. '1.0.0', '1.0.1-dev.3', etc.
     * @param {string} [buildTimestamp] - Optional build timestamp, like '2015-06-12 16:05:03 UTC' (phet.chipper.buildTimestamp)
     * @public
     */
    parse: function( versionString, buildTimestamp ) {
      var matches = versionString.match( /(\d+)\.(\d+)\.(\d+)(-(.+))?/ );

      if ( !matches ) {
        throw new Error( 'could not parse version: ' + versionString );
      }

      return new SimVersion( {
        major: parseInt( matches[ 1 ], 10 ),
        minor: parseInt( matches[ 2 ], 10 ),
        maintenance: parseInt( matches[ 3 ], 10 ),
        suffix: matches[ 5 ],
        buildTimestamp: buildTimestamp
      } );
    }
  } );
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Creates the namespace for this repository.
 *
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'BRAND/../../js/brand',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';

  // modules
  var Namespace = require( 'PHET_CORE/Namespace' );

  return new Namespace( 'brand' );
} );

define("string!JOIST/termsPrivacyAndLicensing",function(){return window.phet.chipper.strings.get("JOIST/termsPrivacyAndLicensing");});


define("string!JOIST/translation.credits.link",function(){return window.phet.chipper.strings.get("JOIST/translation.credits.link");});


define("string!JOIST/thirdParty.credits.link",function(){return window.phet.chipper.strings.get("JOIST/thirdParty.credits.link");});

// Copyright 2002-2014, University of Colorado Boulder

// Returns branding information for the simulations, see https://github.com/phetsims/brand/issues/1
define( 'BRAND/Brand',['require','BRAND/../../js/brand','string!JOIST/termsPrivacyAndLicensing','string!JOIST/translation.credits.link','string!JOIST/thirdParty.credits.link'],function( require ) {
  'use strict';

  // modules
  var brand = require( 'BRAND/../../js/brand' );

  // strings
  var termsPrivacyAndLicensingString = require( 'string!JOIST/termsPrivacyAndLicensing' );
  var translationCreditsLinkString = require( 'string!JOIST/translation.credits.link' );
  var thirdPartyCreditsLinkString = require( 'string!JOIST/thirdParty.credits.link' );

  // Documentation for all properties is available in brand/adapted-from-phet/js/Brand.js
  var Brand = {
    id: 'phet',
    name: 'PhET\u2122 Interactive Simulations', // no i18n
    copyright: 'Copyright © 2002-{{year}} University of Colorado Boulder', // no i18n
    isPhetApp: phet.chipper.queryParameters[ 'phet-app' ] || phet.chipper.queryParameters[ 'phet-android-app' ],
    getLinks: function( simName, locale ) {
      return [
        {
          text: termsPrivacyAndLicensingString,
          url: 'http://phet.colorado.edu/en/licensing/html'
        },
        {
          text: translationCreditsLinkString,
          url: 'http://phet.colorado.edu/translation-credits?simName=' + encodeURIComponent( simName ) +
               '&locale=' + encodeURIComponent( locale )
        },
        {
          text: thirdPartyCreditsLinkString,
          url: 'http://phet.colorado.edu/third-party-credits?simName=' + encodeURIComponent( simName ) +
               '&locale=' + encodeURIComponent( locale ) + '#' + simName
        } ];
    }
  };

  brand.register( 'Brand', Brand );

  return Brand;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * A singleton type/object for handling checking whether our simulation is up-to-date, or whether there is an
 * updated version. See https://github.com/phetsims/joist/issues/189
 *
 * It exposes its current state (for UIs to hook into), and a check() function used to start checking the version.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/UpdateCheck',['require','PHET_CORE/inherit','AXON/Property','JOIST/packageJSON','JOIST/SimVersion','BRAND/Brand','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var packageJSON = require( 'JOIST/packageJSON' ); // parse name/version out of the package.json
  var SimVersion = require( 'JOIST/SimVersion' );
  var Brand = require( 'BRAND/Brand' );
  var joist = require( 'JOIST/joist' );

  var simName = packageJSON.name;
  var simVersion = SimVersion.parse( packageJSON.version, phet.chipper.buildTimestamp );
  var requestProtocolString = ( 'https:' === document.location.protocol ? 'https:' : 'http:' );

  // NOTE: singleton type!
  function UpdateCheck() {

    // @public (joist-internal)
    this.stateProperty = new Property( 'unchecked', {
      validValues: [
        'up-to-date',  // Simulation version is equal to or greater than the currently published version.
        'out-of-date', // Simulation version is less than currently published version (or equal but has a suffix)
        'checking',    // Request to server sent out, has not processed reply yet.
        'offline',     // Last attempt to check failed, most likely offline
        'unchecked'    // No attempt as been made to check the version against the latest online.
      ]
    } );

    // @public (joist-internal) {SimVersion} will be filled in by check() if applicable
    this.latestVersionProperty = new Property( null );

    this.ourVersion = simVersion; // @public (joist-internal) {SimVersion} version of the sim that is running

    this.timeoutCallback = this.timeout.bind( this ); // @public (joist-internal)
  }

  inherit( Object, UpdateCheck, {

    // @public - Whether we actually allow checking for updates, or showing any update-related UIs.
    // If it's not PhET-branded OR if it is phet-io or in the phet-app, do not check for updates
    areUpdatesChecked: Brand.id === 'phet' && !Brand.isPhetApp,

    // @public - The URL to be used for "New version available" clicks
    updateURL: 'http://phet.colorado.edu/html-sim-update' +
               '?simulation=' + encodeURIComponent( simName ) +
               '&version=' + encodeURIComponent( simVersion.toString() ) +
               '&buildTimestamp=' + encodeURIComponent( '' + phet.chipper.buildTimestamp ),

    // @private - Valid only if state === 'checking', the timeout ID of our timeout listener
    timeoutId: -1,

    // @private - How many ms before we time out (set to 'offline')
    timeoutMilliseconds: 15000,

    // @private - Clears our timeout listener.
    clearTimeout: function() {
      window.clearTimeout( this.timeoutId );
    },

    // @private - Sets our timeout listener.
    setTimeout: function() {
      this.timeoutId = window.setTimeout( this.timeoutCallback, this.timeoutMilliseconds );
    },

    // @public - If we are checking, it resets our timeout timer to timeoutMilliseconds
    resetTimeout: function() {
      if ( this.stateProperty.value === 'checking' ) {
        this.clearTimeout();
        this.setTimeout();
      }
    },

    // @private - What happens when we actually time out.
    timeout: function() {
      this.stateProperty.value = 'offline';
    },

    /**
     * @public - Kicks off the version checking request (if able), resulting in state changes.
     */
    check: function() {
      var self = this;

      if ( !this.areUpdatesChecked || ( self.stateProperty.value !== 'unchecked' && self.stateProperty.value !== 'offline' ) ) {
        return;
      }

      // If our sim's version indicates it hasn't been published, don't attempt to send a request for now
      if ( this.ourVersion.isSimNotPublished ) {
        self.stateProperty.value = 'up-to-date';
        return;
      }

      var req = new XMLHttpRequest();

      if ( 'withCredentials' in req ) {
        // we'll be able to send the proper type of request, so we mark ourself as checking
        self.stateProperty.value = 'checking';

        self.setTimeout();

        req.onload = function() {
          self.clearTimeout();

          try {
            var data = JSON.parse( req.responseText );

            if ( data.error ) {
              console.log( 'Update check failure: ' + data.error );
              self.stateProperty.value = 'offline';
            }
            else {
              if ( self.updateURL ) {
                self.updateURL = data.updateURL;
              }
              self.latestVersion = SimVersion.parse( data.latestVersion, data.buildTimestamp );

              if ( data.state === 'out-of-date' || data.state === 'up-to-date' ) {
                self.stateProperty.value = data.state;
              }
              else {
                console.log( 'Failed to get proper state: ' + data.state );
                self.stateProperty.value = 'offline';
              }
            }
          }
          catch( e ) {
            self.stateProperty.value = 'offline';
          }
        };
        req.onerror = function() {
          self.clearTimeout();

          self.stateProperty.value = 'offline';
        };
        req.open( 'post', requestProtocolString + '//phet.colorado.edu/services/check-html-updates', true ); // enable CORS
        req.send( JSON.stringify( {
          api: '1.0',
          simulation: simName,
          locale: phet.joist.sim.locale,
          currentVersion: self.ourVersion.toString(),
          buildTimestamp: phet.chipper.buildTimestamp
        } ) );
      }
    }
  } );

  var singleton = new UpdateCheck();
  joist.register( 'UpdateCheck', singleton );
  return singleton;
} );

// Copyright 2015, University of Colorado Boulder

/**
 * Text that has a handler set up to open a link in a new window when clicked.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/LinkText',['require','PHET_CORE/inherit','SCENERY/nodes/Text','SCENERY/input/ButtonListener','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Text = require( 'SCENERY/nodes/Text' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var joist = require( 'JOIST/joist' );

  function LinkText( text, url, options ) {

    // defaults
    options = _.extend( {
      handleEvent: false // whether the up in the click event should be handled, e.g. to prevent the About dialog closing.
    }, options );

    Text.call( this, text, _.extend( {
      fill: 'rgb(27,0,241)', // blue, like a typical hypertext link
      cursor: 'pointer',

      // a11y
      tagName: 'a',
      accessibleLabel: text
    }, options ) );

    this.addInputListener( new ButtonListener( {
      fire: function( event ) {
        options.handleEvent && event.handle();
        if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
          var newWindow = window.open( url, '_blank' ); // open in a new window/tab
          newWindow.focus();
        }
      }
    } ) );

    // a11y - open the link in the new tab when activated with a keyboard
    this.setAccessibleAttribute( 'href', url );
    this.setAccessibleAttribute( 'target', '_blank' );
  }

  joist.register( 'LinkText', LinkText );

  return inherit( Text, LinkText );
} );

define("string!JOIST/updates.upToDate",function(){return window.phet.chipper.strings.get("JOIST/updates.upToDate");});


define("string!JOIST/updates.outOfDate",function(){return window.phet.chipper.strings.get("JOIST/updates.outOfDate");});


define("string!JOIST/updates.checking",function(){return window.phet.chipper.strings.get("JOIST/updates.checking");});


define("string!JOIST/updates.offline",function(){return window.phet.chipper.strings.get("JOIST/updates.offline");});


define("string!JOIST/updates.newVersionAvailable",function(){return window.phet.chipper.strings.get("JOIST/updates.newVersionAvailable");});


define("string!JOIST/updates.yourCurrentVersion",function(){return window.phet.chipper.strings.get("JOIST/updates.yourCurrentVersion");});


define("string!JOIST/updates.getUpdate",function(){return window.phet.chipper.strings.get("JOIST/updates.getUpdate");});


define("string!JOIST/updates.noThanks",function(){return window.phet.chipper.strings.get("JOIST/updates.noThanks");});

// Copyright 2015, University of Colorado Boulder

/**
 * UI parts for update-related dialogs
 */
define( 'JOIST/UpdateNodes',['require','SCENERY/nodes/HBox','SCENERY/nodes/VBox','SCENERY/nodes/Text','SCENERY/nodes/Rectangle','PHETCOMMON/util/StringUtils','SCENERY_PHET/PhetFont','SUN/FontAwesomeNode','SUN/buttons/TextPushButton','SCENERY_PHET/SpinningIndicatorNode','SCENERY/nodes/VStrut','JOIST/UpdateCheck','JOIST/LinkText','JOIST/joist','string!JOIST/updates.upToDate','string!JOIST/updates.outOfDate','string!JOIST/updates.checking','string!JOIST/updates.offline','string!JOIST/updates.newVersionAvailable','string!JOIST/updates.yourCurrentVersion','string!JOIST/updates.getUpdate','string!JOIST/updates.noThanks'],function( require ) {
  'use strict';

  // modules
  var HBox = require( 'SCENERY/nodes/HBox' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var TextPushButton = require( 'SUN/buttons/TextPushButton' );
  var SpinningIndicatorNode = require( 'SCENERY_PHET/SpinningIndicatorNode' );
  var VStrut = require( 'SCENERY/nodes/VStrut' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var LinkText = require( 'JOIST/LinkText' );
  var joist = require( 'JOIST/joist' );

  // strings
  var updatesUpToDateString = require( 'string!JOIST/updates.upToDate' );
  var updatesOutOfDateString = require( 'string!JOIST/updates.outOfDate' );
  var updatesCheckingString = require( 'string!JOIST/updates.checking' );
  var updatesOfflineString = require( 'string!JOIST/updates.offline' );
  var updatesNewVersionAvailableString = require( 'string!JOIST/updates.newVersionAvailable' );
  var updatesYourCurrentVersionString = require( 'string!JOIST/updates.yourCurrentVersion' );
  var updatesGetUpdateString = require( 'string!JOIST/updates.getUpdate' );
  var updatesNoThanksString = require( 'string!JOIST/updates.noThanks' );

  var updateTextFont = new PhetFont( 14 );

  // Maximum width of the resulting update items
  var MAX_WIDTH = 550;

  var UpdateNodes = {

    /**
     * "Checking" state node. With two size options (if options.big == true, it will be bigger)
     *
     * @param {Object} [options] - passed to the Node
     * @returns {Node} the Checking node, with step( dt ) and stepListener (bound to the node itself)
     * @public (joist-internal)
     */
    createCheckingNode: function( options ) {
      var spinningIndicatorNode = new SpinningIndicatorNode( { indicatorSize: options.big ? 24 : 18 } );
      var checkingNode = new HBox( _.extend( {
        spacing: options.big ? 10 : 8,
        maxWidth: MAX_WIDTH,
        children: [
          spinningIndicatorNode,
          new Text( updatesCheckingString, { font: new PhetFont( options.big ? 16 : 14 ), fontWeight: options.big ? 'bold' : 'normal' } )
        ],

        // a11y
        tagName: 'p',
        accessibleLabel: updatesCheckingString
      }, options ) );
      checkingNode.step = function( dt ) {
        if ( UpdateCheck.stateProperty === 'checking' ) {
          spinningIndicatorNode.step( dt );
        }
      };
      checkingNode.stepListener = checkingNode.step.bind( checkingNode );
      return checkingNode;
    },

    /**
     * "Up-to-date" state node
     * @param {Object} [options] - passed to the Node
     * @returns {Node}
     * @public (joist-internal)
     */
    createUpToDateNode: function( options ) {
      return new HBox( _.extend( {
        spacing: 8,
        maxWidth: MAX_WIDTH,
        children: [
          new Rectangle( 0, 0, 20, 20, 5, 5, { fill: '#5c3', scale: options.big ? 1.2 : 1, children: [
            new FontAwesomeNode( 'check', { fill: '#fff', scale: 0.38, centerX: 10, centerY: 10 } )
          ] } ),
          new Text( updatesUpToDateString, { font: new PhetFont( options.big ? 16 : 14 ), fontWeight: options.big ? 'bold' : 'normal' } )
        ],

        // a11y
        tagName: 'p',
        accessibleLabel: updatesUpToDateString
      }, options ) );
    },

    /**
     * "Out-of-date" state node for the "About" dialog.
     * @param {Object} [options] - passed to the Node
     * @returns {Node}
     * @public (joist-internal)
     */
    createOutOfDateAboutNode: function( options ) {
      return new HBox( _.extend( {
        spacing: 8,
        cursor: 'pointer',
        maxWidth: MAX_WIDTH,
        children: [
          new FontAwesomeNode( 'warning_sign', { fill: '#E87600', scale: 0.5 } ), // "safety orange", according to Wikipedia
          new LinkText( updatesOutOfDateString, UpdateCheck.updateURL, { font: updateTextFont } )
        ],

        // a11y
        tagName: 'div'
      }, options ) );
    },

    /**
     * "Out-of-date" state node for the "Check for udpate" dialog.
     * @param {UpdateDialog} dialog - the dialog, so that it can be closed with the "No thanks..." button
     * @param {string} ourVersionString
     * @param {string} latestVersionString
     * @param {Object} [options] - passed to the Node
     * @returns {Node}
     * @public (joist-internal)
     */
    createOutOfDateDialogNode: function( dialog, ourVersionString, latestVersionString, options ) {
      return new VBox( _.extend( {
        spacing: 15,
        maxWidth: MAX_WIDTH,
        children: [
          new VBox( { spacing: 5, align: 'left', children: [
            new Text( StringUtils.format( updatesNewVersionAvailableString, latestVersionString ), {
              font: new PhetFont( 16 ), fontWeight: 'bold'
            } ),
            new Text( StringUtils.format( updatesYourCurrentVersionString, ourVersionString ), {
              font: updateTextFont
            } )
          ] } ),
          new HBox( { spacing: 25, children: [
            new TextPushButton( updatesGetUpdateString, { baseColor: '#6f6', font: updateTextFont, listener: function() {
              if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
                var newWindow = window.open( UpdateCheck.updateURL, '_blank' ); // open in a new window/tab
                newWindow && newWindow.focus();
              }
            } } ),
            new TextPushButton( updatesNoThanksString, { baseColor: '#ddd', font: updateTextFont, listener: function() {
              dialog.hide();
              // Closing the dialog is handled by the Dialog listener itself, no need to add code to close it here.
            } } )
          ] } )
        ]
      }, options ) );
    },

    /**
     * "Offline" state node
     * @param {Object} [options] - passed to the Node
     * @returns {Node}
     * @public (joist-internal)
     */
    createOfflineNode: function( options ) {
      return new HBox( _.extend( {
        spacing: 0,
        maxWidth: MAX_WIDTH,
        children: [
          new VStrut( 20 ), // spacer to match layout of other nodes
          new Text( updatesOfflineString, { font: new PhetFont( options.big ? 16 : 14 ), fontWeight: options.big ? 'bold' : 'normal' } )
        ],

        // a11y
        tagName: 'p',
        accessibleLabel: updatesOfflineString
      }, options ) );
    }
  };

  joist.register( 'UpdateNodes', UpdateNodes );

  return UpdateNodes;
} );

// Copyright 2017, University of Colorado Boulder

/**
 * Wrapper type for scenery-phet's MultiLineText node.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */
define( 'SCENERY_PHET/TMultiLineText',['require','SCENERY_PHET/sceneryPhet','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/phetioEvents','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';

  // modules
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var phetioEvents = require( 'ifphetio!PHET_IO/phetioEvents' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );

  /**
   * Wrapper type for scenery's Text node.
   * @param {Text} text
   * @param {string} phetioID
   * @constructor
   */
  function TMultiLineText( text, phetioID ) {
    TNode.call( this, text, phetioID );
    assertInstanceOf( text, phet.sceneryPhet.MultiLineText );
    text.on( 'text', function( oldText, newText ) {
      phetioEvents.trigger( 'model', phetioID, TMultiLineText, 'textChanged', {
        oldText: oldText,
        newText: newText
      } );
    } );
  }

  phetioInherit( TNode, 'TMultiLineText', TMultiLineText, {
    setText: {
      returnType: TVoid,
      parameterTypes: [ TString ],
      implementation: function( text ) {
        this.instance.text = text;
      },
      documentation: 'Set the text content'
    },

    getText: {
      returnType: TString,
      parameterTypes: [],
      implementation: function() {
        return this.instance.text;
      },
      documentation: 'Get the text content'
    }
  }, {
    documentation: 'The tandem wrapper type for the scenery phet\'s MultiLineText node'
  } );

  sceneryPhet.register( 'TMultiLineText', TMultiLineText );

  return TMultiLineText;
} );
// Copyright 2013-2017, University of Colorado Boulder

/**
 * DO NOT USE IN NEW DEVELOPMENT. Please use SCENERY/nodes/RichText.
 *
 * MultiLine plain text, with alignment.
 * The line break character is '\n'.
 * Specify alignment via the 'align' option.
 * Text node options can be specified to style the text.
 *
 * Example: new MultiLineText( 'Hello\nWorld', { align: 'left', font: new PhetFont(20), fill: 'red' } );
 *
 * @author Sam Reid
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'SCENERY_PHET/MultiLineText',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','SCENERY/nodes/Text','SCENERY/nodes/VBox','SCENERY_PHET/sceneryPhet','PHETCOMMON/util/StringUtils','TANDEM/Tandem','SCENERY_PHET/TMultiLineText'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TMultiLineText = require( 'SCENERY_PHET/TMultiLineText' );

  /**
   * @param {string} text
   * @param {Object} [options]
   * @constructor
   * @deprecated
   */
  function MultiLineText( text, options ) {

    options = _.extend( {
      font: new PhetFont(),
      align: 'center', // 'center', 'left' or 'right' (as supported by VBox)
      tandem: Tandem.tandemOptional(),
      phetioType: TMultiLineText
    }, options );

    // Normally individual properties from options should be stored rather than the entire options instance,
    // but in this case the options is stored because it must be propagated to child text instances
    this.options = options; // @private

    Node.call( this );

    this._text = null; // @private underscore prefix because it has ES5 set/get
    this.textParent = null; // @private
    this.text = text; // call ES5 setter

    // a11y - set the accessible content with setters since options will be propagated to child text instances
    this.tagName = 'p';
    this.accessibleLabel = text;

    this.mutate( _.omit( options, 'align' ) ); // mutate after removing options that are specific to this subtype
  }

  sceneryPhet.register( 'MultiLineText', MultiLineText );

  return inherit( Node, MultiLineText, {

    /**
     * Sets the text.
     * @param {string} text
     * @public
     */
    setText: function( text ) {

      // save the new text
      this._text = text;

      // parse the text and create {Text[]}
      var self = this;
      var textNodes = StringUtils.embeddedSplit( text, '\n' ).map( function( line ) {

        // create a blank line between consecutive line breaks
        if ( line.length === 0 ) { line = ' '; }

        return new Text( line, _.omit( self.options, 'align', 'maxWidth', 'tandem' ) );
      } );

      // determine where the textParent was, so we can maintain rendering order
      var index = this.textParent ? this.indexOfChild( this.textParent ) : 0;

      // remove the old textParent
      if ( this.textParent ) {
        this.removeChild( this.textParent );
      }

      // add the new textParent
      this.textParent = new VBox( {
        children: textNodes,
        align: this.options.align
      } );
      this.insertChild( index, this.textParent );
    },
    set text( value ) { this.setText( value ); }, // ES5 setter

    /**
     * Gets the text.
     * @returns {string}
     * @public
     */
    getText: function() { return this._text; },
    get text() { return this.getText(); }, // ES5 getter

    /**
     * Sets the fill for all Text nodes.
     * @param {Color|string} fill
     * @public
     */
    setFill: function( fill ) {
      this.options.fill = fill;
      var children = this.textParent.getChildren();
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].setFill( fill );
      }
    },
    set fill( value ) { this.setFill( value ); }, // ES5 setter

    /**
     * Gets the fill used for the text.
     * @returns {Color|string}
     * @public
     */
    getFill: function() { return this.options.fill; },
    get fill() { return this.getFill(); } // ES5 getter
  } );
} );


define("string!JOIST/versionPattern",function(){return window.phet.chipper.strings.get("JOIST/versionPattern");});

// Copyright 2013-2015, University of Colorado Boulder

/**
 * Shows the About dialog.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/AboutDialog',['require','SCENERY/nodes/VBox','SCENERY/nodes/Text','SCENERY/nodes/Node','PHET_CORE/inherit','SCENERY/input/ButtonListener','SCENERY_PHET/PhetFont','PHETCOMMON/util/StringUtils','SCENERY/nodes/VStrut','JOIST/Dialog','PHET_CORE/Timer','JOIST/CreditsNode','JOIST/UpdateNodes','JOIST/UpdateCheck','JOIST/LinkText','SCENERY/nodes/RichText','SCENERY_PHET/MultiLineText','JOIST/packageJSON','JOIST/joist','string!JOIST/versionPattern'],function( require ) {
  'use strict';

  // modules
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var VStrut = require( 'SCENERY/nodes/VStrut' );
  var Dialog = require( 'JOIST/Dialog' );
  var Timer = require( 'PHET_CORE/Timer' );
  var CreditsNode = require( 'JOIST/CreditsNode' );
  var UpdateNodes = require( 'JOIST/UpdateNodes' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var LinkText = require( 'JOIST/LinkText' );
  var RichText = require( 'SCENERY/nodes/RichText' );
  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var packageJSON = require( 'JOIST/packageJSON' );
  var joist = require( 'JOIST/joist' );

  // strings
  var versionPatternString = require( 'string!JOIST/versionPattern' );

  // Maximum width of elements in the dialog
  var MAX_WIDTH = 550;

  /**
   * @param {string} name - The name of the simulation
   * @param {string} version - The version of the simulation
   * @param {string} credits - The credits for the simulation, or falsy to show no credits
   * @param {Brand} Brand
   * @param {string} locale - The locale string
   * @param {Node} phetButton - The PhET button in the navigation bar, receives focus when this dialog is closed
   * @param {Tandem} tandem
   * @constructor
   */
  function AboutDialog( name, version, credits, Brand, locale, phetButton, tandem ) {
    var self = this;

    var children = [];

    var titleText = new Text( name, {
      font: new PhetFont( 28 ),
      maxWidth: MAX_WIDTH,
      tagName: 'h1',
      accessibleLabel: name
    } );
    children.push( titleText );

    var versionString = StringUtils.format( versionPatternString, version );
    children.push( new Text( versionString, {
      font: new PhetFont( 20 ),
      maxWidth: MAX_WIDTH,
      tagName: 'p',
      accessibleLabel: versionString
    } ) );
    if ( phet.chipper.buildTimestamp ) {
      children.push( new Text( phet.chipper.buildTimestamp, {
        font: new PhetFont( 13 ),
        maxWidth: MAX_WIDTH,
        tagName: 'p',
        accessibleLabel: phet.chipper.buildTimestamp
      } ) );
    }

    if ( UpdateCheck.areUpdatesChecked ) {
      var positionOptions = { left: 0, top: 0 };
      var checkingNode = UpdateNodes.createCheckingNode( positionOptions );
      var upToDateNode = UpdateNodes.createUpToDateNode( positionOptions );
      var outOfDateNode = UpdateNodes.createOutOfDateAboutNode( positionOptions );
      var offlineNode = UpdateNodes.createOfflineNode( positionOptions );

      // @private - Listener that should be called every frame where we are shown, with {number} dt as a single parameter.
      this.updateStepListener = checkingNode.stepListener;

      // @private - Listener that should be called whenever our update state changes (while we are displayed)
      this.updateVisibilityListener = function( state ) {
        checkingNode.visible = state === 'checking';
        upToDateNode.visible = state === 'up-to-date';
        outOfDateNode.visible = state === 'out-of-date';
        offlineNode.visible = state === 'offline';

        // a11y - make update content visible/invisible for screen readers by explicitly removing content
        // from the DOM, necessary because AT will ready hidden content in a Dialog.
        checkingNode.accessibleContentDisplayed = checkingNode.visible;
        upToDateNode.accessibleContentDisplayed = upToDateNode.visible;
        outOfDateNode.accessibleContentDisplayed = outOfDateNode.visible;
        offlineNode.accessibleContentDisplayed = offlineNode.visible;
      };

      children.push( new Node( {
        children: [
          checkingNode,
          upToDateNode,
          outOfDateNode,
          offlineNode
        ],
        maxWidth: MAX_WIDTH
      } ) );
    }

    children.push( new VStrut( 15 ) );

    // Show the brand name, if it exists
    if ( Brand.name ) {
      children.push( new RichText( Brand.name, {
        font: new PhetFont( 16 ),
        supScale: 0.5,
        supYOffset: 2,
        maxWidth: MAX_WIDTH,

        // a11y
        tagName: 'h2',
        accessibleLabel: Brand.name
      } ) );
    }

    // Show the brand copyright statement, if it exists
    if ( Brand.copyright ) {
      var year = phet.chipper.buildTimestamp ? // defined for built versions
                 phet.chipper.buildTimestamp.split( '-' )[ 0 ] : // e.g. "2017-04-20 19:04:59 UTC" -> "2017"
                 new Date().getFullYear(); // in requirejs mode

      var copyright = StringUtils.fillIn( Brand.copyright, { year: year } );

      children.push( new Text( copyright, {
        font: new PhetFont( 12 ), maxWidth: MAX_WIDTH,

        // a11y
        tagName: 'p',
        accessibleLabel: copyright
      } ) );
    }

    // Optional additionalLicenseStatement, used in phet-io
    if ( Brand.additionalLicenseStatement ) {
      this.additionalLicenseStatement = new MultiLineText( Brand.additionalLicenseStatement, {
          font: new PhetFont( 10 ),
          fill: 'gray',
          align: 'left',
          maxWidth: MAX_WIDTH
        }
      );
      children.push( this.additionalLicenseStatement );
    }

    // Add credits for specific brands
    if ( credits && ( Brand.id === 'phet' || Brand.id === 'phet-io' ) ) {
      children.push( new VStrut( 15 ) );
      this.creditsNode = new CreditsNode( credits, {
        maxWidth: MAX_WIDTH
      } );
      children.push( this.creditsNode );
    }

    // Show any links identified in the brand
    var links = Brand.getLinks( packageJSON.name, locale );
    if ( links && links.length > 0 ) {
      children.push( new VStrut( 15 ) );
      for ( var i = 0; i < links.length; i++ ) {
        var link = links[ i ];
        children.push( new LinkText( link.text, link.url, {
          font: new PhetFont( 14 ),
          maxWidth: MAX_WIDTH
        } ) );
      }
    }

    var content = new VBox( {
      align: 'left',
      spacing: 5,
      children: children,

      // a11y
      tagName: 'div'
    } );

    Dialog.call( this, content, {
      modal: true,
      hasCloseButton: true,
      tandem: tandem,
      focusOnCloseNode: phetButton,
      xMargin: 25,
      yMargin: 25
    } );

    // a11y - set label association so the title is read when focus enters the dialog
    titleText.setAriaLabelsNode( this );

    // close it on a click
    var closeListener = new ButtonListener( {
      fire: self.hide.bind( self )
    } );
    this.addInputListener( closeListener );

    // @private - to be called in dispose
    this.disposeAboutDialog = function() {
      this.removeInputListener( closeListener );

      this.creditsNode && this.creditsNode.dispose();
      this.additionalLicenseStatement && this.additionalLicenseStatement.dispose();
    };
  }

  joist.register( 'AboutDialog', AboutDialog );

  return inherit( Dialog, AboutDialog, {

    /**
     * Show the dialog
     * @public
     */
    show: function() {
      if ( UpdateCheck.areUpdatesChecked ) {
        UpdateCheck.resetTimeout();

        // Fire off a new update check if we were marked as offline or unchecked before, and we handle updates.
        if ( UpdateCheck.stateProperty.value === 'offline' || UpdateCheck.stateProperty.value === 'unchecked' ) {
          UpdateCheck.check();
        }

        // Hook up our spinner listener when we're shown
        Timer.addStepListener( this.updateStepListener );

        // Hook up our visibility listener
        UpdateCheck.stateProperty.link( this.updateVisibilityListener );
      }

      Dialog.prototype.show.call( this );
    },

    /**
     * Remove listeners that should only be called when the dialog is shown.
     * @public
     */
    hide: function() {
      if ( this.isShowing ) {
        Dialog.prototype.hide.call( this );

        if ( UpdateCheck.areUpdatesChecked ) {

          // Disconnect our visibility listener
          UpdateCheck.stateProperty.unlink( this.updateVisibilityListener );

          // Disconnect our spinner listener when we're hidden
          Timer.removeStepListener( this.updateStepListener );
        }
      }
    },

    /**
     * Make eligible for garbage collection.
     * @public
     */
    dispose: function() {
      this.disposeAboutDialog();
      Dialog.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'JOIST/TOptionsDialog',['require','JOIST/TDialog','ifphetio!PHET_IO/assertions/assertInstanceOf','JOIST/joist','ifphetio!PHET_IO/phetioInherit'],function( require ) {
  'use strict';

  // modules
  var TDialog = require( 'JOIST/TDialog' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var joist = require( 'JOIST/joist' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );

  /**
   * @constructor
   * Wrapper type for phet/joist's OptionsDialog
   * @param {Dialog} dialog - instance of OptionsDialog
   * @param {string} phetioID - identifier string
   */
  function TOptionsDialog( dialog, phetioID ) {
    TDialog.call( this, dialog, phetioID );
    assertInstanceOf( dialog, phet.joist.OptionsDialog );
  }

  phetioInherit( TDialog, 'TOptionsDialog', TOptionsDialog, {}, {
    documentation: 'A dialog panel'
  } );

  joist.register( 'TOptionsDialog', TOptionsDialog );

  return TOptionsDialog;
} );


define("string!JOIST/options.title",function(){return window.phet.chipper.strings.get("JOIST/options.title");});

// Copyright 2014-2017, University of Colorado Boulder

/**
 * Shows an Options dialog that consists of sim-global options.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/OptionsDialog',['require','SCENERY/nodes/Text','PHET_CORE/inherit','SCENERY_PHET/PhetFont','JOIST/Dialog','JOIST/joist','TANDEM/Tandem','JOIST/TOptionsDialog','string!JOIST/options.title'],function( require ) {
  'use strict';

  // modules
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Dialog = require( 'JOIST/Dialog' );
  var joist = require( 'JOIST/joist' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TOptionsDialog = require( 'JOIST/TOptionsDialog' );

  // strings
  var optionsTitleString = require( 'string!JOIST/options.title' );

  /**
   * @param {Node} optionsNode
   * @param {Object} [options]
   * @constructor
   */
  function OptionsDialog( optionsNode, options ) {
    options = _.extend( {
      titleAlign: 'center',
      modal: true,
      hasCloseButton: true,
      tandem: Tandem.tandemRequired(),
      phetioType: TOptionsDialog
    }, options );

    // Can't be in the extend call because it needs the tandem.
    if ( !options.title ) {
      options.title = new Text( optionsTitleString, {
        font: new PhetFont( 30 ),
        maxWidth: 400,
        tandem: options.tandem.createTandem( 'title' )
      } );
    }

    Dialog.call( this, optionsNode, options );

    // @private - to be called by dispose
    this.disposeOptionsDialog = function(){
      options.title && options.title.dispose();
    };
  }

  joist.register( 'OptionsDialog', OptionsDialog );

  return inherit( Dialog, OptionsDialog, {

    /**
     * Make the options dialog eligible for garbage collection.
     * @public
     */
    dispose: function() {
      this.disposeOptionsDialog();
      Dialog.prototype.dispose.call( this );
    }
  }, {
    DEFAULT_FONT: new PhetFont( 15 ),
    DEFAULT_SPACING: 10
  } );
} );
// Copyright 2015, University of Colorado Boulder

/**
 * Shows a fixed-size dialog that displays the current update status
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/UpdateDialog',['require','SCENERY/nodes/Node','PHET_CORE/inherit','SCENERY/input/ButtonListener','JOIST/Dialog','PHET_CORE/Timer','JOIST/UpdateNodes','JOIST/UpdateCheck','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Dialog = require( 'JOIST/Dialog' );
  var Timer = require( 'PHET_CORE/Timer' );
  var UpdateNodes = require( 'JOIST/UpdateNodes' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var joist = require( 'JOIST/joist' );

  /**
   * @param {PhETButton} phetButton - PhET button in the navigation bar, receives focus when this dialog is closed
   */
  function UpdateDialog( phetButton ) {
    assert && assert( UpdateCheck.areUpdatesChecked,
      'Updates need to be checked for UpdateDialog to be created' );

    var self = this;

    var positionOptions = { centerX: 0, centerY: 0, big: true };
    var checkingNode = UpdateNodes.createCheckingNode( positionOptions );
    var upToDateNode = UpdateNodes.createUpToDateNode( positionOptions );
    var outOfDateNode = new Node();
    var offlineNode = UpdateNodes.createOfflineNode( positionOptions );

    function updateOutOfDateNode() {
      // fallback size placeholder for version
      var latestVersionString = UpdateCheck.latestVersion ? UpdateCheck.latestVersion.toString() : 'x.x.xx';
      var ourVersionString = UpdateCheck.ourVersion.toString();

      // a11y - dialog content contained in parent div so ARIA roles can be applied to all children
      outOfDateNode.tagName = 'div';

      outOfDateNode.children = [
        UpdateNodes.createOutOfDateDialogNode( self, ourVersionString, latestVersionString, positionOptions )
      ];
    }

    updateOutOfDateNode();

    // @private - Listener that should be called every frame where we are shown, with {number} dt as a single parameter.
    this.updateStepListener = checkingNode.stepListener;

    // Listener that should be called whenever our update state changes (while we are displayed)
    this.updateVisibilityListener = function( state ) {
      if ( state === 'out-of-date' ) {
        updateOutOfDateNode();
      }

      checkingNode.visible = state === 'checking';
      upToDateNode.visible = state === 'up-to-date';
      outOfDateNode.visible = state === 'out-of-date';
      offlineNode.visible = state === 'offline';
      
      // a11y - update visibility of update nodes for screen readers by adding/removing content from the DOM, 
      // necessary because screen readers will read hidden content in a Dialog
      checkingNode.accessibleContentDisplayed = checkingNode.visible;
      upToDateNode.accessibleContentDisplayed = upToDateNode.visible;
      outOfDateNode.accessibleContentDisplayed = outOfDateNode.visible;
      offlineNode.accessibleContentDisplayed = offlineNode.visible;
    };

    var content = new Node( {
      children: [
        checkingNode,
        upToDateNode,
        outOfDateNode,
        offlineNode
      ],

      // a11y
      tagName: 'div'
    } );

    Dialog.call( this, content, {
      modal: true,
      hasCloseButton: true,

      // margins large enough to make space for close button
      xMargin: 30,
      yMargin: 30,

      // a11y
      focusOnCloseNode: phetButton
    } );

    // close it on a click
    var buttonListener = new ButtonListener( {
      fire: self.hide.bind( self )
    } );
    this.addInputListener( buttonListener );

    // @private - to be called by dispose()
    this.disposeUpdateDialog = function() {
      self.removeInputListener( buttonListener );
    };
  }

  joist.register( 'UpdateDialog', UpdateDialog );

  return inherit( Dialog, UpdateDialog, {

    /**
     * Show the UpdateDialog, registering listeners that should only be called while
     * the dialog is shown.
     * @public (joist-internal)
     */
    show: function() {
      if ( UpdateCheck.areUpdatesChecked ) {
        UpdateCheck.resetTimeout();

        // Fire off a new update check if we were marked as offline or unchecked before, and we handle updates.
        if ( UpdateCheck.stateProperty.value === 'offline' || UpdateCheck.stateProperty === 'unchecked' ) {
          UpdateCheck.check();
        }

        // Hook up our spinner listener when we're shown
        Timer.addStepListener( this.updateStepListener );

        // Hook up our visibility listener
        UpdateCheck.stateProperty.link( this.updateVisibilityListener );
      }

      Dialog.prototype.show.call( this );
    },

    /**
     * Remove listeners that should only be called when the Dialog is shown.
     * @public (joist-internal)
     */
    hide: function() {
      if ( this.isShowing ) {
        Dialog.prototype.hide.call( this );

        if ( UpdateCheck.areUpdatesChecked ) {

          // Disconnect our visibility listener
          UpdateCheck.stateProperty.unlink( this.updateVisibilityListener );

          // Disconnect our spinner listener when we're hidden
          Timer.removeStepListener( this.updateStepListener );
        }
      }
    },

    /**
     * Dispose the UpdateDialog so that it is eligible for garbage collection.
     * @public
     */
    dispose: function() {
      this.disposeUpdateDialog();
      Dialog.prototype.dispose.call( this );
    }
  } );
} );

// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SUN/TMenuItem',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );


  /**
   * Wrapper type for phet/sun's MenuItem
   * @param menuItem
   * @param phetioID
   * @constructor
   */
  function TMenuItem( menuItem, phetioID ) {
    assertInstanceOf( menuItem, phet.sun.MenuItem );
    TNode.call( this, menuItem, phetioID );

    // MenuItem from Sun, it is defined in PhetMenu.js and does not have its own type

    toEventOnEmit(
      menuItem.startedCallbacksForFiredEmitter,
      menuItem.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired' );
  }

  phetioInherit( TNode, 'TMenuItem', TMenuItem, {}, {
    documentation: 'The item buttons shown in a popup menu',
    events: [ 'fired' ]
  } );

  sun.register( 'TMenuItem', TMenuItem );

  return TMenuItem;
} );

// Copyright 2017, University of Colorado Boulder

/**
 * Class for an item that is listed in the PhetMenu
 * See PhetMenu.js for more information
 *
 * @author - Michael Kauzmann (PhET Interactive Simulations)
 */
define( 'SUN/MenuItem',['require','PHET_CORE/inherit','SUN/sun','SUN/FontAwesomeNode','AXON/Emitter','SCENERY_PHET/PhetFont','SCENERY/input/ButtonListener','SCENERY/nodes/Rectangle','SCENERY/nodes/Node','SCENERY/nodes/Text','TANDEM/Tandem','SCENERY/accessibility/AccessibilityUtil','SUN/TMenuItem'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var Emitter = require( 'AXON/Emitter' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );
  var AccessibilityUtil = require( 'SCENERY/accessibility/AccessibilityUtil' );

  // phet-io modules
  var TMenuItem = require( 'SUN/TMenuItem' );

  // the check mark used for toggle-able menu items
  var CHECK_MARK_NODE = new FontAwesomeNode( 'check', {
    fill: 'rgba(0,0,0,0.7)',
    scale: 0.4
  } );

  // constants
  var FONT_SIZE = 18;
  var HIGHLIGHT_COLOR = '#a6d2f4';
  var MAX_ITEM_WIDTH = 400;
  var CHECK_PADDING = 2;  // padding between the check and text
  var CHECK_OFFSET = CHECK_MARK_NODE.width + CHECK_PADDING; // offset that includes the check mark's width and padding
  var LEFT_X_MARGIN = 2;
  var RIGHT_X_MARGIN = 5;
  var Y_MARGIN = 3;
  var CORNER_RADIUS = 5;

  /**
   * @param {Number} width - the width of the menu item
   * @param {Number} height - the height of the menu item
   * @param {Function} closeCallback - called when closing the dialog that the menu item opened
   * @param {String} text
   * @param {Function} callback
   * @param {Object} [options]
   * @constructor
   */
  function MenuItem( width, height, closeCallback, text, callback, options ) {
    var self = this;

    // Extend the object with defaults.
    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      textFill: 'black',

      // a11y
      tagName: 'button',
      focusAfterCallback: false // whether or not next focusable element should receive focus after the callback
    }, options );

    Node.call( this );

    var textNode = new Text( text, {
      font: new PhetFont( FONT_SIZE ),
      fill: options.textFill,
      maxWidth: MAX_ITEM_WIDTH,
      tandem: options.tandem.createTandem( 'textNode' )
    } );

    var highlight = new Rectangle( 0, 0, width + LEFT_X_MARGIN + RIGHT_X_MARGIN + CHECK_OFFSET,
      height + Y_MARGIN + Y_MARGIN, CORNER_RADIUS, CORNER_RADIUS );

    this.addChild( highlight );
    this.addChild( textNode );

    textNode.left = highlight.left + LEFT_X_MARGIN + CHECK_OFFSET; // text is left aligned
    textNode.centerY = highlight.centerY;

    // @public (phet-io)
    this.startedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );

    this.addInputListener( {
      enter: function() { highlight.fill = HIGHLIGHT_COLOR; },
      exit: function() { highlight.fill = null; }
    } );

    var fire = function( event ) {
      self.startedCallbacksForFiredEmitter.emit();
      closeCallback( event );
      callback( event );
      self.endedCallbacksForFiredEmitter.emit();
    };

    this.addInputListener( new ButtonListener( {
      fire: fire
    } ) );

    // @public (sun)
    this.separatorBefore = options.separatorBefore;

    // if there is a check-mark property, add the check mark and hook up visibility changes
    var checkListener;
    if ( options.checkedProperty ) {
      var checkMarkWrapper = new Node( {
        children: [ CHECK_MARK_NODE ],
        right: textNode.left - CHECK_PADDING,
        centerY: textNode.centerY
      } );
      checkListener = function( isChecked ) {
        checkMarkWrapper.visible = isChecked;
      };
      options.checkedProperty.link( checkListener );
      this.addChild( checkMarkWrapper );
    }

    // a11y - activate the item when selected with the keyboard
    var clickListener = this.addAccessibleInputListener( {
      click: function( event ) {
        fire();

        // limit search of next focusable to root accessible HTML element
        var rootElement = phet.joist.display.accessibleDOMElement;
        options.focusAfterCallback && AccessibilityUtil.getNextFocusable( rootElement ).focus();
      }
    } );

    this.mutate( {
      cursor: 'pointer',
      tandem: options.tandem,
      phetioType: TMenuItem,

      // a11y
      parentContainerTagName: 'li',
      parentContainerAriaRole: 'none', // this is required for JAWS to handle focus correctly, see https://github.com/phetsims/john-travoltage/issues/225
      accessibleLabel: text,
      ariaRole: 'menuitem',
      tagName: options.tagName
    } );

    // @private - dispose the menu item
    this.disposeMenuItem = function() {
      if ( options.checkedProperty ) {
        options.checkedProperty.unlink( checkListener );
      }

      self.removeAccessibleInputListener( clickListener );
    };
  }

  sun.register( 'MenuItem', MenuItem );

  return inherit( Node, MenuItem, {

    // @public - dispose the menu item when it will no longer be used.
    dispose: function() {
      this.disposeMenuItem();
      Node.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2015, University of Colorado Boulder

/**
 * Generate a rasterized screenshot for a simulation using scenery's built-in machinery.
 * Used in phet-io as well as PhetMenu (optionally)
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/ScreenshotGenerator',['require','PHET_CORE/inherit','SCENERY/util/CanvasContextWrapper','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var CanvasContextWrapper = require( 'SCENERY/util/CanvasContextWrapper' );
  var joist = require( 'JOIST/joist' );

  /**
   *
   * @constructor
   */
  function ScreenshotGenerator() {
  }

  joist.register( 'ScreenshotGenerator', ScreenshotGenerator );

  return inherit( Object, ScreenshotGenerator, {}, {

    /**
     * Given a sim, generate a screenshot as a data url
     * @param {Sim} sim
     * @param {string} [mimeType] - String for the image mimeType, defaults to 'image/png'
     * @returns {string} dataURL
     * @public
     */
    generateScreenshot: function( sim, mimeType ) {

      // Default to PNG
      mimeType = mimeType || 'image/png';

      // set up our Canvas with the correct background color
      var canvas = document.createElement( 'canvas' );
      canvas.width = sim.display.width;
      canvas.height = sim.display.height;
      var context = canvas.getContext( '2d' );
      context.fillStyle = sim.display.domElement.style.backgroundColor;
      context.fillRect( 0, 0, canvas.width, canvas.height );
      var wrapper = new CanvasContextWrapper( canvas, context );

      sim.rootNode.renderToCanvasSubtree( wrapper );

      // get the data URL in PNG format
      var dataURL = canvas.toDataURL( mimeType );

      return dataURL;
    }
  } );
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'JOIST/TPhetMenu',['require','JOIST/joist','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit'],function( require ) {
  'use strict';

  // modules
  var joist = require( 'JOIST/joist' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );

  /**
   * Wrapper type for phet/joist's PhetMenu
   * @param phetMenu
   * @param phetioID
   * @constructor
   */
  function TPhetMenu( phetMenu, phetioID ) {
    TNode.call( this, phetMenu, phetioID );
    assertInstanceOf( phetMenu, phet.joist.PhetMenu );
  }

  phetioInherit( TNode, 'TPhetMenu', TPhetMenu, {}, {
    documentation: 'The PhET Menu in the bottom right of the screen',
    event: [ 'fired' ]
  } );

  joist.register( 'TPhetMenu', TPhetMenu );

  return TPhetMenu;
} );



define("string!JOIST/menuItem.options",function(){return window.phet.chipper.strings.get("JOIST/menuItem.options");});


define("string!JOIST/menuItem.about",function(){return window.phet.chipper.strings.get("JOIST/menuItem.about");});


define("string!JOIST/menuItem.mailInputEventsLog",function(){return window.phet.chipper.strings.get("JOIST/menuItem.mailInputEventsLog");});


define("string!JOIST/menuItem.outputInputEventsLog",function(){return window.phet.chipper.strings.get("JOIST/menuItem.outputInputEventsLog");});


define("string!JOIST/menuItem.phetWebsite",function(){return window.phet.chipper.strings.get("JOIST/menuItem.phetWebsite");});


define("string!JOIST/menuItem.reportAProblem",function(){return window.phet.chipper.strings.get("JOIST/menuItem.reportAProblem");});


define("string!JOIST/menuItem.screenshot",function(){return window.phet.chipper.strings.get("JOIST/menuItem.screenshot");});


define("string!JOIST/menuItem.fullscreen",function(){return window.phet.chipper.strings.get("JOIST/menuItem.fullscreen");});


define("string!JOIST/menuItem.getUpdate",function(){return window.phet.chipper.strings.get("JOIST/menuItem.getUpdate");});


define("string!JOIST/menuItem.submitInputEventsLog",function(){return window.phet.chipper.strings.get("JOIST/menuItem.submitInputEventsLog");});

// Copyright 2013-2015, University of Colorado Boulder

/**
 * The 'PhET' menu, which appears in the bottom-right of the home screen and the navigation bar, with options like
 * "PhET Website", "Settings", etc.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/PhetMenu',['require','PHET_CORE/platform','SCENERY/nodes/Node','KITE/Shape','SCENERY/nodes/Path','SCENERY/nodes/Text','PHET_CORE/inherit','JOIST/AboutDialog','JOIST/OptionsDialog','JOIST/UpdateDialog','SUN/MenuItem','SCENERY/nodes/Rectangle','SCENERY_PHET/PhetFont','JOIST/FullScreen','BRAND/Brand','JOIST/ScreenshotGenerator','JOIST/UpdateCheck','JOIST/joist','PHETCOMMON/util/StringUtils','AXON/DerivedProperty','SCENERY/input/Input','SCENERY/display/Display','SCENERY/accessibility/AccessibilityUtil','JOIST/TPhetMenu','string!JOIST/menuItem.options','string!JOIST/menuItem.about','string!JOIST/menuItem.mailInputEventsLog','string!JOIST/menuItem.outputInputEventsLog','string!JOIST/menuItem.phetWebsite','string!JOIST/menuItem.reportAProblem','string!JOIST/menuItem.screenshot','string!JOIST/menuItem.fullscreen','string!JOIST/menuItem.getUpdate','string!JOIST/menuItem.submitInputEventsLog'],function( require ) {
  'use strict';

  // modules
  var platform = require( 'PHET_CORE/platform' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Shape = require( 'KITE/Shape' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var AboutDialog = require( 'JOIST/AboutDialog' );
  var OptionsDialog = require( 'JOIST/OptionsDialog' );
  var UpdateDialog = require( 'JOIST/UpdateDialog' );
  var MenuItem = require( 'SUN/MenuItem' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var FullScreen = require( 'JOIST/FullScreen' );
  var Brand = require( 'BRAND/Brand' );
  var ScreenshotGenerator = require( 'JOIST/ScreenshotGenerator' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var joist = require( 'JOIST/joist' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var Input = require( 'SCENERY/input/Input' );
  var Display = require( 'SCENERY/display/Display' );
  var AccessibilityUtil = require( 'SCENERY/accessibility/AccessibilityUtil' );
  var TPhetMenu = require( 'JOIST/TPhetMenu' );

  // strings
  var menuItemOptionsString = require( 'string!JOIST/menuItem.options' );
  var menuItemAboutString = require( 'string!JOIST/menuItem.about' );
  var menuItemMailInputEventsLogString = require( 'string!JOIST/menuItem.mailInputEventsLog' );
  var menuItemOutputInputEventsLogString = require( 'string!JOIST/menuItem.outputInputEventsLog' );
  var menuItemPhetWebsiteString = require( 'string!JOIST/menuItem.phetWebsite' );
  var menuItemReportAProblemString = require( 'string!JOIST/menuItem.reportAProblem' );
  var menuItemScreenshotString = require( 'string!JOIST/menuItem.screenshot' );
  var menuItemFullscreenString = require( 'string!JOIST/menuItem.fullscreen' );
  var menuItemGetUpdateString = require( 'string!JOIST/menuItem.getUpdate' );
  var menuItemSubmitInputEventsLogString = require( 'string!JOIST/menuItem.submitInputEventsLog' );

  // constants
  var FONT_SIZE = 18;
  var MAX_ITEM_WIDTH = 400;

  // For disabling features that are incompatible with fuzzMouse
  var fuzzMouse = phet.chipper.queryParameters.fuzzMouse;

  // Creates a comic-book style bubble.
  var createBubble = function( width, height ) {

    var rectangle = new Rectangle( 0, 0, width, height, 8, 8, { fill: 'white', lineWidth: 1, stroke: 'black' } );

    var tail = new Shape();
    tail.moveTo( width - 20, height - 2 );
    tail.lineToRelative( 0, 20 );
    tail.lineToRelative( -20, -20 );
    tail.close();

    var tailOutline = new Shape();
    tailOutline.moveTo( width - 20, height );
    tailOutline.lineToRelative( 0, 20 - 2 );
    tailOutline.lineToRelative( -18, -18 );

    var bubble = new Node();
    bubble.addChild( rectangle );
    bubble.addChild( new Path( tail, { fill: 'white' } ) );
    bubble.addChild( new Path( tailOutline, { stroke: 'black', lineWidth: 1 } ) );

    return bubble;
  };

  /**
   * @param {Sim} sim
   * @param {Tandem} tandem
   * @param {Object} [options]
   * @constructor
   */
  function PhetMenu( sim, tandem, options ) {

    // Only show certain features for PhET Sims, such as links to our website
    var isPhETBrand = Brand.id === 'phet';
    var isPhetApp = Brand.isPhetApp;

    options = _.extend( {

      // For sims that have save/load enabled, show menu items for those.
      showSaveAndLoad: false,

      phetioType: TPhetMenu
    }, options );

    options.tandem = tandem;

    var self = this;
    Node.call( this );

    // Dialogs that could be constructed by the menu. The menu will create a dialog the
    // first time the item is selected, and they will be reused after that.  Must
    // be created lazily because Dialog requires Sim to have bounds during construction
    var aboutDialog = null;
    var optionsDialog = null;
    var updateDialog = null;

    /*
     * Description of the items in the menu. See Menu Item for a list of properties for each itemDescriptor
     */
    var itemDescriptors = [
      {
        text: menuItemOptionsString,
        present: !!sim.options.optionsNode,
        callback: function() {
          if ( !optionsDialog ) {
            optionsDialog = new OptionsDialog( sim.options.optionsNode, { tandem: tandem.createTandem( 'optionsDialog' ) } );
          }
          optionsDialog.show();
        },
        tandem: tandem.createTandem( 'optionsMenuItem' ),

        // a11y
        tagName: 'button',
        focusAfterCallback: true
      },
      {
        text: menuItemPhetWebsiteString,
        tandem: tandem.createTandem( 'phetWebsiteMenuItem' ),
        present: isPhETBrand,
        callback: function() {
          if ( !fuzzMouse ) {
            // Open locale-specific PhET home page. If there is no website translation for locale, fallback will be handled by server. See joist#97.
            if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
              var phetWindow = window.open( 'http://phet.colorado.edu/' + sim.locale, '_blank' );
              phetWindow && phetWindow.focus();
            }
          }
        },

        // a11y
        tagName: 'button'
      },
      {
        text: menuItemOutputInputEventsLogString,
        present: !!sim.options.recordInputEventLog,
        callback: function() {
          // prints the recorded input event log to the console
          console.log( sim.getRecordedInputEventLogString() );
        },
        tagName: 'button'
      },
      {
        text: menuItemSubmitInputEventsLogString,
        present: !!sim.options.recordInputEventLog,
        callback: function() {
          // submits a recorded event log to the same-origin server (run scenery/tests/event-logs/server/server.js with Node, from the same directory)
          sim.submitEventLog();
        },
        tagName: 'button'
      },
      {
        text: menuItemMailInputEventsLogString,
        present: !!sim.options.recordInputEventLog,
        callback: function() {
          // mailto: link including the body to email
          sim.mailEventLog();
        },
        tagName: 'button'
      },
      {
        text: menuItemReportAProblemString,
        present: isPhETBrand && !isPhetApp,
        callback: function() {
          // Create a smaller version of our dependencies to send, due to the URL length issues.
          // See https://github.com/phetsims/joist/issues/249.
          var dependenciesCopy = phet.chipper.dependencies ? JSON.parse( JSON.stringify( phet.chipper.dependencies ) ) : {};
          delete dependenciesCopy.comment;
          for ( var key in dependenciesCopy ) {
            if ( dependenciesCopy[ key ].sha ) {
              dependenciesCopy[ key ].sha = dependenciesCopy[ key ].sha.substring( 0, 8 );
            }
          }

          var url = 'http://phet.colorado.edu/files/troubleshooting/' +
                    '?sim=' + encodeURIComponent( sim.name ) +
                    '&version=' + encodeURIComponent( sim.version + ' ' +
                    ( phet.chipper.buildTimestamp ? phet.chipper.buildTimestamp : '(require.js)' ) ) +
                    '&url=' + encodeURIComponent( window.location.href ) +
                    '&dependencies=' + encodeURIComponent( JSON.stringify( dependenciesCopy ) );

          if ( !fuzzMouse ) {
            if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
              var reportWindow = window.open( url, '_blank' );
              reportWindow && reportWindow.focus();
            }
          }
        },
        tandem: tandem.createTandem( 'reportAProblemMenuItem' ),
        tagName: 'button'
      },
      {
        text: 'QR code',
        present: phet.chipper.queryParameters.qrCode,
        callback: function() {
          if ( !fuzzMouse ) {
            var win = window.open( 'http://api.qrserver.com/v1/create-qr-code/?data=' + encodeURIComponent( window.location.href ) + '&size=220x220&margin=0', '_blank' );
            win && win.focus();
          }
        },
        tandem: tandem.createTandem( 'qrCodeMenuItem' ),

        // a11y
        tagName: 'button'
      },
      {
        text: menuItemGetUpdateString,
        present: UpdateCheck.areUpdatesChecked,
        textFill: new DerivedProperty( [ UpdateCheck.stateProperty ], function( state ) {
          return state === 'out-of-date' ? '#0a0' : '#000';
        } ),
        callback: function() {
          if ( !updateDialog ) {
            var phetButton = sim.navigationBar.phetButton;
            updateDialog = new UpdateDialog( phetButton );
          }
          updateDialog.show();
        },
        tandem: tandem.createTandem( 'getUpdateMenuItem' ),

        // a11y
        tagName: 'button',
        focusAfterCallback: true
      },

      // "Screenshot" Menu item
      {
        text: menuItemScreenshotString,
        present: !platform.ie9 && !isPhetApp, // Not supported by IE9, see https://github.com/phetsims/joist/issues/212
        callback: function() {
          var dataURL = ScreenshotGenerator.generateScreenshot( sim );

          // if we have FileSaver support
          if ( window.Blob && !!new window.Blob() ) {
            // construct a blob out of it
            var requiredPrefix = 'data:image/png;base64,';
            assert && assert( dataURL.slice( 0, requiredPrefix.length ) === requiredPrefix );
            var dataBase64 = dataURL.slice( requiredPrefix.length );
            var byteChars = window.atob( dataBase64 );
            var byteArray = new window.Uint8Array( byteChars.length );
            for ( var i = 0; i < byteArray.length; i++ ) {
              byteArray[ i ] = byteChars.charCodeAt( i ); // need check to make sure this cast doesn't give problems?
            }

            var blob = new window.Blob( [ byteArray ], { type: 'image/png' } );

            // our preferred filename
            var filename = StringUtils.stripEmbeddingMarks( sim.name ) + ' screenshot.png';

            if ( !fuzzMouse ) {
              window.saveAs( blob, filename );
            }
          }
          else if ( !fuzzMouse ) {
            window.open( dataURL, '_blank', '' );
          }
        },
        tandem: tandem.createTandem( 'screenshotMenuItem' ),
        tagName: 'button'
      },
      {
        text: menuItemFullscreenString,
        present: FullScreen.isFullScreenEnabled() && !isPhetApp && !fuzzMouse && !platform.mobileSafari,
        checkedProperty: FullScreen.isFullScreenProperty,
        callback: function() {
          FullScreen.toggleFullScreen( sim );
        },
        tandem: tandem.createTandem( 'fullScreenMenuItem' ),
        tagName: 'button'
      },

      //About dialog button
      {
        text: menuItemAboutString,
        present: true,
        separatorBefore: isPhETBrand,
        callback: function() {
          if ( !aboutDialog ) {
            var phetButton = sim.navigationBar.phetButton;
            aboutDialog = new AboutDialog( sim.name, sim.version, sim.credits, Brand, sim.locale, phetButton, tandem.createTandem( 'aboutDialog' ) );
          }
          aboutDialog.show();
        },
        tandem: tandem.createTandem( 'aboutMenuItem' ),
        tagName: 'button',
        focusAfterCallback: true
      }
    ];

    // Menu items have uniform size, so compute the max text dimensions.  These are only used for sizing and thus don't
    // need to be tandemized.
    var keepItemDescriptors = _.filter( itemDescriptors, function( itemDescriptor ) {return itemDescriptor.present;} );
    var textNodes = _.map( keepItemDescriptors, function( item ) {
      return new Text( item.text, {
        font: new PhetFont( FONT_SIZE ),
        maxWidth: MAX_ITEM_WIDTH
      } );
    } );
    var maxTextWidth = _.maxBy( textNodes, function( node ) {return node.width;} ).width;
    var maxTextHeight = _.maxBy( textNodes, function( node ) {return node.height;} ).height;

    // Create the menu items.
    var items = this.items = _.map( keepItemDescriptors, function( itemDescriptor ) {

        return new MenuItem(
          maxTextWidth,
          maxTextHeight,
          options.closeCallback,
          itemDescriptor.text,
          itemDescriptor.callback,
          {
            textFill: itemDescriptor.textFill,
            checkedProperty: itemDescriptor.checkedProperty,
            separatorBefore: itemDescriptor.separatorBefore,
            tandem: itemDescriptor.tandem,
            tagName: itemDescriptor.tagName,
            focusAfterCallback: itemDescriptor.focusAfterCallback
          }
        );
      }
    );

    var separatorWidth = _.maxBy( items, function( item ) {return item.width;} ).width;
    var itemHeight = _.maxBy( items, function( item ) {return item.height;} ).height;
    var content = new Node();
    var y = 0;
    var ySpacing = 2;
    var separator;
    _.each( items, function( item ) {
      // Don't add a separator for the first item
      if ( item.separatorBefore && items[ 0 ] !== item ) {
        y += ySpacing;
        separator = new Path( Shape.lineSegment( 0, y, separatorWidth, y ), { stroke: 'gray', lineWidth: 1 } );
        content.addChild( separator );
        y = y + separator.height + ySpacing;
      }
      item.top = y;
      content.addChild( item );
      y += itemHeight;
    } );

    // Create a comic-book-style bubble.
    var X_MARGIN = 5;
    var Y_MARGIN = 5;
    var bubble = createBubble( content.width + X_MARGIN + X_MARGIN, content.height + Y_MARGIN + Y_MARGIN );

    this.addChild( bubble );
    this.addChild( content );
    content.left = X_MARGIN;
    content.top = Y_MARGIN;

    // @private (PhetButton.js) - whether the PhetMenu is showing
    this.isShowing = false;

    // a11y, tagname and role for content in the menu
    this.tagName = 'ul';
    this.ariaRole = 'menu';

    // a11y - add the keydown listener, handling arrow, escape, and tab keys
    // When using the arrow keys, we prevent the virtual cursor from moving in VoiceOver
    var keydownListener = this.addAccessibleInputListener( {
      keydown: function( event ) {
        var firstItem = self.items[ 0 ];
        var lastItem = self.items[ self.items.length - 1 ];

        // this attempts to prevents the scren reader's virtual cursor from also moving with the arrow keys
        if ( Input.isArrowKey( event.keyCode ) ) {
          event.preventDefault();
        }

        if ( event.keyCode === Input.KEY_DOWN_ARROW ) {

          // On down arrow, focus next item in the list, or wrap up to the first item if focus is at the end
          var nextFocusable = lastItem.focussed ? firstItem : AccessibilityUtil.getNextFocusable();
          nextFocusable.focus();
        }
        else if ( event.keyCode === Input.KEY_UP_ARROW ) {

          // On up arow, focus previous item in the list, or wrap back to the last item if focus is on first item
          var previousFocusable = firstItem.focussed ? lastItem : AccessibilityUtil.getPreviousFocusable();
          previousFocusable.focus();
        }
        else if ( event.keyCode === Input.KEY_ESCAPE ) {

          // On escape, close the menu and focus the PhET button
          options.closeCallback();
          sim.navigationBar.phetButton.focus();
        }
        else if ( event.keyCode === Input.KEY_TAB ) {

          // close the menu whenever the user tabs out of it
          options.closeCallback();

          // send focus back to the phet button - the browser should then focus the next/previous focusable
          // element with default 'tab' behavior
          sim.navigationBar.phetButton.focus();
        }
      }
    } );

    // a11y - if the focus goes to something outside of the PhET menu, close it
    var focusListener = function( focus ) {
      if ( focus && !_.includes( focus.trail.nodes, self ) ) {
        self.hide();
      }
    };
    Display.focusProperty.lazyLink( focusListener );


    this.mutate( options);

    this.disposePhetMenu = function() {
      self.removeAccessibleInputListener( keydownListener );
      Display.focusProperty.unlink( focusListener );
    };
  }

  joist.register( 'PhetMenu', PhetMenu );

  inherit( Node, PhetMenu, {

    // @public
    show: function() {
      if ( !this.isShowing ) {

        // make sure that any previously focused elements no longer have focus
        Display.focusProperty.set( null );

        window.phet.joist.sim.showPopup( this, true );
        this.isShowing = true;
      }
    },

    // @public
    hide: function() {
      if ( this.isShowing ) {
        this.isShowing = false;
        window.phet.joist.sim.hidePopup( this, true );
      }
    },

    // @public (joist-internal)
    dispose: function() {
      this.disposePhetMenu();
      _.each( this.items, function( item ) {
        item.dispose();
      } );
      Node.prototype.dispose.call( this );
    }
  } );

  return PhetMenu;
} );

define("mipmap!BRAND/logo.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["BRAND/logo.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );


define("mipmap!BRAND/logo-on-white.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["BRAND/logo-on-white.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );

// Copyright 2013-2015, University of Colorado Boulder

/**
 * The button that pops up the PhET menu, which appears in the bottom right of the home screen and on the right side
 * of the navbar.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/PhetButton',['require','SCENERY/nodes/Node','SCENERY/nodes/Image','KITE/Shape','SCENERY/nodes/Path','PHET_CORE/inherit','JOIST/PhetMenu','AXON/Property','JOIST/JoistButton','JOIST/UpdateCheck','SCENERY/util/TransformTracker','JOIST/JoistA11yStrings','JOIST/joist','mipmap!BRAND/logo.png','mipmap!BRAND/logo-on-white.png'],function( require ) {
  'use strict';

  // modules
  var Node = require( 'SCENERY/nodes/Node' );
  var Image = require( 'SCENERY/nodes/Image' );
  var Shape = require( 'KITE/Shape' );
  var Path = require( 'SCENERY/nodes/Path' );
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetMenu = require( 'JOIST/PhetMenu' );
  var Property = require( 'AXON/Property' );
  var JoistButton = require( 'JOIST/JoistButton' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var TransformTracker = require( 'SCENERY/util/TransformTracker' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var joist = require( 'JOIST/joist' );

  // strings
  var phetString = JoistA11yStrings.phetString;

  // images
  // The logo images are loaded from the brand which is selected via query parameter (during requirejs mode)
  // or a grunt option (during the build), please see initialize-globals.js window.phet.chipper.brand for more
  // details
  var brightLogoMipmap = require( 'mipmap!BRAND/logo.png' ); // on a black navbar
  var darkLogoMipmap = require( 'mipmap!BRAND/logo-on-white.png' ); // on a white navbar

  // Accommodate logos of any height by scaling them down proportionately.
  // The primary logo is 108px high and we have been scaling it at 0.28 to make it look good even on higher resolution
  // displays.  The following math scales up the logo to 108px high so the rest of the layout code will work smoothly
  // Scale to the same height as the PhET logo, so that layout code works correctly.
  // height of the PhET logo, brand/phet/images/logo.png or brand/adapted-from-phet/images/logo.png
  var PHET_LOGO_HEIGHT = 108;
  var PHET_LOGO_SCALE = 0.28;  // scale applied to the PhET logo
  assert && assert( brightLogoMipmap instanceof Array, 'logo must be a mipmap' );
  var LOGO_SCALE = PHET_LOGO_SCALE / brightLogoMipmap[ 0 ].height * PHET_LOGO_HEIGHT;

  /**
   * @param {Sim} sim
   * @param {Property.<Color|string>} backgroundFillProperty
   * @param {Property.<Color|string>} textFillProperty
   * @param {Tandem} tandem
   * @constructor
   */
  function PhetButton( sim, backgroundFillProperty, textFillProperty, tandem ) {

    var phetMenu = new PhetMenu( sim, tandem.createTandem( 'phetMenu' ), {
      showSaveAndLoad: sim.options.showSaveAndLoad,
      closeCallback: function() {
        phetMenu.hide();
      }
    } );

    /**
     * Sim.js handles scaling the popup menu.  This code sets the position of the popup menu.
     * @param {Bounds2} bounds - the size of the window.innerWidth and window.innerHeight, which depends on the scale
     * @param {Bounds2} screenBounds - subtracts off the size of the navbar from the height
     * @param {number} scale - the overall scaling factor for elements in the view
     */
    function onResize( bounds, screenBounds, scale ) {
      phetMenu.right = bounds.right / scale - 2 / scale;
      var navBarHeight = bounds.height - screenBounds.height;
      phetMenu.bottom = screenBounds.bottom / scale + navBarHeight / 2 / scale;
    }

    // sim.bounds are null on init, but we will get the callback when it is sized for the first time
    sim.resizedEmitter.addListener( onResize );

    var options = {
      textDescription: 'PhET Menu Button',
      highlightExtensionWidth: 6,
      highlightExtensionHeight: 5,
      highlightCenterOffsetY: 4,
      listener: function() {
        phetMenu.show();
      },

      // a11y
      tagName: 'button',
      accessibleLabel: phetString
    };

    // The PhET Label, which is the PhET logo
    var logoImage = new Image( brightLogoMipmap, {
      scale: LOGO_SCALE,
      pickable: false
    } );

    var optionsShape = new Shape();
    var optionsCircleRadius = 2.5;
    for ( var i = 0; i < 3; i++ ) {
      var circleOffset = i * 3.543 * optionsCircleRadius;
      optionsShape.arc( 0, circleOffset, optionsCircleRadius, 0, 2 * Math.PI, false );
    }

    var optionsButton = new Path( optionsShape, {
      left: logoImage.width + 8,
      bottom: logoImage.bottom - 0.5,
      pickable: false
    } );

    // The icon combines the PhET label and the thre horizontal bars in the right relative positions
    var icon = new Node( { children: [ logoImage, optionsButton ] } );

    JoistButton.call( this, icon, backgroundFillProperty, tandem, options );

    // a11y - the bounds of the button push the default highlight out of dev bounds
    this.focusHighlight = Shape.bounds( icon.bounds.dilated( 4 ) );

    Property.multilink( [ backgroundFillProperty, sim.showHomeScreenProperty, UpdateCheck.stateProperty ],
      function( backgroundFill, showHomeScreen, updateState ) {
        var backgroundIsWhite = backgroundFill !== 'black' && !showHomeScreen;
        var outOfDate = updateState === 'out-of-date';
        optionsButton.fill = backgroundIsWhite ? ( outOfDate ? '#0a0' : '#222' ) : ( outOfDate ? '#3F3' : 'white' );
        logoImage.image = backgroundIsWhite ? darkLogoMipmap : brightLogoMipmap;
      } );

    // a11y - add a listener that opens the menu on 'click' and 'reset', and closes it on escape and if the
    // button receives focus again
    this.addAccessibleInputListener( {
      click: function() {

        // open and set focus on the first item
        phetMenu.show();
        phetMenu.items[ 0 ].focus();
      }
    } );

    // a11y - add an attribute that lets the user know the button opens a menu
    this.setAccessibleAttribute( 'aria-haspopup', true );
  }

  joist.register( 'PhetButton', PhetButton );

  return inherit( JoistButton, PhetButton, {}, {
      // @public - How much space between the PhetButton and the right side of the screen.
      HORIZONTAL_INSET: 10,

      // @ public - How much space between the PhetButton and the bottom of the screen
      VERTICAL_INSET: 0,

      /**
       * Ensures that the home-screen's phet button will have the same global transform as the navbar's phet button.
       * Listens to both sides (the navbar button, and the home-screen's button's parent) so that when either changes,
       * the transforms are synchronized by changing the home-screen's button position.
       * See https://github.com/phetsims/joist/issues/304.
       * @public (joist-internal)
       *
       * @param {HomeScreenView} homeScreen - The home screen view, where we will position the phet button.
       * @param {NavigationBar} navigationBar - The main navigation bar
       * @param {Node} rootNode - The root of the Display's node tree
       */
      linkPhetButtonTransform: function( homeScreen, navigationBar, rootNode ) {
        var homeScreenButton = homeScreen.view.phetButton;

        var navBarButtonTracker = new TransformTracker( navigationBar.phetButton.getUniqueTrailTo( rootNode ), {
          isStatic: true // our listener won't change any listeners - TODO: replace with emitter? see https://github.com/phetsims/scenery/issues/594
        } );
        var homeScreenTracker = new TransformTracker( homeScreenButton.getParent().getUniqueTrailTo( rootNode ), {
          isStatic: true // our listener won't change any listeners - TODO: replace with emitter? see https://github.com/phetsims/scenery/issues/594
        } );

        function transformPhetButton() {
          // Ensure transform equality: navBarButton(global) = homeScreen(global) * homeScreenButton(self)
          homeScreenButton.matrix = homeScreenTracker.matrix.inverted().timesMatrix( navBarButtonTracker.matrix );
        }

        // hook up listeners
        navBarButtonTracker.addListener( transformPhetButton );
        homeScreenTracker.addListener( transformPhetButton );

        // synchronize immediately, in case there are no more transform changes before display
        transformPhetButton();
      }
    }
  );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Decorative frame around the selected node
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/Frame',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/util/LinearGradient','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var joist = require( 'JOIST/joist' );

  /**
   * @param {Node} content
   * @param {Object} [options]
   * @constructor
   */
  function Frame( content, options ) {

    // default options
    options = _.extend( {
      xMargin1: 6,
      yMargin1: 6,
      cornerRadius: 0 // radius of the rounded corners on the background
    }, options );

    Node.call( this );

    var frameWidth = content.width + 2 * options.xMargin1;
    var frameHeight = content.height + 2 * options.yMargin1;

    // @private
    this.gradient = new LinearGradient( 0, 0, frameWidth, 0 ).addColorStop( 0, '#fbff41' ).addColorStop( 118 / 800.0, '#fef98b' ).addColorStop( 372 / 800.0, '#feff40' ).addColorStop( 616 / 800, '#fffccd' ).addColorStop( 1, '#fbff41' );

    // @private
    this.rectangle = new Rectangle( 0, 0, frameWidth, frameHeight, options.cornerRadius, options.cornerRadius, {
      stroke: this.gradient,
      lineWidth: 3,
      x: content.x - options.xMargin1,
      y: content.y - options.yMargin1
    } );
    this.addChild( this.rectangle );

    // Apply options after the layout is done, so that options that use the bounds will work properly.
    this.mutate( options );

    // @private
    this.frameWidth = frameWidth;

    // @private
    this.frameHeight = frameHeight;
  }

  joist.register( 'Frame', Frame );

  inherit( Node, Frame, {

    // @public
    setHighlighted: function( highlighted ) {
      this.rectangle.lineWidth = highlighted ? 4.5 : 3;

      //Make the frame larger when highlighted, but only so that it expands out
      if ( highlighted ) {
        this.rectangle.setRect( -1.5 / 2, -1.5 / 2, this.frameWidth + 1.5, this.frameHeight + 1.5 );
      }
      else {
        this.rectangle.setRect( 0, 0, this.frameWidth, this.frameHeight );
      }
    }
  } );

  return Frame;
} );
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'JOIST/TScreenButton',['require','JOIST/joist','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var joist = require( 'JOIST/joist' );
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * Wrapper type for phet/joist's ScreenButton
   * @param button
   * @param phetioID
   * @constructor
   */
  function TScreenButton( button, phetioID ) {
    assertInstanceOf( button, phet.joist.ScreenButton );
    TNode.call( this, button, phetioID );
    toEventOnEmit(
      button.startedCallbacksForFiredEmitter,
      button.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired' );
  }

  phetioInherit( TNode, 'TScreenButton', TScreenButton, {}, {
    documentation: 'A pressable button in the simulation, in the home screen',
    events: [ 'fired' ]
  } );

  joist.register( 'TScreenButton', TScreenButton );

  return TScreenButton;
} );


// Copyright 2017, University of Colorado Boulder

/**
 * A ScreenButton is displayed on the HomeScreen. There are small and large ScreenButtons, that can be toggled through
 * to select the desired sim screen to go to. See HomeScreenView.js for more information.
 *
 * @author - Michael Kauzmann (PhET Interactive Simulations)
 */
define( 'JOIST/ScreenButton',['require','PHET_CORE/inherit','JOIST/joist','AXON/Emitter','SCENERY/nodes/Rectangle','SCENERY/nodes/VBox','SCENERY/nodes/Text','SCENERY_PHET/PhetFont','SCENERY/nodes/Node','JOIST/Frame','DOT/Util','SCENERY_PHET/PhetColorScheme','KITE/Shape','JOIST/TScreenButton'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );
  var Emitter = require( 'AXON/Emitter' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Frame = require( 'JOIST/Frame' );
  var Util = require( 'DOT/Util' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var Shape = require( 'KITE/Shape' );
  var TScreenButton = require( 'JOIST/TScreenButton' );

  // constants
  var LARGE_ICON_HEIGHT = 140;

  /**
   * @param {boolean} large - whether or not this is a large or small screenButton
   * @param {Sim} sim
   * @param {number} index - index of this screen so we can get the screen, sorta backwards
   * @param {Property} highlightedScreenIndexProperty
   * @param {Tandem} tandem
   * @param {Object} [options]
   * @constructor
   */
  function ScreenButton( large, sim, index, highlightedScreenIndexProperty, tandem, options ) {
    var self = this;

    options = _.extend( {
      opacity: 1,  // The small screen's nodes have an opacity of .5
      tandem: tandem, // To be passed into mutate, but tandem should be a required param in joist
      phetioType: TScreenButton
    }, options );

    var screen = sim.screens[ index ];

    // @public
    this.startedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );

    // @public
    this.endedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );

    // Maps the number of screens to a scale for the small icons. The scale is percentage of LARGE_ICON_HEIGHT.
    var smallIconScale = Util.linear( 2, 4, 0.875, 0.50, sim.screens.length );

    // Use the small icon scale if this is a small screen button
    var height = large ? LARGE_ICON_HEIGHT : smallIconScale * LARGE_ICON_HEIGHT;

    // Wrap in a Node because we're scaling, and the same icon will be used for small and large icon, and may be used by
    // the navigation bar.
    var icon = new Node( {
      opacity: options.opacity,
      children: [ screen.homeScreenIcon ],
      scale: height / screen.homeScreenIcon.height
    } );

    // Frame for large
    var frame = large ? new Frame( icon ) : new Rectangle( 0, 0, icon.width, icon.height, {
      stroke: options.showSmallHomeScreenIconFrame ? '#dddddd' : null,
      lineWidth: 0.7
    } );

    // Create the icon with the frame inside
    var iconWithFrame = new Node( {
      opacity: options.opacity,
      children: [ frame, icon ]
    } );

    // Text for the screen button
    var text = new Text( screen.name, {
      font: new PhetFont( large ? 42 : 18 ),
      fill: large ? PhetColorScheme.PHET_LOGO_YELLOW : 'gray', // Color match with the PhET Logo yellow
      tandem: tandem.createTandem( 'text' )
    } );

    // Shrink the text if it goes beyond the edge of the image
    text.maxWidth = iconWithFrame.width;

    // Only link if a large button
    highlightedScreenIndexProperty.link( function( highlightedIndex ) {
      var highlighted = highlightedIndex === index;
      frame.setHighlighted && frame.setHighlighted( highlighted );
      icon.opacity = (large || highlighted) ? 1 : 0.5;
      text.fill = (large || highlighted) ? 'white' : 'gray';
    } );

    // The children are needed in the VBox constructor, but the rest of the options should be mutated later.
    VBox.call( this, {
      children: [
        iconWithFrame,
        text
      ]
    } );

    // Input listeners after the parent call depending on if the ScreenButton is large or small
    var buttonDown = large ?
                     function() {
                       sim.showHomeScreenProperty.value = false;
                       highlightedScreenIndexProperty.value = -1;
                     } :
                     function() {
                       sim.screenIndexProperty.value = index;
                     };

    this.addInputListener( {
      down: function( event ) {
        self.startedCallbacksForFiredEmitter.emit();
        buttonDown();
        self.endedCallbacksForFiredEmitter.emit();
      }
    } );

    // Set highlight listeners to the small screen button
    if ( !large ) {

      // @public (joist-internal)
      this.highlightListener = {
        over: function( event ) {
          highlightedScreenIndexProperty.value = index;
        },
        out: function( event ) {
          highlightedScreenIndexProperty.value = -1;
        }
      };

      // On the home screen if you touch an inactive screen thumbnail, it grows.  If then without lifting your finger
      // you swipe over to the next thumbnail, that one would grow.
      this.addInputListener( {
        over: function( event ) {
          if ( event.pointer.isTouch ) {
            sim.screenIndexProperty.value = index;
          }
        }
      } );
    }

    this.mouseArea = this.touchArea = Shape.bounds( this.bounds ); // cover the gap in the vbox

    this.disposeScreenButton = function() {
      highlightedScreenIndexProperty.unlink();
    };

    this.mutate( options );
  }

  joist.register( 'ScreenButton', ScreenButton );

  return inherit( VBox, ScreenButton, {

    // @public
    dispose: function() {
      this.disposeScreenButton();
      VBox.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2013-2015, University of Colorado Boulder

/**
 * Shows the home screen for a multi-screen simulation, which lets the user see all of the screens and select one.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/HomeScreenView',['require','JOIST/PhetButton','SCENERY/nodes/Node','SCENERY/nodes/HBox','SCENERY/nodes/Text','PHET_CORE/inherit','JOIST/ScreenView','JOIST/ScreenButton','AXON/Property','SCENERY_PHET/PhetFont','DOT/Bounds2','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var PhetButton = require( 'JOIST/PhetButton' );
  var Node = require( 'SCENERY/nodes/Node' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ScreenView = require( 'JOIST/ScreenView' );
  var ScreenButton = require( 'JOIST/ScreenButton' );
  var Property = require( 'AXON/Property' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var joist = require( 'JOIST/joist' );


  // constants
  var LAYOUT_BOUNDS = new Bounds2( 0, 0, 768, 504 );

  // iPad doesn't support Century Gothic, so fall back to Futura, see http://wordpress.org/support/topic/font-not-working-on-ipad-browser
  var TITLE_FONT_FAMILY = 'Century Gothic, Futura';

  /**
   * @param {Sim} sim
   * @param {Tandem} tandem
   * @param {Object} [options]
   * @constructor
   */
  function HomeScreenView( sim, tandem, options ) {
    var self = this;

    options = _.extend( {
      showSmallHomeScreenIconFrame: false,
      warningNode: null // {Node | null}, to display below the icons as a warning if available
    }, options );

    // Rendering in SVG seems to solve the problem that the home screen consumes 100% disk and crashes, see
    // https://github.com/phetsims/joist/issues/17.  This also makes it more responsive (and crisper on retina
    // displays). The renderer must be specified here because the node is added directly to the scene (instead of to
    // some other node that already has svg renderer).
    ScreenView.call( this, { layoutBounds: LAYOUT_BOUNDS } );

    var title = new Text( sim.name, {
      font: new PhetFont( {
        size: 52,
        family: TITLE_FONT_FAMILY
      } ),
      fill: 'white',
      y: 110,
      tandem: tandem.createTandem( 'title' )
    } );
    this.addChild( title );
    title.scale( Math.min( 1, 0.9 * this.layoutBounds.width / title.width ) );
    title.centerX = this.layoutBounds.centerX;

    // Keep track of which screen is highlighted so the same screen can remain highlighted even if nodes are replaced
    // (say when one grows larger or smaller).
    var highlightedScreenIndexProperty = new Property( -1 );

    var screenChildren = _.map( sim.screens, function( screen ) {

      assert && assert( screen.name, 'name is required for screen ' + sim.screens.indexOf( screen ) );
      assert && assert( screen.homeScreenIcon, 'homeScreenIcon is required for screen ' + screen.name );

      var index = sim.screens.indexOf( screen );

      // Even though in the user interface the small and large buttons seem like a single UI component that has grown
      // larger, it would be quite a headache to create a composite button for the purposes of tandem, so instead the
      // large and small buttons are registered as separate instances.  See https://github.com/phetsims/phet-io/issues/99
      var largeTandem = tandem.createTandem( screen.tandem.tail + 'LargeButton' );

      var isLarge = true;
      var largeScreenButton = new ScreenButton(
        isLarge,
        sim,
        index,
        highlightedScreenIndexProperty,
        largeTandem,
        {
          // Don't 40 the VBox or it will shift down when the border becomes thicker
          resize: false,
          cursor: 'pointer'
        } );

      // Even though in the user interface the small and large buttons seem like a single UI component that has grown
      // larger, it would be quite a headache to create a composite button for the purposes of tandem, so instead the
      // large and small buttons are registered as separate instances.  See https://github.com/phetsims/phet-io/issues/99
      var smallTandem = tandem.createTandem( screen.tandem.tail + 'SmallButton' );

      isLarge = false;
      var smallScreenButton = new ScreenButton(
        isLarge,
        sim,
        index,
        highlightedScreenIndexProperty,
        smallTandem,
        {
          spacing: 3,
          cursor: 'pointer',
          showSmallHomeScreenIconFrame: options.showSmallHomeScreenIconFrame,
        }
      );


      smallScreenButton.addInputListener( smallScreenButton.highlightListener );
      largeScreenButton.addInputListener( smallScreenButton.highlightListener );
      // largeScreenButton.mouseArea = largeScreenButton.touchArea = Shape.bounds( largeScreenButton.bounds ); // cover the gap in the vbox


      return { screen: screen, small: smallScreenButton, large: largeScreenButton, index: index };
    } );

    // Intermediate node, so that icons are always in the same rendering layer
    var iconsParentNode = new Node();
    self.addChild( iconsParentNode );

    // Space the icons out more if there are fewer, so they will be spaced nicely.
    // Cannot have only 1 screen because for 1-screen sims there is no home screen.
    var spacing = ( sim.screens.length <= 3 ) ? 60 : 33;

    var hBox = null;
    sim.screenIndexProperty.link( function( screenIndex ) {

      // remove previous layout of icons
      if ( hBox ) {
        hBox.removeAllChildren(); // because icons have reference to hBox (their parent)
        iconsParentNode.removeChild( hBox );
      }

      // add new layout of icons
      var icons = _.map( screenChildren, function( screenChild ) {return screenChild.index === screenIndex ? screenChild.large : screenChild.small;} );
      hBox = new HBox( { spacing: spacing, children: icons, align: 'top', resize: false } );
      iconsParentNode.addChild( hBox );

      // position the icons
      iconsParentNode.centerX = self.layoutBounds.width / 2;
      iconsParentNode.top = 170;
    } );

    //TODO move these Properties to LookAndFeel, see https://github.com/phetsims/joist/issues/255
    var homeScreenFillProperty = new Property( 'black' );
    var homeScreenTextFillProperty = new Property( 'white' );

    // @public (joist-internal) - This PhET button is public since our creator (Sim.js) is responsible for positioning
    // this button. See https://github.com/phetsims/joist/issues/304.
    this.phetButton = new PhetButton( sim, homeScreenFillProperty, homeScreenTextFillProperty, tandem.createTandem( 'phetButton' ) );
    this.addChild( this.phetButton );

    if ( options.warningNode ) {
      var warningNode = options.warningNode;

      this.addChild( warningNode );
      warningNode.centerX = this.layoutBounds.centerX;
      warningNode.bottom = this.layoutBounds.maxY - 20;
    }
  }

  joist.register( 'HomeScreenView', HomeScreenView );

  return inherit( ScreenView, HomeScreenView, {},
    // @public - statics
    {
      TITLE_FONT_FAMILY: TITLE_FONT_FAMILY,
      LAYOUT_BOUNDS: LAYOUT_BOUNDS
    }
  );
} );

define("string!JOIST/keyboardShortcuts.title",function(){return window.phet.chipper.strings.get("JOIST/keyboardShortcuts.title");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Shows a Dialog with content describing keyboard interactions. Brought up by a button
 * in the navigation bar.
 *
 * @author Jesse Greenberg
 */
define( 'JOIST/KeyboardHelpDialog',['require','PHET_CORE/inherit','JOIST/Dialog','JOIST/joist','SCENERY/input/ButtonListener','SCENERY/nodes/Path','SCENERY/nodes/Text','KITE/Shape','JOIST/JoistA11yStrings','SCENERY_PHET/PhetFont','TANDEM/Tandem','string!JOIST/keyboardShortcuts.title'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Dialog = require( 'JOIST/Dialog' );
  var joist = require( 'JOIST/joist' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Shape = require( 'KITE/Shape' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Tandem = require( 'TANDEM/Tandem' );

  // constants
  var CLOSE_BUTTON_WIDTH = 7;
  var CLOSE_BUTTON_MARGIN = 10;
  var HELP_CONTENT_MARGIN = 20;
  var TITLE_MAX_WIDTH = 500;

  // string
  var keyboardShortcutsTitleString = require( 'string!JOIST/keyboardShortcuts.title' );

  /**
   * Constructor.
   * @param {KeyboardHelpButton} keyboardHelpButton
   * @param {Node} helpContent - a node containing the sim specific keyboard help content
   * @param {object} options
   * @constructor
   */
  function KeyboardHelpDialog( keyboardHelpButton, helpContent, options ) {

    // title
    var titleText = new Text( keyboardShortcutsTitleString, {
      font: new PhetFont( {
        weight: 'bold',
        size: 20
      } ),
      maxWidth: TITLE_MAX_WIDTH,

      // a11y options
      tagName: 'h1',
      accessibleLabel: JoistA11yStrings.hotKeysAndHelpString
    } );

    options = _.extend( {
      titleAlign: 'center',
      title: titleText,
      modal: true,
      hasCloseButton: false,
      fill: 'rgb( 214, 237, 249 )',
      xMargin: HELP_CONTENT_MARGIN,
      yMargin: HELP_CONTENT_MARGIN,
      titleSpacing: HELP_CONTENT_MARGIN,
      focusOnCloseNode: keyboardHelpButton,
      tandem: Tandem.tandemRequired()
    }, options );

    // shape and path for a custom close button
    var closeButtonShape = new Shape();
    closeButtonShape.moveTo( -CLOSE_BUTTON_WIDTH, -CLOSE_BUTTON_WIDTH ).lineTo( CLOSE_BUTTON_WIDTH, CLOSE_BUTTON_WIDTH );
    closeButtonShape.moveTo( CLOSE_BUTTON_WIDTH, -CLOSE_BUTTON_WIDTH ).lineTo( -CLOSE_BUTTON_WIDTH, CLOSE_BUTTON_WIDTH );

    // @public (joist-internal)
    this.closeButtonPath = new Path( closeButtonShape, {
      stroke: 'black',
      lineCap: 'round',
      lineWidth: 2,
      cursor: 'pointer',

      // a11y
      tagName: 'button',
      accessibleLabel: JoistA11yStrings.closeString,
      focusHighlight: Shape.bounds( closeButtonShape.getBounds().dilated( 10 ) )
    } );

    // add a listener to hide the dialog
    var self = this;
    var buttonListener = new ButtonListener( {
      down: function() {
        self.hide();
      }
    } );
    this.closeButtonPath.addInputListener( buttonListener );

    // mouse/touch areas for the close button
    var areaX = this.closeButtonPath.left - this.closeButtonPath.width * 2;
    var areaY = this.closeButtonPath.top - CLOSE_BUTTON_MARGIN / 2;
    var width = this.closeButtonPath.width * 4;
    var height = this.closeButtonPath.height + CLOSE_BUTTON_MARGIN;
    this.closeButtonPath.mouseArea = Shape.rect( areaX, areaY, width, height );
    this.closeButtonPath.touchArea = this.closeButtonPath.mouseArea;

    Dialog.call( this, helpContent, options );

    // position and add the close button
    this.closeButtonPath.right = helpContent.right + 2 * HELP_CONTENT_MARGIN - CLOSE_BUTTON_MARGIN;
    this.closeButtonPath.top = helpContent.top + CLOSE_BUTTON_MARGIN;
    this.addChild( this.closeButtonPath );

    // @private (a11y) - input listener for the close button, must be disposed
    var clickListener = this.closeButtonPath.addAccessibleInputListener( {
        click: function() {
          self.hide();
          self.focusActiveElement();
        }
      }
    );

    // @private - to be called by dispose
    this.disposeKeyboardHelpDialog = function() {
      self.closeButtonPath.removeInputListener( buttonListener );
      self.closeButtonPath.removeAccessibleInputListener( clickListener );
    };
  }

  joist.register( 'KeyboardHelpDialog', KeyboardHelpDialog );

  return inherit( Dialog, KeyboardHelpDialog, {

    /**
     * So the Dialog is eligible for garbage collection.
     */
    dispose: function() {
      this.disposeKeyboardHelpDialog();
      Dialog.prototype.dispose.call( this );
    }
  } );
} );

define("mipmap!JOIST/keyboard-icon.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["JOIST/keyboard-icon.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );


define("mipmap!JOIST/keyboard-icon-on-white.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["JOIST/keyboard-icon-on-white.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );

// Copyright 2016, University of Colorado Boulder

/**
 * The button that pops up the Keyboard Help Dialog, which appears in the right side of the navbar and
 * to the left of the PhetButton.
 *
 * @author Jesse Greenberg
 */

define( 'JOIST/KeyboardHelpButton',['require','PHET_CORE/inherit','AXON/Property','KITE/Shape','SCENERY/nodes/Image','JOIST/JoistButton','JOIST/KeyboardHelpDialog','JOIST/JoistA11yStrings','JOIST/joist','mipmap!JOIST/keyboard-icon.png','mipmap!JOIST/keyboard-icon-on-white.png'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var Shape = require( 'KITE/Shape' );
  var Image = require( 'SCENERY/nodes/Image' );
  var JoistButton = require( 'JOIST/JoistButton' );
  var KeyboardHelpDialog = require( 'JOIST/KeyboardHelpDialog' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var joist = require( 'JOIST/joist' );

  // images
  var brightIconMipmap = require( 'mipmap!JOIST/keyboard-icon.png' ); // on a black navbar
  var darkIconMipmap = require( 'mipmap!JOIST/keyboard-icon-on-white.png' ); // on a white navbar
  assert && assert( brightIconMipmap instanceof Array, 'icon must be a mipmap' );

  // constants
  var HELP_BUTTON_HEIGHT = 67;
  var HELP_BUTTON_SCALE = 0.32;  // scale applied to the icon
  var BUTTON_SCALE = HELP_BUTTON_SCALE / brightIconMipmap[ 0 ].height * HELP_BUTTON_HEIGHT;

  function KeyboardHelpButton( sim, backgroundFillProperty, tandem ) {
    var self = this;

    var keyboardHelpDialog = null;
    var openDialog = function() {
      if ( !keyboardHelpDialog ) {
        keyboardHelpDialog = new KeyboardHelpDialog( self, sim.keyboardHelpNode, {
          tandem: tandem.createTandem( 'keyboardHelpDialog' )
        } );
      }
      keyboardHelpDialog.show();
    };

    var options = {
      highlightExtensionWidth: 5,
      highlightExtensionHeight: 10,
      highlightCenterOffsetY: 3,
      listener: openDialog,

      // a11y options
      tagName: 'button',
      accessibleLabel: JoistA11yStrings.hotKeysAndHelpString
    };

    var icon = new Image( brightIconMipmap, {
      scale: BUTTON_SCALE,
      pickable: false
    } );

    JoistButton.call( this, icon, backgroundFillProperty, tandem, options );

    // a11y - focus highlight since the bounds of the button push the default highlight out of bounds
    this.focusHighlight = Shape.bounds( icon.bounds.dilated( 5 ) );

    Property.multilink( [ backgroundFillProperty, sim.showHomeScreenProperty ],
      function( backgroundFill, showHomeScreen ) {
        var backgroundIsWhite = backgroundFill !== 'black' && !showHomeScreen;
        icon.image = backgroundIsWhite ? darkIconMipmap : brightIconMipmap;
      } );

    // a11y - open the dialog on 'spacebar' or 'enter' and focus the 'Close' button immediately
    this.clickListener = this.addAccessibleInputListener( {
      click: function() {
        openDialog();
        keyboardHelpDialog.closeButtonPath.focus();
      } }
    );
  }

  joist.register( 'KeyboardHelpButton', KeyboardHelpButton );

  return inherit( JoistButton, KeyboardHelpButton, {

    /**
     * To make eligible for garbage collection.
     * @public
     */
    dispose: function() {
      this.removeAccessibleInputListener( this.clickListener );
      JoistButton.prototype.dispose && JoistButton.prototype.dispose.call( this );
    }
  } );

} );

define("string!JOIST/simTitleWithScreenNamePattern",function(){return window.phet.chipper.strings.get("JOIST/simTitleWithScreenNamePattern");});

// Copyright 2013-2015, University of Colorado Boulder

/**
 * The navigation bar at the bottom of the screen.
 * For a single-screen sim, it shows the name of the sim at the far left and the PhET button at the far right.
 * For a multi-screen sim, it additionally shows buttons for each screen, and a home button.
 *
 * Layout of NavigationBar adapts to different text widths, icon widths, and numbers of screens, and attempts to
 * perform an "optimal" layout. The sim title is initially constrained to a max percentage of the bar width,
 * and that's used to compute how much space is available for screen buttons.  After creation and layout of the
 * screen buttons, we then compute how much space is actually available for the sim title, and use that to
 * constrain the title's width.
 *
 * The bar is composed of a background (always pixel-perfect), and expandable content (that gets scaled as one part).
 * If we are width-constrained, the navigation bar is in a 'compact' state where the children of the content (e.g.
 * home button, screen buttons, phet menu, title) do not change positions. If we are height-constrained, the amount
 * available to the bar expands, so we lay out the children to fit. See https://github.com/phetsims/joist/issues/283
 * for more details on how this is done.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/NavigationBar',['require','DOT/Dimension2','JOIST/HomeButton','PHET_CORE/inherit','PHET_CORE/platform','JOIST/NavigationBarScreenButton','JOIST/HomeScreenView','SCENERY/nodes/Node','JOIST/PhetButton','JOIST/KeyboardHelpButton','SCENERY_PHET/PhetFont','SCENERY/nodes/Rectangle','PHETCOMMON/util/StringUtils','SCENERY/nodes/Text','JOIST/JoistA11yStrings','JOIST/joist','string!JOIST/simTitleWithScreenNamePattern'],function( require ) {
  'use strict';

  // modules
  var Dimension2 = require( 'DOT/Dimension2' );
  var HomeButton = require( 'JOIST/HomeButton' );
  var inherit = require( 'PHET_CORE/inherit' );
  var platform = require( 'PHET_CORE/platform' );
  var NavigationBarScreenButton = require( 'JOIST/NavigationBarScreenButton' );
  var HomeScreenView = require( 'JOIST/HomeScreenView' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetButton = require( 'JOIST/PhetButton' );
  var KeyboardHelpButton = require( 'JOIST/KeyboardHelpButton' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Text = require( 'SCENERY/nodes/Text' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var joist = require( 'JOIST/joist' );

  // strings
  var simTitleWithScreenNamePatternString = require( 'string!JOIST/simTitleWithScreenNamePattern' );

  // constants
  var NAVIGATION_BAR_SIZE = new Dimension2( HomeScreenView.LAYOUT_BOUNDS.width, 40 );
  var TITLE_LEFT_MARGIN = 10;
  var TITLE_RIGHT_MARGIN = 25;
  var PHET_BUTTON_LEFT_MARGIN = 13;
  var PHET_BUTTON_RIGHT_MARGIN = PhetButton.HORIZONTAL_INSET; // same position as PhetButton on home screen
  var PHET_BUTTON_BOTTOM_MARGIN = PhetButton.VERTICAL_INSET; // same position as PhetButton on home screen
  var KEYBOARD_HELP_BUTTON_LEFT_MARGIN = 50;
  var HOME_BUTTON_LEFT_MARGIN = 5;
  var HOME_BUTTON_RIGHT_MARGIN = HOME_BUTTON_LEFT_MARGIN;
  var SCREEN_BUTTON_SPACING = 0;
  var MINIMUM_SCREEN_BUTTON_WIDTH = 60; // Make sure each button is at least a minimum width so they don't get too close together, see #279

  /**
   * Creates a nav bar.
   * @param {Sim} sim
   * @param {Screen[]} screens
   * @param {Tandem} tandem
   * @constructor
   */
  function NavigationBar( sim, screens, tandem ) {

    // @private
    this.screens = screens;

    Node.call( this );

    // @private - The bar's background (resized in layout)
    this.background = new Rectangle( 0, 0, NAVIGATION_BAR_SIZE.width, NAVIGATION_BAR_SIZE.height, {
      pickable: true
    } );
    sim.lookAndFeel.navigationBarFillProperty.linkAttribute( this.background, 'fill' );
    this.addChild( this.background );

    // @private - Everything else besides the background in the navigation bar (used for scaling)
    this.barContents = new Node();
    this.addChild( this.barContents );

    var title = sim.name;

    // If the 'screens' query parameter only selects 1 screen, than update the nav bar title to include that screen name.
    if ( phet.chipper.queryParameters.screens && phet.chipper.queryParameters.screens.length === 1 && screens[ 0 ].name ) {
      title = StringUtils.fillIn( simTitleWithScreenNamePatternString, {
        simName: sim.name,
        screenName: screens[ 0 ].name
      } );
    }

    // Sim title
    this.titleTextNode = new Text( title, {
      font: new PhetFont( 16 ),
      tandem: tandem.createTandem( 'titleTextNode' )
    } );
    sim.lookAndFeel.navigationBarTextFillProperty.linkAttribute( this.titleTextNode, 'fill' );
    this.barContents.addChild( this.titleTextNode );

    // @public (joist-internal) - PhET button. The transform of this is tracked, so we can mirror it over to the
    // homescreen's button. See https://github.com/phetsims/joist/issues/304.
    this.phetButton = new PhetButton( sim, sim.lookAndFeel.navigationBarFillProperty, sim.lookAndFeel.navigationBarTextFillProperty, tandem.createTandem( 'phetButton' ) );
    this.barContents.addChild( this.phetButton );

    // @private - Pops open a dialog with information about keyboard navigation
    this.keyboardHelpButton = new KeyboardHelpButton( sim, sim.lookAndFeel.navigationBarFillProperty, tandem.createTandem( 'keyboardHelpButton' ) );

    // only show the keyboard help button if the sim is accessible, there is keyboard help content, and we are
    // not in mobile safari
    if ( sim.accessible && sim.keyboardHelpNode && !platform.mobileSafari ) {
      this.barContents.addChild( this.keyboardHelpButton );
    }

    if ( screens.length === 1 ) {
      /* single-screen sim */

      // title can occupy all space to the left of the PhET button
      this.titleTextNode.maxWidth = HomeScreenView.LAYOUT_BOUNDS.width - TITLE_LEFT_MARGIN - TITLE_RIGHT_MARGIN -
                                    this.phetButton.width - PHET_BUTTON_RIGHT_MARGIN - this.keyboardHelpButton.width - KEYBOARD_HELP_BUTTON_LEFT_MARGIN;
    }
    else {
      /* multi-screen sim */

      // Start with the assumption that the title can occupy (at most) this percentage of the bar.
      var maxTitleWidth = Math.min( this.titleTextNode.width, 0.20 * HomeScreenView.LAYOUT_BOUNDS.width );

      // @private - Create the home button
      this.homeButton = new HomeButton(
        NAVIGATION_BAR_SIZE.height,
        sim.lookAndFeel.navigationBarFillProperty,
        tandem.createTandem( 'homeButton' ), {
          listener: function() {
            sim.showHomeScreenProperty.value = true;
          }
        } );
      // Add the home button, but only if it isn't turned off with ?homeScreen=false
      phet.chipper.queryParameters.homeScreen && this.barContents.addChild( this.homeButton );

      /*
       * Allocate remaining horizontal space equally for screen buttons, assuming they will be centered in the navbar.
       * Computations here reflect the left-to-right layout of the navbar.
       */
      // available width left of center
      var availableLeft = ( HomeScreenView.LAYOUT_BOUNDS.width / 2 ) - TITLE_LEFT_MARGIN - maxTitleWidth - TITLE_RIGHT_MARGIN -
                          this.homeButton.width - HOME_BUTTON_RIGHT_MARGIN;

      // available width right of center
      var availableRight = ( HomeScreenView.LAYOUT_BOUNDS.width / 2 ) - this.phetButton.width - PHET_BUTTON_RIGHT_MARGIN -
                           this.keyboardHelpButton.width - KEYBOARD_HELP_BUTTON_LEFT_MARGIN;

      // total available width for the screen buttons when they are centered
      var availableTotal = 2 * Math.min( availableLeft, availableRight );

      // width per screen button
      var screenButtonWidth = ( availableTotal - ( screens.length - 1 ) * SCREEN_BUTTON_SPACING ) / screens.length;

      // Create the screen buttons
      var screenButtons = _.map( screens, function( screen ) {
        return new NavigationBarScreenButton(
          sim.lookAndFeel.navigationBarFillProperty,
          sim.screenIndexProperty,
          sim.screens,
          screen,
          NAVIGATION_BAR_SIZE.height, {
            maxButtonWidth: screenButtonWidth,
            tandem: tandem.createTandem( screen.tandem.tail + 'Button' )
          } );
      } );

      // Layout out screen buttons horizontally, with equal distance between their centers
      // Make sure each button is at least a minimum size, so they don't get too close together, see #279
      var maxScreenButtonWidth = Math.max( MINIMUM_SCREEN_BUTTON_WIDTH, _.maxBy( screenButtons, function( button ) {
        return button.width;
      } ).width );

      // Compute the distance between *centers* of each button
      var spaceBetweenButtons = maxScreenButtonWidth + SCREEN_BUTTON_SPACING;
      for ( var i = 0; i < screenButtons.length; i++ ) {

        // Equally space the centers of the buttons around the origin of their parent (screenButtonsContainer)
        screenButtons[ i ].centerX = spaceBetweenButtons * ( i - ( screenButtons.length - 1 ) / 2 );
      }

      // @private - Put all screen buttons under a parent, to simplify layout
      this.screenButtonsContainer = new Node( {
        children: screenButtons,
        // NOTE: these layout settings are duplicated in layout(), but are necessary due to title's maxWidth requiring layout
        x: this.background.centerX, // since we have buttons centered around our origin, this centers the buttons
        centerY: this.background.centerY,
        maxWidth: availableTotal // in case we have so many screens that the screen buttons need to be scaled down
      } );
      this.barContents.addChild( this.screenButtonsContainer );

      this.accessibleOrder = [ this.screenButtonsContainer, this.homeButton ];

      // Now determine the actual width constraint for the sim title.
      this.titleTextNode.maxWidth = this.screenButtonsContainer.left - TITLE_LEFT_MARGIN - TITLE_RIGHT_MARGIN -
                                    HOME_BUTTON_RIGHT_MARGIN - this.homeButton.width - HOME_BUTTON_LEFT_MARGIN;
    }


    // initial layout (that doesn't need to change when we are re-layed out)
    this.titleTextNode.left = TITLE_LEFT_MARGIN;
    this.titleTextNode.centerY = NAVIGATION_BAR_SIZE.height / 2;
    this.phetButton.bottom = NAVIGATION_BAR_SIZE.height - PHET_BUTTON_BOTTOM_MARGIN;
    this.keyboardHelpButton.centerY = this.phetButton.centerY;
    if ( this.screens.length !== 1 ) {
      this.screenButtonsContainer.centerY = NAVIGATION_BAR_SIZE.height / 2;
      this.homeButton.centerY = NAVIGATION_BAR_SIZE.height / 2;
    }

    this.layout( 1, NAVIGATION_BAR_SIZE.width, NAVIGATION_BAR_SIZE.height );

    // a11y - container tag name and accessible label for all content in the nav bar
    this.tagName = 'footer';
    this.ariaLabel = JoistA11yStrings.simResourcesAndToolsString;

    // a11y - keyboard help button before phet menu button
    this.accessibleOrder = [ this.keyboardHelpButton, this.phetButton ];
  }

  joist.register( 'NavigationBar', NavigationBar );

  return inherit( Node, NavigationBar, {

    /**
     * Called when the navigation bar layout needs to be updated, typically when the browser window is resized.
     * @param {number} scale
     * @param {number} width
     * @param {number} height
     * @public
     */
    layout: function( scale, width, height ) {

      // resize the background
      this.background.rectWidth = width;
      this.background.rectHeight = height;

      // scale the entire bar contents
      this.barContents.setScaleMagnitude( scale );

      // determine our local-coordinate 'right' side of the screen, so we can expand if necessary
      var right;
      if ( NAVIGATION_BAR_SIZE.width * scale < width ) {
        // expanded
        right = width / scale;
      }
      else {
        // compact
        right = NAVIGATION_BAR_SIZE.width;
      }

      // horizontal positioning
      this.phetButton.right = right - PHET_BUTTON_RIGHT_MARGIN;
      this.keyboardHelpButton.right = this.phetButton.left - PHET_BUTTON_LEFT_MARGIN;

      // For multi-screen sims ...
      if ( this.screens.length !== 1 ) {
        // screen buttons and home screen button are centered.  These buttons are centered
        // around the origin in the screenButtonsContainer, so the screenButtonsContainer can
        // be put at the center of the navbar, shifted by the width of the home button.
        this.screenButtonsContainer.x = right / 2 + this.homeButton.width / 2;

        // home button to the left of screen buttons
        this.homeButton.right = this.screenButtonsContainer.left - HOME_BUTTON_RIGHT_MARGIN;

        // max width relative to position of home button
        this.titleTextNode.maxWidth = this.homeButton.left - TITLE_LEFT_MARGIN - TITLE_RIGHT_MARGIN;
      }
    }
  }, {

    // @public
    NAVIGATION_BAR_SIZE: NAVIGATION_BAR_SIZE
  } );
} );
// Copyright 2015, University of Colorado Boulder

/**
 * Screen for the home screen, which shows icons for selecting the sim content screens.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/HomeScreen',['require','PHET_CORE/inherit','JOIST/Screen','JOIST/HomeScreenView','JOIST/joist','AXON/Property'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Screen = require( 'JOIST/Screen' );
  var HomeScreenView = require( 'JOIST/HomeScreenView' );
  var joist = require( 'JOIST/joist' );
  var Property = require( 'AXON/Property' );

  /**
   *
   * @constructor
   */
  function HomeScreen( sim, tandem, options ) {

    options = _.extend( {

      //TODO get this color from LookAndFeel, see https://github.com/phetsims/joist/issues/255
      backgroundColorProperty: new Property( 'black' )
    }, options );

    assert && assert( !options.tandem, 'tandem is a required constructor parameter, not an option' );
    options.tandem = tandem;

    Screen.call( this,

      // createModel
      function() { return {}; },

      // createView
      function() {
        return new HomeScreenView( sim, tandem.createTandem( 'view' ), _.pick( options, [
          'showSmallHomeScreenIconFrame',
          'warningNode'
        ] ) );
      },

      options
    );
  }

  joist.register( 'HomeScreen', HomeScreen );

  return inherit( Screen, HomeScreen );
} );
// Copyright 2016, University of Colorado Boulder

/**
 * PhET-iO wrapper type for phet's ObservableArray type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'AXON/TObservableArray',['require','AXON/axon','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/toEventOnEmit','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TNumber','ifphetio!PHET_IO/types/TFunctionWrapper','ifphetio!PHET_IO/phetio'],function( require ) {
  'use strict';

  // modules
  var axon = require( 'AXON/axon' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );

  /**
   * Parametric wrapper type constructor.  Given an element type, this function returns an ObservbleArray wrapper type.
   * @param {TObject} elementType - wrapper type of the DerivedProperty. If loaded by phet (not phet-io)
   *                                    it will be the function returned by the 'ifphetio!' plugin.
   * @constructor
   */
  function TObservableArray( elementType ) {

    /**
     * This type constructor is parameterized based on the instance of Events.
     * @param observableArray
     * @param {string} phetioID - the full unique tandem name for the instance
     * @constructor
     */
    var TObservableArrayImpl = function TObservableArrayImpl( observableArray, phetioID ) {
      assert && assert( typeof( elementType ) === 'function', 'element type should be defined' );

      TObject.call( this, observableArray, phetioID );
      assertInstanceOf( observableArray, phet.axon.ObservableArray );

      /**
       * @param item
       * @returns {Object} - returns the stateObject of child item
       */
      var formatForDataStream = function( item ) {

        // Supply phetioID if it is available
        var result = { phetioID: item.phetioID };

        // Supply state if it is available
        if ( elementType.toStateObject ) {
          result.state = elementType.toStateObject( item );
        }
        return result;
      };
      toEventOnEmit( observableArray.startedCallbacksForItemAddedEmitter, observableArray.endedCallbacksForItemAddedEmitter, 'model', phetioID, this.constructor, 'itemAdded', formatForDataStream );
      toEventOnEmit( observableArray.startedCallbacksForItemRemovedEmitter, observableArray.endedCallbacksForItemRemovedEmitter, 'model', phetioID, this.constructor, 'itemRemoved', formatForDataStream );
    };
    return phetioInherit( TObject, 'TObservableArray', TObservableArrayImpl, {

        /**
         * Adds a listener to the observable array.
         * @param listener
         * @public
         */
        addItemAddedListener: {
          returnType: TVoid,
          parameterTypes: [ TFunctionWrapper( TVoid, [ elementType ] ) ],
          implementation: function( listener ) {
            this.instance.addItemAddedListener( listener );
          },
          documentation: 'Add a listener that is called when an item is added to the observable array.'
        },

        /**
         * Removes a listener that was added via addItemAddedListener.
         * @param listener
         * @public
         */
        addItemRemovedListener: {
          returnType: TVoid,
          parameterTypes: [ TFunctionWrapper( TVoid, [ elementType ] ) ],
          implementation: function( listener ) {
            this.instance.addItemRemovedListener( listener );
          },
          documentation: 'Add a listener that is called when an item is removed from the observable array.'
        },

        /**
         * Get the number of electrons currently in the array.
         */
        getLength: {
          returnType: TNumber( { type: 'Integer' } ),
          parameterTypes: [],
          implementation: function() {
            return this.instance.length;
          },
          documentation: 'Get the number of elements in the observable array'
        }
      },

      {

        toStateObject: function( observableArray ) {
          if ( !observableArray ) {
            return observableArray;
          }
          return {
            array: observableArray.getArray().map( function( item ) { return item.phetioID; } )
          };
        },

        fromStateObject: function( stateObject ) {

          var tempArray = [];
          stateObject.array.forEach( function( elementTypePhetioID ) {
            tempArray.push( phetio.getWrapper( elementTypePhetioID ).instance );
          } );


          return tempArray;
        },

        setValue: function( instance, value){
          // TODO: is this is a no no? Does PhET-iO have this sort of power, see https://github.com/phetsims/phet-io/issues/1054
          instance._array = value;

        },

        documentation: 'An array that sends notifications when its values have changed.',
        elementType: elementType,
        events: [ 'itemAdded', 'itemRemoved' ]
      } );
  }

  axon.register( 'TObservableArray', TObservableArray );

  return TObservableArray;
} );


// Copyright 2013-2016, University of Colorado Boulder

/**
 * An observable array of items.
 *
 * Because the array is observable, we must be careful about the possibility of concurrent-modification errors.
 * Any time we iterate over the array, we must iterate over a copy, because callback may be modifying the array.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'AXON/ObservableArray',['require','AXON/Property','AXON/axon','PHET_CORE/inherit','AXON/Emitter','AXON/TObservableArray','TANDEM/Tandem','ifphetio!PHET_IO/types/TNumber'],function( require ) {
  'use strict';

  // modules
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var TObservableArray = require( 'AXON/TObservableArray' );
  var Tandem = require( 'TANDEM/Tandem' );

  // phet-io modules
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );

  /**
   * @param {Object[]} [array]
   * @param {Object} [options]
   * @constructor
   */
  function ObservableArray( array, options ) {

    var self = this;

    // Special case that the user supplied options but no array
    if ( array instanceof Object && !(array instanceof Array) ) {
      options = array;
      array = null;
    }

    options = _.extend( {
      allowDuplicates: false, // are duplicate items allowed in the array?
      tandem: Tandem.tandemOptional(),
      phetioValueType: null,
      phetioIncludeInState: false // keep ObservableArray out of the state unless they opt in.
    }, options );

    // TODO: Should we require tandems for all ObservableArrays?

    this.allowDuplicates = options.allowDuplicates; // @private

    this._array = array || []; // @private internal, do not access directly
    this._addedListeners = []; // @private listeners called when an item is added
    this._removedListeners = []; // @private listeners called when an item is removed

    // @public (read-only) observe this, but don't set it
    this.lengthProperty = new Property( this._array.length, {
      tandem: options.tandem && options.tandem.createTandem( 'lengthProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } )
    } );

    // @private Store the initial array, if any, for resetting, see #4
    this.initialArray = array ? array.slice() : [];

    // @private Event stream for signifying begin/end of callbacks
    this.startedCallbacksForItemAddedEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForItemAddedEmitter = new Emitter( { indicateCallbacks: false } );
    this.startedCallbacksForItemRemovedEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForItemRemovedEmitter = new Emitter( { indicateCallbacks: false } );

    // public (phet-io) (read-only)
    this.phetioIncludeInState = options.phetioIncludeInState;
    options.tandem.supplied && options.tandem.addInstance( this, TObservableArray( options.phetioValueType ) );
    this.disposeObservableArray = function() {
      options.tandem.supplied && options.tandem.removeInstance( self );
    };
  }

  axon.register( 'ObservableArray', ObservableArray );

  return inherit( Object, ObservableArray, {

    // @public
    dispose: function() {
      this.disposeObservableArray();
    },

    /**
     * Restore the array back to its initial state
     * Note: if an item is in the current array and original array, it is removed and added back
     * This may or may not change in the future, see #4
     * @public
     */
    reset: function() {
      for ( var i = 0; i < this._array.length; i++ ) {
        this._fireItemRemoved( this._array[ i ] );
      }
      this._array = this.initialArray.slice();
      for ( i = 0; i < this._array.length; i++ ) {
        this._fireItemAdded( this._array[ i ] );
      }
    },

    // @public
    get length() { return this._array.length; },

    /**
     * Adds a listener that will be notified when an item is added to the list.
     * @param listener function( item, observableArray )
     * @public
     */
    addItemAddedListener: function( listener ) {
      assert && assert( this._addedListeners.indexOf( listener ) === -1 ); // listener is not already registered
      this._addedListeners.push( listener );
    },

    /**
     * Removes a listener that was added via addItemAddedListener.
     * @param listener
     * @public
     */
    removeItemAddedListener: function( listener ) {
      var index = this._addedListeners.indexOf( listener );
      assert && assert( index !== -1 ); // listener is registered
      this._addedListeners.splice( index, 1 );
    },

    /**
     * Adds a listener that will be notified when an item is removed from the list.
     * @param listener function( item, observableArray )
     * @public
     */
    addItemRemovedListener: function( listener ) {
      assert && assert( this._removedListeners.indexOf( listener ) === -1, 'Listener was already registered' ); // listener is not already registered
      this._removedListeners.push( listener );
    },

    /**
     * Removes a listener that was added via addItemRemovedListener.
     * @param listener
     * @public
     */
    removeItemRemovedListener: function( listener ) {
      var index = this._removedListeners.indexOf( listener );
      assert && assert( index !== -1, 'Listener is still registered after removal' ); // listener is registered
      this._removedListeners.splice( index, 1 );
    },

    // @private called when an item is added.
    _fireItemAdded: function( item ) {
      this.startedCallbacksForItemAddedEmitter.emit1( item );

      //Signify that an item was added to the list
      var copy = this._addedListeners.slice( 0 ); // operate on a copy, firing could result in the listeners changing
      for ( var i = 0; i < copy.length; i++ ) {
        copy[ i ]( item, this );
      }

      this.endedCallbacksForItemAddedEmitter.emit();
    },

    // @private called when an item is removed.
    _fireItemRemoved: function( item ) {

      this.startedCallbacksForItemRemovedEmitter.emit1( item );

      //Signify that an item was removed from the list
      var copy = this._removedListeners.slice( 0 ); // operate on a copy, firing could result in the listeners changing
      for ( var i = 0; i < copy.length; i++ ) {
        copy[ i ]( item, this );
      }

      this.endedCallbacksForItemRemovedEmitter.emit();
    },

    /**
     * Adds an item to the end of the array.
     * This is a convenience function, and is the same as push.
     * @param item
     * @public
     */
    add: function( item ) {
      this.push( item );
    },

    /**
     * Add items to the end of the array.
     * This is a convenience function, and is the same as push.
     * @param {Array} items
     * @public
     */
    addAll: function( items ) {
      for ( var i = 0; i < items.length; i++ ) {
        this.add( items[ i ] );
      }
    },

    /**
     * Removes the first occurrence of an item from the array.
     * If duplicates are allowed (see options.allowDuplicates) you may need to call this multiple
     * times to totally purge item from the array.
     * @param item
     * @public
     */
    remove: function( item ) {
      var index = this._array.indexOf( item );
      if ( index !== -1 ) {
        this._array.splice( index, 1 );
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
    },

    /**
     * Removes the first occurrence of each item in the specified array.
     * @param {Array} array a list of items to remove
     * @see ObservableArray.remove
     * @public
     */
    removeAll: function( array ) {
      assert && assert( _.isArray( array ), 'array should be an array' );
      for ( var i = 0; i < array.length; i++ ) {
        this.remove( array[ i ] );
      }
    },

    /**
     * Pushes an item onto the end of the array.
     * @param item
     * @throws Error if duplicates are not allowed (see options.allowDuplicates) and item is already in the array
     * @public
     */
    push: function( item ) {
      if ( !this.allowDuplicates && this.contains( item ) ) {
        throw new Error( 'duplicates are not allowed' );
      }
      this._array.push( item );
      this.lengthProperty.set( this._array.length );
      this._fireItemAdded( item );
    },

    /**
     * Removes an item from the end of the array and returns it.
     * @returns {*}
     * @public
     */
    pop: function() {
      var item = this._array.pop();
      if ( item !== undefined ) {
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
      return item;
    },

    /**
     * Removes an item from the beginning of the array and returns it.
     * @returns {*}
     * @public
     */
    shift: function() {
      var item = this._array.shift();
      if ( item !== undefined ) {
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
      return item;
    },

    /**
     * Does the array contain the specified item?
     * @param item
     * @returns {boolean}
     * @public
     */
    contains: function( item ) {
      return this.indexOf( item ) !== -1;
    },

    /**
     * Gets an item at the specified index.
     * @param index
     * @returns {*} the item, or undefined if there is no item at the specified index
     * @public
     */
    get: function( index ) {
      return this._array[ index ];
    },

    /**
     * Gets the index of a specified item.
     * @param item
     * @returns {*} -1 if item is not in the array
     * @public
     */
    indexOf: function( item ) {
      return this._array.indexOf( item );
    },

    /**
     * Removes all items from the array.
     * @public
     */
    clear: function() {
      while ( this.length > 0 ) {
        this.pop();
      }
    },

    /**
     * Applies a callback function to each item in the array
     * @param callback function(item)
     * @public
     */
    forEach: function( callback ) {
      this._array.slice().forEach( callback ); // do this on a copy of the array, in case callbacks involve array modification
    },

    /**
     * Maps the values in this ObservableArray using the specified function, and returns a new ObservableArray for chaining.
     * @param mapFunction
     * @returns {ObservableArray}
     * @public
     */
    map: function( mapFunction ) {
      return new ObservableArray( this._array.map( mapFunction ) );
    },

    /**
     * Filters the values in this ObservableArray using the predicate function, and returns a new ObservableArray for chaining.
     * @param predicate
     * @returns {ObservableArray}
     * @public
     */
    filter: function( predicate ) {
      return new ObservableArray( this._array.filter( predicate ) );
    },

    /**
     * Count the number of items in this ObservableArray that satisfy the given Predicate.
     * @param {function} predicate
     * @returns {number}
     * @public
     */
    count: function( predicate ) {
      var count = 0;
      for ( var i = 0; i < this._array.length; i++ ) {
        if ( predicate( this._array[ i ] ) ) {
          count++;
        }
      }
      return count;
    },

    /**
     * Find the first element that matches the given predicate.
     * @param {function} predicate
     * @param {number} [fromIndex] - optional start index for the search
     */
    find: function( predicate, fromIndex ) {
      return _.find( this._array, predicate, fromIndex );
    },

    /**
     * Starting with the initial value, combine values from this ObservableArray to come up with a composite result.
     * Same as foldLeft.  In underscore this is called _.reduce aka _.fold or _.inject
     * @param value
     * @param combiner
     * @returns {*}
     * @public
     */
    reduce: function( value, combiner ) {
      for ( var i = 0; i < this._array.length; i++ ) {
        value = combiner( value, this._array[ i ] );
      }
      return value;
    },

    /**
     * Return the underlying array
     * @returns {Array}
     * @public
     */
    getArray: function() {
      return this._array;
    },

    /**
     * Add/remove elements from any point in the array
     * @param {number} start - the index to start adding/removing items
     * @param {number} deleteCount - the number of items to delete
     * @param {Object} [item1] - an item to add
     * @param {Object} [item2] - an item to add
     * @param {Object} [etc] - varargs items to add etc.
     * @returns {Object[]} the items that were deleted.
     * @public
     */
    splice: function( start, deleteCount, item1, item2, etc ) {
      var deleted = this._array.splice.apply( this._array, arguments );
      var args = Array.prototype.slice.call( arguments );
      for ( var i = 0; i < deleted.length; i++ ) {
        this._fireItemRemoved( deleted[ i ] );
      }

      for ( var k = 2; k < args.length; k++ ) {
        this._fireItemAdded( args[ k ] );
      }
      return deleted;
    },

    /**
     * Changes the ordering of elements in the array.  Requires a Random source so that shuffles can be reproducible.
     * No items are added or removed, and this method does not send out any notifications.
     * @param {Random} random - from dot
     */
    shuffle: function( random ) {
      assert && assert( random, 'random must be supplied' );

      // preserve the same _array reference in case any clients got a reference to it with getArray()
      var shuffled = random.shuffle( this._array );
      this._array.length = 0;
      Array.prototype.push.apply( this._array, shuffled );
    }
  } );
} );
// Copyright 2017, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'SCENERY_PHET/TBarrierRectangle',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SCENERY_PHET/sceneryPhet','ifphetio!PHET_IO/toEventOnEmit'],function( require ) {
  'use strict';

  // modules
  var TNode = require( 'SCENERY/nodes/TNode' );

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );

  /**
   * Wrapper type for phet/scenery's BarrierRectangle
   * @param barrierRectangle
   * @param phetioID
   * @constructor
   */
  function TBarrierRectangle( barrierRectangle, phetioID ) {
    assertInstanceOf( barrierRectangle, phet.sceneryPhet.BarrierRectangle );
    TNode.call( this, barrierRectangle, phetioID );

    toEventOnEmit( barrierRectangle.startedCallbacksForFiredEmitter,
      barrierRectangle.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired' );
  }

  phetioInherit( TNode, 'TBarrierRectangle', TBarrierRectangle, {}, {
    documentation: 'Shown when a dialog is present, so that clicking on the invisible barrier rectangle will dismiss the dialog',
    events: [ 'fired' ],
    dataStreamOnlyType: true
  } );

  sceneryPhet.register( 'TBarrierRectangle', TBarrierRectangle );

  return TBarrierRectangle;
} );


// Copyright 2017, University of Colorado Boulder

/**
 * Semi-transparent black barrier used to block input events when a dialog (or other popup) is present, and fade out
 * the background.
 *
 * @author - Michael Kauzmann (PhET Interactive Simulations)
 */
define( 'SCENERY_PHET/BarrierRectangle',['require','PHET_CORE/inherit','SCENERY_PHET/sceneryPhet','AXON/Emitter','SCENERY/nodes/Plane','SCENERY/input/ButtonListener','TANDEM/Tandem','SCENERY_PHET/TBarrierRectangle'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Emitter = require( 'AXON/Emitter' );
  var Plane = require( 'SCENERY/nodes/Plane' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TBarrierRectangle = require( 'SCENERY_PHET/TBarrierRectangle' );

  /**
   * @param {ObservableArray} modalNodeStack - see usage in Sim.js
   * @param {Object} [options]
   * @constructor
   */
  function BarrierRectangle( modalNodeStack, options ) {
    var self = this;

    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      phetioType: TBarrierRectangle
    }, options );

    Plane.call( this );

    // @private
    this.startedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );
    this.endedCallbacksForFiredEmitter = new Emitter( { indicateCallbacks: false } );

    modalNodeStack.lengthProperty.link( function( numBarriers ) {
      self.visible = numBarriers > 0;
    } );

    this.addInputListener( new ButtonListener( {
      fire: function( event ) {
        self.startedCallbacksForFiredEmitter.emit();
        assert && assert( modalNodeStack.length > 0, 'There must be a Node in the stack to hide.' );
        modalNodeStack.get( modalNodeStack.length - 1 ).hide();
        self.endedCallbacksForFiredEmitter.emit();
      }
    } ) );

    // @private
    this.disposeBarrierRectangle = function() {
      modalNodeStack.lengthProperty.unlink();
    };

    this.mutate( options );
  }

  sceneryPhet.register( 'BarrierRectangle', BarrierRectangle );

  return inherit( Plane, BarrierRectangle, {

    // @public
    dispose: function() {
      this.disposeBarrierRectangle();
      Plane.prototype.dispose.call( this );
    }
  } );
} );
// Copyright 2014-2016, University of Colorado Boulder

/**
 * This minimalistic profiler is meant to help understand the time spent in running a PhET simulation.
 * It was designed to be minimally invasive, so it won't alter the simulation's performance significantly.
 * Note: just showing the average FPS or ms/frame is not sufficient, since we need to see when garbage collections
 * happen, which are typically a spike in a single frame.  Hence, the data is shown as a histogram. Data that
 * doesn't fit in the histogram appears in an optional 'longTimes' field.
 *
 * Output is displayed in the upper-left corner of the browser window, and updates every 60 frames.
 *
 * The general format is:
 *
 * FPS - ms/frame - histogram [- longTimes]
 *
 * Here's an example:
 *
 * 48 FPS - 21ms/frame - 0,0,5,0,0,0,0,0,1,0,0,0,0,3,1,3,18,19,5,3,1,0,1,0,0,0,0,1,0,0 - 50,37,217
 *
 * The histogram field is a sequence of 30 numbers, for 0-29ms. Each number indicates the number of frames that took
 * that amount of time. In the above example, histogram[2] is 5; there were 5 frames that took 2ms.
 *
 * The longTimes field is the set of frame times that exceeded 29ms, and thus don't fit in the histogram.
 * If 2 frames took 37ms, then 37ms will appear twice.  If no frames exceeded 29ms, then this field will be absent.
 * These values are sorted in descending order, so you can easily identify the largest frame time.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 */
define( 'JOIST/Profiler',['require','PHET_CORE/inherit','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );

  // constants
  var FIELD_SEPARATOR = ' \u2014 '; // em dash, a long horizontal dash
  var HISTOGRAM_LENGTH = 30;

  /**
   * Construct a Profiler
   * @constructor
   */
  function Profiler() {

    // @private These data structured were chosen to minimize CPU time.
    this.allTimes = [];  // {number[]} times for all frames, in ms
    this.histogram = []; // {number[]} array index corresponds to number of ms, value is number of frames at that time
    this.longTimes = []; // {number[]} any frame times that didn't fit in histogram
    this.frameStartTime = 0; // {number} start time of the current frame
    this.previousFrameStartTime = 0; // {number} start time of the previous frame

    // initialize histogram
    for ( var i = 0; i < HISTOGRAM_LENGTH; i++ ) {
      this.histogram.push( 0 );
    }

    // this is where the profiler displays its output
    $( 'body' ).append( '<div style="z-index: 99999999;position: absolute;color:red" id="phetProfiler" ></div>' );
  }

  joist.register( 'Profiler', Profiler );

  return inherit( Object, Profiler, {

    // @private
    frameStarted: function() {
      this.frameStartTime = Date.now();
    },

    // @private
    frameEnded: function() {

      // update the display every 60 frames
      if ( this.allTimes.length > 0 && this.allTimes.length % 60 === 0 ) {

        var totalTime = 0;
        for ( var i = 0; i < this.allTimes.length; i++ ) {
          totalTime += this.allTimes[ i ];
        }

        // FPS
        var averageFPS = Math.round( 1000 / (totalTime / this.allTimes.length) );
        var text = '' + averageFPS + ' FPS';

        // ms/frame
        var averageFrameTime = Math.round( totalTime / this.allTimes.length );
        text = text + FIELD_SEPARATOR + averageFrameTime + 'ms/frame';

        // histogram
        text = text + FIELD_SEPARATOR + this.histogram;

        // longTimes
        if ( this.longTimes.length > 0 ) {
          this.longTimes.sort( function( a, b ) { return b - a; } ); // sort longTimes in descending order
          text = text + FIELD_SEPARATOR + this.longTimes;
        }

        // update the display
        $( '#phetProfiler' ).html( text );

        // clear data structures
        for ( i = 0; i < HISTOGRAM_LENGTH; i++ ) {
          this.histogram[ i ] = 0;
        }
        this.longTimes.length = 0;
        this.allTimes.length = 0;
      }

      // record data for the current frame, skip first frame because we can't compute its dt
      if ( this.previousFrameStartTime ) {
        var dt = this.frameStartTime - this.previousFrameStartTime;
        this.allTimes.push( dt );
        if ( dt < HISTOGRAM_LENGTH ) {
          this.histogram[ dt ]++; // increment the histogram cell for the corresponding time
        }
        else {
          this.longTimes.push( dt ); // time doesn't fit in histogram, record in longTimes
        }
      }

      this.previousFrameStartTime = this.frameStartTime;
    }
  }, {

    // @public
    start: function( sim ) {
      var profiler = new Profiler();
      sim.frameStartedEmitter.addListener( function() {
        profiler.frameStarted();
      } );
      sim.frameEndedEmitter.addListener( function() {
        profiler.frameEnded();
      } );
    }
  } );
} );
// Copyright 2015-2016, University of Colorado Boulder

/**
 * Provides colors for Joist elements.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/LookAndFeel',['require','SCENERY/util/Color','AXON/DerivedProperty','PHET_CORE/inherit','JOIST/joist','AXON/Property'],function( require ) {
  'use strict';

  // modules
  var Color = require( 'SCENERY/util/Color' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );
  var Property = require( 'AXON/Property' );

  /**
   *
   * @constructor
   */
  function LookAndFeel() {

    // @public background color for the currently selected screen, which will be set on the Display as its backgroundColor
    this.backgroundColorProperty = new Property( 'black' );

    // @public (joist-internal) - Navigation bar background fill
    this.navigationBarFillProperty = new DerivedProperty( [ this.backgroundColorProperty ],
      function( backgroundColor ) {
        var screenIsBlack = !!new Color( backgroundColor ).equals( Color.BLACK );
        return screenIsBlack ? 'white' : 'black';
      } );

    // @public (joist-internal) - Navigation bar text fill
    this.navigationBarTextFillProperty = new DerivedProperty( [ this.navigationBarFillProperty ],
      function( navigationBarFill ) {
        return navigationBarFill === 'black' ? 'white' : 'black';
      } );
  }

  joist.register( 'LookAndFeel', LookAndFeel );

  return inherit( Object, LookAndFeel, {

    // @public
    reset: function() {
      this.backgroundColorProperty.reset();
    }
  } );
} );

define("PHET_IO/SimIFrameAPI", function(){return function(){ return function(){}; };});
// Copyright 2016, University of Colorado Boulder

/**
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
define( 'JOIST/TSim',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetio','ifphetio!PHET_IO/phetioInherit','JOIST/joist','ifphetio!PHET_IO/SimIFrameAPI','ifphetio!PHET_IO/types/TFunctionWrapper','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/toEventOnEmit','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';

  // phet-io modules
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var joist = require( 'JOIST/joist' );
  var SimIFrameAPI = require( 'ifphetio!PHET_IO/SimIFrameAPI' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/toEventOnEmit' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );

  // constants
  // The token for the event that occurs when the simulation constructor completes. This is hard-coded in many places
  // such as th playback wrapper, so should not be changed lightly!
  var SIM_STARTED = 'simStarted';

  /**
   * Wrapper type for phet/joist's Sim class.
   * @param sim
   * @param phetioID
   * @constructor
   */
  function TSim( sim, phetioID ) {
    assertInstanceOf( sim, phet.joist.Sim );
    TObject.call( this, sim, phetioID );

    // startedSimConstructorEmitter is called in the constructor of the sim, and endedSimConstructionEmitter is called
    // once all of the screens have been fully initialized, hence construction not constructor.
    // The simStarted event is guaranteed to be a top-level event, not nested under other events.
    toEventOnEmit( sim.startedSimConstructorEmitter, sim.endedSimConstructionEmitter, 'model', phetioID, this.constructor, SIM_STARTED,
      function( value ) {
        var simData = {
          repoName: value.repoName,
          simName: value.simName,
          simVersion: value.simVersion,
          simURL: value.url,
          userAgent: window.navigator.userAgent,
          randomSeed: value.randomSeed,
          wrapperMetadata: window.simStartedMetadata,
          provider: 'PhET Interactive Simulations, University of Colorado Boulder' // See #137
        };

        // Delete this global object once it has been used with this emitted event.
        delete window.simStartedMetadata;
        return simData;
      } );

    // Store a reference to the sim so that subsequent calls will be simpler.  PhET-iO only works with a single sim.
    phetio.sim = sim;
    sim.endedSimConstructionEmitter.addListener( function() {

      // TODO: Can these be coalesced?  See https://github.com/phetsims/joist/issues/412
      SimIFrameAPI.triggerSimInitialized();
      phetio.simulationStarted();
    } );
  }

  phetioInherit( TObject, 'TSim', TSim, {

    disableRequestAnimationFrame: {
      returnType: TVoid,
      parameterTypes: [],
      implementation: function() {
        this.instance.disableRequestAnimationFrame();
      },
      documentation: 'Prevents the simulation from animating/updating'
    },

    addEventListener: {
      returnType: TVoid,
      parameterTypes: [ TString, TFunctionWrapper( TVoid, [ TString, TFunctionWrapper( TVoid, [] ) ] ) ],
      implementation: function( eventName, listener ) {
        this.instance.onStatic( eventName, listener );
      },
      documentation: 'Add an event listener to the sim instance'
    },

    getScreenshotDataURL: {
      returnType: TString,
      parameterTypes: [],
      implementation: function() {
        return window.phet.joist.ScreenshotGenerator.generateScreenshot( this.instance );
      },
      documentation: 'Gets a base64 representation of a screenshot of the simulation as a data url'
    }
  }, {
    documentation: 'The type for the simulation instance',
    events: [
      SIM_STARTED
    ]
  } );


  joist.register( 'TSim', TSim );

  return TSim;
} );


// Copyright 2017, University of Colorado Boulder

/**
 * Support for Legends of Learning platform. Sends init message after sim is constructed and support pause/resume.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/thirdPartySupport/LegendsOfLearningSupport',['require','JOIST/joist','PHET_CORE/inherit'],function( require ) {
  'use strict';

  // modules
  var joist = require( 'JOIST/joist' );
  var inherit = require( 'PHET_CORE/inherit' );

  /**
   * @param {Sim} sim
   * @constructor
   */
  function LegendsOfLearningSupport( sim ) {

    // @private
    this.sim = sim;

    // Respond to pause/resume commands from the Legends of Learning platform
    window.addEventListener( 'message', function( message ) {
      if ( message.data.messageName === 'pause' ) {
        sim.stepOneFrame();
        sim.activeProperty.value = false;
      }
      else if ( message.data.messageName === 'resume' ) {
        sim.activeProperty.value = true;
      }
    } );
  }

  joist.register( 'LegendsOfLearningSupport', LegendsOfLearningSupport );

  return inherit( Object, LegendsOfLearningSupport, {
    start: function() {

      // Send init message when sim has started up so that Legends of Learning can remove their splash screen
      this.sim.endedSimConstructionEmitter.addListener( function() {
        window.parent && window.parent.postMessage( { message: 'init' }, '*' );
      } );
    }
  } );
} );
// Copyright 2013-2017, University of Colorado Boulder

/**
 * Main class that represents one simulation.
 * Provides default initialization, such as polyfills as well.
 * If the simulation has only one screen, then there is no homescreen, home icon or screen icon in the navigation bar.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/Sim',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Dimension2','SCENERY/util/Features','JOIST/NavigationBar','JOIST/HomeScreen','JOIST/HomeScreenView','JOIST/UpdateCheck','SCENERY/util/Util','SCENERY/display/Display','SCENERY/nodes/Node','AXON/Property','AXON/BooleanProperty','AXON/ObservableArray','PHET_CORE/platform','PHET_CORE/Timer','SCENERY_PHET/BarrierRectangle','JOIST/Profiler','JOIST/LookAndFeel','JOIST/ScreenshotGenerator','JOIST/packageJSON','JOIST/PhetButton','JOIST/joist','TANDEM/Tandem','DOT/Util','AXON/Emitter','JOIST/TSim','JOIST/thirdPartySupport/LegendsOfLearningSupport','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TNumber'],function( require ) {
  'use strict';

  // modules
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Features = require( 'SCENERY/util/Features' );
  var NavigationBar = require( 'JOIST/NavigationBar' );
  var HomeScreen = require( 'JOIST/HomeScreen' );
  var HomeScreenView = require( 'JOIST/HomeScreenView' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var Util = require( 'SCENERY/util/Util' );
  var Display = require( 'SCENERY/display/Display' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var ObservableArray = require( 'AXON/ObservableArray' );
  var platform = require( 'PHET_CORE/platform' );
  var Timer = require( 'PHET_CORE/Timer' );
  var BarrierRectangle = require( 'SCENERY_PHET/BarrierRectangle' );
  var Profiler = require( 'JOIST/Profiler' );
  var LookAndFeel = require( 'JOIST/LookAndFeel' );
  var ScreenshotGenerator = require( 'JOIST/ScreenshotGenerator' );
  var packageJSON = require( 'JOIST/packageJSON' );
  var PhetButton = require( 'JOIST/PhetButton' );
  var joist = require( 'JOIST/joist' );
  var Tandem = require( 'TANDEM/Tandem' );
  var DotUtil = require( 'DOT/Util' );// eslint-disable-line
  var Emitter = require( 'AXON/Emitter' );
  var TSim = require( 'JOIST/TSim' );
  var LegendsOfLearningSupport = require( 'JOIST/thirdPartySupport/LegendsOfLearningSupport' );

  // phet-io modules
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );

  // constants
  var PROGRESS_BAR_WIDTH = 273;

  // globals
  phet.joist.elapsedTime = 0; // in milliseconds, use this in Tween.start for replicable playbacks

  // When the simulation is going to be used to play back a recorded session, the simulation must be put into a special
  // mode in which it will only update the model + view based on the playback clock events rather than the system clock.
  // This must be set before the simulation is launched in order to ensure that no errant stepSimulation steps are called
  // before the playback events begin.  This value is overridden for playback by TPhETIO.
  // @public (phet-io)
  phet.joist.playbackModeEnabledProperty = new BooleanProperty( phet.chipper.queryParameters.playbackMode );

  /**
   * Main Sim constructor
   * @param {string} name - the name of the simulation, to be displayed in the navbar and homescreen
   * @param {Screen[]} screens - the screens for the sim
   * @param {Object} [options] - see below for options
   * @constructor
   */
  function Sim( name, screens, options ) {

    var self = this;

    window.phetSplashScreenDownloadComplete();

    // playbackModeEnabledProperty cannot be changed after Sim construction has begun, hence this listener is added before
    // anything else is done, see https://github.com/phetsims/phet-io/issues/1146
    phet.joist.playbackModeEnabledProperty.lazyLink( function( playbackModeEnabled ) {
      throw new Error( 'playbackModeEnabledProperty cannot be changed after Sim construction has begun' );
    } );

    var tandem = Tandem.createRootTandem();
    var simTandem = tandem.createTandem( 'sim' );

    // @public (phet-io)
    this.tandem = tandem;

    // @public (phet-io) Emitter for PhET-iO data stream to describe the startup sequence
    this.startedSimConstructorEmitter = new Emitter();

    // @public (phet-io) Emitter for PhET-iO data stream to describe the startup sequence
    this.endedSimConstructionEmitter = new Emitter();

    // @public Emitter that indicates when the sim resized
    this.resizedEmitter = new Emitter();

    // @public Emitter that indicates when a frame starts
    this.frameStartedEmitter = new Emitter();

    // @public Emitter that indicates when a frame ends
    // phetioEmitData is false because we only want this manually wired for phetio event recording.
    this.frameEndedEmitter = new Emitter( {
      tandem: simTandem.createTandem( 'frameEndedEmitter' ),
      phetioArgumentTypes: [ TNumber( { units: 'seconds' } ) ],
      phetioEmitData: false // An adapter in phetio will create input events when recording for playback.
      // If we are not recording for visual playback, then we omit these from the data stream so that we don't get spammed with dt's.
    } );

    var initialScreen = phet.chipper.queryParameters.initialScreen;

    // The screens to be included, and their order, may be specified via a query parameter.
    // For documentation, see the schema for phet.chipper.queryParameters.screens in initialize-globals.js.
    // Do this before setting options.showHomeScreen, since no home screen should be shown if we have 1 screen.
    if ( QueryStringMachine.containsKey( 'screens' ) ) {
      var newScreens = [];
      phet.chipper.queryParameters.screens.forEach( function( userIndex ) {
        var screenIndex = userIndex - 1; // screens query parameter is 1-based
        if ( screenIndex < 0 || screenIndex > screens.length - 1 ) {
          throw new Error( 'invalid screen index: ' + userIndex );
        }
        newScreens.push( screens[ screenIndex ] );
      } );

      // If the user specified an initial screen other than the homescreen and specified a subset of screens
      // remap the selected 1-based index from the original screens list to the filtered screens list.
      if ( initialScreen !== 0 ) {
        var index = _.indexOf( newScreens, screens[ initialScreen - 1 ] );
        assert && assert( index !== -1, 'screen not found' );
        initialScreen = index + 1;
      }

      screens = newScreens;
    }

    options = _.extend( {

      // whether to show the home screen, or go immediately to the screen indicated by screenIndex
      showHomeScreen: ( screens.length > 1 ) && phet.chipper.queryParameters.homeScreen,

      // index of the screen that will be selected at startup (the query parameter is 1-based)
      screenIndex: initialScreen === 0 ? 0 : initialScreen - 1,

      // credits, see AboutDialog for format
      credits: {},

      // a {Node} placed into the Options dialog (if available)
      optionsNode: null,

      // a {Node} placed onto the home screen (if available)
      homeScreenWarningNode: null,

      // if true, records the scenery input events and sends them to a server that can store them
      recordInputEventLog: false,

      // when playing back a recorded scenery input event log, use the specified filename.  Please see getEventLogName for more
      inputEventLogName: undefined,

      // TODO https://github.com/phetsims/energy-skate-park-basics/issues/370
      // this function is currently (9-5-2014) specific to Energy Skate Park: Basics, which shows Save/Load buttons in
      // the PhET menu.  This interface is not very finalized and will probably be changed for future versions,
      // so don't rely on it.
      showSaveAndLoad: false,

      // If true, there will be a border shown around the home screen icons.  Use this option if the home screen icons
      // have the same color as the background, as in Color Vision.
      showSmallHomeScreenIconFrame: false,

      // Whether accessibility features are enabled or not.  Use this option to render the Parallel DOM for
      // keyboard navigation and screen reader based auditory descriptions.
      accessibility: phet.chipper.queryParameters.accessibility,

      // a {Node} placed into the keyboard help dialog that can be opened from the navigation bar
      keyboardHelpNode: null,

      // the default renderer for the rootNode, see #221, #184 and https://github.com/phetsims/molarity/issues/24
      rootRenderer: platform.edge ? 'canvas' : 'svg'
    }, options );

    // @private - store this for access from prototype functions, assumes that it won't be changed later
    this.options = options;

    // override rootRenderer using query parameter, see #221 and #184
    options.rootRenderer = phet.chipper.queryParameters.rootRenderer || options.rootRenderer;

    // @public (joist-internal) - True if the home screen is showing
    this.showHomeScreenProperty = new Property( initialScreen === 0 ? options.showHomeScreen : false, {
      tandem: tandem.createTandem( 'sim.showHomeScreenProperty' ),
      phetioValueType: TBoolean
    } );

    // @public (joist-internal) - The selected screen's index
    this.screenIndexProperty = new Property( options.screenIndex, {
      tandem: tandem.createTandem( 'sim.screenIndexProperty' ),
      phetioValueType: TNumber( { values: _.range( 0, screens.length ) } )
    } );

    // @public
    // When the sim is active, scenery processes inputs and stepSimulation(dt) runs from the system clock.
    //
    // Set to false for when the sim will be paused.  If the sim has playbackModeEnabledProperty set to true, the activeProperty will
    // automatically be set to false so the timing and inputs can be controlled by the playback engine
    this.activeProperty = new Property( !phet.joist.playbackModeEnabledProperty.value, {
      tandem: tandem.createTandem( 'sim.activeProperty' ),
      phetioValueType: TBoolean
    } );

    // @public (read-only) - property that indicates whether the browser tab containing the simulation is currently visible
    this.browserTabVisibleProperty = new Property( true, {
      tandem: tandem.createTandem( 'browserTabVisibleProperty' ),
      phetioValueType: TBoolean,
      phetioInstanceDocumentation: 'this Property is read-only, do not attempt to set its value'
    } );

    // set the state of the property that indicates if the browser tab is visible
    document.addEventListener( 'visibilitychange', function() {
      self.browserTabVisibleProperty.set( document.visibilityState === 'visible' );
    }, false );

    // @public (joist-internal, read-only) - how the home screen and navbar are scaled
    this.scaleProperty = new Property( 1 );

    // @public (joist-internal, read-only) - global bounds for the entire simulation
    this.boundsProperty = new Property( null );

    // @public (joist-internal, read-only) - global bounds for the screen-specific part (excludes the navigation bar)
    this.screenBoundsProperty = new Property( null );

    // @public (joist-internal, read-only) - {Screen|null} - The current screen, or null if showing the home screen
    this.currentScreenProperty = new Property( null );

    // Many other components use addInstance at the end of their constructor but in this case we must register early
    // to (a) enable the SimIFrameAPI as soon as possible and (b) to enable subsequent component registrations,
    // which require the sim to be registered
    simTandem.addInstance( this, TSim );

    // @public
    this.lookAndFeel = new LookAndFeel();

    assert && assert( window.phet.joist.launchCalled, 'Sim must be launched using SimLauncher, ' +
                                                      'see https://github.com/phetsims/joist/issues/142' );

    // @private
    this.destroyed = false;

    // @public ( joist-internal, read-only )
    this.accessible = options.accessibility;

    // @public ( joist-internal, read-only )
    this.keyboardHelpNode = options.keyboardHelpNode;

    assert && assert( !window.phet.joist.sim, 'Only supports one sim at a time' );
    window.phet.joist.sim = self;

    // Make ScreenshotGenerator available globally so it can be used in preload files such as PhET-iO.
    window.phet.joist.ScreenshotGenerator = ScreenshotGenerator;

    this.name = name;                   // @public (joist-internal)
    this.version = packageJSON.version; // @public (joist-internal)
    this.credits = options.credits;     // @public (joist-internal)

    // @private - number of animation frames that have occurred
    this.frameCounter = 0;

    // @private {boolean} - Whether the window has resized since our last updateDisplay()
    this.resizePending = true;

    // used to store input events and requestAnimationFrame cycles
    this.inputEventLog = [];                 // @public (joist-internal)
    this.inputEventBounds = Bounds2.NOTHING; // @public (joist-internal)

    // @public - Make our locale available
    this.locale = phet.chipper.locale || 'en';

    // If the locale query parameter was specified, then we may be running the all.html file, so adjust the title.
    // See https://github.com/phetsims/chipper/issues/510
    if ( QueryStringMachine.containsKey( 'locale' ) ) {
      $( 'title' ).html( name );
    }

    if ( phet.chipper.queryParameters.recordInputEventLog ) {
      // enables recording of Scenery's input events, request animation frames, and dt's so the sim can be played back
      options.recordInputEventLog = true;
      options.inputEventLogName = phet.chipper.queryParameters.recordInputEventLog;
    }

    if ( phet.chipper.queryParameters.playbackInputEventLog ) {
      // instead of loading like normal, download a previously-recorded event sequence and play it back (unique to the browser and window size)
      options.playbackInputEventLog = true;
      options.inputEventLogName = phet.chipper.queryParameters.playbackInputEventLog;
    }

    // override window.open with a semi-API-compatible function, so fuzzing doesn't open new windows.
    if ( phet.chipper.queryParameters.fuzzMouse ) {
      window.open = function() {
        return {
          focus: function() {},
          blur: function() {}
        };
      };
    }

    this.startedSimConstructorEmitter.emit1( {
      repoName: packageJSON.name,
      simName: this.name,
      simVersion: this.version,
      url: window.location.href,
      randomSeed: window.phet.chipper.randomSeed
    } );

    var $body = $( 'body' );

    // prevent scrollbars
    $body.css( 'padding', '0' ).css( 'margin', '0' ).css( 'overflow', 'hidden' );

    // set `user-select: none` on the aria-live container to prevent iOS text selection issue, see
    // https://github.com/phetsims/scenery/issues/1006
    var ariaLiveContainer = document.getElementById( 'aria-live-elements' );
    if ( ariaLiveContainer ) {
      ariaLiveContainer.style[ Features.userSelect ] = 'none';
    }

    // check to see if the sim div already exists in the DOM under the body. This is the case for https://github.com/phetsims/scenery/issues/174 (iOS offline reading list)
    if ( document.getElementById( 'sim' ) && document.getElementById( 'sim' ).parentNode === document.body ) {
      document.body.removeChild( document.getElementById( 'sim' ) );
    }

    // Prevents selection cursor issues in Safari, see https://github.com/phetsims/scenery/issues/476
    document.onselectstart = function() {
      return false;
    };

    // @public
    this.rootNode = new Node( { renderer: options.rootRenderer } );

    // When the sim becomes inactive, interrupt any currently active input listeners, see https://github.com/phetsims/scenery/issues/619.
    this.activeProperty.lazyLink( function( active ) {
      if ( !active ) {
        self.rootNode.interruptSubtreeInput();
      }
    } );

    // @private
    this.display = new Display( self.rootNode, {
      // prevent overflow that can cause iOS bugginess, see https://github.com/phetsims/phet-io/issues/341
      allowSceneOverflow: false,

      // Indicate whether webgl is allowed to facilitate testing on non-webgl platforms, see https://github.com/phetsims/scenery/issues/289
      allowWebGL: phet.chipper.queryParameters.webgl,

      accessibility: options.accessibility,
      isApplication: false,

      assumeFullWindow: true // a bit faster if we can assume no coordinate translations are needed for the display.
    } );

    // When the sim is inactive, make it non-interactive, see https://github.com/phetsims/scenery/issues/414
    this.activeProperty.link( function( active ) {
      self.display.interactive = active;

      // The sim must remain inactive while playbackModeEnabledProperty is true
      if ( active ) {
        assert && assert( !phet.joist.playbackModeEnabledProperty.value, 'The sim must remain inactive while playbackModeEnabledProperty is true' );
      }
    } );

    var simDiv = self.display.domElement;
    simDiv.id = 'sim';
    document.body.appendChild( simDiv );

    // for preventing Safari from going to sleep - added to the simDiv instead of the body to prevent a VoiceOver bug
    // where the virtual cursor would spontaneously move when the div content changed, see
    // https://github.com/phetsims/joist/issues/140
    var heartbeatDiv = this.heartbeatDiv = document.createElement( 'div' );
    heartbeatDiv.style.opacity = 0;

    // Extra style (also used for accessibility) that makes it take up no visual layout space.
    // Without this, it could cause some layout issues. See https://github.com/phetsims/gravity-force-lab/issues/39
    heartbeatDiv.style.position = 'absolute';
    heartbeatDiv.style.left = '0';
    heartbeatDiv.style.top = '0';
    heartbeatDiv.style.width = '0';
    heartbeatDiv.style.height = '0';
    heartbeatDiv.style.clip = 'rect(0,0,0,0)';
    heartbeatDiv.setAttribute( 'aria-hidden', true ); // hide div from screen readers (a11y)
    simDiv.appendChild( heartbeatDiv );

    if ( phet.chipper.queryParameters.sceneryLog ) {
      this.display.scenery.enableLogging( phet.chipper.queryParameters.sceneryLog );
    }

    if ( phet.chipper.queryParameters.sceneryStringLog ) {
      this.display.scenery.switchLogToString();
    }

    this.display.initializeEvents(); // sets up listeners on the document with preventDefault(), and forwards those events to our scene
    window.phet.joist.rootNode = this.rootNode; // make the scene available for debugging
    window.phet.joist.display = this.display; // make the display available for debugging

    // Pass through query parameters to scenery for showing supplemental information
    self.display.setPointerDisplayVisible( phet.chipper.queryParameters.showPointers );
    self.display.setPointerAreaDisplayVisible( phet.chipper.queryParameters.showPointerAreas );
    self.display.setCanvasNodeBoundsVisible( phet.chipper.queryParameters.showCanvasNodeBounds );
    self.display.setFittedBlockBoundsVisible( phet.chipper.queryParameters.showFittedBlockBounds );

    function sleep( millis ) {
      var date = new Date();
      var curDate;
      do {
        curDate = new Date();
      } while ( curDate - date < millis );
    }

    /*
     * These are used to make sure our sims still behave properly with an artificially higher load (so we can test what happens
     * at 30fps, 5fps, etc). There tend to be bugs that only happen on less-powerful devices, and these functions facilitate
     * testing a sim for robustness, and allowing others to reproduce slow-behavior bugs.
     */
    window.phet.joist.makeEverythingSlow = function() {
      window.setInterval( function() { sleep( 64 ); }, 16 );
    };
    window.phet.joist.makeRandomSlowness = function() {
      window.setInterval( function() { sleep( Math.ceil( 100 + Math.random() * 200 ) ); }, Math.ceil( 100 + Math.random() * 200 ) );
    };

    // @public
    this.screens = screens;

    // Multi-screen sims get a home screen.
    if ( screens.length > 1 ) {
      this.homeScreen = new HomeScreen( this, tandem.createTandem( 'homeScreen' ), {
        warningNode: options.homeScreenWarningNode,
        showSmallHomeScreenIconFrame: options.showSmallHomeScreenIconFrame
      } );
      this.homeScreen.initializeModelAndView();
    }
    else {
      this.homeScreen = null;
    }

    // @public (joist-internal)
    this.navigationBar = new NavigationBar( this, screens, tandem.createTandem( 'navigationBar' ) );

    // @public (joist-internal)
    this.updateBackground = function() {
      self.lookAndFeel.backgroundColorProperty.value = self.currentScreenProperty.value ?
                                                       self.currentScreenProperty.value.backgroundColorProperty.value :
                                                       self.homeScreen.backgroundColorProperty.value;
    };

    this.lookAndFeel.backgroundColorProperty.link( function( backgroundColor ) {
      self.display.backgroundColor = backgroundColor;
    } );

    Property.multilink( [ this.showHomeScreenProperty, this.screenIndexProperty ],
      function( showHomeScreen, screenIndex ) {
        self.currentScreenProperty.value = ( showHomeScreen && self.homeScreen ) ? null : screens[ screenIndex ];
        self.updateBackground();
      } );

    // When the user switches screens, interrupt the input on the previous screen.
    // See https://github.com/phetsims/scenery/issues/218
    this.currentScreenProperty.lazyLink( function( newScreen, oldScreen ) {
      if ( oldScreen === null ) {
        self.homeScreen.view.interruptSubtreeInput();
      }
      else {
        oldScreen.view.interruptSubtreeInput();
      }
    } );

    // Third party support
    phet.chipper.queryParameters.legendsOfLearning && new LegendsOfLearningSupport( this ).start();
  }

  joist.register( 'Sim', Sim );

  return inherit( Object, Sim, {
    finishInit: function( screens, tandem ) {
      var self = this;

      // ModuleIndex should always be defined.  On startup screenIndex=1 to highlight the 1st screen.
      // When moving from a screen to the homescreen, the previous screen should be highlighted

      if ( this.homeScreen ) {
        this.rootNode.addChild( this.homeScreen.view );
      }
      _.each( screens, function( screen ) {
        screen.view.layerSplit = true;
        self.rootNode.addChild( screen.view );
      } );
      this.rootNode.addChild( this.navigationBar );

      if ( this.homeScreen ) {

        // Once both the navbar and homescreen have been added, link the PhET button positions together.
        // See https://github.com/phetsims/joist/issues/304.
        PhetButton.linkPhetButtonTransform( this.homeScreen, this.navigationBar, this.rootNode );
      }

      Property.multilink( [ this.showHomeScreenProperty, this.screenIndexProperty ],
        function( showHomeScreen, screenIndex ) {

          if ( self.homeScreen ) {

            // You can't set the active property if the screen is visible, so order matters here
            if ( showHomeScreen ) {
              self.homeScreen.activeProperty.set( true );
              self.homeScreen.view.setVisible( true );
            }
            else {
              self.homeScreen.view.setVisible( false );
              self.homeScreen.activeProperty.set( false );
            }
          }

          // Make the selected screen visible and active, other screens invisible and inactive.
          // screen.isActiveProperty should change only while the screen is invisible.
          // See https://github.com/phetsims/joist/issues/418.
          for ( var i = 0; i < screens.length; i++ ) {
            var screen = screens[ i ];
            var visible = ( !showHomeScreen && screenIndex === i );
            if ( visible ) {
              screen.activeProperty.set( visible );
            }
            screen.view.setVisible( visible );
            if ( !visible ) {
              screen.activeProperty.set( visible );
            }
          }

          self.navigationBar.setVisible( !showHomeScreen );
          self.updateBackground();
        } );

      // layer for popups, dialogs, and their backgrounds and barriers
      this.topLayer = new Node();
      this.rootNode.addChild( this.topLayer );

      // @private list of nodes that are "modal" and hence block input with the barrierRectangle.  Used by modal dialogs
      // and the PhetMenu
      this.modalNodeStack = new ObservableArray( {
        // tandem: tandem.createTandem( 'modalNodeStack' ),
        // phetioValueType: TNode
      } ); // {Node} with node.hide()

      // @public (joist-internal) Semi-transparent black barrier used to block input events when a dialog (or other popup)
      // is present, and fade out the background.
      this.barrierRectangle = new BarrierRectangle(
        this.modalNodeStack,
        {
          fill: 'rgba(0,0,0,0.3)',
          pickable: true,
          tandem: tandem.createTandem( 'sim.barrierRectangle' )
        } );

      this.topLayer.addChild( this.barrierRectangle );


      // Fit to the window and render the initial scene
      // Can't synchronously do this in Firefox, see https://github.com/phetsims/vegas/issues/55 and
      // https://bugzilla.mozilla.org/show_bug.cgi?id=840412.
      var resizeListener = function() {
        // Don't resize on window size changes if we are playing back input events.
        // See https://github.com/phetsims/joist/issues/37
        if ( !phet.joist.playbackModeEnabledProperty.value ) {
          self.resizePending = true;
        }
      };
      $( window ).resize( resizeListener );
      window.addEventListener( 'resize', resizeListener );
      window.addEventListener( 'orientationchange', resizeListener );
      window.visualViewport && window.visualViewport.addEventListener( 'resize', resizeListener );
      this.resizeToWindow();

      // Kick off checking for updates, if that is enabled
      UpdateCheck.check();

      // @public (joist-internal) - Keep track of the previous time for computing dt, and initially signify that time
      // hasn't been recorded yet.
      this.lastTime = -1;

      // @public (joist-internal)
      // Bind the animation loop so it can be called from requestAnimationFrame with the right this.
      this.boundRunAnimationLoop = this.runAnimationLoop.bind( this );
    },

    /*
     * Adds a popup in the global coordinate frame, and optionally displays a semi-transparent black input barrier behind it.
     * Use hidePopup() to remove it.
     * @param {Node} node - Should have node.hide() implemented to hide the popup (should subsequently call
     *                      sim.hidePopup()).
     * @param {boolean} isModal - Whether to display the semi-transparent black input barrier behind it.
     * @public
     */
    showPopup: function( node, isModal ) {
      assert && assert( node );
      assert && assert( !!node.hide, 'Missing node.hide() for showPopup' );
      assert && assert( !this.topLayer.hasChild( node ), 'Popup already shown' );

      if ( isModal ) {
        this.modalNodeStack.push( node );
      }
      this.topLayer.addChild( node );

    },

    /*
     * Hides a popup that was previously displayed with showPopup()
     * @param {Node} node
     * @param {boolean} isModal - Whether the previous popup was modal (or not)
     * @public
     */
    hidePopup: function( node, isModal ) {
      assert && assert( node && this.modalNodeStack.contains( node ) );
      assert && assert( this.topLayer.hasChild( node ), 'Popup was not shown' );

      if ( isModal ) {
        this.modalNodeStack.remove( node );
      }
      this.topLayer.removeChild( node );

    },

    /**
     * @public (joist-internal)
     */
    resizeToWindow: function() {
      this.resizePending = false;

      this.resize( window.innerWidth, window.innerHeight );
    },

    // @public (joist-internal, phet-io)
    resize: function( width, height ) {
      var self = this;

      var scale = Math.min( width / HomeScreenView.LAYOUT_BOUNDS.width, height / HomeScreenView.LAYOUT_BOUNDS.height );

      // 40 px high on iPad Mobile Safari
      var navBarHeight = scale * NavigationBar.NAVIGATION_BAR_SIZE.height;
      self.navigationBar.layout( scale, width, navBarHeight );
      self.navigationBar.y = height - navBarHeight;
      self.display.setSize( new Dimension2( width, height ) );

      var screenHeight = height - self.navigationBar.height;

      // Layout each of the screens
      _.each( self.screens, function( m ) {
        m.view.layout( width, screenHeight );
      } );

      // Resize the layer with all of the dialogs, etc.
      self.topLayer.setScaleMagnitude( scale );

      self.homeScreen && self.homeScreen.view.layout( width, height );

      // Startup can give spurious resizes (seen on ipad), so defer to the animation loop for painting

      // Fixes problems where the div would be way off center on iOS7
      if ( platform.mobileSafari ) {
        window.scrollTo( 0, 0 );
      }

      // update our scale and bounds properties after other changes (so listeners can be fired after screens are resized)
      this.scaleProperty.value = scale;
      this.boundsProperty.value = new Bounds2( 0, 0, width, height );
      this.screenBoundsProperty.value = new Bounds2( 0, 0, width, screenHeight );

      // Signify that the sim has been resized.
      // {Bounds2} bounds - the size of the window.innerWidth and window.innerHeight, which depends on the scale
      // {Bounds2} screenBounds - subtracts off the size of the navbar from the height
      // {number} scale - the overall scaling factor for elements in the view
      this.resizedEmitter.emit3( this.boundsProperty.value, this.screenBoundsProperty.value, this.scaleProperty.value );
    },

    // @public (joist-internal)
    start: function() {

      var self = this;

      // In order to animate the loading progress bar, we must schedule work with setTimeout
      // This array of {function} is the work that must be completed to launch the sim.
      var workItems = [];

      var screens = this.screens;

      // Schedule instantiation of the screens
      screens.forEach( function initializeScreen( screen ) {
        workItems.push( function() {
          screen.backgroundColorProperty.link( self.updateBackground );
          screen.initializeModel();
        } );
        workItems.push( function() {
          screen.initializeView();
        } );
      } );

      // loop to run startup items asynchronously so the DOM can be updated to show animation on the progress bar
      var runItem = function( i ) {
        setTimeout(
          function() {
            workItems[ i ]();
            // Move the progress ahead by one so we show the full progress bar for a moment before the sim starts up

            var progress = DotUtil.linear( 0, workItems.length - 1, 0.25, 1.0, i );

            // Support iOS Reading Mode, which saves a DOM snapshot after the progressBarForeground has already been
            // removed from the document, see https://github.com/phetsims/joist/issues/389
            if ( document.getElementById( 'progressBarForeground' ) ) {

              // Grow the progress bar foreground to the right based on the progress so far.
              document.getElementById( 'progressBarForeground' ).setAttribute( 'width', (progress * PROGRESS_BAR_WIDTH) + '' );
            }
            if ( i + 1 < workItems.length ) {
              runItem( i + 1 );
            }
            else {

              setTimeout( function() {
                self.finishInit( screens, self.tandem );

                // Make sure requestAnimationFrame is defined
                Util.polyfillRequestAnimationFrame();

                // Option for profiling
                // if true, prints screen initialization time (total, model, view) to the console and displays
                // profiling information on the screen
                if ( phet.chipper.queryParameters.profiler ) {
                  Profiler.start( self );
                }

                // place the rAF *before* the render() to assure as close to 60fps with the setTimeout fallback.
                // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
                // Launch the bound version so it can easily be swapped out for debugging.
                self.boundRunAnimationLoop();

                // Communicate sim load (successfully) to joist/tests/test-sims.html
                if ( phet.chipper.queryParameters.postMessageOnLoad ) {
                  window.parent && window.parent.postMessage( JSON.stringify( {
                    type: 'load',
                    url: window.location.href
                  } ), '*' );
                }

                // After the application is ready to go, remove the splash screen and progress bar
                window.phetSplashScreen.dispose();

                // Signify the end of simulation startup.  Used by PhET-iO.
                self.endedSimConstructionEmitter.emit();

              }, 25 ); // pause for a few milliseconds with the progress bar filled in before going to the home screen
            }
          },
          // The following sets the amount of delay between each work item to make it easier to see the changes to the
          // progress bar.  A total value is divided by the number of work items.  This makes it possible to see the
          // progress bar when few work items exist, such as for a single screen sim, but allows things to move
          // reasonably quickly when more work items exist, such as for a four-screen sim.
          30 / workItems.length
        );
      };

      runItem( 0 );
    },

    // Destroy a sim so that it will no longer consume any resources. Formerly used in Smorgasbord.  May not be used by
    // anything else at the moment.
    // @public (joist-internal)
    destroy: function() {
      this.destroyed = true;
      var simDiv = this.display.domElement;
      simDiv.parentNode && simDiv.parentNode.removeChild( simDiv );
    },

    // @private - Bound to this.boundRunAnimationLoop so it can be run in window.requestAnimationFrame
    runAnimationLoop: function() {

      if ( !this.destroyed ) {
        window.requestAnimationFrame( this.boundRunAnimationLoop );
      }

      // Setting the activeProperty to false pauses the sim and also enables optional support for playback back recorded
      // events (if playbackModeEnabledProperty) is true
      if ( this.activeProperty.value ) {

        this.stepOneFrame();
      }
    },

    // @private - run a single frame including model, view and display updates
    stepOneFrame: function() {

      // Compute the elapsed time since the last frame, or guess 1/60th of a second if it is the first frame
      var time = Date.now();
      var elapsedTimeMilliseconds = (this.lastTime === -1) ? (1000.0 / 60.0) : (time - this.lastTime);
      this.lastTime = time;

      // Convert to seconds
      var dt = elapsedTimeMilliseconds / 1000.0;

      // Don't run the simulation on steps back in time (see https://github.com/phetsims/joist/issues/409)
      if ( dt >= 0 ) {
        this.stepSimulation( dt );
      }
    },

    /**
     * Returns the selected screen, or null if the home screen is showing.
     * @returns {Screen|null}
     * @private
     */
    getSelectedScreen: function() {
      return this.showHomeScreenProperty.value ? null : this.screens[ this.screenIndexProperty.value ];
    },

    /**
     * Update the simulation model, view, scenery display with an elapsed time of dt.
     * @param {number} dt in seconds
     * @public (phet-io)
     */
    stepSimulation: function( dt ) {

      this.frameStartedEmitter.emit();

      // increment this before we can have an exception thrown, to see if we are missing frames
      this.frameCounter++;

      phetAllocation && phetAllocation( 'loop' );

      // prevent Safari from going to sleep, see https://github.com/phetsims/joist/issues/140
      if ( this.frameCounter % 1000 === 0 ) {
        this.heartbeatDiv.innerHTML = Math.random();
      }

      if ( this.resizePending ) {
        this.resizeToWindow();
      }

      // fire or synthesize input events
      if ( phet.chipper.queryParameters.fuzzMouse ) {
        this.display.fuzzMouseEvents( phet.chipper.queryParameters.fuzzRate );
      }

      // If the user is on the home screen, we won't have a Screen that we'll want to step.  This must be done after
      // fuzz mouse, because fuzzing could change the selected screen, see #130
      var screen = this.getSelectedScreen();

      // cap dt based on the current screen, see https://github.com/phetsims/joist/issues/130
      if ( screen && screen.maxDT ) {
        dt = Math.min( dt, screen.maxDT );
      }

      // TODO: we are /1000 just to *1000?  Seems wasteful and like opportunity for error. See https://github.com/phetsims/joist/issues/387
      // Store the elapsed time in milliseconds for usage by Tween clients
      phet.joist.elapsedTime = phet.joist.elapsedTime + dt * 1000;

      // Timer step before model/view steps, see https://github.com/phetsims/joist/issues/401
      Timer.step( dt );

      // If the DT is 0, we will skip the model step (see https://github.com/phetsims/joist/issues/171)
      if ( screen && screen.model.step && dt ) {
        screen.model.step( dt );
      }

      // If using the TWEEN animation library, then update all of the tweens (if any) before rendering the scene.
      // Update the tweens after the model is updated but before the view step.
      // See https://github.com/phetsims/joist/issues/401.
      //TODO https://github.com/phetsims/joist/issues/404 run TWEENs for the selected screen only
      if ( window.TWEEN ) {
        window.TWEEN.update( phet.joist.elapsedTime );
      }

      // View step is the last thing before updateDisplay(), so we can do paint updates there.
      // See https://github.com/phetsims/joist/issues/401.
      if ( screen && screen.view.step ) {
        screen.view.step( dt );
      }

      this.display.updateDisplay();

      this.frameEndedEmitter.emit1( dt );
    }
  } );
} );
// Copyright 2015, University of Colorado Boulder

/**
 * Checks global references (on the phet object) to verify all modules loaded through require.js that match the usual
 * pattern that would be namespaced. For example, if the sim uses SCENERY_PHET/buttons/ArrowButton, calling this
 * will check for the presence of phet.sceneryPhet.ArrowButton.
 *
 * See https://github.com/phetsims/tasks/issues/378
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */
define( 'JOIST/checkNamespaces',['require','JOIST/joist'],function( require ) {
  'use strict';

  // modules
  var joist = require( 'JOIST/joist' );

  var checkNamespaces = function() {

    // Get a reference to the defined modules. There doesn't seem to be a common way to access this internal
    // information yet in the optimizer (with almond) and with require.js, so we have a fall-back set up.
    var defined = window.requirejs._defined || window.require.s.contexts._.defined;

    /**
     * This function iterates over all defined AMD modules and reports to a problemHandler any problems.
     * @param {function} problemHandler, a function that is called when an error occurs, with an {string} argument that
     * describes the problem
     */
    var visit = function( problemHandler ) {
      for ( var moduleName in defined ) {
        // Skip strings, images, or anything imported with a plugin. Could be added later if needed
        if ( moduleName.indexOf( '!' ) >= 0 ) {
          continue;
        }

        // Skip anything without a slash (the plugins themselves, and the main/config files)
        if ( moduleName.indexOf( '/' ) < 0 ) {
          continue;
        }

        // Skip anything with '..' in the path (chipper imports some things where we can't get the repository prefix)
        if ( moduleName.indexOf( '..' ) >= 0 ) {
          continue;
        }

        var prefix = moduleName.slice( 0, moduleName.indexOf( '/' ) ); // e.g. 'SCENERY_PHET'
        var name = moduleName.slice( moduleName.lastIndexOf( '/' ) + 1 ); // e.g. 'ArrowButton'

        // Convert to camel-case, e.g. 'SCENERY_PHET' to 'sceneryPhet'
        var prefixTokens = prefix.toLowerCase().split( '_' );
        var namespace = [ prefixTokens[ 0 ] ].concat( prefixTokens.slice( 1 ).map( function( token ) {
          return token.charAt( 0 ).toUpperCase() + token.slice( 1 );
        } ) ).join( '' );

        // Skip the module that contains the namespace object (e.g. scenery.js, tandemNamespace.js)
        if ( name === namespace || name === ( namespace + 'Namespace' ) ) {
          continue;
        }

        var namespacedObject = phet[ namespace ] && phet[ namespace ][ name ];

        if ( !namespacedObject ) {
          problemHandler( 'not namespaced: ' + namespace + '.' + name );
        }
        if ( namespacedObject && namespacedObject !== defined[ moduleName ] ) {
          problemHandler( namespace + '.' + name + ' is different than the expected namespaced object' );
        }
      }
    };

    // First pass prints out all issues, to assist developers as we are adding the namespace register calls
    visit( function( errorMessage ) {
      console.log( errorMessage );
    } );

    // Second pass fails with an assertion error.
    visit( function( errorMessage ) {
      assert && assert( false, errorMessage );
    } );
  };

  joist.register( 'checkNamespaces', checkNamespaces );

  return checkNamespaces;
} );
// Copyright 2015-2016, University of Colorado Boulder

/**
 * Random number generator with an optional seed.
 *
 * @author John Blanco (PhET Interactive Simulations)
 * @author Aaron Davis (PhET Interactive Simulations)
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Mohamed Safi
 */
define( 'DOT/Random',['require','DOT/Util','DOT/dot','PHET_CORE/inherit'],function( require ) {
  'use strict';

  // modules
  var Util = require( 'DOT/Util' );
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );

  /**
   * Construct a Random instance.
   *
   * If you are developing a PhET Simulation, you should probably use the global `phet.joist.random` because it
   * provides built-in support for phet-io seeding and a check that it isn't used before the seed has been set.
   *
   * @param {Object} [options]
   * @constructor
   */
  function Random( options ) {
    options = _.extend( {

      // {number|null} seed for the random number generator.  When seed is null, Math.random() is used.
      seed: null,

      // {boolean} if true, use the seed specified statically in `phet.chipper.randomSeed`.  This value is declared
      // in initialize-globals.js and can be overriden by PhET-iO for reproducible playback (see TPhETIO.setRandomSeed).
      staticSeed: false

    }, options );

    // If staticSeed and seed are both specified, there will be an assertion error.
    if ( options.seed !== null && options.staticSeed ) {
      assert && assert( false, 'cannot specify seed and staticSeed, use one or the other' );
    }

    var seed = options.staticSeed ? window.phet.chipper.randomSeed : options.seed;
    this.setSeed( seed );
  }

  inherit( Object, Random, {

    /**
     * Sets the seed of the random number generator. Setting it to null reverts the random generator to Math.random()
     * @param {number|null} seed
     */
    setSeed: function( seed ) {
      this.seed = seed;

      // If seed is provided, create a local random number generator without altering Math.random.
      this.seedrandom = this.seed !== null ? new Math.seedrandom( this.seed + '' ) : null;
    },

    /**
     * Returns the next pseudo-random boolean
     * @public
     * @returns {boolean}
     */
    nextBoolean: function() {
      return this.nextDouble() >= 0.5;
    },

    /**
     * Returns the next pseudo random number from this random number generator sequence.
     * The random number is an integer ranging from 0 to n-1.
     * @public
     * @param {number} n
     * @returns {number} - an integer
     */
    nextInt: function( n ) {
      var value = this.nextDouble() * n;
      return value | 0; // convert to int by removing the decimal places
    },

    /**
     * Randomly select a random integer between min and max (inclusive).
     *
     * @param {number} min - must be an integer
     * @param {number} max - must be an integer
     * @returns {number} an integer between min and max, inclusive
     */
    nextIntBetween: function( min, max ) {

      assert && assert( arguments.length === 2, 'nextIntBetween must have exactly 2 arguments' );
      assert && assert( Util.isInteger( min ), 'min must be an integer: ' + min );
      assert && assert( Util.isInteger( max ), 'max must be an integer: ' + max );

      var range = max - min;
      return this.nextInt( range + 1 ) + min;
    },

    /**
     * Randomly select one element from the given array.
     * @param {Object[]} array - the array from which one element will be selected, must have at least one element
     * @returns {Object} - the selected element from the array
     */
    sample: function( array ) {
      assert && assert( array.length > 0, 'Array should have at least 1 item.' );
      var index = this.nextIntBetween( 0, array.length - 1 );
      return array[ index ];
    },

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates shuffle.  Adapted from lodash-2.4.1 by
     * Sam Reid on Aug 16, 2016, See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @param {Array} array - the array which will be shuffled
     * @returns {Array} a new array with all the same elements in the passed-in array, in randomized order.
     */
    shuffle: function( array ) {
      assert && assert( array, 'Array should exist' );
      var self = this;
      var index = -1;
      var result = new Array( array.length );

      _.forEach( array, function( value ) {
        var rand = self.nextIntBetween( 0, ++index );
        result[ index ] = result[ rand ];
        result[ rand ] = value;
      } );
      return result;
    },

    /**
     * Returns the next pseudo random number from this random number generator sequence in the range [0, 1)
     * The distribution of the random numbers is uniformly distributed across the interval
     * @public
     * @returns {number} - the random number
     */
    nextDouble: function() {
      return this.seed === null ? Math.random() : this.seedrandom();
    },

    /**
     * Returns the next gaussian-distributed random number from this random number generator sequence.
     * The distribution of the random numbers is gaussian, with a mean = 0 and standard deviation = 1
     * @public
     * @returns {number}
     */
    nextGaussian: function() {
      return Util.boxMullerTransform( 0, 1, this );
    }
  } );

  dot.register( 'Random', Random );

  return Random;
} );

define("PHET_IO/types/TPhETIO", function(){return function(){ return function(){}; };});
// Copyright 2013-2015, University of Colorado Boulder
/**
 * Launches a PhET Simulation, after preloading the specified images.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */
define( 'JOIST/SimLauncher',['require','JOIST/checkNamespaces','JOIST/joist','TANDEM/Tandem','DOT/Random','ifphetio!PHET_IO/SimIFrameAPI','ifphetio!PHET_IO/types/TPhETIO','ifphetio!PHET_IO/phetio'],function( require ) {
  'use strict';

  // modules
  var checkNamespaces = require( 'JOIST/checkNamespaces' );
  var joist = require( 'JOIST/joist' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Random = require( 'DOT/Random' );

  // phet-io modules
  var SimIFrameAPI = require( 'ifphetio!PHET_IO/SimIFrameAPI' );
  var TPhETIO = require( 'ifphetio!PHET_IO/types/TPhETIO' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );

  var SimLauncher = {

    /**
     * Launch the Sim by preloading the images and calling the callback.
     *
     * @param callback the callback function which should create and start the sim, given that the images are loaded
     * @public - to be called by main()s everywhere
     */
    launch: function( callback ) {
      assert && assert( !window.phet.launchCalled, 'Tried to launch twice' );

      //Signify that the SimLauncher was called, see https://github.com/phetsims/joist/issues/142
      window.phet.joist.launchCalled = true;

      // image elements to remove once we are fully loaded
      var elementsToRemove = [];

      function doneLoadingImages() {

        window.phetLaunchSimulation = function() {

          // Register all of the static tandems.
          Tandem.launch();

          // Provide a global Random that is easy to use and seedable from phet-io for playback
          // phet-io configuration happens after SimLauncher.launch is called and before phetLaunchSimulation is called
          phet.joist.random = new Random( { staticSeed: true } );

          // Instantiate the sim and show it.
          callback();
        };

        // PhET-iO simulations support an initialization phase (before the sim launches)
        if ( phet.phetio ) {
          new Tandem( 'phetio' ).addInstance( phetio, TPhETIO );
          SimIFrameAPI.initialize(); // calls back to window.phetLaunchSimulation
        }

        if ( phet.chipper.queryParameters.postMessageOnReady ) {
          window.parent && window.parent.postMessage( JSON.stringify( {
            type: 'ready',
            url: window.location.href
          } ), '*' );
        }

        if ( ( phet.phetio && !phet.phetio.queryParameters.phetioStandalone ) ||
             phet.chipper.queryParameters.playbackMode ) {

          // Wait for phet-io to finish adding listeners. It will direct the launch from there.
        }
        else {
          window.phetLaunchSimulation();
        }
      }

      // if image dimensions exist, immediately fire the "all images loaded" event
      var loaded = 0;

      // Taken from http://stackoverflow.com/questions/1977871/check-if-an-image-is-loaded-no-errors-in-javascript
      function isImageOK( img ) {

        // During the onload event, IE correctly identifies any images that
        // weren’t downloaded as not complete. Others should too. Gecko-based
        // browsers act like NS4 in that they report this incorrectly.
        if ( !img.complete ) {
          return false;
        }

        // However, they do have two very useful properties: naturalWidth and
        // naturalHeight. These give the true size of the image. If it failed
        // to load, either of these should be zero.
        if ( typeof img.naturalWidth !== 'undefined' && img.naturalWidth === 0 ) {
          return false;
        }

        // No other way of checking: assume it’s ok.
        return true;
      }

      //For the images that were written to base64 format using requirejs, make sure they are loaded.
      //img.src = base64 is asynchronous on IE10 and OSX/Safari, so we have to make sure they loaded before returning.
      if ( window.phetImages ) {
        for ( var i = 0; i < window.phetImages.length; i++ ) {
          var phetImage = window.phetImages[ i ];

          // For built versions that use phet-io, the simulation may have already loaded all of the images, so
          // check them here before scheduling them for load.
          if ( isImageOK( phetImage ) ) {
            loaded++;
            if ( loaded === window.phetImages.length ) {
              doneLoadingImages();
            }
          }
          else {
            phetImage.onload = function() {
              loaded++;
              if ( loaded === window.phetImages.length ) {
                doneLoadingImages();
              }
            };
          }

        }
      }
      else {
        doneLoadingImages();
      }

      $( window ).load( function() {
        // if images were not loaded immediately, signal the "all images loaded" event

        // we wait for here to remove the images from the DOM, otherwise IE9/10 treat the images as completely blank!
        _.each( elementsToRemove, function( element ) {

          //TODO: Why is this null sometimes?  see https://github.com/phetsims/joist/issues/388
          if ( element.parentNode ) {
            element.parentNode.removeChild( element );
          }
        } );
      } );

      // Check namespaces if assertions are enabled, see https://github.com/phetsims/joist/issues/307.
      assert && checkNamespaces();
    }
  };

  joist.register( 'SimLauncher', SimLauncher );

  return SimLauncher;
} );

define("string!PENDULUM_LAB/pendulum-lab.title",function(){return window.phet.chipper.strings.get("PENDULUM_LAB/pendulum-lab.title");});

// Copyright 2014-2015, University of Colorado Boulder

/**
 * Main entry point for the sim.
 *
 * @author Andrey Zelenkov (Mlearner)
 */
define( 'pendulum-lab-main',['require','PENDULUM_LAB/energy/EnergyScreen','PENDULUM_LAB/intro/IntroScreen','PENDULUM_LAB/lab/LabScreen','JOIST/Sim','JOIST/SimLauncher','string!PENDULUM_LAB/pendulum-lab.title'],function( require ) {
  'use strict';

  // modules
  var EnergyScreen = require( 'PENDULUM_LAB/energy/EnergyScreen' );
  var IntroScreen = require( 'PENDULUM_LAB/intro/IntroScreen' );
  var LabScreen = require( 'PENDULUM_LAB/lab/LabScreen' );
  var Sim = require( 'JOIST/Sim' );
  var SimLauncher = require( 'JOIST/SimLauncher' );

  // strings
  var pendulumLabTitleString = require( 'string!PENDULUM_LAB/pendulum-lab.title' );

  var simOptions = {
    credits: {
      leadDesign: 'Michael Dubson, Amy Rouinfar',
      softwareDevelopment: 'Jonathan Olson, Michael Dubson',
      team: 'Trish Loeblein, Ariel Paul, Kathy Perkins',
      qualityAssurance: 'Steele Dalton, Bryce Griebenow, Ethan Johnson, Elise Morgan, Liam Mulhall, Oliver Orejola, Ben Roberts, Bryan Yoelin',
      thanks: 'Thanks to Mobile Learner Labs for working with the PhET development team to convert this ' +
              'simulation to HTML5.'
    }
  };

  SimLauncher.launch( function() {
    var sim = new Sim( pendulumLabTitleString, [ new IntroScreen(), new EnergyScreen(), new LabScreen() ], simOptions );
    sim.start();
  } );
} );


require(["pendulum-lab-main"]);
}());</script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/v84a3a4012de94ce1a686ba8c167c359c1696973893317" integrity="sha512-euoFGowhlaLqXsPWQ48qSkBSCFs3DPRyiwVu3FjR96cMPx+Fr+gpWRhIafcHwqwCqWS42RZhIudOvEI+Ckf6MA==" data-cf-beacon='{"rayId":"85f50c9a3b932d6f","version":"2024.2.4","token":"57ed97624d4c401fb934c2dd728ace72"}' crossorigin="anonymous"></script>
</body>
</html>
